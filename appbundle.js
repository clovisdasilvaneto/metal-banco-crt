/******/ (function(modules) { // webpackBootstrap
	/******/  // The module cache
	/******/  var installedModules = {};
	/******/
	/******/  // The require function
	/******/  function __webpack_require__(moduleId) {
		/******/
		/******/    // Check if module is in cache
		/******/    if(installedModules[moduleId]) {
			/******/      return installedModules[moduleId].exports;
			/******/    }
		/******/    // Create a new module (and put it into the cache)
		/******/    var module = installedModules[moduleId] = {
			/******/      i: moduleId,
			/******/      l: false,
			/******/      exports: {}
			/******/    };
		/******/
		/******/    // Execute the module function
		/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
		/******/
		/******/    // Flag the module as loaded
		/******/    module.l = true;
		/******/
		/******/    // Return the exports of the module
		/******/    return module.exports;
		/******/  }
	/******/
	/******/
	/******/  // expose the modules object (__webpack_modules__)
	/******/  __webpack_require__.m = modules;
	/******/
	/******/  // expose the module cache
	/******/  __webpack_require__.c = installedModules;
	/******/
	/******/  // define getter function for harmony exports
	/******/  __webpack_require__.d = function(exports, name, getter) {
		/******/    if(!__webpack_require__.o(exports, name)) {
			/******/      Object.defineProperty(exports, name, {
				/******/        configurable: false,
				/******/        enumerable: true,
				/******/        get: getter
				/******/      });
			/******/    }
		/******/  };
	/******/
	/******/  // getDefaultExport function for compatibility with non-harmony modules
	/******/  __webpack_require__.n = function(module) {
		/******/    var getter = module && module.__esModule ?
			/******/      function getDefault() { return module['default']; } :
			/******/      function getModuleExports() { return module; };
		/******/    __webpack_require__.d(getter, 'a', getter);
		/******/    return getter;
		/******/  };
	/******/
	/******/  // Object.prototype.hasOwnProperty.call
	/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
	/******/
	/******/  // __webpack_public_path__
	/******/  __webpack_require__.p = "";
	/******/
	/******/  // Load entry module and return exports
	/******/  return __webpack_require__(__webpack_require__.s = 38);
	/******/ })
/************************************************************************/
/******/ ([
	/* 0 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.ComponentRenderer = exports.ComponentRegistry = exports.ComponentDataManager = exports.Component = undefined;
		
		var _events = __webpack_require__(17);
		
		Object.keys(_events).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _events[key];
				}
			});
		});
		
		var _Component = __webpack_require__(53);
		
		var _Component2 = _interopRequireDefault(_Component);
		
		var _ComponentDataManager = __webpack_require__(24);
		
		var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);
		
		var _ComponentRegistry = __webpack_require__(84);
		
		var _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);
		
		var _ComponentRenderer = __webpack_require__(28);
		
		var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _Component2.default;
		exports.Component = _Component2.default;
		exports.ComponentDataManager = _ComponentDataManager2.default;
		exports.ComponentRegistry = _ComponentRegistry2.default;
		exports.ComponentRenderer = _ComponentRenderer2.default;
		
		/***/ }),
	/* 1 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.validators = exports.SoyAop = exports.Soy = exports.Config = undefined;
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		__webpack_require__(85);
		
		var _metalComponent = __webpack_require__(0);
		
		var _metal = __webpack_require__(97);
		
		var _metalState = __webpack_require__(25);
		
		var _html2incdom = __webpack_require__(104);
		
		var _html2incdom2 = _interopRequireDefault(_html2incdom);
		
		var _metalIncrementalDom = __webpack_require__(29);
		
		var _metalIncrementalDom2 = _interopRequireDefault(_metalIncrementalDom);
		
		var _SoyAop = __webpack_require__(108);
		
		var _SoyAop2 = _interopRequireDefault(_SoyAop);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// The injected data that will be passed to soy templates.
		var ijData = {};
		
		var Soy = function (_IncrementalDomRender) {
			_inherits(Soy, _IncrementalDomRender);
			
			function Soy() {
				_classCallCheck(this, Soy);
				
				return _possibleConstructorReturn(this, (Soy.__proto__ || Object.getPrototypeOf(Soy)).apply(this, arguments));
			}
			
			_createClass(Soy, [{
				key: 'getExtraDataConfig',
				
				/**
				 * Adds the template params to the component's state, if they don't exist yet.
				 * @param {!Component} component
				 * @return {Object}
				 */
				value: function getExtraDataConfig(component) {
					var elementTemplate = component.constructor.TEMPLATE;
					if (!(0, _metal.isFunction)(elementTemplate)) {
						return;
					}
					
					elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
					this.soyParamTypes_ = elementTemplate.types || {};
					
					var keys = elementTemplate.params || [];
					var configs = {};
					for (var i = 0; i < keys.length; i++) {
						if (!component[keys[i]]) {
							configs[keys[i]] = {};
						}
					}
					return configs;
				}
				
				/**
				 * Copies the component's state to an object so it can be passed as it's
				 * template call's data. The copying needs to be done because, if the component
				 * itself is passed directly, some problems occur when soy tries to merge it
				 * with other data, due to property getters and setters. This is safer.
				 * Also calls the component's "prepareStateForRender" to let it change the
				 * data passed to the template.
				 * @param {!Component} component
				 * @param {!Array<string>} params The params used by this template.
				 * @return {!Object}
				 * @protected
				 */
				
			}, {
				key: 'buildTemplateData_',
				value: function buildTemplateData_(component, params) {
					var _this2 = this;
					
					var data = _metal.object.mixin({}, this.getConfig(component));
					component.getStateKeys().forEach(function (key) {
						var value = component[key];
						if (_this2.isHtmlParam_(component, key)) {
							value = soyRenderer_.toIncDom(value);
						}
						data[key] = value;
					});
					
					for (var i = 0; i < params.length; i++) {
						if (!data[params[i]] && (0, _metal.isFunction)(component[params[i]])) {
							data[params[i]] = component[params[i]].bind(component);
						}
					}
					
					if ((0, _metal.isFunction)(component.prepareStateForRender)) {
						return component.prepareStateForRender(data) || data;
					} else {
						return data;
					}
				}
				
				/**
				 * Returns the requested template function. This function will be wrapped in
				 * another though, just to defer the requirement of the template's module
				 * being ready until the function is actually called.
				 * @param {string} namespace The soy template's namespace.
				 * @param {string} templateName The name of the template function.
				 * @return {!function()}
				 */
				
			}, {
				key: 'getTemplate',
				value: function getTemplate(namespace, templateName) {
					return function (opt_data, opt_ignored, opt_ijData) {
						if (!goog.loadedModules_[namespace]) {
							throw new Error('No template with namespace "' + namespace + '" has been loaded yet.');
						}
						return goog.loadedModules_[namespace][templateName](opt_data, opt_ignored, opt_ijData);
					};
				}
				
				/**
				 * Handles an intercepted soy template call. If the call is for a component's
				 * main template, then it will be replaced with a call that incremental dom
				 * can use for both handling an instance of that component and rendering it.
				 * @param {!function()} originalFn The original template function that was
				 *     intercepted.
				 * @param {Object} data The data the template was called with.
				 * @protected
				 */
				
			}, {
				key: 'handleInterceptedCall_',
				value: function handleInterceptedCall_(originalFn) {
					var opt_data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
					
					var args = [originalFn.componentCtor, null, []];
					for (var key in opt_data) {
						args.push(key, opt_data[key]);
					}
					IncrementalDOM.elementVoid.apply(null, args);
				}
				
				/**
				 * Checks if the given param type is html.
				 * @param {!Component} component
				 * @param {string} name
				 * @protected
				 */
				
			}, {
				key: 'isHtmlParam_',
				value: function isHtmlParam_(component, name) {
					var state = component.getDataManager().getStateInstance(component);
					if (state.getStateKeyConfig(name).isHtml) {
						return true;
					}
					
					var elementTemplate = _SoyAop2.default.getOriginalFn(component.constructor.TEMPLATE);
					var type = (elementTemplate.types || {})[name] || '';
					return type.split('|').indexOf('html') !== -1;
				}
				
				/**
				 * Registers the given templates to be used by `Soy` for the specified
				 * component constructor.
				 * @param {!Function} componentCtor The constructor of the component that
				 *     should use the given templates.
				 * @param {!Object} templates Object containing soy template functions.
				 * @param {string=} mainTemplate The name of the main template that should be
				 *     used to render the component. Defaults to "render".
				 */
				
			}, {
				key: 'register',
				value: function register(componentCtor, templates) {
					var mainTemplate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'render';
					
					componentCtor.RENDERER = soyRenderer_;
					componentCtor.TEMPLATE = _SoyAop2.default.getOriginalFn(templates[mainTemplate]);
					componentCtor.TEMPLATE.componentCtor = componentCtor;
					_SoyAop2.default.registerForInterception(templates, mainTemplate);
					_metalComponent.ComponentRegistry.register(componentCtor);
				}
				
				/**
				 * Overrides the default method from `IncrementalDomRenderer` so the component's
				 * soy template can be used for rendering.
				 * @param {!Component} component
				 * @param {!Object} data Data passed to the component when rendering it.
				 * @override
				 */
				
			}, {
				key: 'renderIncDom',
				value: function renderIncDom(component) {
					var elementTemplate = component.constructor.TEMPLATE;
					if ((0, _metal.isFunction)(elementTemplate) && !component.render) {
						elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
						_SoyAop2.default.startInterception(this.handleInterceptedCall_);
						var data = this.buildTemplateData_(component, elementTemplate.params || []);
						elementTemplate(data, null, ijData);
						_SoyAop2.default.stopInterception();
					} else {
						_get(Soy.prototype.__proto__ || Object.getPrototypeOf(Soy.prototype), 'renderIncDom', this).call(this, component);
					}
				}
				
				/**
				 * Sets the injected data object that should be passed to templates.
				 * @param {Object} data
				 */
				
			}, {
				key: 'setInjectedData',
				value: function setInjectedData(data) {
					ijData = data || {};
				}
				
				/**
				 * Overrides the original `IncrementalDomRenderer` method so that only
				 * state keys used by the main template can cause updates.
				 * @param {!Component} component
				 * @param {Object} changes
				 * @return {boolean}
				 */
				
			}, {
				key: 'shouldUpdate',
				value: function shouldUpdate(component, changes) {
					var should = _get(Soy.prototype.__proto__ || Object.getPrototypeOf(Soy.prototype), 'shouldUpdate', this).call(this, component, changes);
					if (!should || component.shouldUpdate) {
						return should;
					}
					
					var fn = component.constructor.TEMPLATE;
					var params = fn ? _SoyAop2.default.getOriginalFn(fn).params : [];
					for (var i = 0; i < params.length; i++) {
						if (changes.props[params[i]]) {
							return true;
						}
					}
					return false;
				}
				
				/**
				 * Converts the given incremental dom function into an html string.
				 * @param {!function()} incDomFn
				 * @return {string}
				 */
				
			}, {
				key: 'toHtmlString',
				value: function toHtmlString(incDomFn) {
					var element = document.createElement('div');
					IncrementalDOM.patch(element, incDomFn);
					return element.innerHTML;
				}
				
				/**
				 * Converts the given html string into an incremental dom function.
				 * @param {string|{contentKind: string, content: string}} value
				 * @return {!function()}
				 */
				
			}, {
				key: 'toIncDom',
				value: function toIncDom(value) {
					if ((0, _metal.isObject)(value) && (0, _metal.isString)(value.content) && value.contentKind === 'HTML') {
						value = value.content;
					}
					if ((0, _metal.isString)(value)) {
						value = _html2incdom2.default.buildFn(value);
					}
					return value;
				}
			}]);
			
			return Soy;
		}(_metalIncrementalDom2.default.constructor);
		
		var soyRenderer_ = new Soy();
		soyRenderer_.RENDERER_NAME = 'soy';
		
		exports.default = soyRenderer_;
		exports.Config = _metalState.Config;
		exports.Soy = soyRenderer_;
		exports.SoyAop = _SoyAop2.default;
		exports.validators = _metalState.validators;
		
		/***/ }),
	/* 2 */
	/***/ (function(module, exports) {

// shim for using process in browser
		var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
		
		var cachedSetTimeout;
		var cachedClearTimeout;
		
		function defaultSetTimout() {
			throw new Error('setTimeout has not been defined');
		}
		function defaultClearTimeout () {
			throw new Error('clearTimeout has not been defined');
		}
		(function () {
			try {
				if (typeof setTimeout === 'function') {
					cachedSetTimeout = setTimeout;
				} else {
					cachedSetTimeout = defaultSetTimout;
				}
			} catch (e) {
				cachedSetTimeout = defaultSetTimout;
			}
			try {
				if (typeof clearTimeout === 'function') {
					cachedClearTimeout = clearTimeout;
				} else {
					cachedClearTimeout = defaultClearTimeout;
				}
			} catch (e) {
				cachedClearTimeout = defaultClearTimeout;
			}
		} ())
		function runTimeout(fun) {
			if (cachedSetTimeout === setTimeout) {
				//normal enviroments in sane situations
				return setTimeout(fun, 0);
			}
			// if setTimeout wasn't available but was latter defined
			if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
				cachedSetTimeout = setTimeout;
				return setTimeout(fun, 0);
			}
			try {
				// when when somebody has screwed with setTimeout but no I.E. maddness
				return cachedSetTimeout(fun, 0);
			} catch(e){
				try {
					// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
					return cachedSetTimeout.call(null, fun, 0);
				} catch(e){
					// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
					return cachedSetTimeout.call(this, fun, 0);
				}
			}
			
			
		}
		function runClearTimeout(marker) {
			if (cachedClearTimeout === clearTimeout) {
				//normal enviroments in sane situations
				return clearTimeout(marker);
			}
			// if clearTimeout wasn't available but was latter defined
			if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
				cachedClearTimeout = clearTimeout;
				return clearTimeout(marker);
			}
			try {
				// when when somebody has screwed with setTimeout but no I.E. maddness
				return cachedClearTimeout(marker);
			} catch (e){
				try {
					// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
					return cachedClearTimeout.call(null, marker);
				} catch (e){
					// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
					// Some versions of I.E. have different rules for clearTimeout vs setTimeout
					return cachedClearTimeout.call(this, marker);
				}
			}
			
			
			
		}
		var queue = [];
		var draining = false;
		var currentQueue;
		var queueIndex = -1;
		
		function cleanUpNextTick() {
			if (!draining || !currentQueue) {
				return;
			}
			draining = false;
			if (currentQueue.length) {
				queue = currentQueue.concat(queue);
			} else {
				queueIndex = -1;
			}
			if (queue.length) {
				drainQueue();
			}
		}
		
		function drainQueue() {
			if (draining) {
				return;
			}
			var timeout = runTimeout(cleanUpNextTick);
			draining = true;
			
			var len = queue.length;
			while(len) {
				currentQueue = queue;
				queue = [];
				while (++queueIndex < len) {
					if (currentQueue) {
						currentQueue[queueIndex].run();
					}
				}
				queueIndex = -1;
				len = queue.length;
			}
			currentQueue = null;
			draining = false;
			runClearTimeout(timeout);
		}
		
		process.nextTick = function (fun) {
			var args = new Array(arguments.length - 1);
			if (arguments.length > 1) {
				for (var i = 1; i < arguments.length; i++) {
					args[i - 1] = arguments[i];
				}
			}
			queue.push(new Item(fun, args));
			if (queue.length === 1 && !draining) {
				runTimeout(drainQueue);
			}
		};

// v8 likes predictible objects
		function Item(fun, array) {
			this.fun = fun;
			this.array = array;
		}
		Item.prototype.run = function () {
			this.fun.apply(null, this.array);
		};
		process.title = 'browser';
		process.browser = true;
		process.env = {};
		process.argv = [];
		process.version = ''; // empty string to avoid regexp issues
		process.versions = {};
		
		function noop() {}
		
		process.on = noop;
		process.addListener = noop;
		process.once = noop;
		process.off = noop;
		process.removeListener = noop;
		process.removeAllListeners = noop;
		process.emit = noop;
		process.prependListener = noop;
		process.prependOnceListener = noop;
		
		process.listeners = function (name) { return [] }
		
		process.binding = function (name) {
			throw new Error('process.binding is not supported');
		};
		
		process.cwd = function () { return '/' };
		process.chdir = function (dir) {
			throw new Error('process.chdir is not supported');
		};
		process.umask = function() { return 0; };
		
		
		/***/ }),
	/* 3 */
	/***/ (function(module, exports, __webpack_require__) {
		
		var apply = Function.prototype.apply;

// DOM APIs, for completeness
		
		exports.setTimeout = function() {
			return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
		};
		exports.setInterval = function() {
			return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
		};
		exports.clearTimeout =
			exports.clearInterval = function(timeout) {
				if (timeout) {
					timeout.close();
				}
			};
		
		function Timeout(id, clearFn) {
			this._id = id;
			this._clearFn = clearFn;
		}
		Timeout.prototype.unref = Timeout.prototype.ref = function() {};
		Timeout.prototype.close = function() {
			this._clearFn.call(window, this._id);
		};

// Does not start the time, just sets up the members needed.
		exports.enroll = function(item, msecs) {
			clearTimeout(item._idleTimeoutId);
			item._idleTimeout = msecs;
		};
		
		exports.unenroll = function(item) {
			clearTimeout(item._idleTimeoutId);
			item._idleTimeout = -1;
		};
		
		exports._unrefActive = exports.active = function(item) {
			clearTimeout(item._idleTimeoutId);
			
			var msecs = item._idleTimeout;
			if (msecs >= 0) {
				item._idleTimeoutId = setTimeout(function onTimeout() {
					if (item._onTimeout)
						item._onTimeout();
				}, msecs);
			}
		};

// setimmediate attaches itself to the global object
		__webpack_require__(49);
		exports.setImmediate = setImmediate;
		exports.clearImmediate = clearImmediate;
		
		
		/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.dom = undefined;
		
		var _domNamed = __webpack_require__(55);
		
		Object.keys(_domNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _domNamed[key];
				}
			});
		});
		
		var dom = _interopRequireWildcard(_domNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = dom;
		exports.dom = dom;
		
		/***/ }),
	/* 5 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;
		
		var _core = __webpack_require__(18);
		
		Object.keys(_core).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _core[key];
				}
			});
		});
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(47);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(48);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(50);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(51);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(52);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		exports.default = _core2.default;
		
		/***/ }),
	/* 6 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.globalEvalStyles = exports.globalEval = exports.features = exports.DomEventHandle = exports.DomEventEmitterProxy = exports.domData = undefined;
		
		var _dom = __webpack_require__(4);
		
		Object.keys(_dom).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _dom[key];
				}
			});
		});
		
		var _dom2 = _interopRequireDefault(_dom);
		
		var _domData = __webpack_require__(13);
		
		var _domData2 = _interopRequireDefault(_domData);
		
		var _DomEventEmitterProxy = __webpack_require__(72);
		
		var _DomEventEmitterProxy2 = _interopRequireDefault(_DomEventEmitterProxy);
		
		var _DomEventHandle = __webpack_require__(22);
		
		var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);
		
		var _features = __webpack_require__(23);
		
		var _features2 = _interopRequireDefault(_features);
		
		var _globalEval = __webpack_require__(73);
		
		var _globalEval2 = _interopRequireDefault(_globalEval);
		
		var _globalEvalStyles = __webpack_require__(74);
		
		var _globalEvalStyles2 = _interopRequireDefault(_globalEvalStyles);
		
		__webpack_require__(75);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.domData = _domData2.default;
		exports.DomEventEmitterProxy = _DomEventEmitterProxy2.default;
		exports.DomEventHandle = _DomEventHandle2.default;
		exports.features = _features2.default;
		exports.globalEval = _globalEval2.default;
		exports.globalEvalStyles = _globalEvalStyles2.default;
		exports.default = _dom2.default;
		
		/***/ }),
	/* 7 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;
		
		var _core = __webpack_require__(19);
		
		Object.keys(_core).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _core[key];
				}
			});
		});
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(57);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(58);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(59);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(60);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(61);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		exports.default = _core2.default;
		
		/***/ }),
	/* 8 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.EventHandler = exports.EventHandle = exports.EventEmitterProxy = exports.EventEmitter = undefined;
		
		var _EventEmitter = __webpack_require__(63);
		
		var _EventEmitter2 = _interopRequireDefault(_EventEmitter);
		
		var _EventEmitterProxy = __webpack_require__(70);
		
		var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);
		
		var _EventHandle = __webpack_require__(21);
		
		var _EventHandle2 = _interopRequireDefault(_EventHandle);
		
		var _EventHandler = __webpack_require__(71);
		
		var _EventHandler2 = _interopRequireDefault(_EventHandler);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _EventEmitter2.default;
		exports.EventEmitter = _EventEmitter2.default;
		exports.EventEmitterProxy = _EventEmitterProxy2.default;
		exports.EventHandle = _EventHandle2.default;
		exports.EventHandler = _EventHandler2.default;
		
		/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.clearData = clearData;
		exports.getData = getData;
		var RENDERER_DATA = '__METAL_IC_RENDERER_DATA__';
		
		/**
		 * Removes the incremental dom renderer data object for this component.
		 * @param {!Component} component
		 */
		function clearData(component) {
			component[RENDERER_DATA] = null;
		}
		
		/**
		 * Gets the incremental dom renderer data object for this component, creating
		 * it if it doesn't exist yet.
		 * @param {!Component} component
		 * @return {!Object}
		 */
		function getData(component) {
			if (!component[RENDERER_DATA]) {
				component[RENDERER_DATA] = {};
			}
			return component[RENDERER_DATA];
		}
		
		/***/ }),
	/* 10 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;
		
		var _core = __webpack_require__(20);
		
		Object.keys(_core).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _core[key];
				}
			});
		});
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(65);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(66);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(67);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(68);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(69);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		exports.default = _core2.default;
		
		/***/ }),
	/* 11 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;
		
		var _core = __webpack_require__(31);
		
		Object.keys(_core).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _core[key];
				}
			});
		});
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(89);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(90);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(91);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(92);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(93);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		exports.default = _core2.default;
		
		/***/ }),
	/* 12 */
	/***/ (function(module, exports) {
		
		var g;

// This works in non-strict mode
		g = (function() {
			return this;
		})();
		
		try {
			// This works if eval is allowed (see CSP)
			g = g || Function("return this")() || (1,eval)("this");
		} catch(e) {
			// This works if the window reference is available
			if(typeof window === "object")
				g = window;
		}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}
		
		module.exports = g;
		
		
		/***/ }),
	/* 13 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var METAL_DATA = '__metal_data__';
		
		var domData = function () {
			function domData() {
				_classCallCheck(this, domData);
			}
			
			_createClass(domData, null, [{
				key: 'get',
				
				/**
				 * Gets Metal.js's data for the given element.
				 * @param {!Element} element
				 * @param {string=} opt_name Optional property from the data to be returned.
				 * @param {*} opt_initialVal Optinal value to the set the requested property
				 *     to if it doesn't exist yet in the data.
				 * @return {!Object}
				 */
				value: function get(element, opt_name, opt_initialVal) {
					if (!element[METAL_DATA]) {
						element[METAL_DATA] = {};
					}
					if (!opt_name) {
						return element[METAL_DATA];
					}
					if (!element[METAL_DATA][opt_name] && opt_initialVal) {
						element[METAL_DATA][opt_name] = opt_initialVal;
					}
					return element[METAL_DATA][opt_name];
				}
				
				/**
				 * Checks if the given element has data stored in it.
				 * @param {!Element} element
				 * @return {boolean}
				 */
				
			}, {
				key: 'has',
				value: function has(element) {
					return !!element[METAL_DATA];
				}
			}]);
			
			return domData;
		}();
		
		exports.default = domData;
		
		/***/ }),
	/* 14 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;
		
		var _core = __webpack_require__(27);
		
		Object.keys(_core).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _core[key];
				}
			});
		});
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(77);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(78);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(79);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(80);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(81);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		exports.default = _core2.default;
		
		/***/ }),
	/* 15 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.getOriginalFns = getOriginalFns;
		exports.getOriginalFn = getOriginalFn;
		exports.startInterception = startInterception;
		exports.stopInterception = stopInterception;
		
		__webpack_require__(30);
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		/**
		 * Gets the original incremental dom functions.
		 * @return {!Object}
		 */
		function getOriginalFns() {
			return originalFns;
		}
		
		/**
		 * Gets the original incremental dom function with the given name.
		 * @param {string} name
		 * @return {!Object}
		 */
		function getOriginalFn(name) {
			return originalFns[name];
		}
		
		/**
		 * Starts intercepting calls to incremental dom, replacing them with the given
		 * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`
		 * and `attr` are the only ones that can't be intercepted, since they'll
		 * automatically be converted into equivalent calls to `elementOpen` and
		 * `elementClose`.
		 * @param {!Object} fns Functions to be called instead of the original ones
		 *     from incremental DOM. Should be given as a map from the function name
		 *     to the function that should intercept it. All interceptors will receive
		 *     the original function as the first argument, the actual arguments from
		 *     from the original call following it.
		 */
		function startInterception(fns) {
			fns.attr = fnAttr;
			fns.elementOpenEnd = fnOpenEnd;
			fns.elementOpenStart = fnOpenStart;
			fns.elementVoid = fnVoid;
			fnStack.push(fns);
		}
		
		/**
		 * Restores the original `elementOpen` function from incremental dom to the
		 * implementation it used before the last call to `startInterception`.
		 */
		function stopInterception() {
			fnStack.pop();
		}
		
		var originalFns = {
			attr: IncrementalDOM.attr,
			attributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],
			elementClose: IncrementalDOM.elementClose,
			elementOpen: IncrementalDOM.elementOpen,
			elementOpenEnd: IncrementalDOM.elementOpenEnd,
			elementOpenStart: IncrementalDOM.elementOpenStart,
			elementVoid: IncrementalDOM.elementVoid,
			text: IncrementalDOM.text
		};
		
		var fnStack = [];
		
		var collectedArgs = [];
		
		function fnAttr(name, value) {
			collectedArgs.push(name, value);
		}
		
		function fnOpenStart(tag, key, statics) {
			collectedArgs = [tag, key, statics];
		}
		
		function fnOpenEnd() {
			var _IncrementalDOM;
			
			return (_IncrementalDOM = IncrementalDOM).elementOpen.apply(_IncrementalDOM, _toConsumableArray(collectedArgs));
		}
		
		function fnVoid() {
			IncrementalDOM.elementOpen.apply(null, arguments);
			return IncrementalDOM.elementClose.apply(null, arguments);
		}
		
		function getStack() {
			return fnStack.length > 0 ? fnStack[fnStack.length - 1] : null;
		}
		
		function buildHandleCall(name) {
			var data = {
				name: name
			};
			var fn = handleCall.bind(data);
			return fn;
		}
		
		function handleCall() {
			var name = this.name; // eslint-disable-line
			var stack = getStack();
			var fn = stack && stack[name] || originalFns[name];
			return fn.apply(null, arguments);
		}
		
		IncrementalDOM.attr = buildHandleCall('attr');
		IncrementalDOM.elementClose = buildHandleCall('elementClose');
		IncrementalDOM.elementOpen = buildHandleCall('elementOpen');
		IncrementalDOM.elementOpenEnd = buildHandleCall('elementOpenEnd');
		IncrementalDOM.elementOpenStart = buildHandleCall('elementOpenStart');
		IncrementalDOM.elementVoid = buildHandleCall('elementVoid');
		IncrementalDOM.text = buildHandleCall('text');
		
		IncrementalDOM.attributes[IncrementalDOM.symbols.default] = buildHandleCall('attributes');
		
		/***/ }),
	/* 16 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(115);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);
		
		class EventEmitter extends __WEBPACK_IMPORTED_MODULE_0_events___default.a{
			constructor(){
				super();
			}
		}
		/* harmony export (immutable) */ __webpack_exports__["a"] = EventEmitter;
		
		
		
		/***/ }),
	/* 17 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.addListenersFromObj = addListenersFromObj;
		exports.getComponentFn = getComponentFn;
		
		var _metal = __webpack_require__(5);
		
		/**
		 * Adds the listeners specified in the given object.
		 * @param {!Component} component
		 * @param {Object} events
		 * @return {!Array<!EventHandle>} Handles from all subscribed events.
		 */
		function addListenersFromObj(component, events) {
			var eventNames = Object.keys(events || {});
			var handles = [];
			for (var i = 0; i < eventNames.length; i++) {
				var info = extractListenerInfo_(component, events[eventNames[i]]);
				if (info.fn) {
					var handle = void 0;
					if (info.selector) {
						handle = component.delegate(eventNames[i], info.selector, info.fn);
					} else {
						handle = component.on(eventNames[i], info.fn);
					}
					handles.push(handle);
				}
			}
			return handles;
		}
		
		/**
		 * Extracts listener info from the given value.
		 * @param {!Component} component
		 * @param {!Component} component
		 * @param {function()|string|{selector:string,fn:function()|string}} value
		 * @return {!{selector:string,fn:function()}}
		 * @protected
		 */
		function extractListenerInfo_(component, value) {
			var info = {
				fn: value
			};
			if ((0, _metal.isObject)(value) && !(0, _metal.isFunction)(value)) {
				info.selector = value.selector;
				info.fn = value.fn;
			}
			if ((0, _metal.isString)(info.fn)) {
				info.fn = getComponentFn(component, info.fn);
			}
			return info;
		}
		
		/**
		 * Gets the listener function from its name. Throws an error if none exist.
		 * @param {!Component} component
		 * @param {string} fnName
		 * @return {function()}
		 */
		function getComponentFn(component, fnName) {
			if ((0, _metal.isFunction)(component[fnName])) {
				return component[fnName].bind(component);
			} else {
				console.error('No function named ' + fnName + ' was found in the component\n\t\t\t"' + (0, _metal.getFunctionName)(component.constructor) + '". Make sure that you specify\n\t\t\tvalid function names when adding inline listeners');
			}
		}
		
		/***/ }),
	/* 18 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.core = undefined;
		
		var _coreNamed = __webpack_require__(46);
		
		Object.keys(_coreNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _coreNamed[key];
				}
			});
		});
		
		var core = _interopRequireWildcard(_coreNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = core;
		exports.core = core;
		
		/***/ }),
	/* 19 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.core = undefined;
		
		var _coreNamed = __webpack_require__(56);
		
		Object.keys(_coreNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _coreNamed[key];
				}
			});
		});
		
		var core = _interopRequireWildcard(_coreNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = core;
		exports.core = core;
		
		/***/ }),
	/* 20 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.core = undefined;
		
		var _coreNamed = __webpack_require__(64);
		
		Object.keys(_coreNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _coreNamed[key];
				}
			});
		});
		
		var core = _interopRequireWildcard(_coreNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = core;
		exports.core = core;
		
		/***/ }),
	/* 21 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(10);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * EventHandle utility. Holds information about an event subscription, and
		 * allows removing them easily.
		 * EventHandle is a Disposable, but it's important to note that the
		 * EventEmitter that created it is not the one responsible for disposing it.
		 * That responsibility is for the code that holds a reference to it.
		 * @param {!EventEmitter} emitter Emitter the event was subscribed to.
		 * @param {string} event The name of the event that was subscribed to.
		 * @param {!Function} listener The listener subscribed to the event.
		 * @constructor
		 * @extends {Disposable}
		 */
		var EventHandle = function (_Disposable) {
			_inherits(EventHandle, _Disposable);
			
			function EventHandle(emitter, event, listener) {
				_classCallCheck(this, EventHandle);
				
				/**
				 * The EventEmitter instance that the event was subscribed to.
				 * @type {EventEmitter}
				 * @protected
				 */
				var _this = _possibleConstructorReturn(this, (EventHandle.__proto__ || Object.getPrototypeOf(EventHandle)).call(this));
				
				_this.emitter_ = emitter;
				
				/**
				 * The name of the event that was subscribed to.
				 * @type {string}
				 * @protected
				 */
				_this.event_ = event;
				
				/**
				 * The listener subscribed to the event.
				 * @type {Function}
				 * @protected
				 */
				_this.listener_ = listener;
				return _this;
			}
			
			/**
			 * Disposes of this instance's object references.
			 * @override
			 */
			
			
			_createClass(EventHandle, [{
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.removeListener();
					this.emitter_ = null;
					this.listener_ = null;
				}
				
				/**
				 * Removes the listener subscription from the emitter.
				 */
				
			}, {
				key: 'removeListener',
				value: function removeListener() {
					if (!this.emitter_.isDisposed()) {
						this.emitter_.removeListener(this.event_, this.listener_);
					}
				}
			}]);
			
			return EventHandle;
		}(_metal.Disposable);
		
		exports.default = EventHandle;
		
		/***/ }),
	/* 22 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metalEvents = __webpack_require__(8);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * This is a special EventHandle, that is responsible for dom events, instead
		 * of EventEmitter events.
		 * @extends {EventHandle}
		 */
		var DomEventHandle = function (_EventHandle) {
			_inherits(DomEventHandle, _EventHandle);
			
			/**
			 * The constructor for `DomEventHandle`.
			 * @param {!EventEmitter} emitter Emitter the event was subscribed to.
			 * @param {string} event The name of the event that was subscribed to.
			 * @param {!Function} listener The listener subscribed to the event.
			 * @param {boolean} opt_capture Flag indicating if listener should be triggered
			 *   during capture phase, instead of during the bubbling phase. Defaults to false.
			 * @constructor
			 */
			function DomEventHandle(emitter, event, listener, opt_capture) {
				_classCallCheck(this, DomEventHandle);
				
				var _this = _possibleConstructorReturn(this, (DomEventHandle.__proto__ || Object.getPrototypeOf(DomEventHandle)).call(this, emitter, event, listener));
				
				_this.capture_ = opt_capture;
				return _this;
			}
			
			/**
			 * @inheritDoc
			 */
			
			
			_createClass(DomEventHandle, [{
				key: 'removeListener',
				value: function removeListener() {
					this.emitter_.removeEventListener(this.event_, this.listener_, this.capture_);
				}
			}]);
			
			return DomEventHandle;
		}(_metalEvents.EventHandle);
		
		exports.default = DomEventHandle;
		
		/***/ }),
	/* 23 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _dom = __webpack_require__(4);
		
		var _metal = __webpack_require__(7);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		/**
		 * Class with static methods responsible for doing browser feature checks.
		 */
		var features = function () {
			function features() {
				_classCallCheck(this, features);
			}
			
			_createClass(features, null, [{
				key: 'checkAnimationEventName',
				
				/**
				 * Some browsers still supports prefixed animation events. This method can
				 * be used to retrieve the current browser event name for both, animation
				 * and transition.
				 * @return {object}
				 */
				value: function checkAnimationEventName() {
					if (features.animationEventName_ === undefined) {
						features.animationEventName_ = {
							animation: features.checkAnimationEventName_('animation'),
							transition: features.checkAnimationEventName_('transition')
						};
					}
					return features.animationEventName_;
				}
				
				/**
				 * @protected
				 * @param {string} type Type to test: animation, transition.
				 * @return {string} Browser event name.
				 */
				
			}, {
				key: 'checkAnimationEventName_',
				value: function checkAnimationEventName_(type) {
					var prefixes = ['Webkit', 'MS', 'O', ''];
					var typeTitleCase = _metal.string.replaceInterval(type, 0, 1, type.substring(0, 1).toUpperCase());
					var suffixes = [typeTitleCase + 'End', typeTitleCase + 'End', typeTitleCase + 'End', type + 'end'];
					for (var i = 0; i < prefixes.length; i++) {
						if (features.animationElement_.style[prefixes[i] + typeTitleCase] !== undefined) {
							return prefixes[i].toLowerCase() + suffixes[i];
						}
					}
					return type + 'end';
				}
				
				/**
				 * Some browsers (like IE9) change the order of element attributes, when html
				 * is rendered. This method can be used to check if this behavior happens on
				 * the current browser.
				 * @return {boolean}
				 */
				
			}, {
				key: 'checkAttrOrderChange',
				value: function checkAttrOrderChange() {
					if (features.attrOrderChange_ === undefined) {
						var originalContent = '<div data-component="" data-ref=""></div>';
						var element = document.createElement('div');
						(0, _dom.append)(element, originalContent);
						features.attrOrderChange_ = originalContent !== element.innerHTML;
					}
					return features.attrOrderChange_;
				}
			}]);
			
			return features;
		}();
		
		features.animationElement_ = document.createElement('div');
		features.animationEventName_ = undefined;
		features.attrOrderChange_ = undefined;
		
		exports.default = features;
		
		/***/ }),
	/* 24 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(5);
		
		var _metalState = __webpack_require__(25);
		
		var _metalState2 = _interopRequireDefault(_metalState);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var BLACKLIST = {
			components: true,
			context: true,
			element: true,
			refs: true,
			state: true,
			stateKey: true,
			wasRendered: true
		};
		var DATA_MANAGER_DATA = '__DATA_MANAGER_DATA__';
		
		var ComponentDataManager = function () {
			function ComponentDataManager() {
				_classCallCheck(this, ComponentDataManager);
			}
			
			_createClass(ComponentDataManager, [{
				key: 'createState_',
				
				/**
				 * Creates the `State` instance that will handle the main component data.
				 * @param {!Component} component
				 * @param {!Object} data
				 * @protected
				 */
				value: function createState_(component, data) {
					var state = new _metalState2.default(component.getInitialConfig(), component, component);
					state.setKeysBlacklist(BLACKLIST);
					state.configState(_metal.object.mixin({}, data, _metalState2.default.getStateStatic(component.constructor)));
					this.getManagerData(component).state_ = state;
				}
				
				/**
				 * Disposes of any data being used by the manager in this component.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'dispose',
				value: function dispose(component) {
					var data = this.getManagerData(component);
					if (data.state_) {
						data.state_.dispose();
					}
					component[DATA_MANAGER_DATA] = null;
				}
				
				/**
				 * Gets the data with the given name.
				 * @param {!Component} component
				 * @param {string} name
				 * @return {*}
				 */
				
			}, {
				key: 'get',
				value: function get(component, name) {
					return this.getManagerData(component).state_.get(name);
				}
				
				/**
				 * Gets the manager data for the given component.
				 * @param {!Component} component
				 * @return {Object}
				 */
				
			}, {
				key: 'getManagerData',
				value: function getManagerData(component) {
					return component[DATA_MANAGER_DATA];
				}
				
				/**
				 * Gets the keys for state data that can be synced via `sync` functions.
				 * @param {!Component} component
				 * @return {!Array<string>}
				 */
				
			}, {
				key: 'getSyncKeys',
				value: function getSyncKeys(component) {
					return this.getManagerData(component).state_.getStateKeys();
				}
				
				/**
				 * Gets the keys for state data.
				 * @param {!Component} component
				 * @return {!Array<string>}
				 */
				
			}, {
				key: 'getStateKeys',
				value: function getStateKeys(component) {
					return this.getManagerData(component).state_.getStateKeys();
				}
				
				/**
				 * Gets the whole state data.
				 * @param {!Component} component
				 * @return {!Object}
				 */
				
			}, {
				key: 'getState',
				value: function getState(component) {
					return this.getManagerData(component).state_.getState();
				}
				
				/**
				 * Gets the `State` instance being used.
				 * @param {!Component} component
				 * @return {!Object}
				 */
				
			}, {
				key: 'getStateInstance',
				value: function getStateInstance(component) {
					return this.getManagerData(component).state_;
				}
				
				/**
				 * Updates all non internal data with the given values (or to the default
				 * value if none is given).
				 * @param {!Component} component
				 * @param {!Object} data
				 * @param {State=} opt_state
				 */
				
			}, {
				key: 'replaceNonInternal',
				value: function replaceNonInternal(component, data, opt_state) {
					var state = opt_state || this.getManagerData(component).state_;
					var keys = state.getStateKeys();
					for (var i = 0; i < keys.length; i++) {
						var key = keys[i];
						if (!state.getStateKeyConfig(key).internal) {
							if (data.hasOwnProperty(key)) {
								state.set(key, data[key]);
							} else {
								state.setDefaultValue(key);
							}
						}
					}
				}
				
				/**
				 * Sets the value of all the specified state keys.
				 * @param {!Component} component
				 * @param {!Object.<string,*>} values A map of state keys to the values they
				 *   should be set to.
				 * @param {function()=} opt_callback An optional function that will be run
				 *   after the next batched update is triggered.
				 */
				
			}, {
				key: 'setState',
				value: function setState(component, state, opt_callback) {
					this.getManagerData(component).state_.setState(state, opt_callback);
				}
				
				/**
				 * Sets up the specified component's data.
				 * @param {!Component} component
				 * @param {!Object} data
				 */
				
			}, {
				key: 'setUp',
				value: function setUp(component, data) {
					component[DATA_MANAGER_DATA] = {};
					this.createState_(component, data);
				}
			}]);
			
			return ComponentDataManager;
		}();
		
		exports.default = new ComponentDataManager();
		
		/***/ }),
	/* 25 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.State = exports.Config = exports.validators = undefined;
		
		var _validators = __webpack_require__(26);
		
		var _validators2 = _interopRequireDefault(_validators);
		
		var _Config = __webpack_require__(82);
		
		var _Config2 = _interopRequireDefault(_Config);
		
		var _State = __webpack_require__(83);
		
		var _State2 = _interopRequireDefault(_State);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _State2.default;
		exports.validators = _validators2.default;
		exports.Config = _Config2.default;
		exports.State = _State2.default;
		
		/***/ }),
	/* 26 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
		
		var _metal = __webpack_require__(14);
		
		var ERROR_ARRAY_OF_TYPE = 'Expected an array of single type.';
		var ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';
		var ERROR_ONE_OF = 'Expected one of given values.';
		var ERROR_ONE_OF_TYPE = 'Expected one of given types.';
		var ERROR_SHAPE_OF = 'Expected object with a specific shape.';
		
		/**
		 * Provides access to various type validators that will return an
		 * instance of Error when validation fails. Note that all type validators
		 * will also accept null or undefined values. To not accept these you should
		 * instead make your state property required.
		 */
		var validators = {
			any: function any() {
				return function () {
					return true;
				};
			},
			array: buildTypeValidator('array'),
			bool: buildTypeValidator('boolean'),
			func: buildTypeValidator('function'),
			number: buildTypeValidator('number'),
			object: buildTypeValidator('object'),
			string: buildTypeValidator('string'),
			
			/**
			 * Creates a validator that checks that the value it receives is an array
			 * of items, and that all of the items pass the given validator.
			 * @param {!function()} validator Validator to check each item against.
			 * @return {!function()}
			 */
			arrayOf: function arrayOf(validator) {
				return maybe(function (value, name, context) {
					var result = validators.array(value, name, context);
					if (isInvalid(result)) {
						return result;
					}
					return validateArrayItems(validator, value, name, context);
				});
			},
			
			/**
			 * Creates a validator that checks if a value is an instance of a given class.
			 * @param {!function()} expectedClass Class to check value against.
			 * @return {!function()}
			 */
			instanceOf: function instanceOf(expectedClass) {
				return maybe(function (value, name, context) {
					if (value instanceof expectedClass) {
						return true;
					}
					var msg = 'Expected instance of ' + expectedClass;
					return composeError(msg, name, context);
				});
			},
			
			/**
			 * Creates a validator that checks that the value it receives is an object,
			 * and that all values within that object pass the given validator.
			 * @param {!function()} validator Validator to check each object value against.
			 * @return {!function()}
			 */
			objectOf: function objectOf(validator) {
				return maybe(function (value, name, context) {
					for (var key in value) {
						if (isInvalid(validator(value[key]))) {
							return composeError(ERROR_OBJECT_OF_TYPE, name, context);
						}
					}
					return true;
				});
			},
			
			/**
			 * Creates a validator that checks if the received value matches one of the
			 * given values.
			 * @param {!Array} arrayOfValues Array of values to check equality against.
			 * @return {!function()}
			 */
			oneOf: function oneOf(arrayOfValues) {
				return maybe(function (value, name, context) {
					var result = validators.array(arrayOfValues, name, context);
					if (isInvalid(result)) {
						return result;
					}
					return arrayOfValues.indexOf(value) === -1 ? composeError(ERROR_ONE_OF, name, context) : true;
				});
			},
			
			/**
			 * Creates a validator that checks if the received value matches one of the
			 * given types.
			 * @param {!Array} arrayOfTypeValidators Array of validators to check value
			 *     against.
			 * @return {!function()}
			 */
			oneOfType: function oneOfType(arrayOfTypeValidators) {
				return maybe(function (value, name, context) {
					var result = validators.array(arrayOfTypeValidators, name, context);
					if (isInvalid(result)) {
						return result;
					}
					
					for (var i = 0; i < arrayOfTypeValidators.length; i++) {
						if (!isInvalid(arrayOfTypeValidators[i](value, name, context))) {
							return true;
						}
					}
					return composeError(ERROR_ONE_OF_TYPE, name, context);
				});
			},
			
			/**
			 * Creates a validator that checks if the received value is an object, and
			 * that its contents match the given shape.
			 * @param {!Object} shape An object containing validators for each key.
			 * @return {!function()}
			 */
			shapeOf: function shapeOf(shape) {
				return maybe(function (value, name, context) {
					var result = validators.object(shape, name, context);
					if (isInvalid(result)) {
						return result;
					}
					
					for (var key in shape) {
						var validator = shape[key];
						var required = false;
						if (validator.config) {
							required = validator.config.required;
							validator = validator.config.validator;
						}
						if (required && !(0, _metal.isDefAndNotNull)(value[key]) || isInvalid(validator(value[key]))) {
							return composeError(ERROR_SHAPE_OF, name, context);
						}
					}
					return true;
				});
			}
		};
		
		/**
		 * Creates a validator that checks against a specific primitive type.
		 * @param {string} expectedType Type to check against.
		 * @return {!function()} Function that runs the validator if called with
		 *     arguments, or just returns it otherwise. This means that when using a
		 *     type validator in `State` it may be just passed directly (like
		 *     `validators.bool`), or called with no args (like `validators.bool()`).
		 *     That's done to allow all validators to be used consistently, since some
		 *     (like `arrayOf`) always require that you call the function before
		 *     receiving the actual validator. Type validators don't need the call, but
		 *     work if it's made anyway.
		 */
		function buildTypeValidator(expectedType) {
			var validatorFn = maybe(validateType.bind(null, expectedType));
			return function () {
				if (arguments.length === 0) {
					return validatorFn;
				} else {
					return validatorFn.apply(undefined, arguments);
				}
			};
		}
		
		/**
		 * Composes a warning a warning message.
		 * @param {string} error Error message to display to console.
		 * @param {?string} name Name of state property that is giving the error.
		 * @param {Object} context The property's owner.
		 * @return {!Error}
		 */
		function composeError(error, name, context) {
			var compName = context ? (0, _metal.getFunctionName)(context.constructor) : null;
			var renderer = context && context.getRenderer && context.getRenderer();
			var parent = renderer && renderer.getParent && renderer.getParent();
			var parentName = parent ? (0, _metal.getFunctionName)(parent.constructor) : null;
			var location = parentName ? 'Check render method of \'' + parentName + '\'.' : '';
			return new Error('Warning: Invalid state passed to \'' + name + '\'. ' + (error + ' Passed to \'' + compName + '\'. ' + location));
		}
		
		/**
		 * Returns the type of the given value.
		 * @param {*} value Any value.
		 * @return {string} Type of value.
		 */
		function getType(value) {
			return Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
		}
		
		/**
		 * Checks if the given validator result says that the value is invalid.
		 * @param {boolean|!Error} result
		 * @return {boolean}
		 */
		function isInvalid(result) {
			return result instanceof Error;
		}
		
		/**
		 * Wraps the given validator so that it also accepts null/undefined values.
		 *   a validator that checks a value against a single type, null, or
		 * undefined.
		 * @param {!function()} typeValidator Validator to wrap.
		 * @return {!function()} Wrapped validator.
		 */
		function maybe(typeValidator) {
			return function (value, name, context) {
				return (0, _metal.isDefAndNotNull)(value) ? typeValidator(value, name, context) : true;
			};
		}
		
		/**
		 * Checks if all the items of the given array pass the given validator.
		 * @param {!function()} validator
		 * @param {*} value The array to validate items for.
		 * @param {string} name The name of the array property being checked.
		 * @param {!Object} context Owner of the array property being checked.
		 * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
		 */
		function validateArrayItems(validator, value, name, context) {
			for (var i = 0; i < value.length; i++) {
				if (isInvalid(validator(value[i], name, context))) {
					return composeError(ERROR_ARRAY_OF_TYPE, name, context);
				}
			}
			return true;
		}
		
		/**
		 * Checks if the given value matches the expected type.
		 * @param {string} expectedType String representing the expected type.
		 * @param {*} value The value to match the type of.
		 * @param {string} name The name of the property being checked.
		 * @param {!Object} context Owner of the property being checked.
		 * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
		 */
		function validateType(expectedType, value, name, context) {
			var type = getType(value);
			if (type !== expectedType) {
				var msg = 'Expected type \'' + expectedType + '\', but received type \'' + type + '\'.';
				return composeError(msg, name, context);
			}
			return true;
		}
		
		exports.default = validators;
		
		/***/ }),
	/* 27 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.core = undefined;
		
		var _coreNamed = __webpack_require__(76);
		
		Object.keys(_coreNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _coreNamed[key];
				}
			});
		});
		
		var core = _interopRequireWildcard(_coreNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = core;
		exports.core = core;
		
		/***/ }),
	/* 28 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Base class that component renderers should extend from. It defines the
		 * required methods all renderers should have.
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var ComponentRenderer = function () {
			function ComponentRenderer() {
				_classCallCheck(this, ComponentRenderer);
			}
			
			_createClass(ComponentRenderer, [{
				key: 'dispose',
				
				
				/**
				 * Disposes of any data specific to the given component.
				 * @param {!Component} component
				 */
				value: function dispose() {}
				
				/**
				 * Returns extra configuration for data that should be added to the manager.
				 * Sub classes can override to return `State` config for properties that
				 * should be added to the component.
				 * @param {!Component} component
				 * @return {Object}
				 */
				
			}, {
				key: 'getExtraDataConfig',
				value: function getExtraDataConfig() {}
				
				/**
				 * Renders the whole content (including its main element) and informs the
				 * component about it. Should be overridden by sub classes.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'render',
				value: function render(component) {
					if (!component.element) {
						component.element = document.createElement('div');
					}
					component.informRendered();
				}
				
				/**
				 * Sets up this component to be used by this renderer. Sub classes should
				 * override as needed for more behavior.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'setUp',
				value: function setUp() {}
				
				/**
				 * Updates the component's element html. This is automatically called when
				 * the value of at least one of the component's state keys has changed.
				 * Should be implemented by sub classes. Sub classes have to remember to call
				 * "informRendered" on the component when any update rendering is done.
				 * @param {!Component} component
				 * @param {Object.<string, Object>} changes Object containing the names
				 *     of all changed state keys, each mapped to an object with its new
				 *     (newVal) and previous (prevVal) values.
				 */
				
			}, {
				key: 'update',
				value: function update() {}
			}]);
			
			return ComponentRenderer;
		}();
		
		exports.default = new ComponentRenderer();
		
		/***/ }),
	/* 29 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		__webpack_require__(30);
		
		var _changes = __webpack_require__(32);
		
		var _data = __webpack_require__(9);
		
		var _children = __webpack_require__(33);
		
		var _patch2 = __webpack_require__(94);
		
		var _render = __webpack_require__(35);
		
		var _metalComponent = __webpack_require__(0);
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var IncrementalDomRenderer = function (_ComponentRenderer$co) {
			_inherits(IncrementalDomRenderer, _ComponentRenderer$co);
			
			function IncrementalDomRenderer() {
				_classCallCheck(this, IncrementalDomRenderer);
				
				return _possibleConstructorReturn(this, (IncrementalDomRenderer.__proto__ || Object.getPrototypeOf(IncrementalDomRenderer)).apply(this, arguments));
			}
			
			_createClass(IncrementalDomRenderer, [{
				key: 'buildShouldUpdateArgs',
				
				/**
				 * Returns an array with the args that should be passed to the component's
				 * `shouldUpdate` method. This can be overridden by sub classes to change
				 * what the method should receive.
				 * @param {Object} changes
				 * @return {!Array}
				 */
				value: function buildShouldUpdateArgs(changes) {
					return [changes.props];
				}
				
				/**
				 * @inheritDoc
				 */
				
			}, {
				key: 'dispose',
				value: function dispose(component) {
					var data = (0, _data.getData)(component);
					var ref = data.config.ref;
					var owner = data.owner;
					if (owner && owner.components && owner.components[ref] === component) {
						delete owner.components[ref];
					}
					
					if (data.childComponents) {
						for (var i = 0; i < data.childComponents.length; i++) {
							var child = data.childComponents[i];
							if (!child.isDisposed()) {
								child.element = null;
								child.dispose();
							}
						}
					}
					
					(0, _data.clearData)(component);
				}
				
				/**
				 * Generates a key for the element currently being rendered in the given
				 * component. By default, just returns the original key. Sub classes can
				 * override this to change the behavior.
				 * @param {!Component} component
				 * @param {string} key
				 * @return {?string}
				 */
				
			}, {
				key: 'generateKey',
				value: function generateKey(component, key) {
					return key;
				}
				
				/**
				 * Get the component's config data.
				 * @param {!Component} component
				 * @return {!Object}
				 */
				
			}, {
				key: 'getConfig',
				value: function getConfig(component) {
					return (0, _data.getData)(component).config;
				}
				
				/**
				 * Get the component's incremental dom renderer data.
				 * @param {!Component} component
				 * @return {!Object}
				 */
				
			}, {
				key: 'getData',
				value: function getData(component) {
					return (0, _data.getData)(component);
				}
				
				/**
				 * Gets the component that triggered the current patch operation.
				 * @return {Component}
				 */
				
			}, {
				key: 'getPatchingComponent',
				value: function getPatchingComponent() {
					return (0, _patch2.getPatchingComponent)();
				}
				
				/**
				 * Handles a node having just been rendered. Sub classes should override this
				 * for custom behavior.
				 */
				
			}, {
				key: 'handleNodeRendered',
				value: function handleNodeRendered() {}
				
				/**
				 * Checks if the given object is an incremental dom node.
				 * @param {!Object} node
				 * @return {boolean}
				 */
				
			}, {
				key: 'isIncDomNode',
				value: function isIncDomNode(node) {
					return !!(0, _children.getOwner)(node);
				}
				
				/**
				 * Calls incremental dom's patch function to render the component.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'patch',
				value: function patch(component) {
					(0, _patch2.patch)(component);
				}
				
				/**
				 * Renders the renderer's component for the first time, patching its element
				 * through incremental dom function calls. If the first arg is a function
				 * instead of a component instance, creates and renders this function, which
				 * can either be a simple incremental dom function or a component constructor.
				 * @param {!Component} component
				 * @param {!Component|function()} component Can be a component instance, a
				 *     simple incremental dom function or a component constructor.
				 * @param {Object|Element=} opt_dataOrElement Optional config data for the
				 *     function, or parent for the rendered content.
				 * @param {Element=} opt_parent Optional parent for the rendered content.
				 * @return {!Component} The rendered component's instance.
				 */
				
			}, {
				key: 'render',
				value: function render(component, opt_dataOrElement, opt_parent) {
					if (component instanceof _metalComponent.Component) {
						this.patch(component);
					} else {
						return (0, _render.renderFunction)(this, component, opt_dataOrElement, opt_parent);
					}
				}
				
				/**
				 * Renders the given child node via its owner renderer.
				 * @param {!Object} child
				 */
				
			}, {
				key: 'renderChild',
				value: function renderChild(child) {
					(0, _render.renderChild)(child);
				}
				
				/**
				 * Calls functions from `IncrementalDOM` to build the component element's
				 * content. Can be overriden by subclasses (for integration with template
				 * engines for example).
				 * @param {!Component} component
				 */
				
			}, {
				key: 'renderIncDom',
				value: function renderIncDom(component) {
					if (component.render) {
						component.render();
					} else {
						IncrementalDOM.elementVoid('div');
					}
				}
				
				/**
				 * Runs the incremental dom functions for rendering this component, without
				 * calling `patch`. This function needs to be called inside a `patch`.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'renderInsidePatch',
				value: function renderInsidePatch(component) {
					var shouldRender = !component.wasRendered || this.shouldUpdate(component, (0, _changes.getChanges)(component)) || IncrementalDOM.currentPointer() !== component.element;
					if (shouldRender) {
						(0, _render.render)(component);
					} else if (component.element) {
						this.skipRender();
					}
				}
				
				/**
				 * Sets up this component to be used by this renderer.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'setUp',
				value: function setUp(component) {
					component.context = {};
					component.components = {};
					component.refs = {};
					
					var data = (0, _data.getData)(component);
					data.config = component.getInitialConfig();
					(0, _changes.trackChanges)(component);
				}
				
				/**
				 * Checks if the component should be updated with the current state changes.
				 * @param {!Component} component
				 * @param {Object} changes
				 * @return {boolean}
				 */
				
			}, {
				key: 'shouldUpdate',
				value: function shouldUpdate(component, changes) {
					if (!changes) {
						return false;
					}
					if (component.shouldUpdate) {
						return component.shouldUpdate.apply(component, _toConsumableArray(this.buildShouldUpdateArgs(changes)));
					}
					return true;
				}
				
				/**
				 * Skips the next disposal of children components, by clearing the array as
				 * if there were no children rendered the last time. This can be useful for
				 * allowing components to be reused by other parent components in separate
				 * render update cycles.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'skipNextChildrenDisposal',
				value: function skipNextChildrenDisposal(component) {
					(0, _data.getData)(component).childComponents = null;
				}
				
				/**
				 * Skips rendering the current node.
				 */
				
			}, {
				key: 'skipRender',
				value: function skipRender() {
					IncrementalDOM.skipNode();
				}
				
				/**
				 * Updates the renderer's component when state changes, patching its element
				 * through incremental dom function calls.
				 * @param {!Component} component
				 */
				
			}, {
				key: 'update',
				value: function update(component) {
					if (this.shouldUpdate(component, (0, _changes.getChanges)(component))) {
						this.patch(component);
					}
				}
			}]);
			
			return IncrementalDomRenderer;
		}(_metalComponent.ComponentRenderer.constructor);
		
		var renderer = new IncrementalDomRenderer();

// Name of this renderer. Renderers should provide this as a way to identify
// them via a simple string (when calling enableCompatibilityMode to add
// support to old features for specific renderers for example).
		renderer.RENDERER_NAME = 'incremental-dom';
		
		exports.default = renderer;
		
		/***/ }),
	/* 30 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(global) {
			
			var _incrementalDom = __webpack_require__(86);
			
			var IncrementalDOM = _interopRequireWildcard(_incrementalDom);
			
			var _incrementalDomString = __webpack_require__(87);
			
			var IncrementalDOMString = _interopRequireWildcard(_incrementalDomString);
			
			var _metal = __webpack_require__(11);
			
			function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
			
			if ((0, _metal.isServerSide)()) {
				// Overrides global.IncrementalDOM virtual elements with incremental dom
				// string implementation for server side rendering. At the moment it does not
				// override for Node.js tests since tests are using jsdom to simulate the
				// browser.
				global.IncrementalDOM = IncrementalDOMString;
			} else {
				var scope = typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window;
				
				scope.IncrementalDOM = IncrementalDOM;
			}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))
		
		/***/ }),
	/* 31 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.core = undefined;
		
		var _coreNamed = __webpack_require__(88);
		
		Object.keys(_coreNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _coreNamed[key];
				}
			});
		});
		
		var core = _interopRequireWildcard(_coreNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = core;
		exports.core = core;
		
		/***/ }),
	/* 32 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.clearChanges = clearChanges;
		exports.getChanges = getChanges;
		exports.trackChanges = trackChanges;
		
		var _data = __webpack_require__(9);
		
		/**
		 * Clears the changes tracked so far.
		 * @param {!Object} data
		 */
		function clearChanges(data) {
			data.changes = null;
		}
		
		/**
		 * Handles the `stateKeyChanged` event from a component. Stores change data.
		 * @param {!Object} data
		 * @param {!Object} eventData
		 * @private
		 */
		function handleStateKeyChanged_(data, eventData) {
			data.changes = data.changes || {};
			var type = eventData.type || 'props';
			data.changes[type] = data.changes[type] || {};
			data.changes[type][eventData.key] = eventData;
		}
		
		/**
		 * Returns an object with changes in the given component since the last time,
		 * or null if there weren't any.
		 * @param {!Component} component
		 * @return {Object}
		 */
		function getChanges(component) {
			return (0, _data.getData)(component).changes;
		}
		
		/**
		 * Starts tracking changes for the given component
		 * @param {!Component} component
		 */
		function trackChanges(component) {
			var data = (0, _data.getData)(component);
			component.on('stateKeyChanged', handleStateKeyChanged_.bind(null, data));
		}
		
		/***/ }),
	/* 33 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.CHILD_OWNER = undefined;
		exports.captureChildren = captureChildren;
		exports.isChildTag = isChildTag;
		exports.getOwner = getOwner;
		exports.renderChildTree = renderChildTree;
		
		var _callArgs = __webpack_require__(34);
		
		var _metal = __webpack_require__(11);
		
		var _incrementalDomAop = __webpack_require__(15);
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		/**
		 * Property identifying a specific object as a Metal.js child node, and
		 * pointing to the component instance that created it.
		 * @type {string}
		 */
		var CHILD_OWNER = exports.CHILD_OWNER = '__metalChildOwner';
		
		/**
		 * Captures all child elements from incremental dom calls.
		 * @param {!Component} component The component that is capturing children.
		 * @param {!function()} callback Function to be called when children have all
		 *     been captured.
		 * @param {Object} data Data to pass to the callback function when calling it.
		 */
		function captureChildren(component, callback, data) {
			owner_ = component;
			callback_ = callback;
			callbackData_ = data;
			tree_ = {
				props: {
					children: []
				}
			};
			tree_.config = tree_.props;
			currentParent_ = tree_;
			isCapturing_ = true;
			(0, _incrementalDomAop.startInterception)({
				elementClose: handleInterceptedCloseCall_,
				elementOpen: handleInterceptedOpenCall_,
				text: handleInterceptedTextCall_
			});
		}
		
		/**
		 * Checks if the given tag was built from a component's children.
		 * @param {*} tag
		 * @return {boolean}
		 */
		function isChildTag(tag) {
			return (0, _metal.isDef)(tag.tag);
		}
		
		/**
		 * Gets the node's original owner.
		 * @param {!Object} node
		 * @return {Component}
		 */
		function getOwner(node) {
			return node[CHILD_OWNER];
		}
		
		/**
		 * Renders a children tree through incremental dom.
		 * @param {!{args: Array, children: !Array, isText: ?boolean}}
		 * @param {function()=} opt_skipNode Optional function that is called for
		 *     each node to be rendered. If it returns true, the node will be skipped.
		 * @protected
		 */
		function renderChildTree(tree, opt_skipNode) {
			if (isCapturing_) {
				// If capturing, just add the node directly to the captured tree.
				addChildToTree(tree);
				return;
			}
			
			if (opt_skipNode && opt_skipNode.call(null, tree)) {
				return;
			}
			
			if ((0, _metal.isDef)(tree.text)) {
				var args = tree.args ? tree.args : [];
				args[0] = tree.text;
				IncrementalDOM.text.apply(null, args);
			} else {
				var _args = (0, _callArgs.buildCallFromConfig)(tree.tag, tree.props);
				_args[0] = {
					tag: _args[0],
					owner: getOwner(tree)
				};
				IncrementalDOM.elementOpen.apply(null, _args);
				if (tree.props.children) {
					for (var i = 0; i < tree.props.children.length; i++) {
						renderChildTree(tree.props.children[i], opt_skipNode);
					}
				}
				IncrementalDOM.elementClose(tree.tag);
			}
		}
		
		var callbackData_ = void 0;
		var callback_ = void 0;
		var currentParent_ = void 0;
		var isCapturing_ = false;
		var owner_ = void 0;
		var tree_ = void 0;
		
		/**
		 * Adds a child element to the tree.
		 * @param {!Array} args The arguments passed to the incremental dom call.
		 * @param {boolean=} opt_isText Optional flag indicating if the child is a
		 *     text element.
		 * @protected
		 */
		function addChildCallToTree_(args, opt_isText) {
			var child = _defineProperty({
				parent: currentParent_
			}, CHILD_OWNER, owner_);
			
			if (opt_isText) {
				child.text = args[0];
				if (args.length > 1) {
					child.args = args;
				}
			} else {
				child.tag = args[0];
				child.props = (0, _callArgs.buildConfigFromCall)(args);
				child.props.children = [];
				child.config = child.props;
			}
			
			addChildToTree(child);
			return child;
		}
		
		function addChildToTree(child) {
			currentParent_.props.children.push(child);
		}
		
		/**
		 * Handles an intercepted call to the `elementClose` function from incremental
		 * dom.
		 * @protected
		 */
		function handleInterceptedCloseCall_() {
			if (currentParent_ === tree_) {
				(0, _incrementalDomAop.stopInterception)();
				isCapturing_ = false;
				var node = callback_.call(owner_, tree_, callbackData_);
				callback_ = null;
				callbackData_ = null;
				currentParent_ = null;
				owner_ = null;
				tree_ = null;
				return node;
			} else {
				currentParent_ = currentParent_.parent;
				return true;
			}
		}
		
		/**
		 * Handles an intercepted call to the `elementOpen` function from incremental
		 * dom.
		 * @param {!function()} originalFn The original function before interception.
		 * @protected
		 */
		function handleInterceptedOpenCall_() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			
			currentParent_ = addChildCallToTree_(args);
		}
		
		/**
		 * Handles an intercepted call to the `text` function from incremental dom.
		 * @param {!function()} originalFn The original function before interception.
		 * @protected
		 */
		function handleInterceptedTextCall_() {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}
			
			addChildCallToTree_(args, true);
		}
		
		/***/ }),
	/* 34 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Builds the component config object from its incremental dom call's
		 * arguments.
		 * @param {!Array} args
		 * @return {!Object}
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.buildConfigFromCall = buildConfigFromCall;
		exports.buildCallFromConfig = buildCallFromConfig;
		function buildConfigFromCall(args) {
			var config = {};
			if (args[1]) {
				config.key = args[1];
			}
			var attrsArr = (args[2] || []).concat(args.slice(3));
			for (var i = 0; i < attrsArr.length; i += 2) {
				config[attrsArr[i]] = attrsArr[i + 1];
			}
			return config;
		}
		
		/**
		 * Builds an incremental dom call array from the given tag and config object.
		 * @param {string} tag
		 * @param {!Object} config
		 * @return {!Array}
		 */
		function buildCallFromConfig(tag, config) {
			var call = [tag, config.key, []];
			var keys = Object.keys(config);
			for (var i = 0; i < keys.length; i++) {
				if (keys[i] !== 'children' && keys[i] !== 'key') {
					call.push(keys[i], config[keys[i]]);
				}
			}
			return call;
		}
		
		/***/ }),
	/* 35 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		exports.getComponentBeingRendered = getComponentBeingRendered;
		exports.isComponentTag_ = isComponentTag_;
		exports.render = render;
		exports.renderChild = renderChild;
		exports.renderFunction = renderFunction;
		
		var _attributes = __webpack_require__(95);
		
		var _callArgs = __webpack_require__(34);
		
		var _children = __webpack_require__(33);
		
		var _changes = __webpack_require__(32);
		
		var _metalDom = __webpack_require__(6);
		
		var _data = __webpack_require__(9);
		
		var _metal = __webpack_require__(11);
		
		var _unused = __webpack_require__(96);
		
		var _incrementalDomAop = __webpack_require__(15);
		
		var _metalComponent = __webpack_require__(0);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var renderingComponents_ = [];
		var emptyChildren_ = [];
		
		/**
		 * Adds the given css classes to the specified arguments for an incremental
		 * dom call, merging with the existing value if there is one.
		 * @param {string} elementClasses
		 * @param {!Object} config
		 * @private
		 */
		function addElementClasses_(elementClasses, config) {
			if (config.class) {
				config.class += ' ' + elementClasses;
				config.class = removeDuplicateClasses_(config.class);
			} else {
				config.class = elementClasses;
			}
		}
		
		/**
		 * Builds the "children" array to be passed to the current component.
		 * @param {!Array<!Object>} children
		 * @return {!Array<!Object>}
		 * @private
		 */
		function buildChildren_(children) {
			return children.length === 0 ? emptyChildren_ : children;
		}
		
		/**
		 * Finishes the render operation, doing some cleaups.
		 * @param {!Component} component
		 * @private
		 */
		function cleanUpRender_(component) {
			(0, _incrementalDomAop.stopInterception)();
			if (!(0, _data.getData)(component).rootElementReached) {
				component.element = null;
			}
			component.informRendered();
			finishedRenderingComponent_();
		}
		
		/**
		 * Removes the most recent component from the queue of rendering components.
		 * @private
		 */
		function finishedRenderingComponent_() {
			renderingComponents_.pop();
			if (renderingComponents_.length === 0) {
				(0, _unused.disposeUnused)();
			}
		}
		
		/**
		 * Generates a key for the next element to be rendered.
		 * @param {!Component} component
		 * @param {?string} key The key originally passed to the element.
		 * @return {?string}
		 * @private
		 */
		function generateKey_(component, key) {
			var data = (0, _data.getData)(component);
			if (!data.rootElementReached && data.config.key) {
				key = data.config.key;
			}
			return component.getRenderer().generateKey(component, key);
		}
		
		/**
		 * Gets the child components stored in the given object.
		 * @param {!Object} data
		 * @return {!Array<!Component>}
		 * @private
		 */
		function getChildComponents_(data) {
			data.childComponents = data.childComponents || [];
			return data.childComponents;
		}
		
		/**
		 * Gets the component being currently rendered.
		 * @return {Component}
		 */
		function getComponentBeingRendered() {
			return renderingComponents_[renderingComponents_.length - 1];
		}
		
		/**
		 * Gets the data object that should be currently used. This object will either
		 * come from the current element being rendered by incremental dom or from
		 * the component instance being rendered (only when the current element is the
		 * component's direct parent).
		 * @return {!Object}
		 * @private
		 */
		function getCurrentData() {
			var element = IncrementalDOM.currentElement();
			var comp = getComponentBeingRendered();
			var obj = (0, _data.getData)(comp);
			if (obj.rootElementReached && element !== comp.element.parentNode) {
				obj = _metalDom.domData.get(element);
			}
			obj.icComponentsData = obj.icComponentsData || {};
			return obj.icComponentsData;
		}
		
		/**
		 * Returns the "ref" to be used for a component. Uses "key" as "ref" when
		 * compatibility mode is on for the current renderer.
		 * @param {!Component} owner
		 * @param {!Object} config
		 * @return {?string}
		 * @private
		 */
		function getRef_(owner, config) {
			var compatData = (0, _metal.getCompatibilityModeData)();
			if (compatData) {
				var ownerRenderer = owner.getRenderer();
				var renderers = compatData.renderers;
				var useKey = !renderers || renderers.indexOf(ownerRenderer) !== -1 || renderers.indexOf(ownerRenderer.RENDERER_NAME) !== -1;
				if (useKey && config.key && !config.ref) {
					return config.key;
				}
			}
			return config.ref;
		}
		
		/**
		 * Gets the sub component referenced by the given tag and config data,
		 * creating it if it doesn't yet exist.
		 * @param {string|!Function} tagOrCtor The tag name.
		 * @param {!Object} config The config object for the sub component.
		 * @param {!Component} owner
		 * @return {!Component} The sub component.
		 * @protected
		 */
		function getSubComponent_(tagOrCtor, config, owner) {
			var Ctor = tagOrCtor;
			if ((0, _metal.isString)(Ctor)) {
				Ctor = _metalComponent.ComponentRegistry.getConstructor(tagOrCtor);
			}
			
			var ref = getRef_(owner, config);
			var comp = void 0;
			if ((0, _metal.isDef)(ref)) {
				comp = match_(owner.components[ref], Ctor, config, owner);
				owner.components[ref] = comp;
				owner.refs[ref] = comp;
			} else {
				var data = getCurrentData();
				var key = config.key;
				if (!(0, _metal.isDef)(key)) {
					var type = (0, _metal.getUid)(Ctor, true);
					data.currCount = data.currCount || {};
					data.currCount[type] = data.currCount[type] || 0;
					key = '__METAL_IC__' + type + '_' + data.currCount[type]++;
				}
				comp = match_(data.prevComps ? data.prevComps[key] : null, Ctor, config, owner);
				data.currComps = data.currComps || {};
				data.currComps[key] = comp;
			}
			
			return comp;
		}
		
		/**
		 * Handles the event of children having finished being captured.
		 * @param {!Object} tree The captured children in tree format.
		 * @private
		 */
		function handleChildrenCaptured_(tree, _ref) {
			var props = _ref.props,
				tag = _ref.tag;
			
			props.children = buildChildren_(tree.props.children);
			return renderFromTag_(tag, props);
		}
		
		/**
		 * Handles a child being rendered via `IncrementalDomChildren.render`. Skips
		 * component nodes so that they can be rendered the correct way without
		 * having to recapture both them and their children via incremental dom.
		 * @param {!Object} node
		 * @return {boolean}
		 * @private
		 */
		function handleChildRender_(node) {
			if (node.tag && isComponentTag_(node.tag)) {
				node.props.children = buildChildren_(node.props.children);
				renderFromTag_(node.tag, node.props, (0, _children.getOwner)(node));
				return true;
			}
		}
		
		/**
		 * Handles an intercepted call to the attributes default handler from
		 * incremental dom.
		 * @param {!Element} element
		 * @param {string} name
		 * @param {*} value
		 * @private
		 */
		function handleInterceptedAttributesCall_(element, name, value) {
			(0, _attributes.applyAttribute)(getComponentBeingRendered(), element, name, value);
		}
		
		/**
		 * Handles an intercepted call to the `elementOpen` function from incremental
		 * dom.
		 * @param {string} tag
		 * @private
		 */
		function handleInterceptedOpenCall_(tag) {
			if (isComponentTag_(tag)) {
				return handleSubComponentCall_.apply(null, arguments);
			} else {
				return handleRegularCall_.apply(null, arguments);
			}
		}
		
		/**
		 * Handles an intercepted call to the `elementOpen` function from incremental
		 * dom, done for a regular element. Among other things, adds any inline
		 * listeners found on the first render and makes sure that component root
		 * elements are always reused.
		 * @param {!Component} owner
		 * @param {!Array} args
		 * @return {!Element} The rendered element.
		 * @private
		 */
		function handleRegularCall_() {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}
			
			var config = (0, _callArgs.buildConfigFromCall)(args);
			var tag = args[0];
			
			var comp = getComponentBeingRendered();
			var owner = comp;
			if ((0, _children.isChildTag)(tag)) {
				owner = tag.owner;
				tag = tag.tag;
			}
			config.key = generateKey_(comp, config.key);
			
			if (!(0, _data.getData)(comp).rootElementReached) {
				var elementClasses = comp.getDataManager().get(comp, 'elementClasses');
				if (elementClasses) {
					addElementClasses_(elementClasses, config);
				}
			}
			(0, _attributes.convertListenerNamesToFns)(comp, config);
			
			var call = (0, _callArgs.buildCallFromConfig)(tag, config);
			var node = (0, _incrementalDomAop.getOriginalFn)('elementOpen').apply(null, call);
			resetNodeData_(node);
			updateElementIfNotReached_(comp, node);
			
			if ((0, _metal.isDefAndNotNull)(config.ref)) {
				owner.refs[config.ref] = node;
			}
			owner.getRenderer().handleNodeRendered(node);
			
			return node;
		}
		
		/**
		 * Handles an intercepted call to the `elementOpen` function from incremental
		 * dom, done for a sub component element. Creates and updates the appropriate
		 * sub component.
		 * @private
		 */
		function handleSubComponentCall_() {
			for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
				args[_key2] = arguments[_key2];
			}
			
			(0, _children.captureChildren)(getComponentBeingRendered(), handleChildrenCaptured_, {
				props: (0, _callArgs.buildConfigFromCall)(args),
				tag: args[0]
			});
		}
		
		/**
		 * Passes down elementClasses to a child component if the parent component
		 * returns another component at the top level (HOC).
		 * @param {*} parent The parent component
		 * @param {*} config The config of the subcomponent
		 */
		function inheritElementClasses_(parent, config) {
			var parentData = (0, _data.getData)(parent);
			var parentConfig = parentData.config;
			
			if (!parentData.rootElementReached && parentConfig && (0, _metal.isString)(parentConfig.elementClasses)) {
				var currentClasses = '';
				if ((0, _metal.isString)(config.elementClasses)) {
					currentClasses = config.elementClasses + ' ';
				}
				
				config.elementClasses = currentClasses + parentConfig.elementClasses;
			}
		}
		
		/**
		 * Checks if the given tag represents a metal component.
		 * @param {string} tag
		 * @return {boolean}
		 * @private
		 */
		function isComponentTag_(tag) {
			return (0, _metal.isFunction)(tag) || (0, _metal.isString)(tag) && tag[0] === tag[0].toUpperCase();
		}
		
		/**
		 * Checks if the given component can be a match for a constructor.
		 * @param {!Component} comp
		 * @param {!function()} Ctor
		 * @param {!Component} owner
		 * @return {boolean}
		 * @private
		 */
		function isMatch_(comp, Ctor, owner) {
			if (!comp || comp.constructor !== Ctor || comp.isDisposed()) {
				return false;
			}
			return (0, _data.getData)(comp).owner === owner;
		}
		
		/**
		 * Returns the given component if it matches the specified constructor
		 * function. Otherwise, returns a new instance of the given constructor. On
		 * both cases the component's state and config will be updated.
		 * @param {Component} comp
		 * @param {!function()} Ctor
		 * @param {!Object} config
		 * @param {!Component} owner
		 * @return {!Component}
		 * @private
		 */
		function match_(comp, Ctor, config, owner) {
			if (isMatch_(comp, Ctor, owner)) {
				comp.startSkipUpdates();
				comp.getDataManager().replaceNonInternal(comp, config);
				comp.stopSkipUpdates();
			} else {
				comp = new Ctor(config, false);
			}
			(0, _data.getData)(comp).config = config;
			return comp;
		}
		
		/**
		 * Prepares the render operation, resetting the component's data and starting
		 * the incremental dom interception.
		 * @param {!Component} component
		 * @private
		 */
		function prepareRender_(component) {
			renderingComponents_.push(component);
			
			var data = (0, _data.getData)(component);
			resetComponentsData_(data.icComponentsData);
			(0, _changes.clearChanges)(data);
			data.rootElementReached = false;
			component.refs = {};
			
			if (data.childComponents) {
				(0, _unused.schedule)(data.childComponents);
				data.childComponents = null;
			}
			
			(0, _incrementalDomAop.startInterception)({
				attributes: handleInterceptedAttributesCall_,
				elementOpen: handleInterceptedOpenCall_
			});
		}
		
		/**
		 * Removes duplicate css classes from the given string.
		 * @param {string} classString
		 * @return {string}
		 * @private
		 */
		function removeDuplicateClasses_(classString) {
			var classes = [];
			var all = classString.split(/\s+/);
			var used = {};
			for (var i = 0; i < all.length; i++) {
				if (!used[all[i]]) {
					used[all[i]] = true;
					classes.push(all[i]);
				}
			}
			return classes.join(' ');
		}
		
		/**
		 * Renders the component with incremental dom function calls. This assumes that
		 * an incremental dom `patch` is already running, and that this function has
		 * been called inside it.
		 * @param {!Component} component
		 */
		function render(component) {
			prepareRender_(component);
			component.getRenderer().renderIncDom(component);
			cleanUpRender_(component);
		}
		
		/**
		 * Renders the given child node.
		 * @param {!Object} child
		 */
		function renderChild(child) {
			(0, _children.renderChildTree)(child, handleChildRender_);
		}
		
		/**
		 * Renders the contents for the given tag.
		 * @param {!function()|string} tag
		 * @param {!Object} config
		 * @param {Component=} opt_owner
		 * @private
		 */
		function renderFromTag_(tag, config, opt_owner) {
			if ((0, _metal.isString)(tag) || tag.prototype.getRenderer) {
				var comp = renderSubComponent_(tag, config, opt_owner);
				updateElementIfNotReached_(getComponentBeingRendered(), comp.element);
				return comp.element;
			} else {
				return tag(config);
			}
		}
		
		/**
		 * Creates and renders the given function, which can either be a simple
		 * incremental dom function or a component constructor.
		 * @param {!IncrementalDomRenderer} renderer
		 * @param {!function()} fnOrCtor Either a simple incremental dom function or a
		 *     component constructor.
		 * @param {Object|Element=} opt_dataOrElement Optional config data for the
		 *     function or parent for the rendered content.
		 * @param {Element=} opt_parent Optional parent for the rendered content.
		 * @return {!Component} The rendered component's instance.
		 */
		function renderFunction(renderer, fnOrCtor, opt_dataOrElement, opt_parent) {
			if (!_metalComponent.Component.isComponentCtor(fnOrCtor)) {
				var fn = fnOrCtor;
				
				var TempComponent = function (_Component) {
					_inherits(TempComponent, _Component);
					
					function TempComponent() {
						_classCallCheck(this, TempComponent);
						
						return _possibleConstructorReturn(this, (TempComponent.__proto__ || Object.getPrototypeOf(TempComponent)).apply(this, arguments));
					}
					
					_createClass(TempComponent, [{
						key: 'created',
						value: function created() {
							var parent = getComponentBeingRendered();
							if (parent) {
								updateContext_(this, parent);
							}
						}
					}, {
						key: 'render',
						value: function render() {
							fn(this.getInitialConfig());
						}
					}]);
					
					return TempComponent;
				}(_metalComponent.Component);
				
				TempComponent.RENDERER = renderer;
				fnOrCtor = TempComponent;
			}
			return _metalComponent.Component.render(fnOrCtor, opt_dataOrElement, opt_parent);
		}
		
		/**
		 * This updates the sub component that is represented by the given data.
		 * The sub component is created, added to its parent and rendered. If it
		 * had already been rendered before though, it will only have its state
		 * updated instead.
		 * @param {string|!function()} tagOrCtor The tag name or constructor function.
		 * @param {!Object} config The config object for the sub component.
		 * @param {ComponentRenderer=} opt_owner
		 * @return {!Component} The updated sub component.
		 * @private
		 */
		function renderSubComponent_(tagOrCtor, config, opt_owner) {
			var parent = getComponentBeingRendered();
			var owner = opt_owner || parent;
			
			inheritElementClasses_(parent, config);
			
			var comp = getSubComponent_(tagOrCtor, config, owner);
			updateContext_(comp, parent);
			
			var data = (0, _data.getData)(comp);
			data.parent = parent;
			data.owner = owner;
			
			var parentData = (0, _data.getData)(parent);
			getChildComponents_(parentData).push(comp);
			if (!config.key && !parentData.rootElementReached) {
				config.key = parentData.config.key;
			}
			
			comp.getRenderer().renderInsidePatch(comp);
			if (!comp.wasRendered) {
				comp.renderComponent();
			}
			return comp;
		}
		
		/**
		 * Resets the given incremental dom data object, preparing it for the next pass.
		 * @param {Object} data
		 * @private
		 */
		function resetComponentsData_(data) {
			if (data) {
				data.prevComps = data.currComps;
				data.currComps = null;
				data.currCount = null;
			}
		}
		/**
		 * Resets all data stored in the given node.
		 * @param {!Element} node
		 * @private
		 */
		function resetNodeData_(node) {
			if (_metalDom.domData.has(node)) {
				resetComponentsData_(_metalDom.domData.get(node).icComponentsData);
			}
		}
		
		/**
		 * Updates the given component's context according to the data from the
		 * component that is currently being rendered.
		 * @param {!Component} comp
		 * @protected
		 */
		function updateContext_(comp, parent) {
			var context = comp.context;
			var childContext = parent.getChildContext ? parent.getChildContext() : null;
			_metal.object.mixin(context, parent.context, childContext);
			comp.context = context;
		}
		
		/**
		 * Updates this renderer's component's element with the given values, unless
		 * it has already been reached by an earlier call.
		 * @param {!Component} component
		 * @param {!Element} node
		 * @private
		 */
		function updateElementIfNotReached_(component, node) {
			var data = (0, _data.getData)(component);
			if (!data.rootElementReached) {
				data.rootElementReached = true;
				if (component.element !== node) {
					component.element = node;
				}
			}
		}
		
		/***/ }),
	/* 36 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.core = undefined;
		
		var _coreNamed = __webpack_require__(98);
		
		Object.keys(_coreNamed).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _coreNamed[key];
				}
			});
		});
		
		var core = _interopRequireWildcard(_coreNamed);
		
		function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
		
		exports.default = core;
		exports.core = core;
		
		/***/ }),
	/* 37 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * A collection of core utility functions.
		 * @const
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var core = function () {
			function core() {
				_classCallCheck(this, core);
			}
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = core.abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			core.abstractMethod = function abstractMethod() {
				throw Error('Unimplemented abstract method');
			};
			
			/**
			 * Loops constructor super classes collecting its properties values. If
			 * property is not available on the super class `undefined` will be
			 * collected as value for the class hierarchy position.
			 * @param {!function()} constructor Class constructor.
			 * @param {string} propertyName Property name to be collected.
			 * @return {Array.<*>} Array of collected values.
			 * TODO(*): Rethink superclass loop.
			 */
			
			
			core.collectSuperClassesProperty = function collectSuperClassesProperty(constructor, propertyName) {
				var propertyValues = [constructor[propertyName]];
				while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
					constructor = constructor.__proto__;
					propertyValues.push(constructor[propertyName]);
				}
				return propertyValues;
			};
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			
			
			core.getFunctionName = function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			};
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link core.UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			
			
			core.getUid = function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[core.UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(core.UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[core.UID_PROPERTY] = core.uniqueIdCounter_++);
				}
				return core.uniqueIdCounter_++;
			};
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			
			
			core.identityFunction = function identityFunction(opt_returnValue) {
				return opt_returnValue;
			};
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			
			
			core.isBoolean = function isBoolean(val) {
				return typeof val === 'boolean';
			};
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			
			
			core.isDef = function isDef(val) {
				return val !== undefined;
			};
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isDefAndNotNull = function isDefAndNotNull(val) {
				return core.isDef(val) && !core.isNull(val);
			};
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isDocument = function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			};
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isElement = function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			};
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			
			
			core.isFunction = function isFunction(val) {
				return typeof val === 'function';
			};
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isNull = function isNull(val) {
				return val === null;
			};
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			
			
			core.isNumber = function isNumber(val) {
				return typeof val === 'number';
			};
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isWindow = function isWindow(val) {
				return val !== null && val === val.window;
			};
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			
			
			core.isObject = function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			};
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isPromise = function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			};
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {Boolean}
			 */
			
			
			core.isString = function isString(val) {
				return typeof val === 'string';
			};
			
			/**
			 * Merges the values of a static property a class with the values of that
			 * property for all its super classes, and stores it as a new static
			 * property of that class. If the static property already existed, it won't
			 * be recalculated.
			 * @param {!function()} constructor Class constructor.
			 * @param {string} propertyName Property name to be collected.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
			 *   with the values of the property for the current class and all its super classes.
			 *   Should return the merged value to be stored on the current class.
			 * @return {boolean} Returns true if merge happens, false otherwise.
			 */
			
			
			core.mergeSuperClassesProperty = function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (constructor.hasOwnProperty(mergedName)) {
					return false;
				}
				
				var merged = core.collectSuperClassesProperty(constructor, propertyName);
				if (opt_mergeFn) {
					merged = opt_mergeFn(merged);
				}
				constructor[mergedName] = merged;
				return true;
			};
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			
			
			core.nullFunction = function nullFunction() {};
			
			return core;
		}();
		
		/**
		 * Unique id property prefix.
		 * @type {String}
		 * @protected
		 */
		
		
		core.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
		
		/**
		 * Counter for unique id.
		 * @type {Number}
		 * @private
		 */
		core.uniqueIdCounter_ = 1;
		
		exports.default = core;
		
		/***/ }),
	/* 38 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scss_app_scss__ = __webpack_require__(39);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scss_app_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__scss_app_scss__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_MetalForm_MetalForm__ = __webpack_require__(44);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_Dropdown_Dropdown__ = __webpack_require__(116);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Calculator_Calculator__ = __webpack_require__(119);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_CalculatorButton_CalculatorButton__ = __webpack_require__(122);
		
		
		
		
		
		
		new __WEBPACK_IMPORTED_MODULE_1__components_MetalForm_MetalForm__["a" /* default */]({
			endpoint: 'http://localhost:3100/calculator'
		});
		
		
		
		
		/***/ }),
	/* 39 */
	/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
		var content = __webpack_require__(40);
		if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
		var transform;
		
		var options = {}
		options.transform = transform
// add the styles to the DOM
		var update = __webpack_require__(42)(content, options);
		if(content.locals) module.exports = content.locals;
// Hot Module Replacement
		if(false) {
			// When the styles change, update the <style> tags
			if(!content.locals) {
				module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./app.scss", function() {
					var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./app.scss");
					if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
					update(newContent);
				});
			}
			// When the module is disposed, remove the <style> tags
			module.hot.dispose(function() { update(); });
		}
		
		/***/ }),
	/* 40 */
	/***/ (function(module, exports, __webpack_require__) {
		
		exports = module.exports = __webpack_require__(41)(undefined);
// imports
		exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=Open+Sans);", ""]);

// module
		exports.push([module.i, "html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline; }\n\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section {\n  display: block; }\n\nbody {\n  line-height: 1; }\n\nol, ul {\n  list-style: none; }\n\nblockquote, q {\n  quotes: none; }\n\nblockquote:before, blockquote:after {\n  content: '';\n  content: none; }\n\nq:before, q:after {\n  content: '';\n  content: none; }\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\n*, *:after, *:before {\n  box-sizing: border-box; }\n\nbody {\n  font-family: \"Open Sans\";\n  font-size: 13px;\n  background: #fafafa; }\n  body:before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 421px;\n    background: #3e9cfc;\n    left: 0;\n    top: 0; }\n\nhtml, body {\n  height: 100%; }\n\na {\n  text-decoration: none; }\n\n.wrapper {\n  padding-top: 56px;\n  min-height: calc(100% - 168px);\n  position: relative; }\n\n.container {\n  padding: 0 20px;\n  max-width: 1280px;\n  width: 100%;\n  margin: 0 auto; }\n  .container:after {\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: \" \";\n    clear: both;\n    height: 0; }\n\nform.loan-form fieldset .input-error {\n  color: #d0021b;\n  background: rgba(208, 1, 27, 0.2); }\n  form.loan-form fieldset .input-error::-webkit-input-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error:-moz-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error::-moz-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error:-ms-input-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error:active {\n    border-color: #d0021b; }\n\nbutton:hover, button:focus, button:active, a:hover, a:focus, a:active, input:hover, input:focus, input:active {\n  outline: none; }\n\nh1 {\n  font-size: 38px;\n  color: #fff;\n  font-weight: 400;\n  text-align: center;\n  margin-bottom: 46px; }\n  h1 small {\n    margin-top: 35px;\n    display: block;\n    font-size: 18px;\n    font-weight: 300; }\n\n.site-footer {\n  width: 100%;\n  height: 128px;\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flex;\n  display: -o-flex;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n  line-height: 1.5;\n  color: #9b9b9b;\n  background: #ffffff;\n  width: 100%;\n  bottom: -168px;\n  position: absolute; }\n\n.dropdown {\n  position: relative;\n  font-size: 14px; }\n  .dropdown .dropdown-display {\n    position: relative; }\n  .dropdown .dropdown-list-wrapper {\n    display: none;\n    width: 100%;\n    top: 40px;\n    box-shadow: 0 2px 14px 0 rgba(97, 149, 237, 0.1);\n    border: solid 1px #e4e9ec;\n    position: absolute;\n    z-index: 5;\n    background: #fff; }\n    .dropdown .dropdown-list-wrapper input {\n      background: no-repeat 5px center transparent url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4NCiAgIDxwYXRoIGZpbGw9IiMwMDAwMDAiIGQ9Ik05LjUsM0E2LjUsNi41IDAgMCwxIDE2LDkuNUMxNiwxMS4xMSAxNS40MSwxMi41OSAxNC40NCwxMy43M0wxNC43MSwxNEgxNS41TDIwLjUsMTlMMTksMjAuNUwxNCwxNS41VjE0LjcxTDEzLjczLDE0LjQ0QzEyLjU5LDE1LjQxIDExLjExLDE2IDkuNSwxNkE2LjUsNi41IDAgMCwxIDMsOS41QTYuNSw2LjUgMCAwLDEgOS41LDNNOS41LDVDNyw1IDUsNyA1LDkuNUM1LDEyIDcsMTQgOS41LDE0QzEyLDE0IDE0LDEyIDE0LDkuNUMxNCw3IDEyLDUgOS41LDVaIiAvPg0KPC9zdmc+\");\n      padding-left: 38px;\n      padding-top: 9px;\n      padding-bottom: 12px;\n      border-radius: 0; }\n      .dropdown .dropdown-list-wrapper input, .dropdown .dropdown-list-wrapper input:focus {\n        border-color: transparent;\n        border-bottom: 1px solid #e4e9ec; }\n  .dropdown .arrow_box {\n    position: relative;\n    background: #869cae;\n    position: absolute;\n    right: 12px;\n    z-index: 2;\n    height: 4px;\n    top: 19px; }\n    .dropdown .arrow_box:after {\n      bottom: 100%;\n      left: 50%;\n      border: solid transparent;\n      content: \" \";\n      height: 0;\n      width: 0;\n      position: absolute;\n      pointer-events: none;\n      border-bottom-color: #869cae;\n      border-width: 4px;\n      margin-left: -4px; }\n    .dropdown .arrow_box:before {\n      top: 100%;\n      left: 50%;\n      border: solid transparent;\n      content: \" \";\n      height: 0;\n      width: 0;\n      position: absolute;\n      pointer-events: none;\n      border-top-color: #869cae;\n      border-width: 4px;\n      margin-left: -4px; }\n\n.box-calculator {\n  position: relative;\n  flex: 1 0 202px;\n  margin: 0 65px 0 0; }\n  .box-calculator .calculator-display {\n    width: 202px;\n    height: 56px;\n    padding: 21px 16px 0;\n    font-size: 14px;\n    overflow: auto;\n    background: #eaf0f3; }\n  .box-calculator .calculator-buttons-wrapper {\n    display: -webkit-flex;\n    display: -moz-flex;\n    display: -ms-flex;\n    display: -o-flex;\n    display: flex;\n    flex-direction: row;\n    align-items: flex-start;\n    justify-content: space-between;\n    width: 202px;\n    margin-top: 10px; }\n  .box-calculator .calculator-digits {\n    width: 144px;\n    overflow: hidden;\n    border-radius: 5px; }\n  .box-calculator .calculator-operators {\n    overflow: hidden;\n    border-radius: 5px;\n    width: 47px; }\n    .box-calculator .calculator-operators .calculator-button, .box-calculator .calculator-operators .calculator-button--double-size {\n      margin-right: 0; }\n  .box-calculator .calculator-button, .box-calculator .calculator-button--double-size {\n    cursor: pointer;\n    width: 47px;\n    height: 47px;\n    float: left;\n    margin: 0 1px 1px 0;\n    border: 0;\n    background: rgba(62, 156, 252, 0.3);\n    color: #3e9cfc; }\n    .box-calculator .calculator-button:hover, .box-calculator .calculator-button--double-size:hover {\n      background: rgba(62, 156, 252, 0.45); }\n    .box-calculator .calculator-button:active, .box-calculator .calculator-button--double-size:active {\n      background: rgba(62, 156, 252, 0.55); }\n  .box-calculator .calculator-button--double-size {\n    width: 95px; }\n\n.loan-form {\n  background: #fff;\n  padding: 61px 65px;\n  border-radius: 6px;\n  box-shadow: 0 0 20px 0 rgba(0, 5, 61, 0.1);\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flex;\n  display: -o-flex;\n  display: flex;\n  flex-direction: row;\n  align-items: initial;\n  justify-content: stretch;\n  margin: 0 auto 122px;\n  max-width: 688px;\n  flex-wrap: wrap; }\n\n.box-loan-options {\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flex;\n  display: -o-flex;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  justify-content: flex-start;\n  flex: 1 0 290px;\n  position: relative; }\n  .box-loan-options input, .box-loan-options label, .box-loan-options button {\n    width: 100%; }\n  .box-loan-options .calculate-interest {\n    margin-bottom: 16px;\n    cursor: pointer;\n    margin-top: -3px;\n    transition: ease-out .3s all;\n    box-shadow: inset 0 0 0 #3e9cfc; }\n    .box-loan-options .calculate-interest:hover {\n      box-shadow: inset 0 50px 0 #3e9cfc;\n      color: #fff; }\n  .box-loan-options .get-quot {\n    cursor: pointer;\n    position: absolute;\n    max-width: 290px;\n    bottom: 0; }\n  .box-loan-options #input-total {\n    margin-bottom: 26px; }\n\ninput[type=\"text\"] {\n  font-size: 14px;\n  border-radius: 4px;\n  background: #eaf0f3;\n  padding: 11px 10px;\n  font-weight: 500;\n  color: #39536c;\n  border: 1px solid transparent; }\n  input[type=\"text\"]::-webkit-input-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]:-moz-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]::-moz-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]:-ms-input-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]:focus {\n    border-color: #65b4f0; }\n\n.warning-label {\n  font-size: 12.5px;\n  margin-top: 6px;\n  line-height: 16px;\n  color: #d0021b;\n  display: none; }\n  .warning-label i {\n    cursor: pointer; }\n\n.dropdown .dropdown-list-wrapper.show, .warning-label.show {\n  display: block; }\n\nlabel {\n  margin-bottom: 27px; }\n  label:after {\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: \" \";\n    clear: both;\n    height: 0; }\n  label .caption {\n    color: #4a4a4a;\n    font-size: 18px;\n    margin-bottom: 6px;\n    display: block; }\n  label .mandatory-sign {\n    font-weight: bold;\n    color: #f5984c; }\n\n.button, .button--filled {\n  color: #308fff;\n  padding: 10px;\n  font-size: 16px;\n  background: #ffffff;\n  text-align: center;\n  font-weight: 500;\n  border: 1px solid #308fff;\n  border-radius: 4px; }\n  .button[disabled], [disabled].button--filled {\n    background-color: #728694;\n    border-color: transparent; }\n\n.button--filled {\n  background: #308fff;\n  color: #ffffff; }\n\n.dropdown-list-item, .dropdown-list-item:hover {\n  cursor: pointer;\n  padding: 10px; }\n  .dropdown-list-item:hover {\n    background: #f8fafa; }\n  .dropdown-list-item[data-selected] {\n    color: #329de6; }\n\n.submit-label {\n  position: absolute;\n  bottom: 45px;\n  width: 100%;\n  color: #fff;\n  background: #3e9cfc;\n  padding: 0.5rem;\n  border-radius: 4px;\n  opacity: 0;\n  visibility: hidden;\n  transform: translateY(10px);\n  z-index: 2;\n  transition: all .3s ease-in-out; }\n  .submit-label:before {\n    content: \"\";\n    display: block;\n    border: solid 7px transparent;\n    border-top-color: #3e9cfc;\n    width: 0;\n    height: 0;\n    position: absolute;\n    bottom: -11px;\n    left: 50%;\n    margin-left: -10px; }\n  .submit-label.danger {\n    background: #be0000; }\n    .submit-label.danger:before {\n      border-top-color: #be0000; }\n  .submit-label.show-message {\n    opacity: 1;\n    visibility: visible;\n    transform: translateY(0); }\n", ""]);

// exports
		
		
		/***/ }),
	/* 41 */
	/***/ (function(module, exports) {
		
		/*
		 MIT License http://www.opensource.org/licenses/mit-license.php
		 Author Tobias Koppers @sokra
		 */
// css base code, injected by the css-loader
		module.exports = function(useSourceMap) {
			var list = [];
			
			// return the list of modules as css string
			list.toString = function toString() {
				return this.map(function (item) {
					var content = cssWithMappingToString(item, useSourceMap);
					if(item[2]) {
						return "@media " + item[2] + "{" + content + "}";
					} else {
						return content;
					}
				}).join("");
			};
			
			// import a list of modules into the list
			list.i = function(modules, mediaQuery) {
				if(typeof modules === "string")
					modules = [[null, modules, ""]];
				var alreadyImportedModules = {};
				for(var i = 0; i < this.length; i++) {
					var id = this[i][0];
					if(typeof id === "number")
						alreadyImportedModules[id] = true;
				}
				for(i = 0; i < modules.length; i++) {
					var item = modules[i];
					// skip already imported module
					// this implementation is not 100% perfect for weird media query combinations
					//  when a module is imported multiple times with different media queries.
					//  I hope this will never occur (Hey this way we have smaller bundles)
					if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
						if(mediaQuery && !item[2]) {
							item[2] = mediaQuery;
						} else if(mediaQuery) {
							item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
						}
						list.push(item);
					}
				}
			};
			return list;
		};
		
		function cssWithMappingToString(item, useSourceMap) {
			var content = item[1] || '';
			var cssMapping = item[3];
			if (!cssMapping) {
				return content;
			}
			
			if (useSourceMap && typeof btoa === 'function') {
				var sourceMapping = toComment(cssMapping);
				var sourceURLs = cssMapping.sources.map(function (source) {
					return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
				});
				
				return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
			}
			
			return [content].join('\n');
		}

// Adapted from convert-source-map (MIT)
		function toComment(sourceMap) {
			// eslint-disable-next-line no-undef
			var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
			var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
			
			return '/*# ' + data + ' */';
		}
		
		
		/***/ }),
	/* 42 */
	/***/ (function(module, exports, __webpack_require__) {
		
		/*
		 MIT License http://www.opensource.org/licenses/mit-license.php
		 Author Tobias Koppers @sokra
		 */
		
		var stylesInDom = {};
		
		var memoize = function (fn) {
			var memo;
			
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		};
		
		var isOldIE = memoize(function () {
			// Test for IE <= 9 as proposed by Browserhacks
			// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
			// Tests for existence of standard globals is to allow style-loader
			// to operate correctly into non-standard environments
			// @see https://github.com/webpack-contrib/style-loader/issues/177
			return window && document && document.all && !window.atob;
		});
		
		var getElement = (function (fn) {
			var memo = {};
			
			return function(selector) {
				if (typeof memo[selector] === "undefined") {
					memo[selector] = fn.call(this, selector);
				}
				
				return memo[selector]
			};
		})(function (target) {
			return document.querySelector(target)
		});
		
		var singleton = null;
		var singletonCounter = 0;
		var stylesInsertedAtTop = [];
		
		var fixUrls = __webpack_require__(43);
		
		module.exports = function(list, options) {
			if (typeof DEBUG !== "undefined" && DEBUG) {
				if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
			}
			
			options = options || {};
			
			options.attrs = typeof options.attrs === "object" ? options.attrs : {};
			
			// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
			// tags it will allow on a page
			if (!options.singleton) options.singleton = isOldIE();
			
			// By default, add <style> tags to the <head> element
			if (!options.insertInto) options.insertInto = "head";
			
			// By default, add <style> tags to the bottom of the target
			if (!options.insertAt) options.insertAt = "bottom";
			
			var styles = listToStyles(list, options);
			
			addStylesToDom(styles, options);
			
			return function update (newList) {
				var mayRemove = [];
				
				for (var i = 0; i < styles.length; i++) {
					var item = styles[i];
					var domStyle = stylesInDom[item.id];
					
					domStyle.refs--;
					mayRemove.push(domStyle);
				}
				
				if(newList) {
					var newStyles = listToStyles(newList, options);
					addStylesToDom(newStyles, options);
				}
				
				for (var i = 0; i < mayRemove.length; i++) {
					var domStyle = mayRemove[i];
					
					if(domStyle.refs === 0) {
						for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
						
						delete stylesInDom[domStyle.id];
					}
				}
			};
		};
		
		function addStylesToDom (styles, options) {
			for (var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				
				if(domStyle) {
					domStyle.refs++;
					
					for(var j = 0; j < domStyle.parts.length; j++) {
						domStyle.parts[j](item.parts[j]);
					}
					
					for(; j < item.parts.length; j++) {
						domStyle.parts.push(addStyle(item.parts[j], options));
					}
				} else {
					var parts = [];
					
					for(var j = 0; j < item.parts.length; j++) {
						parts.push(addStyle(item.parts[j], options));
					}
					
					stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
				}
			}
		}
		
		function listToStyles (list, options) {
			var styles = [];
			var newStyles = {};
			
			for (var i = 0; i < list.length; i++) {
				var item = list[i];
				var id = options.base ? item[0] + options.base : item[0];
				var css = item[1];
				var media = item[2];
				var sourceMap = item[3];
				var part = {css: css, media: media, sourceMap: sourceMap};
				
				if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
				else newStyles[id].parts.push(part);
			}
			
			return styles;
		}
		
		function insertStyleElement (options, style) {
			var target = getElement(options.insertInto)
			
			if (!target) {
				throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
			}
			
			var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
			
			if (options.insertAt === "top") {
				if (!lastStyleElementInsertedAtTop) {
					target.insertBefore(style, target.firstChild);
				} else if (lastStyleElementInsertedAtTop.nextSibling) {
					target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
				} else {
					target.appendChild(style);
				}
				stylesInsertedAtTop.push(style);
			} else if (options.insertAt === "bottom") {
				target.appendChild(style);
			} else {
				throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
			}
		}
		
		function removeStyleElement (style) {
			if (style.parentNode === null) return false;
			style.parentNode.removeChild(style);
			
			var idx = stylesInsertedAtTop.indexOf(style);
			if(idx >= 0) {
				stylesInsertedAtTop.splice(idx, 1);
			}
		}
		
		function createStyleElement (options) {
			var style = document.createElement("style");
			
			options.attrs.type = "text/css";
			
			addAttrs(style, options.attrs);
			insertStyleElement(options, style);
			
			return style;
		}
		
		function createLinkElement (options) {
			var link = document.createElement("link");
			
			options.attrs.type = "text/css";
			options.attrs.rel = "stylesheet";
			
			addAttrs(link, options.attrs);
			insertStyleElement(options, link);
			
			return link;
		}
		
		function addAttrs (el, attrs) {
			Object.keys(attrs).forEach(function (key) {
				el.setAttribute(key, attrs[key]);
			});
		}
		
		function addStyle (obj, options) {
			var style, update, remove, result;
			
			// If a transform function was defined, run it on the css
			if (options.transform && obj.css) {
				result = options.transform(obj.css);
				
				if (result) {
					// If transform returns a value, use that instead of the original css.
					// This allows running runtime transformations on the css.
					obj.css = result;
				} else {
					// If the transform function returns a falsy value, don't add this css.
					// This allows conditional loading of css
					return function() {
						// noop
					};
				}
			}
			
			if (options.singleton) {
				var styleIndex = singletonCounter++;
				
				style = singleton || (singleton = createStyleElement(options));
				
				update = applyToSingletonTag.bind(null, style, styleIndex, false);
				remove = applyToSingletonTag.bind(null, style, styleIndex, true);
				
			} else if (
				obj.sourceMap &&
				typeof URL === "function" &&
				typeof URL.createObjectURL === "function" &&
				typeof URL.revokeObjectURL === "function" &&
				typeof Blob === "function" &&
				typeof btoa === "function"
			) {
				style = createLinkElement(options);
				update = updateLink.bind(null, style, options);
				remove = function () {
					removeStyleElement(style);
					
					if(style.href) URL.revokeObjectURL(style.href);
				};
			} else {
				style = createStyleElement(options);
				update = applyToTag.bind(null, style);
				remove = function () {
					removeStyleElement(style);
				};
			}
			
			update(obj);
			
			return function updateStyle (newObj) {
				if (newObj) {
					if (
						newObj.css === obj.css &&
						newObj.media === obj.media &&
						newObj.sourceMap === obj.sourceMap
					) {
						return;
					}
					
					update(obj = newObj);
				} else {
					remove();
				}
			};
		}
		
		var replaceText = (function () {
			var textStore = [];
			
			return function (index, replacement) {
				textStore[index] = replacement;
				
				return textStore.filter(Boolean).join('\n');
			};
		})();
		
		function applyToSingletonTag (style, index, remove, obj) {
			var css = remove ? "" : obj.css;
			
			if (style.styleSheet) {
				style.styleSheet.cssText = replaceText(index, css);
			} else {
				var cssNode = document.createTextNode(css);
				var childNodes = style.childNodes;
				
				if (childNodes[index]) style.removeChild(childNodes[index]);
				
				if (childNodes.length) {
					style.insertBefore(cssNode, childNodes[index]);
				} else {
					style.appendChild(cssNode);
				}
			}
		}
		
		function applyToTag (style, obj) {
			var css = obj.css;
			var media = obj.media;
			
			if(media) {
				style.setAttribute("media", media)
			}
			
			if(style.styleSheet) {
				style.styleSheet.cssText = css;
			} else {
				while(style.firstChild) {
					style.removeChild(style.firstChild);
				}
				
				style.appendChild(document.createTextNode(css));
			}
		}
		
		function updateLink (link, options, obj) {
			var css = obj.css;
			var sourceMap = obj.sourceMap;
			
			/*
			 If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
			 and there is no publicPath defined then lets turn convertToAbsoluteUrls
			 on by default.  Otherwise default to the convertToAbsoluteUrls option
			 directly
			 */
			var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;
			
			if (options.convertToAbsoluteUrls || autoFixUrls) {
				css = fixUrls(css);
			}
			
			if (sourceMap) {
				// http://stackoverflow.com/a/26603875
				css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
			}
			
			var blob = new Blob([css], { type: "text/css" });
			
			var oldSrc = link.href;
			
			link.href = URL.createObjectURL(blob);
			
			if(oldSrc) URL.revokeObjectURL(oldSrc);
		}
		
		
		/***/ }),
	/* 43 */
	/***/ (function(module, exports) {
		
		
		/**
		 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
		 * embed the css on the page. This breaks all relative urls because now they are relative to a
		 * bundle instead of the current page.
		 *
		 * One solution is to only use full urls, but that may be impossible.
		 *
		 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
		 *
		 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
		 *
		 */
		
		module.exports = function (css) {
			// get current location
			var location = typeof window !== "undefined" && window.location;
			
			if (!location) {
				throw new Error("fixUrls requires window.location");
			}
			
			// blank or null?
			if (!css || typeof css !== "string") {
				return css;
			}
			
			var baseUrl = location.protocol + "//" + location.host;
			var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
			
			// convert each url(...)
			/*
			 This regular expression is just a way to recursively match brackets within
			 a string.
			 
			 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
			 (  = Start a capturing group
			 (?:  = Start a non-capturing group
			 [^)(]  = Match anything that isn't a parentheses
			 |  = OR
			 \(  = Match a start parentheses
			 (?:  = Start another non-capturing groups
			 [^)(]+  = Match anything that isn't a parentheses
			 |  = OR
			 \(  = Match a start parentheses
			 [^)(]*  = Match anything that isn't a parentheses
			 \)  = Match a end parentheses
			 )  = End Group
			 *\) = Match anything and then a close parens
			 )  = Close non-capturing group
			 *  = Match anything
			 )  = Close capturing group
			 \)  = Match a close parens
			 
			 /gi  = Get all matches, not the first.  Be case insensitive.
			 */
			var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
				// strip quotes (if they exist)
				var unquotedOrigUrl = origUrl
					.trim()
					.replace(/^"(.*)"$/, function(o, $1){ return $1; })
					.replace(/^'(.*)'$/, function(o, $1){ return $1; });
				
				// already a full url? no change
				if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
					return fullMatch;
				}
				
				// convert the url to a full url
				var newUrl;
				
				if (unquotedOrigUrl.indexOf("//") === 0) {
					//TODO: should we add protocol?
					newUrl = unquotedOrigUrl;
				} else if (unquotedOrigUrl.indexOf("/") === 0) {
					// path should be relative to the base url
					newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
				} else {
					// path should be relative to current directory
					newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
				}
				
				// send back the fixed url(...)
				return "url(" + JSON.stringify(newUrl) + ")";
			});
			
			// send back the fixed css
			return fixedCss;
		};
		
		
		/***/ }),
	/* 44 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MetalForm_soy_js__ = __webpack_require__(45);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal__ = __webpack_require__(109);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_metal_soy__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__ = __webpack_require__(16);
		
		
		
		
		
		
		
		
		class MetalForm extends __WEBPACK_IMPORTED_MODULE_2_metal_component___default.a {
			/**
			 * MetalForm component
			 */
			created(){
				let instance = this;
				
				instance.ApplicationEmitter = new __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__["a" /* default */]();
				instance.ApplicationEmitter.on('LISTEN_DROPDOWN_EVENT', data => instance.dropdownData = data);
				instance.ApplicationEmitter.on('LISTEN_CALCULATOR_EVENT', data => instance.calculatorData = data);
			}
			
			/**
			 * Remove the form default behavior
			 * Set body event to verify the button show message
			 */
			attached(){
				let instance = this;
				
				instance.element.querySelector('form').addEventListener('submit', e => e.preventDefault());
				
				document.querySelector('body').addEventListener('click', (e)=> {
					if(e.target.classList.contains('get-quot')) return
				instance.element.querySelector('.submit-label').classList.remove('show-message');
			});
			}
			
			/**
			 * Check if has operators in the calculator display
			 * @param {Sring} text
			 * @returns {boolean}
			 */
			hasCalculatorOperators(text){
				return /[()+\-/*]/.test(text);
			}
			
			/**
			 * Check if has error in the form
			 * @returns {boolean || null}
			 */
			hasErrorInTheForm(){
				let instance = this,
					err;
				
				if(!instance.checkDropdownData()) err = true;
				if(!instance.checkCalculatorData()) err = true;
				
				return instance.error = err;
			}
			
			/**
			 * Calculate the form using the compound interest formula
			 * and show the result in the total input
			 */
			calculateForm(){
				let instance = this;
				
				if(instance.hasErrorInTheForm()) return;
				
				instance.debt = instance.calculateDebt({
					amount: instance.calculatorData,
					interest: instance.dropdownData.interest,
					months: instance.dropdownData.months
				});
				
				instance.element.querySelector('#input-total').placeholder = `R$: ${instance.debt}`;
				instance.element.querySelector('.get-quot').removeAttribute('disabled');
			}
			
			/**
			 * Calculate the debit using the compound interest formula
			 * @returns { string }
			 */
			calculateDebt({amount, interest, months}){
				let result;
				interest = interest / 100;
				result = (amount * Math.pow(1 + interest, months)).toLocaleString('pt-BR');
				
				if(result.split(',')[1].length > 2) result = result.substr(0, result.length-1);
				
				return result;
			}
			
			/**
			 * Check if the dropdown has item selected
			 * @returns {boolean}
			 */
			checkDropdownData(){
				let instance = this,
					isValid = true;
				
				if(!instance.dropdownData){
					instance.ApplicationEmitter.emit('LISTEN_DROPDOWN_ERROR', 'Please, select an item of the dropdown');
					isValid = false;
				}
				
				return isValid;
			}
			
			/**
			 * Check if the calculator has just numbers (integers or floats)
			 * @returns {boolean}
			 */
			checkCalculatorData(){
				let instance = this,
					data = instance.calculatorData,
					isValid = true;
				
				if(instance.hasCalculatorOperators(data) || !data || !parseFloat(data)){
					instance.ApplicationEmitter.emit('LISTEN_CALCULATOR_ERROR', "Please, type an exepression in your calculator and click in the button '='");
					isValid = false;
				}
				
				return isValid;
			}
			
			/**
			 * Send the count results to the server
			 */
			submitForm(){
				let instance = this;
				const data = JSON.stringify({
					interest: instance.dropdownData.interest,
					loan: instance.calculatorData,
					numberOfMonths: instance.dropdownData.months,
					totalDebt: instance.debt
				});
				
				
				fetch(instance.endpoint, {
					method: "POST",
					headers: {
						'Accept': 'application/json, text/plain, */*',
						'Content-Type': 'application/json'
					},
					body: data
				}).then(resp => resp.json())
			.then(({status}) => instance.showFormMessage(status))
			.catch(err => instance.showFormMessage(`something wrong. Please contact the administrator.`, true))
			}
			
			/**
			 *  Show a vizual feedback in the form
			 * @param { String } text
			 * @param { Boolean } hasError
			 */
			showFormMessage(text, hasError){
				let instance = this;
				let element = instance.element.querySelector('.submit-label');
				
				element.textContent = text;
				element.classList.remove('danger');
				
				if(hasError) element.classList.add('danger');
				return element.classList.add('show-message');
			}
		}
		
		__WEBPACK_IMPORTED_MODULE_3_metal_soy___default.a.register(MetalForm, __WEBPACK_IMPORTED_MODULE_0__MetalForm_soy_js__["a" /* default */]);
		
		/**
		 * MetalForm State Definition
		 */
		MetalForm.STATE = {
			/**
			 * The emitter of the application
			 * to communicate with the other components
			 */
			ApplicationEmitter: {
				value: false
			},
			/**
			 * The user debit calculated in this component
			 */
			debt: {
				value: null
			},
			
			/**
			 * Expression that is in the calculator display
			 */
			calculatorData: {
				value: null
			},
			
			/**
			 * Item selected in the dropdown component
			 */
			dropdownData: {
				value: null
			},
			
			/**
			 * Url of the server, that will save the form data
			 */
			endpoint: {
				value: 'http://localhost:3100/calculator'
			}
		};
		
		/* harmony default export */ __webpack_exports__["a"] = (MetalForm);
		
		
		/***/ }),
	/* 45 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* unused harmony export MetalForm */
		/* unused harmony export templates */
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
		/* jshint ignore:start */
		
		
		var templates;
		goog.loadModule(function(exports) {

// This file was automatically generated from MetalForm.soy.
// Please don't edit this file by hand.
			
			/**
			 * @fileoverview Templates in namespace MetalForm.
			 * @public
			 */
			
			goog.module('MetalForm.incrementaldom');
			
			/** @suppress {extraRequire} */
			var soy = goog.require('soy');
			/** @suppress {extraRequire} */
			var soydata = goog.require('soydata');
			/** @suppress {extraRequire} */
			goog.require('goog.i18n.bidi');
			/** @suppress {extraRequire} */
			goog.require('goog.asserts');
			var IncrementalDom = goog.require('incrementaldom');
			var ie_open = IncrementalDom.elementOpen;
			var ie_close = IncrementalDom.elementClose;
			var ie_void = IncrementalDom.elementVoid;
			var ie_open_start = IncrementalDom.elementOpenStart;
			var ie_open_end = IncrementalDom.elementOpenEnd;
			var itext = IncrementalDom.text;
			var iattr = IncrementalDom.attr;
			
			var $templateAlias1 = __WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.getTemplate('Calculator.incrementaldom', 'render');
			
			var $templateAlias2 = __WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.getTemplate('Dropdown.incrementaldom', 'render');
			
			
			/**
			 * @param {Object<string, *>=} opt_data
			 * @param {(null|undefined)=} opt_ignored
			 * @param {Object<string, *>=} opt_ijData
			 * @return {void}
			 * @suppress {checkTypes}
			 */
			function $render(opt_data, opt_ignored, opt_ijData) {
				ie_open('main', null, null,
					'class', 'wrapper');
				ie_open('h1');
				ie_open('span');
				itext('Personal Loan');
				ie_close('span');
				ie_open('small');
				itext('Save and no red tape loan.');
				ie_close('small');
				ie_close('h1');
				ie_open('form', null, null,
					'method', 'post',
					'class', 'loan-form');
				ie_open('fieldset', null, null,
					'class', 'box-calculator');
				$templateAlias1({Listener: opt_data.ApplicationEmitter}, null, opt_ijData);
				ie_close('fieldset');
				ie_open('fieldset', null, null,
					'class', 'box-loan-options');
				ie_open('label', null, null,
					'for', 'select-months');
				ie_open('span', null, null,
					'class', 'caption');
				itext('Months ');
				ie_open('span', null, null,
					'class', 'mandatory-sign');
				itext('*');
				ie_close('span');
				ie_close('span');
				$templateAlias2({shown: '', Listener: opt_data.ApplicationEmitter}, null, opt_ijData);
				ie_close('label');
				ie_open('button', null, null,
					'class', 'button calculate-interest',
					'data-onclick', 'calculateForm');
				itext('Calculate');
				ie_close('button');
				ie_open('label', null, null,
					'for', 'input-total');
				ie_open('span', null, null,
					'class', 'caption');
				itext('Total');
				ie_close('span');
				ie_open('input', null, null,
					'type', 'text',
					'id', 'input-total',
					'disabled', '',
					'placeholder', 'R$: 0,00',
					'readonly', '');
				ie_close('input');
				ie_close('label');
				ie_void('span', null, null,
					'class', 'submit-label');
				ie_open('button', null, null,
					'class', 'get-quot button--filled',
					'data-onclick', 'submitForm',
					'disabled', '');
				itext('Get Quot');
				ie_close('button');
				ie_close('fieldset');
				ie_close('form');
				ie_open('footer', null, null,
					'class', 'site-footer');
				ie_open('div', null, null,
					'class', 'container');
				ie_open('p');
				itext(' Liferay Inc. ');
				ie_open('br');
				ie_close('br');
				itext(' Copyright \u00A9 2016 All Rights Reserved.');
				ie_close('p');
				ie_close('div');
				ie_close('footer');
				ie_close('main');
			}
			exports.render = $render;
			if (goog.DEBUG) {
				$render.soyTemplateName = 'MetalForm.render';
			}
			
			exports.render.params = ["ApplicationEmitter"];
			exports.render.types = {"ApplicationEmitter":"any"};
			templates = exports;
			return exports;
			
		});
		
		class MetalForm extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
		__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(MetalForm, templates);
		
		/* harmony default export */ __webpack_exports__["a"] = (templates);
		/* jshint ignore:end */
		
		
		/***/ }),
	/* 46 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(process) {
			
			/**
			 * A collection of core utility functions.
			 * @const
			 */
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			exports.abstractMethod = abstractMethod;
			exports.disableCompatibilityMode = disableCompatibilityMode;
			exports.enableCompatibilityMode = enableCompatibilityMode;
			exports.getCompatibilityModeData = getCompatibilityModeData;
			exports.getFunctionName = getFunctionName;
			exports.getStaticProperty = getStaticProperty;
			exports.getUid = getUid;
			exports.identityFunction = identityFunction;
			exports.isBoolean = isBoolean;
			exports.isDef = isDef;
			exports.isDefAndNotNull = isDefAndNotNull;
			exports.isDocument = isDocument;
			exports.isDocumentFragment = isDocumentFragment;
			exports.isElement = isElement;
			exports.isFunction = isFunction;
			exports.isNull = isNull;
			exports.isNumber = isNumber;
			exports.isWindow = isWindow;
			exports.isObject = isObject;
			exports.isPromise = isPromise;
			exports.isString = isString;
			exports.isServerSide = isServerSide;
			exports.nullFunction = nullFunction;
			var compatibilityModeData_ = void 0;
			
			/**
			 * Counter for unique id.
			 * @type {Number}
			 * @private
			 */
			var uniqueIdCounter_ = 1;
			
			/**
			 * Unique id property prefix.
			 * @type {String}
			 * @protected
			 */
			var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}
			
			/**
			 * Disables Metal.js's compatibility mode.
			 */
			function disableCompatibilityMode() {
				compatibilityModeData_ = undefined;
			}
			
			/**
			 * Enables Metal.js's compatibility mode with the following features from rc
			 * and 1.x versions:
			 *     - Using "key" to reference component instances. In the current version
			 *       this should be done via "ref" instead. This allows old code still
			 *       using "key" to keep working like before. NOTE: this may cause
			 *       problems, since "key" is meant to be used differently. Only use this
			 *       if it's not possible to upgrade the code to use "ref" instead.
			 * @param {Object=} opt_data Optional object with data to specify more
			 *     details, such as:
			 *         - renderers {Array} the template renderers that should be in
			 *           compatibility mode, either their constructors or strings
			 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
			 *           that extend from IncrementalDomRenderer.
			 * @type {Object}
			 */
			function enableCompatibilityMode() {
				var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				
				compatibilityModeData_ = opt_data;
			}
			
			/**
			 * Returns the data used for compatibility mode, or nothing if it hasn't been
			 * enabled.
			 * @return {Object}
			 */
			function getCompatibilityModeData() {
				// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
				if (compatibilityModeData_ === undefined) {
					if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
						enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
					}
				}
				return compatibilityModeData_;
			}
			
			/**
			 * Returns the first argument if it's truthy, or the second otherwise.
			 * @param {*} a
			 * @param {*} b
			 * @return {*}
			 * @protected
			 */
			function getFirstTruthy_(a, b) {
				return a || b;
			}
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}
			
			/**
			 * Gets the value of a static property in the given class. The value will be
			 * inherited from ancestors as expected, unless a custom merge function is given,
			 * which can change how the super classes' value for that property will be merged
			 * together.
			 * The final merged value will be stored in another property, so that it won't
			 * be recalculated even if this function is called multiple times.
			 * @param {!function()} ctor Class constructor.
			 * @param {string} propertyName Property name to be merged.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
			 *     value of the property so far and the next value to be merged to it.
			 *     Should return these two merged together. If not passed the final property
			 *     will be the first truthy value among ancestors.
			 */
			function getStaticProperty(ctor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (!ctor.hasOwnProperty(mergedName)) {
					var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
					if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
						var mergeFn = opt_mergeFn || getFirstTruthy_;
						merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
					}
					ctor[mergedName] = merged;
				}
				return ctor[mergedName];
			}
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
				}
				return uniqueIdCounter_++;
			}
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			function isBoolean(val) {
				return typeof val === 'boolean';
			}
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			function isDef(val) {
				return val !== undefined;
			}
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDefAndNotNull(val) {
				return isDef(val) && !isNull(val);
			}
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			}
			
			/**
			 * Returns true if value is a document-fragment.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocumentFragment(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
			}
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			}
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			function isFunction(val) {
				return typeof val === 'function';
			}
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isNull(val) {
				return val === null;
			}
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			function isNumber(val) {
				return typeof val === 'number';
			}
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isWindow(val) {
				return val !== null && val === val.window;
			}
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			}
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}
			
			/**
			 * Sets to true if running inside Node.js environment with extra check for
			 * `process.browser` to skip Karma runner environment. Karma environment has
			 * `process` defined even though it runs on the browser.
			 * @return {boolean}
			 */
			function isServerSide() {
				return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
			}
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			function nullFunction() {}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))
		
		/***/ }),
	/* 47 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _core = __webpack_require__(18);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			_createClass(array, null, [{
				key: 'equal',
				
				/**
				 * Checks if the given arrays have the same content.
				 * @param {!Array<*>} arr1
				 * @param {!Array<*>} arr2
				 * @return {boolean}
				 */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}
				
				/**
				 * Returns the first value in the given array that isn't undefined.
				 * @param {!Array} arr
				 * @return {*}
				 */
				
			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}
				
				/**
				 * Transforms the input nested array to become flat.
				 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
				 * @param {Array.<*>} opt_output Optional output array.
				 * @return {Array.<*>} Flat array.
				 */
				
			}, {
				key: 'flatten',
				value: function flatten(arr, opt_output) {
					var output = opt_output || [];
					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}
				
				/**
				 * Removes the first occurrence of a particular value from an array.
				 * @param {Array.<T>} arr Array from which to remove value.
				 * @param {T} obj Object to remove.
				 * @return {boolean} True if an element was removed.
				 * @template T
				 */
				
			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}
				
				/**
				 * Removes from an array the element at index i
				 * @param {Array} arr Array or array like object from which to remove value.
				 * @param {number} i The index to remove.
				 * @return {boolean} True if an element was removed.
				 */
				
			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}
				
				/**
				 * Slices the given array, just like Array.prototype.slice, but this
				 * is faster and working on all array-like objects (like arguments).
				 * @param {!Object} arr Array-like object to slice.
				 * @param {number} start The index that should start the slice.
				 * @param {number=} opt_end The index where the slice should end, not
				 *   included in the final array. If not given, all elements after the
				 *   start index will be included.
				 * @return {!Array}
				 */
				
			}, {
				key: 'slice',
				value: function slice(arr, start, opt_end) {
					var sliced = [];
					var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 48 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel = void 0;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 49 */
	/***/ (function(module, exports, __webpack_require__) {
		
		/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
			"use strict";
			
			if (global.setImmediate) {
				return;
			}
			
			var nextHandle = 1; // Spec says greater than zero
			var tasksByHandle = {};
			var currentlyRunningATask = false;
			var doc = global.document;
			var registerImmediate;
			
			function setImmediate(callback) {
				// Callback can either be a function or a string
				if (typeof callback !== "function") {
					callback = new Function("" + callback);
				}
				// Copy function arguments
				var args = new Array(arguments.length - 1);
				for (var i = 0; i < args.length; i++) {
					args[i] = arguments[i + 1];
				}
				// Store and register the task
				var task = { callback: callback, args: args };
				tasksByHandle[nextHandle] = task;
				registerImmediate(nextHandle);
				return nextHandle++;
			}
			
			function clearImmediate(handle) {
				delete tasksByHandle[handle];
			}
			
			function run(task) {
				var callback = task.callback;
				var args = task.args;
				switch (args.length) {
					case 0:
						callback();
						break;
					case 1:
						callback(args[0]);
						break;
					case 2:
						callback(args[0], args[1]);
						break;
					case 3:
						callback(args[0], args[1], args[2]);
						break;
					default:
						callback.apply(undefined, args);
						break;
				}
			}
			
			function runIfPresent(handle) {
				// From the spec: "Wait until any invocations of this algorithm started before this one have completed."
				// So if we're currently running a task, we'll need to delay this invocation.
				if (currentlyRunningATask) {
					// Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
					// "too much recursion" error.
					setTimeout(runIfPresent, 0, handle);
				} else {
					var task = tasksByHandle[handle];
					if (task) {
						currentlyRunningATask = true;
						try {
							run(task);
						} finally {
							clearImmediate(handle);
							currentlyRunningATask = false;
						}
					}
				}
			}
			
			function installNextTickImplementation() {
				registerImmediate = function(handle) {
					process.nextTick(function () { runIfPresent(handle); });
				};
			}
			
			function canUsePostMessage() {
				// The test against `importScripts` prevents this implementation from being installed inside a web worker,
				// where `global.postMessage` means something completely different and can't be used for this purpose.
				if (global.postMessage && !global.importScripts) {
					var postMessageIsAsynchronous = true;
					var oldOnMessage = global.onmessage;
					global.onmessage = function() {
						postMessageIsAsynchronous = false;
					};
					global.postMessage("", "*");
					global.onmessage = oldOnMessage;
					return postMessageIsAsynchronous;
				}
			}
			
			function installPostMessageImplementation() {
				// Installs an event handler on `global` for the `message` event: see
				// * https://developer.mozilla.org/en/DOM/window.postMessage
				// * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
				
				var messagePrefix = "setImmediate$" + Math.random() + "$";
				var onGlobalMessage = function(event) {
					if (event.source === global &&
						typeof event.data === "string" &&
						event.data.indexOf(messagePrefix) === 0) {
						runIfPresent(+event.data.slice(messagePrefix.length));
					}
				};
				
				if (global.addEventListener) {
					global.addEventListener("message", onGlobalMessage, false);
				} else {
					global.attachEvent("onmessage", onGlobalMessage);
				}
				
				registerImmediate = function(handle) {
					global.postMessage(messagePrefix + handle, "*");
				};
			}
			
			function installMessageChannelImplementation() {
				var channel = new MessageChannel();
				channel.port1.onmessage = function(event) {
					var handle = event.data;
					runIfPresent(handle);
				};
				
				registerImmediate = function(handle) {
					channel.port2.postMessage(handle);
				};
			}
			
			function installReadyStateChangeImplementation() {
				var html = doc.documentElement;
				registerImmediate = function(handle) {
					// Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
					// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
					var script = doc.createElement("script");
					script.onreadystatechange = function () {
						runIfPresent(handle);
						script.onreadystatechange = null;
						html.removeChild(script);
						script = null;
					};
					html.appendChild(script);
				};
			}
			
			function installSetTimeoutImplementation() {
				registerImmediate = function(handle) {
					setTimeout(runIfPresent, 0, handle);
				};
			}
			
			// If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
			var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
			attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
			
			// Don't get fooled by e.g. browserify environments.
			if ({}.toString.call(global.process) === "[object process]") {
				// For Node.js before 0.9
				installNextTickImplementation();
				
			} else if (canUsePostMessage()) {
				// For non-IE10 modern browsers
				installPostMessageImplementation();
				
			} else if (global.MessageChannel) {
				// For web workers, where supported
				installMessageChannelImplementation();
				
			} else if (doc && "onreadystatechange" in doc.createElement("script")) {
				// For IE 68
				installReadyStateChangeImplementation();
				
			} else {
				// For older browsers
				installSetTimeoutImplementation();
			}
			
			attachTo.setImmediate = setImmediate;
			attachTo.clearImmediate = clearImmediate;
		}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
			
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), __webpack_require__(2)))
		
		/***/ }),
	/* 50 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}
				
				/**
				 * Subclasses should override this method to implement any specific
				 * disposing logic (like clearing references and calling `dispose` on other
				 * disposables).
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}
				
				/**
				 * Checks if this instance has already been disposed.
				 * @return {boolean}
				 */
				
			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 51 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			_createClass(object, null, [{
				key: 'mixin',
				
				/**
				 * Copies all the members of a source object to a target object.
				 * @param {Object} target Target object.
				 * @param {...Object} var_args The objects from which values will be copied.
				 * @return {Object} Returns the target object reference.
				 */
				value: function mixin(target) {
					var key = void 0,
						source = void 0;
					for (var i = 1; i < arguments.length; i++) {
						source = arguments[i];
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}
				
				/**
				 * Returns an object based on its fully qualified external name.
				 * @param {string} name The fully qualified name.
				 * @param {object=} opt_obj The object within which to look; default is
				 *     <code>window</code>.
				 * @return {?} The value (object or primitive) or, if not found, undefined.
				 */
				
			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name, opt_obj) {
					var scope = opt_obj || window;
					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}
				
				/**
				 * Returns a new object with the same keys as the given one, but with
				 * their values set to the return values of the specified function.
				 * @param {!Object} obj
				 * @param {!function(string, *)} fn
				 * @return {!Object}
				 */
				
			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}
				
				/**
				 * Checks if the two given objects are equal. This is done via a shallow
				 * check, including only the keys directly contained by the 2 objects.
				 * @return {boolean}
				 */
				
			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}
					
					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}
					
					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 52 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',
				
				/**
				 * Compares the given strings without taking the case into account.
				 * @param {string|number} str1
				 * @param {string|number} str2
				 * @return {number} Either -1, 0 or 1, according to if the first string is
				 *     "smaller", equal or "bigger" than the second given string.
				 */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();
					
					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}
				
				/**
				 * Removes the breaking spaces from the left and right of the string and
				 * collapses the sequences of breaking spaces in the middle into single spaces.
				 * The original and the result strings render the same way in HTML.
				 * @param {string} str A string in which to collapse spaces.
				 * @return {string} Copy of the string with normalized breaking spaces.
				 */
				
			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}
				
				/**
				 * Escapes characters in the string that are not safe to use in a RegExp.
				 * @param {*} str The string to escape. If not a string, it will be casted
				 *     to one.
				 * @return {string} A RegExp safe, escaped copy of {@code s}.
				 */
				
			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
				}
				
				/**
				 * Returns a string with at least 64-bits of randomness.
				 * @return {string} A random string, e.g. sn1s7vb4gcic.
				 */
				
			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}
				
				/**
				 * Calculates the hashcode for a string. The hashcode value is computed by
				 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
				 * property of using 31 prime is that the multiplication can be replaced by
				 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
				 * Modern VMs do this sort of optimization automatically.
				 * @param {String} val Target string.
				 * @return {Number} Returns the string hashcode.
				 */
				
			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}
				
				/**
				 * Replaces interval into the string with specified value, e.g.
				 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
				 * @param {string} str The input string.
				 * @param {Number} start Start interval position to be replaced.
				 * @param {Number} end End interval position to be replaced.
				 * @param {string} value The value that replaces the specified interval.
				 * @return {string}
				 */
				
			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 53 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _events = __webpack_require__(17);
		
		var _metal = __webpack_require__(5);
		
		var _sync = __webpack_require__(54);
		
		var _metalDom = __webpack_require__(6);
		
		var _ComponentDataManager = __webpack_require__(24);
		
		var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);
		
		var _ComponentRenderer = __webpack_require__(28);
		
		var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);
		
		var _metalEvents = __webpack_require__(8);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		
		function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * Component collects common behaviors to be followed by UI components, such
		 * as Lifecycle, CSS classes management, events encapsulation and support for
		 * different types of rendering.
		 * Rendering logic can be done by either:
		 *     - Listening to the `render` event inside the `created` lifecycle function
		 *       and adding the rendering logic to the listener.
		 *     - Using an existing implementation of `ComponentRenderer` like `Soy`,
		 *       and following its patterns.
		 *     - Building your own implementation of a `ComponentRenderer`.
		 * Specifying the renderer that will be used can be done by setting the RENDERER
		 * static variable to the renderer's constructor function.
		 *
		 * Example:
		 *
		 * <code>
		 * class CustomComponent extends Component {
 *   created() {
 *   }
 *
 *   rendered() {
 *   }
 *
 *   attached() {
 *   }
 *
 *   detached() {
 *   }
 *
 *   disposed() {
 *   }
 * }
		 *
		 * CustomComponent.RENDERER = MyRenderer;
		 *
		 * CustomComponent.STATE = {
 *   title: { value: 'Title' },
 *   fontSize: { value: '10px' }
 * };
		 * </code>
		 *
		 * @extends {State}
		 */
		var Component = function (_EventEmitter) {
			_inherits(Component, _EventEmitter);
			
			/**
			 * Constructor function for `Component`.
			 * @param {Object=} opt_config An object with the initial values for this
			 *     component's state.
			 * @param {boolean|string|Element=} opt_parentElement The element where the
			 *     component should be rendered. Can be given as a selector or an element.
			 *     If `false` is passed, the component won't be rendered automatically
			 *     after created.
			 * @constructor
			 */
			function Component(opt_config, opt_parentElement) {
				_classCallCheck(this, Component);
				
				/**
				 * Instance of `DomEventEmitterProxy` which proxies events from the component's
				 * element to the component itself.
				 * @type {!DomEventEmitterProxy}
				 * @protected
				 */
				var _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));
				
				_this.elementEventProxy_ = new _metalDom.DomEventEmitterProxy(null, _this, proxyBlackList_);
				
				/**
				 * The `EventHandler` instance for events attached from the `events` state key.
				 * @type {EventHandler}
				 * @protected
				 */
				_this.eventsStateKeyHandler_ = null;
				
				/**
				 * Whether the element is in document.
				 * @type {boolean}
				 */
				_this.inDocument = false;
				
				/**
				 * The initial config option passed to this constructor.
				 * @type {!Object}
				 * @protected
				 */
				_this.initialConfig_ = opt_config || {};
				
				/**
				 * Whether the element was rendered.
				 * @type {boolean}
				 */
				_this.wasRendered = false;
				
				/**
				 * The component's element will be appended to the element this variable is
				 * set to, unless the user specifies another parent when calling `render` or
				 * `attach`.
				 * @type {!Element}
				 */
				_this.DEFAULT_ELEMENT_PARENT = document.body;
				
				_this.setShouldUseFacade(true);
				_this.element = _this.initialConfig_.element;
				
				_this.setUpRenderer_();
				_this.setUpDataManager_();
				_this.setUpSyncUpdates_();
				
				_this.on('stateChanged', _this.handleComponentStateChanged_);
				_this.on('eventsChanged', _this.onEventsChanged_);
				_this.addListenersFromObj_(_this.dataManager_.get(_this, 'events'));
				
				_this.created();
				_this.componentCreated_ = true;
				if (opt_parentElement !== false) {
					_this.renderComponent(opt_parentElement);
				}
				return _this;
			}
			
			/**
			 * Getter logic for the element property.
			 * @return {Element}
			 */
			
			
			_createClass(Component, [{
				key: 'addListenersFromObj_',
				
				
				/**
				 * Adds the listeners specified in the given object.
				 * @param {!Object} obj
				 * @protected
				 */
				value: function addListenersFromObj_(obj) {
					var _eventsStateKeyHandle;
					
					if (!this.eventsStateKeyHandler_) {
						this.eventsStateKeyHandler_ = new _metalEvents.EventHandler();
					}
					var handles = (0, _events.addListenersFromObj)(this, obj);
					(_eventsStateKeyHandle = this.eventsStateKeyHandler_).add.apply(_eventsStateKeyHandle, _toConsumableArray(handles));
				}
				
				/**
				 * Invokes the attached Lifecycle. When attached, the component element is
				 * appended to the DOM and any other action to be performed must be
				 * implemented in this method, such as, binding DOM events. A component can
				 * be re-attached multiple times.
				 * @param {(string|Element)=} opt_parentElement Optional parent element
				 *     to render the component.
				 * @param {(string|Element)=} opt_siblingElement Optional sibling element
				 *     to render the component before it. Relevant when the component needs
				 *     to be rendered before an existing element in the DOM.
				 * @protected
				 * @chainable
				 */
				
			}, {
				key: 'attach',
				value: function attach(opt_parentElement, opt_siblingElement) {
					if (!this.inDocument) {
						this.attachElement(opt_parentElement, opt_siblingElement);
						this.inDocument = true;
						this.attachData_ = {
							parent: opt_parentElement,
							sibling: opt_siblingElement
						};
						this.emit('attached', this.attachData_);
						this.attached();
					}
					return this;
				}
				
				/**
				 * Lifecycle. When attached, the component element is appended to the DOM
				 * and any other action to be performed must be implemented in this method,
				 * such as, binding DOM events. A component can be re-attached multiple
				 * times, therefore the undo behavior for any action performed in this phase
				 * must be implemented on the detach phase.
				 */
				
			}, {
				key: 'attached',
				value: function attached() {}
				
				/**
				 * Attaches the component element into the DOM.
				 * @param {(string|Element)=} opt_parentElement Optional parent element
				 *     to render the component.
				 * @param {(string|Element)=} opt_siblingElement Optional sibling element
				 *     to render the component before it. Relevant when the component needs
				 *     to be rendered before an existing element in the DOM, e.g.
				 *     `component.attach(null, existingElement)`.
				 */
				
			}, {
				key: 'attachElement',
				value: function attachElement(opt_parentElement, opt_siblingElement) {
					var element = this.element;
					if (element && (opt_siblingElement || !element.parentNode)) {
						var parent = (0, _metalDom.toElement)(opt_parentElement) || this.DEFAULT_ELEMENT_PARENT;
						parent.insertBefore(element, (0, _metalDom.toElement)(opt_siblingElement));
					}
				}
				
				/**
				 * Lifecycle. This is called when the component has just been created, before
				 * it's rendered.
				 */
				
			}, {
				key: 'created',
				value: function created() {}
				
				/**
				 * Listens to a delegate event on the component's element.
				 * @param {string} eventName The name of the event to listen to.
				 * @param {string} selector The selector that matches the child elements that
				 *   the event should be triggered for.
				 * @param {!function(!Object)} callback Function to be called when the event is
				 *   triggered. It will receive the normalized event object.
				 * @return {!EventHandle} Can be used to remove the listener.
				 */
				
			}, {
				key: 'delegate',
				value: function delegate(eventName, selector, callback) {
					return this.on('delegate:' + eventName + ':' + selector, callback);
				}
				
				/**
				 * Invokes the detached Lifecycle. When detached, the component element is
				 * removed from the DOM and any other action to be performed must be
				 * implemented in this method, such as, unbinding DOM events. A component
				 * can be detached multiple times.
				 * @chainable
				 */
				
			}, {
				key: 'detach',
				value: function detach() {
					if (this.inDocument) {
						if (this.element && this.element.parentNode) {
							this.element.parentNode.removeChild(this.element);
						}
						this.inDocument = false;
						this.detached();
					}
					this.emit('detached');
					return this;
				}
				
				/**
				 * Lifecycle. When detached, the component element is removed from the DOM
				 * and any other action to be performed must be implemented in this method,
				 * such as, unbinding DOM events. A component can be detached multiple
				 * times, therefore the undo behavior for any action performed in this phase
				 * must be implemented on the attach phase.
				 */
				
			}, {
				key: 'detached',
				value: function detached() {}
				
				/**
				 * Lifecycle. Called when the component is disposed. Should be overridden by
				 * sub classes to dispose of any internal data or events.
				 */
				
			}, {
				key: 'disposed',
				value: function disposed() {}
				
				/**
				 * @inheritDoc
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.detach();
					this.disposed();
					
					this.elementEventProxy_.dispose();
					this.elementEventProxy_ = null;
					
					this.dataManager_.dispose(this);
					this.dataManager_ = null;
					
					this.renderer_.dispose(this);
					this.renderer_ = null;
					
					_get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'disposeInternal', this).call(this);
				}
				
				/**
				 * Gets data about where this component was attached at.
				 * @return {!Object}
				 */
				
			}, {
				key: 'getAttachData',
				value: function getAttachData() {
					return this.attachData_;
				}
				
				/**
				 * Gets the `ComponentDataManager` being used.
				 * @return {!ComponentDataManager}
				 */
				
			}, {
				key: 'getDataManager',
				value: function getDataManager() {
					return this.dataManager_;
				}
				
				/**
				 * Gets the configuration object that was passed to this component's constructor.
				 * @return {!Object}
				 */
				
			}, {
				key: 'getInitialConfig',
				value: function getInitialConfig() {
					return this.initialConfig_;
				}
				
				/**
				 * Gets state data for this component.
				 * @return {!Object}
				 */
				
			}, {
				key: 'getState',
				value: function getState() {
					return this.dataManager_.getState(this);
				}
				
				/**
				 * Gets the keys for the state data.
				 * @return {!Array<string>}
				 */
				
			}, {
				key: 'getStateKeys',
				value: function getStateKeys() {
					return this.dataManager_.getStateKeys(this);
				}
				
				/**
				 * Gets the `ComponentRenderer` instance being used.
				 * @return {!ComponentRenderer}
				 */
				
			}, {
				key: 'getRenderer',
				value: function getRenderer() {
					return this.renderer_;
				}
				
				/**
				 * Handles a change in the component's element.
				 * @param {Element} prevVal
				 * @param {Element} newVal
				 * @protected
				 */
				
			}, {
				key: 'handleComponentElementChanged_',
				value: function handleComponentElementChanged_(prevVal, newVal) {
					this.elementEventProxy_.setOriginEmitter(newVal);
					if (this.componentCreated_) {
						this.emit('elementChanged', {
							prevVal: prevVal,
							newVal: newVal
						});
						if (newVal && this.wasRendered) {
							this.syncVisible(this.dataManager_.get(this, 'visible'));
						}
					}
				}
				
				/**
				 * Handles state batch changes. Calls any existing `sync` functions that
				 * match the changed state keys.
				 * @param {Event} event
				 * @protected
				 */
				
			}, {
				key: 'handleComponentStateChanged_',
				value: function handleComponentStateChanged_(event) {
					if (!this.hasSyncUpdates()) {
						this.updateRenderer_(event);
					}
					(0, _sync.syncState)(this, event.changes);
					this.emit('stateSynced', event);
				}
				
				/**
				 * Handles a `stateKeyChanged` event. This is only called for components that
				 * have requested updates to happen synchronously.
				 * @param {!{key: string, newVal: *, prevVal: *}} data
				 * @protected
				 */
				
			}, {
				key: 'handleComponentStateKeyChanged_',
				value: function handleComponentStateKeyChanged_(data) {
					this.updateRenderer_({
						changes: _defineProperty({}, data.key, data)
					});
				}
				
				/**
				 * Checks if this component has sync updates enabled.
				 * @return {boolean}
				 */
				
			}, {
				key: 'hasSyncUpdates',
				value: function hasSyncUpdates() {
					return this.syncUpdates_;
				}
				
				/**
				 * Informs that the component that the rendered has finished rendering it. The
				 * renderer is the one responsible for calling this when appropriate. This
				 * will emit events and run the appropriate lifecycle for the first render.
				 */
				
			}, {
				key: 'informRendered',
				value: function informRendered() {
					var firstRender = !this.hasRendererRendered_;
					this.hasRendererRendered_ = true;
					this.rendered(firstRender);
					this.emit('rendered', firstRender);
				}
				
				/**
				 * Checks if the given function is a component constructor.
				 * @param {!function()} fn Any function
				 * @return {boolean}
				 */
				
			}, {
				key: 'mergeElementClasses_',
				
				
				/**
				 * Merges two values for the ELEMENT_CLASSES property into a single one.
				 * @param {string} class1
				 * @param {string} class2
				 * @return {string} The merged value.
				 * @protected
				 */
				value: function mergeElementClasses_(class1, class2) {
					return class1 ? class1 + ' ' + (class2 || '') : class2;
				}
				
				/**
				 * Fired when the `events` state value is changed.
				 * @param {!Object} event
				 * @protected
				 */
				
			}, {
				key: 'onEventsChanged_',
				value: function onEventsChanged_(event) {
					this.eventsStateKeyHandler_.removeAllListeners();
					this.addListenersFromObj_(event.newVal);
				}
				
				/**
				 * Creates and renders a component for the given constructor function. This
				 * will always make sure that the constructor runs without rendering the
				 * component, having the `render` step happen only after it has finished.
				 * @param {!function()} Ctor The component's constructor function.
				 * @param {Object|Element=} opt_configOrElement Optional config data or parent
				 *     for the component.
				 * @param {Element=} opt_element Optional parent for the component.
				 * @return {!Component} The rendered component's instance.
				 */
				
			}, {
				key: 'renderComponent',
				
				
				/**
				 * Renders the component into the DOM via its `ComponentRenderer`. Stores the
				 * given parent element to be used when the renderer is done (`informRendered`).
				 * @param {(string|Element|boolean)=} opt_parentElement Optional parent element
				 *     to render the component. If set to `false`, the element won't be
				 *     attached to any element after rendering. In this case, `attach` should
				 *     be called manually later to actually attach it to the dom.
				 */
				value: function renderComponent(opt_parentElement) {
					if (!this.hasRendererRendered_) {
						if (window.__METAL_DEV_TOOLS_HOOK__) {
							window.__METAL_DEV_TOOLS_HOOK__(this);
						}
						this.getRenderer().render(this);
					}
					this.emit('render');
					(0, _sync.syncState)(this);
					this.attach(opt_parentElement);
					this.wasRendered = true;
				}
				
				/**
				 * Setter logic for the element property.
				 * @param {?string|Element} val
				 */
				
			}, {
				key: 'setState',
				
				
				/**
				 * Sets the value of all the specified state keys.
				 * @param {!Object.<string,*>} values A map of state keys to the values they
				 *   should be set to.
				 * @param {function()=} opt_callback An optional function that will be run
				 *   after the next batched update is triggered.
				 */
				value: function setState(state, opt_callback) {
					this.dataManager_.setState(this, state, opt_callback);
				}
				
				/**
				 * Setter for the `elementClasses` data property. Appends given value with
				 * the one specified in `ELEMENT_CLASSES`.
				 * @param {string} val
				 * @return {string}
				 * @protected
				 */
				
			}, {
				key: 'setterElementClassesFn_',
				value: function setterElementClassesFn_(val) {
					var elementClasses = (0, _metal.getStaticProperty)(this.constructor, 'ELEMENT_CLASSES', this.mergeElementClasses_);
					if (elementClasses) {
						val += ' ' + elementClasses;
					}
					return val.trim();
				}
				
				/**
				 * Sets up the component's data manager.
				 * @protected
				 */
				
			}, {
				key: 'setUpDataManager_',
				value: function setUpDataManager_() {
					this.dataManager_ = (0, _metal.getStaticProperty)(this.constructor, 'DATA_MANAGER');
					this.dataManager_.setUp(this, _metal.object.mixin({}, this.renderer_.getExtraDataConfig(this), Component.DATA));
				}
				
				/**
				 * Sets up the component's renderer.
				 * @protected
				 */
				
			}, {
				key: 'setUpRenderer_',
				value: function setUpRenderer_() {
					this.renderer_ = (0, _metal.getStaticProperty)(this.constructor, 'RENDERER');
					this.renderer_.setUp(this);
				}
				
				/**
				 * Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.
				 * @protected
				 */
				
			}, {
				key: 'setUpSyncUpdates_',
				value: function setUpSyncUpdates_() {
					this.syncUpdates_ = (0, _metal.getStaticProperty)(this.constructor, 'SYNC_UPDATES');
					if (this.hasSyncUpdates()) {
						this.on('stateKeyChanged', this.handleComponentStateKeyChanged_.bind(this));
					}
				}
				
				/**
				 * Skips renderer updates until `stopSkipUpdates` is called.
				 */
				
			}, {
				key: 'startSkipUpdates',
				value: function startSkipUpdates() {
					this.skipUpdates_ = true;
				}
				
				/**
				 * Stops skipping renderer updates.
				 */
				
			}, {
				key: 'stopSkipUpdates',
				value: function stopSkipUpdates() {
					this.skipUpdates_ = false;
				}
				
				/**
				 * State synchronization logic for `visible` state key.
				 * Updates the element's display value according to its visibility.
				 * @param {boolean} newVal
				 */
				
			}, {
				key: 'syncVisible',
				value: function syncVisible(newVal) {
					if (this.element) {
						this.element.style.display = newVal ? '' : 'none';
					}
				}
				
				/**
				 * Lifecycle. Called whenever the component has just been rendered.
				 * @param {boolean} firstRender Flag indicating if this was the component's
				 *     first render.
				 */
				
			}, {
				key: 'rendered',
				value: function rendered() {}
				
				/**
				 * Calls "update" on the renderer, passing it the changed data.
				 * @param {!{changes: !Object}} data
				 * @protected
				 */
				
			}, {
				key: 'updateRenderer_',
				value: function updateRenderer_(data) {
					if (!this.skipUpdates_ && this.hasRendererRendered_) {
						this.getRenderer().update(this, data);
					}
				}
				
				/**
				 * Validator logic for the `events` state key.
				 * @param {Object} val
				 * @return {boolean}
				 * @protected
				 */
				
			}, {
				key: 'validatorEventsFn_',
				value: function validatorEventsFn_(val) {
					return !(0, _metal.isDefAndNotNull)(val) || (0, _metal.isObject)(val);
				}
			}, {
				key: 'element',
				get: function get() {
					return this.elementValue_;
				},
				set: function set(val) {
					if (!(0, _metal.isElement)(val) && !(0, _metal.isString)(val) && (0, _metal.isDefAndNotNull)(val)) {
						return;
					}
					
					if (val) {
						val = (0, _metalDom.toElement)(val) || this.elementValue_;
					}
					
					if (this.elementValue_ !== val) {
						var prev = this.elementValue_;
						this.elementValue_ = val;
						this.handleComponentElementChanged_(prev, val);
					}
				}
			}], [{
				key: 'isComponentCtor',
				value: function isComponentCtor(fn) {
					return fn.prototype && fn.prototype[Component.COMPONENT_FLAG];
				}
			}, {
				key: 'render',
				value: function render(Ctor, opt_configOrElement, opt_element) {
					var config = opt_configOrElement;
					var element = opt_element;
					if ((0, _metal.isElement)(opt_configOrElement)) {
						config = null;
						element = opt_configOrElement;
					}
					var instance = new Ctor(config, false);
					instance.renderComponent(element);
					return instance;
				}
				
				/**
				 * Creates and renders a component for the given constructor function as
				 * string. This will always make sure that the constructor runs without
				 * rendering the component, having the `render` step happen only after it
				 * has finished.
				 * @param {!function()} Ctor The component's constructor function.
				 * @param {Object|Element=} opt_configOrElement Optional config data or
				 *     parent for the component.
				 * @return {!String} The rendered component's content as string.
				 */
				
			}, {
				key: 'renderToString',
				value: function renderToString(Ctor, opt_config) {
					var rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;
					switch (rendererName) {
						case 'jsx':
						case 'soy':
						case 'incremental-dom':
						{
							if (typeof IncrementalDOM === 'undefined') {
								throw new Error('Error. Trying to render incremental dom ' + 'based component to string requires IncrementalDOM ' + 'implementation to be loaded.');
							}
							// Incremental dom patches for components or nested components are
							// isolated inside the component element. The following code intercepts
							// incremental dom patches and collect results into temporary stack in
							// order to successfully collect the final string of the outermost
							// component after all nested components stack rendered.
							var interceptedComponentStrings = [];
							var patch = IncrementalDOM.patch;
							var patchInterceptor = function patchInterceptor() {
								var currentElement = patch.apply(null, arguments);
								interceptedComponentStrings.push(currentElement.innerHTML);
								IncrementalDOM.patch = patch;
							};
							IncrementalDOM.patch = patchInterceptor;
							Component.render(Ctor, opt_config).dispose();
							return interceptedComponentStrings[0];
						}
						default:
							throw new Error('Error. Trying to render non incremental dom ' + 'based component to string.');
					}
				}
			}]);
			
			return Component;
		}(_metalEvents.EventEmitter);
		
		/**
		 * Component data definition.
		 * @type {Object}
		 * @static
		 */
		
		
		Component.DATA = {
			/**
			 * Objects describing children elements that were passed to be rendered inside
			 * this component.
			 * @type {!Array<!Object>}
			 */
			children: {
				validator: Array.isArray,
				value: []
			},
			
			/**
			 * CSS classes to be applied to the element.
			 * @type {string}
			 */
			elementClasses: {
				setter: 'setterElementClassesFn_',
				validator: _metal.isString,
				value: ''
			},
			
			/**
			 * Listeners that should be attached to this component. Should be provided as
			 * an object, where the keys are event names and the values are the listener
			 * functions (or function names).
			 * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}
			 */
			events: {
				validator: 'validatorEventsFn_',
				value: null
			},
			
			/**
			 * Indicates if the component is visible or not.
			 * @type {boolean}
			 */
			visible: {
				validator: _metal.isBoolean,
				value: true
			}
		};
		
		/**
		 * Name of the flag used to identify component constructors via their prototype.
		 * @type {string}
		 */
		Component.COMPONENT_FLAG = '__metal_component__';
		
		/**
		 * The `ComponentDataManager` class that should be used. This class will be
		 * responsible for handling the component's data. Each component may have its
		 * own implementation.
		 * @type {!ComponentDataManager}
		 */
		Component.DATA_MANAGER = _ComponentDataManager2.default;
		
		/**
		 * CSS classes to be applied to the element.
		 * @type {string}
		 */
		Component.ELEMENT_CLASSES = '';
		
		/**
		 * The `ComponentRenderer` that should be used. Components need to set this
		 * to a subclass of `ComponentRenderer` that has the rendering logic, like
		 * `SoyRenderer`.
		 * @type {!ComponentRenderer}
		 */
		Component.RENDERER = _ComponentRenderer2.default;
		
		/**
		 * Flag indicating if component updates will happen synchronously. Updates are
		 * done asynchronously by default, which allows changes to be batched and
		 * applied together.
		 * @type {boolean}
		 */
		Component.SYNC_UPDATES = false;
		
		/**
		 * Sets a prototype flag to easily determine if a given constructor is for
		 * a component or not.
		 */
		Component.prototype[Component.COMPONENT_FLAG] = true;
		
		var proxyBlackList_ = {
			eventsChanged: true,
			stateChanged: true,
			stateKeyChanged: true
		};
		
		exports.default = Component;
		
		/***/ }),
	/* 54 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.syncState = syncState;
		
		var _metal = __webpack_require__(5);
		
		var SYNC_FNS_KEY = '__METAL_SYNC_FNS__';
		
		/**
		 * Gets the `sync` methods for this component's state. Caches the results in
		 * the component's constructor whenever possible, so that this doesn't need to
		 * be calculated again. It's not possible to cache the results when at least
		 * one sync method is defined in the instance itself instead of in its
		 * prototype, as it may be bound to the instance (not reusable by others).
		 * @param {!Component} component
		 * @return {!Object}
		 * @private
		 */
		function getSyncFns_(component) {
			var ctor = component.constructor;
			if (ctor.hasOwnProperty(SYNC_FNS_KEY)) {
				return ctor[SYNC_FNS_KEY];
			}
			
			var fns = {};
			var keys = component.getDataManager().getSyncKeys(component);
			var canCache = true;
			for (var i = 0; i < keys.length; i++) {
				var name = 'sync' + keys[i].charAt(0).toUpperCase() + keys[i].slice(1);
				var fn = component[name];
				if (fn) {
					fns[keys[i]] = fn;
					canCache = canCache && component.constructor.prototype[name];
				}
			}
			
			if (canCache) {
				ctor[SYNC_FNS_KEY] = fns;
			}
			return fns;
		}
		
		/**
		 * Calls "sync" functions for the given component's state.
		 * @param {!Component} component
		 * @param {Object=} opt_changes When given, only the properties inside it will
		 *     be synced. Otherwise all state properties will be synced.
		 */
		function syncState(component, opt_changes) {
			var syncFns = getSyncFns_(component);
			var keys = Object.keys(opt_changes || syncFns);
			for (var i = 0; i < keys.length; i++) {
				var fn = syncFns[keys[i]];
				if ((0, _metal.isFunction)(fn)) {
					var change = opt_changes && opt_changes[keys[i]];
					var manager = component.getDataManager();
					fn.call(component, change ? change.newVal : manager.get(component, keys[i]), change ? change.prevVal : undefined);
				}
			}
		}
		
		/***/ }),
	/* 55 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.customEvents = undefined;
		exports.addClasses = addClasses;
		exports.closest = closest;
		exports.append = append;
		exports.buildFragment = buildFragment;
		exports.contains = contains;
		exports.delegate = delegate;
		exports.enterDocument = enterDocument;
		exports.exitDocument = exitDocument;
		exports.hasClass = hasClass;
		exports.isEmpty = isEmpty;
		exports.match = match;
		exports.next = next;
		exports.on = on;
		exports.once = once;
		exports.parent = parent;
		exports.registerCustomEvent = registerCustomEvent;
		exports.removeChildren = removeChildren;
		exports.removeClasses = removeClasses;
		exports.replace = replace;
		exports.supportsEvent = supportsEvent;
		exports.toElement = toElement;
		exports.toggleClasses = toggleClasses;
		exports.triggerEvent = triggerEvent;
		
		var _metal = __webpack_require__(7);
		
		var _domData = __webpack_require__(13);
		
		var _domData2 = _interopRequireDefault(_domData);
		
		var _DomDelegatedEventHandle = __webpack_require__(62);
		
		var _DomDelegatedEventHandle2 = _interopRequireDefault(_DomDelegatedEventHandle);
		
		var _DomEventHandle = __webpack_require__(22);
		
		var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var elementsByTag_ = {};
		var supportCache_ = {};
		var customEvents = exports.customEvents = {};
		
		var LAST_CONTAINER = '__metal_last_container__';
		var USE_CAPTURE = {
			blur: true,
			error: true,
			focus: true,
			invalid: true,
			load: true,
			scroll: true
		};
		
		/**
		 * Adds the requested CSS classes to an element.
		 * @param {!Element|!Nodelist} elements The element or elements to add CSS classes to.
		 * @param {string} classes CSS classes to add.
		 */
		function addClasses(elements, classes) {
			if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
				return;
			}
			
			if (!elements.length) {
				elements = [elements];
			}
			
			for (var i = 0; i < elements.length; i++) {
				if ('classList' in elements[i]) {
					addClassesWithNative_(elements[i], classes);
				} else {
					addClassesWithoutNative_(elements[i], classes);
				}
			}
		}
		
		/**
		 * Adds the requested CSS classes to an element using classList.
		 * @param {!Element} element The element to add CSS classes to.
		 * @param {string} classes CSS classes to add.
		 * @private
		 */
		function addClassesWithNative_(element, classes) {
			classes.split(' ').forEach(function (className) {
				if (className) {
					element.classList.add(className);
				}
			});
		}
		
		/**
		 * Adds the requested CSS classes to an element without using classList.
		 * @param {!Element} element The element to add CSS classes to.
		 * @param {string} classes CSS classes to add.
		 * @private
		 */
		function addClassesWithoutNative_(element, classes) {
			var elementClassName = ' ' + element.className + ' ';
			var classesToAppend = '';
			
			classes = classes.split(' ');
			
			for (var i = 0; i < classes.length; i++) {
				var className = classes[i];
				
				if (elementClassName.indexOf(' ' + className + ' ') === -1) {
					classesToAppend += ' ' + className;
				}
			}
			
			if (classesToAppend) {
				element.className = element.className + classesToAppend;
			}
		}
		
		/**
		 * Adds an event listener to the given element, to be triggered via delegate.
		 * @param {!Element} element
		 * @param {string} eventName
		 * @param {!function()} listener
		 * @private
		 */
		function addElementListener_(element, eventName, listener) {
			addToArr_(_domData2.default.get(element, 'listeners', {}), eventName, listener);
		}
		
		/**
		 * Adds an event listener to the given element, to be triggered via delegate
		 * selectors.
		 * @param {!Element} element
		 * @param {string} eventName
		 * @param {string} selector
		 * @param {!function()} listener
		 * @private
		 */
		function addSelectorListener_(element, eventName, selector, listener) {
			var delegatingData = _domData2.default.get(element, 'delegating', {});
			addToArr_(delegatingData[eventName].selectors, selector, listener);
		}
		
		/**
		 * Adds a value to an array inside an object, creating it first if it doesn't
		 * yet exist.
		 * @param {!Array} arr
		 * @param {string} key
		 * @param {*} value
		 * @private
		 */
		function addToArr_(arr, key, value) {
			if (!arr[key]) {
				arr[key] = [];
			}
			arr[key].push(value);
		}
		
		/**
		 * Attaches a delegate listener, unless there's already one attached.
		 * @param {!Element} element
		 * @param {string} eventName
		 * @private
		 */
		function attachDelegateEvent_(element, eventName) {
			var delegatingData = _domData2.default.get(element, 'delegating', {});
			if (!delegatingData[eventName]) {
				delegatingData[eventName] = {
					handle: on(element, eventName, handleDelegateEvent_, !!USE_CAPTURE[eventName]),
					selectors: {}
				};
			}
		}
		
		/**
		 * Gets the closest element up the tree from the given element (including
		 * itself) that matches the specified selector, or null if none match.
		 * @param {Element} element
		 * @param {string} selector
		 * @return {Element}
		 */
		function closest(element, selector) {
			while (element && !match(element, selector)) {
				element = element.parentNode;
			}
			return element;
		}
		
		/**
		 * Appends a child node with text or other nodes to a parent node. If
		 * child is a HTML string it will be automatically converted to a document
		 * fragment before appending it to the parent.
		 * @param {!Element} parent The node to append nodes to.
		 * @param {!(Element|NodeList|string)} child The thing to append to the parent.
		 * @return {!Element} The appended child.
		 */
		function append(parent, child) {
			if ((0, _metal.isString)(child)) {
				child = buildFragment(child);
			}
			if (child instanceof NodeList) {
				var childArr = Array.prototype.slice.call(child);
				for (var i = 0; i < childArr.length; i++) {
					parent.appendChild(childArr[i]);
				}
			} else {
				parent.appendChild(child);
			}
			return child;
		}
		
		/**
		 * Helper for converting a HTML string into a document fragment.
		 * @param {string} htmlString The HTML string to convert.
		 * @return {!Element} The resulting document fragment.
		 */
		function buildFragment(htmlString) {
			var tempDiv = document.createElement('div');
			tempDiv.innerHTML = '<br>' + htmlString;
			tempDiv.removeChild(tempDiv.firstChild);
			
			var fragment = document.createDocumentFragment();
			while (tempDiv.firstChild) {
				fragment.appendChild(tempDiv.firstChild);
			}
			return fragment;
		}
		
		/**
		 * Checks if the first element contains the second one.
		 * @param {!Element} element1
		 * @param {!Element} element2
		 * @return {boolean}
		 */
		function contains(element1, element2) {
			if ((0, _metal.isDocument)(element1)) {
				// document.contains is not defined on IE9, so call it on documentElement instead.
				return element1.documentElement.contains(element2);
			} else {
				return element1.contains(element2);
			}
		}
		
		/**
		 * Listens to the specified event on the given DOM element, but only calls the
		 * given callback listener when it's triggered by elements that match the
		 * given selector or target element.
		 * @param {!Element} element The DOM element the event should be listened on.
		 * @param {string} eventName The name of the event to listen to.
		 * @param {!Element|string} selectorOrTarget Either an element or css selector
		 *     that should match the event for the listener to be triggered.
		 * @param {!function(!Object)} callback Function to be called when the event
		 *     is triggered. It will receive the normalized event object.
		 * @param {boolean=} opt_default Optional flag indicating if this is a default
		 *     listener. That means that it would only be executed after all non
		 *     default listeners, and only if the event isn't prevented via
		 *     `preventDefault`.
		 * @return {!EventHandle} Can be used to remove the listener.
		 */
		function delegate(element, eventName, selectorOrTarget, callback, opt_default) {
			var customConfig = customEvents[eventName];
			if (customConfig && customConfig.delegate) {
				eventName = customConfig.originalEvent;
				callback = customConfig.handler.bind(customConfig, callback);
			}
			
			if (opt_default) {
				// Wrap callback so we don't set property directly on it.
				callback = callback.bind();
				callback.defaultListener_ = true;
			}
			
			attachDelegateEvent_(element, eventName);
			if ((0, _metal.isString)(selectorOrTarget)) {
				addSelectorListener_(element, eventName, selectorOrTarget, callback);
			} else {
				addElementListener_(selectorOrTarget, eventName, callback);
			}
			
			return new _DomDelegatedEventHandle2.default((0, _metal.isString)(selectorOrTarget) ? element : selectorOrTarget, eventName, callback, (0, _metal.isString)(selectorOrTarget) ? selectorOrTarget : null);
		}
		
		/**
		 * Verifies if the element is able to trigger the Click event,
		 * simulating browsers behaviour, avoiding event listeners to be called by triggerEvent method.
		 * @param {Element} node Element to be checked.
		 * @param {string} eventName The event name.
		 * @private
		 */
		function isAbleToInteractWith_(node, eventName, opt_eventObj) {
			if (opt_eventObj && eventName === 'click' && opt_eventObj.button === 2) {
				// Firefox triggers "click" events on the document for right clicks. This
				// causes our delegate logic to trigger it for regular elements too, which
				// shouldn't happen. Ignoring them here.
				return false;
			}
			
			var matchesSelector = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'];
			if (eventName === 'click' && matchesSelector.indexOf(node.tagName) > -1) {
				return !(node.disabled || parent(node, 'fieldset[disabled]'));
			}
			return true;
		}
		
		/**
		 * Inserts node in document as last element.
		 * @param {Element} node Element to remove children from.
		 */
		function enterDocument(node) {
			node && append(document.body, node);
		}
		
		/**
		 * Removes node from document.
		 * @param {Element} node Element to remove children from.
		 */
		function exitDocument(node) {
			if (node && node.parentNode) {
				node.parentNode.removeChild(node);
			}
		}
		
		/**
		 * This is called when an event is triggered by a delegate listener. All
		 * matching listeners of this event type from `target` to `currentTarget` will
		 * be triggered.
		 * @param {!Event} event The event payload.
		 * @return {boolean} False if at least one of the triggered callbacks returns
		 *     false, or true otherwise.
		 * @private
		 */
		function handleDelegateEvent_(event) {
			normalizeDelegateEvent_(event);
			var ret = true;
			var container = event.currentTarget;
			var defFns = [];
			
			ret &= triggerDelegatedListeners_(container, event, defFns);
			ret &= triggerDefaultDelegatedListeners_(defFns, event);
			
			event.delegateTarget = null;
			event[LAST_CONTAINER] = container;
			return ret;
		}
		
		/**
		 * Checks if the given element has the requested css class.
		 * @param {!Element} element
		 * @param {string} className
		 * @return {boolean}
		 */
		function hasClass(element, className) {
			if ('classList' in element) {
				return hasClassWithNative_(element, className);
			} else {
				return hasClassWithoutNative_(element, className);
			}
		}
		
		/**
		 * Checks if the given element has the requested css class using classList.
		 * @param {!Element} element
		 * @param {string} className
		 * @return {boolean}
		 * @private
		 */
		function hasClassWithNative_(element, className) {
			return element.classList.contains(className);
		}
		
		/**
		 * Checks if the given element has the requested css class without using classList.
		 * @param {!Element} element
		 * @param {string} className
		 * @return {boolean}
		 * @private
		 */
		function hasClassWithoutNative_(element, className) {
			return (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0;
		}
		
		/**
		 * Checks if the given element is empty or not.
		 * @param {!Element} element
		 * @return {boolean}
		 */
		function isEmpty(element) {
			return element.childNodes.length === 0;
		}
		
		/**
		 * Check if an element matches a given selector.
		 * @param {Element} element
		 * @param {string} selector
		 * @return {boolean}
		 */
		function match(element, selector) {
			if (!element || element.nodeType !== 1) {
				return false;
			}
			
			var p = Element.prototype;
			var m = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;
			if (m) {
				return m.call(element, selector);
			}
			
			return matchFallback_(element, selector);
		}
		
		/**
		 * Check if an element matches a given selector, using an internal implementation
		 * instead of calling existing javascript functions.
		 * @param {Element} element
		 * @param {string} selector
		 * @return {boolean}
		 * @private
		 */
		function matchFallback_(element, selector) {
			var nodes = document.querySelectorAll(selector, element.parentNode);
			for (var i = 0; i < nodes.length; ++i) {
				if (nodes[i] === element) {
					return true;
				}
			}
			return false;
		}
		
		/**
		 * Returns the next sibling of the given element that matches the specified
		 * selector, or null if there is none.
		 * @param {!Element} element
		 * @param {?string} selector
		 */
		function next(element, selector) {
			do {
				element = element.nextSibling;
				if (element && match(element, selector)) {
					return element;
				}
			} while (element);
			return null;
		}
		
		/**
		 * Normalizes the event payload for delegate listeners.
		 * @param {!Event} event
		 * @private
		 */
		function normalizeDelegateEvent_(event) {
			event.stopPropagation = stopPropagation_;
			event.stopImmediatePropagation = stopImmediatePropagation_;
		}
		
		/**
		 * Listens to the specified event on the given DOM element. This function normalizes
		 * DOM event payloads and functions so they'll work the same way on all supported
		 * browsers.
		 * @param {!Element|string} element The DOM element to listen to the event on, or
		 *   a selector that should be delegated on the entire document.
		 * @param {string} eventName The name of the event to listen to.
		 * @param {!function(!Object)} callback Function to be called when the event is
		 *   triggered. It will receive the normalized event object.
		 * @param {boolean} opt_capture Flag indicating if listener should be triggered
		 *   during capture phase, instead of during the bubbling phase. Defaults to false.
		 * @return {!DomEventHandle} Can be used to remove the listener.
		 */
		function on(element, eventName, callback, opt_capture) {
			if ((0, _metal.isString)(element)) {
				return delegate(document, eventName, element, callback);
			}
			var customConfig = customEvents[eventName];
			if (customConfig && customConfig.event) {
				eventName = customConfig.originalEvent;
				callback = customConfig.handler.bind(customConfig, callback);
			}
			element.addEventListener(eventName, callback, opt_capture);
			return new _DomEventHandle2.default(element, eventName, callback, opt_capture);
		}
		
		/**
		 * Listens to the specified event on the given DOM element once. This
		 * function normalizes DOM event payloads and functions so they'll work the
		 * same way on all supported browsers.
		 * @param {!Element} element The DOM element to listen to the event on.
		 * @param {string} eventName The name of the event to listen to.
		 * @param {!function(!Object)} callback Function to be called when the event
		 *   is triggered. It will receive the normalized event object.
		 * @return {!DomEventHandle} Can be used to remove the listener.
		 */
		function once(element, eventName, callback) {
			var domEventHandle = on(element, eventName, function () {
				domEventHandle.removeListener();
				return callback.apply(this, arguments);
			});
			return domEventHandle;
		}
		
		/**
		 * Gets the first parent from the given element that matches the specified
		 * selector, or null if none match.
		 * @param {!Element} element
		 * @param {string} selector
		 * @return {Element}
		 */
		function parent(element, selector) {
			return closest(element.parentNode, selector);
		}
		
		/**
		 * Registers a custom event.
		 * @param {string} eventName The name of the custom event.
		 * @param {!Object} customConfig An object with information about how the event
		 *   should be handled.
		 */
		function registerCustomEvent(eventName, customConfig) {
			customEvents[eventName] = customConfig;
		}
		
		/**
		 * Removes all the child nodes on a DOM node.
		 * @param {Element} node Element to remove children from.
		 */
		function removeChildren(node) {
			var child = void 0;
			while (child = node.firstChild) {
				node.removeChild(child);
			}
		}
		
		/**
		 * Removes the requested CSS classes from an element.
		 * @param {!Element|!NodeList} elements The element or elements to remove CSS classes from.
		 * @param {string} classes CSS classes to remove.
		 */
		function removeClasses(elements, classes) {
			if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
				return;
			}
			
			if (!elements.length) {
				elements = [elements];
			}
			
			for (var i = 0; i < elements.length; i++) {
				if ('classList' in elements[i]) {
					removeClassesWithNative_(elements[i], classes);
				} else {
					removeClassesWithoutNative_(elements[i], classes);
				}
			}
		}
		
		/**
		 * Removes the requested CSS classes from an element using classList.
		 * @param {!Element} element The element to remove CSS classes from.
		 * @param {string} classes CSS classes to remove.
		 * @private
		 */
		function removeClassesWithNative_(element, classes) {
			classes.split(' ').forEach(function (className) {
				if (className) {
					element.classList.remove(className);
				}
			});
		}
		
		/**
		 * Removes the requested CSS classes from an element without using classList.
		 * @param {!Element} element The element to remove CSS classes from.
		 * @param {string} classes CSS classes to remove.
		 * @private
		 */
		function removeClassesWithoutNative_(element, classes) {
			var elementClassName = ' ' + element.className + ' ';
			
			classes = classes.split(' ');
			
			for (var i = 0; i < classes.length; i++) {
				elementClassName = elementClassName.replace(' ' + classes[i] + ' ', ' ');
			}
			
			element.className = elementClassName.trim();
		}
		
		/**
		 * Replaces the first element with the second.
		 * @param {Element} element1
		 * @param {Element} element2
		 */
		function replace(element1, element2) {
			if (element1 && element2 && element1 !== element2 && element1.parentNode) {
				element1.parentNode.insertBefore(element2, element1);
				element1.parentNode.removeChild(element1);
			}
		}
		
		/**
		 * The function that replaces `stopImmediatePropagation_` for events.
		 * @private
		 */
		function stopImmediatePropagation_() {
			var event = this; // eslint-disable-line
			event.stopped = true;
			event.stoppedImmediate = true;
			Event.prototype.stopImmediatePropagation.call(event);
		}
		
		/**
		 * The function that replaces `stopPropagation` for events.
		 * @private
		 */
		function stopPropagation_() {
			var event = this; // eslint-disable-line
			event.stopped = true;
			Event.prototype.stopPropagation.call(event);
		}
		
		/**
		 * Checks if the given element supports the given event type.
		 * @param {!Element|string} element The DOM element or element tag name to check.
		 * @param {string} eventName The name of the event to check.
		 * @return {boolean}
		 */
		function supportsEvent(element, eventName) {
			if (customEvents[eventName]) {
				return true;
			}
			
			if ((0, _metal.isString)(element)) {
				if (!elementsByTag_[element]) {
					elementsByTag_[element] = document.createElement(element);
				}
				element = elementsByTag_[element];
			}
			
			var tag = element.tagName;
			if (!supportCache_[tag] || !supportCache_[tag].hasOwnProperty(eventName)) {
				supportCache_[tag] = supportCache_[tag] || {};
				supportCache_[tag][eventName] = 'on' + eventName in element;
			}
			return supportCache_[tag][eventName];
		}
		
		/**
		 * This triggers all default matched delegated listeners of a given event type.
		 * @param {!Array} defaultFns Array to collect default listeners in, instead
		 * @param {!Event} event
		 * @return {boolean} False if at least one of the triggered callbacks returns
		 *     false, or true otherwise.
		 * @private
		 */
		function triggerDefaultDelegatedListeners_(defFns, event) {
			var ret = true;
			
			for (var i = 0; i < defFns.length && !event.defaultPrevented; i++) {
				event.delegateTarget = defFns[i].element;
				ret &= defFns[i].fn(event);
			}
			
			return ret;
		}
		
		/**
		 * This triggers all matched delegated listeners of a given event type when its
		 * delegated target is able to interact.
		 * @param {!Element} container
		 * @param {!Event} event
		 * @param {!Array} defaultFns Array to collect default listeners in, instead
		 *     of running them.
		 * @return {boolean} False if at least one of the triggered callbacks returns
		 *     false, or true otherwise.
		 * @private
		 */
		function triggerDelegatedListeners_(container, event, defaultFns) {
			var ret = true;
			var currElement = event.target;
			var limit = container.parentNode;
			
			while (currElement && currElement !== limit && !event.stopped) {
				if (isAbleToInteractWith_(currElement, event.type, event)) {
					event.delegateTarget = currElement;
					ret &= triggerElementListeners_(currElement, event, defaultFns);
					ret &= triggerSelectorListeners_(container, currElement, event, defaultFns);
				}
				currElement = currElement.parentNode;
			}
			
			return ret;
		}
		
		/**
		 * Converts the given argument to a DOM element. Strings are assumed to
		 * be selectors, and so a matched element will be returned. If the arg
		 * is already a DOM element it will be the return value.
		 * @param {string|Element|Document} selectorOrElement
		 * @return {Element} The converted element, or null if none was found.
		 */
		function toElement(selectorOrElement) {
			if ((0, _metal.isElement)(selectorOrElement) || (0, _metal.isDocument)(selectorOrElement) || (0, _metal.isDocumentFragment)(selectorOrElement)) {
				return selectorOrElement;
			} else if ((0, _metal.isString)(selectorOrElement)) {
				if (selectorOrElement[0] === '#' && selectorOrElement.indexOf(' ') === -1) {
					return document.getElementById(selectorOrElement.substr(1));
				} else {
					return document.querySelector(selectorOrElement);
				}
			} else {
				return null;
			}
		}
		
		/**
		 * Adds or removes one or more classes from an element. If any of the classes
		 * is present, it will be removed from the element, or added otherwise.
		 * @param {!Element} element The element which classes will be toggled.
		 * @param {string} classes The classes which have to added or removed from the element.
		 */
		function toggleClasses(element, classes) {
			if (!(0, _metal.isObject)(element) || !(0, _metal.isString)(classes)) {
				return;
			}
			
			if ('classList' in element) {
				toggleClassesWithNative_(element, classes);
			} else {
				toggleClassesWithoutNative_(element, classes);
			}
		}
		
		/**
		 * Adds or removes one or more classes from an element using classList.
		 * If any of the classes is present, it will be removed from the element,
		 * or added otherwise.
		 * @param {!Element} element The element which classes will be toggled.
		 * @param {string} classes The classes which have to added or removed from the element.
		 * @private
		 */
		function toggleClassesWithNative_(element, classes) {
			classes.split(' ').forEach(function (className) {
				element.classList.toggle(className);
			});
		}
		
		/**
		 * Adds or removes one or more classes from an element without using classList.
		 * If any of the classes is present, it will be removed from the element,
		 * or added otherwise.
		 * @param {!Element} element The element which classes will be toggled.
		 * @param {string} classes The classes which have to added or removed from the element.
		 * @private
		 */
		function toggleClassesWithoutNative_(element, classes) {
			var elementClassName = ' ' + element.className + ' ';
			
			classes = classes.split(' ');
			
			for (var i = 0; i < classes.length; i++) {
				var className = ' ' + classes[i] + ' ';
				var classIndex = elementClassName.indexOf(className);
				
				if (classIndex === -1) {
					elementClassName = '' + elementClassName + classes[i] + ' ';
				} else {
					var before = elementClassName.substring(0, classIndex);
					var after = elementClassName.substring(classIndex + className.length);
					elementClassName = before + ' ' + after;
				}
			}
			
			element.className = elementClassName.trim();
		}
		
		/**
		 * Triggers all listeners for the given event type that are stored in the
		 * specified element.
		 * @param {!Element} element
		 * @param {!Event} event
		 * @param {!Array} defaultFns Array to collect default listeners in, instead
		 *     of running them.
		 * @return {boolean} False if at least one of the triggered callbacks returns
		 *     false, or true otherwise.
		 * @private
		 */
		function triggerElementListeners_(element, event, defaultFns) {
			var lastContainer = event[LAST_CONTAINER];
			if (!(0, _metal.isDef)(lastContainer) || !contains(lastContainer, element)) {
				var listeners = _domData2.default.get(element, 'listeners', {})[event.type];
				return triggerListeners_(listeners, event, element, defaultFns);
			}
			return true;
		}
		
		/**
		 * Triggers the specified event on the given element.
		 * NOTE: This should mostly be used for testing, not on real code.
		 * @param {!Element} element The node that should trigger the event.
		 * @param {string} eventName The name of the event to be triggred.
		 * @param {Object=} opt_eventObj An object with data that should be on the
		 *   triggered event's payload.
		 */
		function triggerEvent(element, eventName, opt_eventObj) {
			if (isAbleToInteractWith_(element, eventName, opt_eventObj)) {
				var eventObj = document.createEvent('HTMLEvents');
				eventObj.initEvent(eventName, true, true);
				_metal.object.mixin(eventObj, opt_eventObj);
				element.dispatchEvent(eventObj);
			}
		}
		
		/**
		 * Triggers the given listeners array.
		 * @param {Array<!function()>} listeners
		 * @param {!Event} event
		 * @param {!Element} element
		 * @param {!Array} defaultFns Array to collect default listeners in, instead
		 *     of running them.
		 * @return {boolean} False if at least one of the triggered callbacks returns
		 *     false, or true otherwise.
		 * @private
		 */
		function triggerListeners_(listeners, event, element, defaultFns) {
			var ret = true;
			listeners = listeners || [];
			for (var i = 0; i < listeners.length && !event.stoppedImmediate; i++) {
				if (listeners[i].defaultListener_) {
					defaultFns.push({
						element: element,
						fn: listeners[i]
					});
				} else {
					ret &= listeners[i](event);
				}
			}
			return ret;
		}
		
		/**
		 * Triggers all selector listeners for the given event.
		 * @param {!Element} container
		 * @param {!Element} element
		 * @param {!Event} event
		 * @param {!Array} defaultFns Array to collect default listeners in, instead
		 *     of running them.
		 * @return {boolean} False if at least one of the triggered callbacks returns
		 *     false, or true otherwise.
		 * @private
		 */
		function triggerSelectorListeners_(container, element, event, defaultFns) {
			var ret = true;
			var data = _domData2.default.get(container, 'delegating', {});
			var map = data[event.type].selectors;
			var selectors = Object.keys(map);
			for (var i = 0; i < selectors.length && !event.stoppedImmediate; i++) {
				if (match(element, selectors[i])) {
					var listeners = map[selectors[i]];
					ret &= triggerListeners_(listeners, event, element, defaultFns);
				}
			}
			return ret;
		}
		
		/***/ }),
	/* 56 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(process) {
			
			/**
			 * A collection of core utility functions.
			 * @const
			 */
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			exports.abstractMethod = abstractMethod;
			exports.disableCompatibilityMode = disableCompatibilityMode;
			exports.enableCompatibilityMode = enableCompatibilityMode;
			exports.getCompatibilityModeData = getCompatibilityModeData;
			exports.getFunctionName = getFunctionName;
			exports.getStaticProperty = getStaticProperty;
			exports.getUid = getUid;
			exports.identityFunction = identityFunction;
			exports.isBoolean = isBoolean;
			exports.isDef = isDef;
			exports.isDefAndNotNull = isDefAndNotNull;
			exports.isDocument = isDocument;
			exports.isDocumentFragment = isDocumentFragment;
			exports.isElement = isElement;
			exports.isFunction = isFunction;
			exports.isNull = isNull;
			exports.isNumber = isNumber;
			exports.isWindow = isWindow;
			exports.isObject = isObject;
			exports.isPromise = isPromise;
			exports.isString = isString;
			exports.isServerSide = isServerSide;
			exports.nullFunction = nullFunction;
			var compatibilityModeData_ = void 0;
			
			/**
			 * Counter for unique id.
			 * @type {Number}
			 * @private
			 */
			var uniqueIdCounter_ = 1;
			
			/**
			 * Unique id property prefix.
			 * @type {String}
			 * @protected
			 */
			var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}
			
			/**
			 * Disables Metal.js's compatibility mode.
			 */
			function disableCompatibilityMode() {
				compatibilityModeData_ = undefined;
			}
			
			/**
			 * Enables Metal.js's compatibility mode with the following features from rc
			 * and 1.x versions:
			 *     - Using "key" to reference component instances. In the current version
			 *       this should be done via "ref" instead. This allows old code still
			 *       using "key" to keep working like before. NOTE: this may cause
			 *       problems, since "key" is meant to be used differently. Only use this
			 *       if it's not possible to upgrade the code to use "ref" instead.
			 * @param {Object=} opt_data Optional object with data to specify more
			 *     details, such as:
			 *         - renderers {Array} the template renderers that should be in
			 *           compatibility mode, either their constructors or strings
			 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
			 *           that extend from IncrementalDomRenderer.
			 * @type {Object}
			 */
			function enableCompatibilityMode() {
				var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				
				compatibilityModeData_ = opt_data;
			}
			
			/**
			 * Returns the data used for compatibility mode, or nothing if it hasn't been
			 * enabled.
			 * @return {Object}
			 */
			function getCompatibilityModeData() {
				// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
				if (compatibilityModeData_ === undefined) {
					if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
						enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
					}
				}
				return compatibilityModeData_;
			}
			
			/**
			 * Returns the first argument if it's truthy, or the second otherwise.
			 * @param {*} a
			 * @param {*} b
			 * @return {*}
			 * @protected
			 */
			function getFirstTruthy_(a, b) {
				return a || b;
			}
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}
			
			/**
			 * Gets the value of a static property in the given class. The value will be
			 * inherited from ancestors as expected, unless a custom merge function is given,
			 * which can change how the super classes' value for that property will be merged
			 * together.
			 * The final merged value will be stored in another property, so that it won't
			 * be recalculated even if this function is called multiple times.
			 * @param {!function()} ctor Class constructor.
			 * @param {string} propertyName Property name to be merged.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
			 *     value of the property so far and the next value to be merged to it.
			 *     Should return these two merged together. If not passed the final property
			 *     will be the first truthy value among ancestors.
			 */
			function getStaticProperty(ctor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (!ctor.hasOwnProperty(mergedName)) {
					var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
					if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
						var mergeFn = opt_mergeFn || getFirstTruthy_;
						merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
					}
					ctor[mergedName] = merged;
				}
				return ctor[mergedName];
			}
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
				}
				return uniqueIdCounter_++;
			}
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			function isBoolean(val) {
				return typeof val === 'boolean';
			}
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			function isDef(val) {
				return val !== undefined;
			}
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDefAndNotNull(val) {
				return isDef(val) && !isNull(val);
			}
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			}
			
			/**
			 * Returns true if value is a document-fragment.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocumentFragment(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
			}
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			}
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			function isFunction(val) {
				return typeof val === 'function';
			}
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isNull(val) {
				return val === null;
			}
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			function isNumber(val) {
				return typeof val === 'number';
			}
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isWindow(val) {
				return val !== null && val === val.window;
			}
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			}
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}
			
			/**
			 * Sets to true if running inside Node.js environment with extra check for
			 * `process.browser` to skip Karma runner environment. Karma environment has
			 * `process` defined even though it runs on the browser.
			 * @return {boolean}
			 */
			function isServerSide() {
				return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
			}
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			function nullFunction() {}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))
		
		/***/ }),
	/* 57 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _core = __webpack_require__(19);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			_createClass(array, null, [{
				key: 'equal',
				
				/**
				 * Checks if the given arrays have the same content.
				 * @param {!Array<*>} arr1
				 * @param {!Array<*>} arr2
				 * @return {boolean}
				 */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}
				
				/**
				 * Returns the first value in the given array that isn't undefined.
				 * @param {!Array} arr
				 * @return {*}
				 */
				
			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}
				
				/**
				 * Transforms the input nested array to become flat.
				 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
				 * @param {Array.<*>} opt_output Optional output array.
				 * @return {Array.<*>} Flat array.
				 */
				
			}, {
				key: 'flatten',
				value: function flatten(arr, opt_output) {
					var output = opt_output || [];
					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}
				
				/**
				 * Removes the first occurrence of a particular value from an array.
				 * @param {Array.<T>} arr Array from which to remove value.
				 * @param {T} obj Object to remove.
				 * @return {boolean} True if an element was removed.
				 * @template T
				 */
				
			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}
				
				/**
				 * Removes from an array the element at index i
				 * @param {Array} arr Array or array like object from which to remove value.
				 * @param {number} i The index to remove.
				 * @return {boolean} True if an element was removed.
				 */
				
			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}
				
				/**
				 * Slices the given array, just like Array.prototype.slice, but this
				 * is faster and working on all array-like objects (like arguments).
				 * @param {!Object} arr Array-like object to slice.
				 * @param {number} start The index that should start the slice.
				 * @param {number=} opt_end The index where the slice should end, not
				 *   included in the final array. If not given, all elements after the
				 *   start index will be included.
				 * @return {!Array}
				 */
				
			}, {
				key: 'slice',
				value: function slice(arr, start, opt_end) {
					var sliced = [];
					var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 58 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel = void 0;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 59 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}
				
				/**
				 * Subclasses should override this method to implement any specific
				 * disposing logic (like clearing references and calling `dispose` on other
				 * disposables).
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}
				
				/**
				 * Checks if this instance has already been disposed.
				 * @return {boolean}
				 */
				
			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 60 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			_createClass(object, null, [{
				key: 'mixin',
				
				/**
				 * Copies all the members of a source object to a target object.
				 * @param {Object} target Target object.
				 * @param {...Object} var_args The objects from which values will be copied.
				 * @return {Object} Returns the target object reference.
				 */
				value: function mixin(target) {
					var key = void 0,
						source = void 0;
					for (var i = 1; i < arguments.length; i++) {
						source = arguments[i];
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}
				
				/**
				 * Returns an object based on its fully qualified external name.
				 * @param {string} name The fully qualified name.
				 * @param {object=} opt_obj The object within which to look; default is
				 *     <code>window</code>.
				 * @return {?} The value (object or primitive) or, if not found, undefined.
				 */
				
			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name, opt_obj) {
					var scope = opt_obj || window;
					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}
				
				/**
				 * Returns a new object with the same keys as the given one, but with
				 * their values set to the return values of the specified function.
				 * @param {!Object} obj
				 * @param {!function(string, *)} fn
				 * @return {!Object}
				 */
				
			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}
				
				/**
				 * Checks if the two given objects are equal. This is done via a shallow
				 * check, including only the keys directly contained by the 2 objects.
				 * @return {boolean}
				 */
				
			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}
					
					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}
					
					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 61 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',
				
				/**
				 * Compares the given strings without taking the case into account.
				 * @param {string|number} str1
				 * @param {string|number} str2
				 * @return {number} Either -1, 0 or 1, according to if the first string is
				 *     "smaller", equal or "bigger" than the second given string.
				 */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();
					
					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}
				
				/**
				 * Removes the breaking spaces from the left and right of the string and
				 * collapses the sequences of breaking spaces in the middle into single spaces.
				 * The original and the result strings render the same way in HTML.
				 * @param {string} str A string in which to collapse spaces.
				 * @return {string} Copy of the string with normalized breaking spaces.
				 */
				
			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}
				
				/**
				 * Escapes characters in the string that are not safe to use in a RegExp.
				 * @param {*} str The string to escape. If not a string, it will be casted
				 *     to one.
				 * @return {string} A RegExp safe, escaped copy of {@code s}.
				 */
				
			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
				}
				
				/**
				 * Returns a string with at least 64-bits of randomness.
				 * @return {string} A random string, e.g. sn1s7vb4gcic.
				 */
				
			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}
				
				/**
				 * Calculates the hashcode for a string. The hashcode value is computed by
				 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
				 * property of using 31 prime is that the multiplication can be replaced by
				 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
				 * Modern VMs do this sort of optimization automatically.
				 * @param {String} val Target string.
				 * @return {Number} Returns the string hashcode.
				 */
				
			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}
				
				/**
				 * Replaces interval into the string with specified value, e.g.
				 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
				 * @param {string} str The input string.
				 * @param {Number} start Start interval position to be replaced.
				 * @param {Number} end End interval position to be replaced.
				 * @param {string} value The value that replaces the specified interval.
				 * @return {string}
				 */
				
			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 62 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(7);
		
		var _domData = __webpack_require__(13);
		
		var _domData2 = _interopRequireDefault(_domData);
		
		var _metalEvents = __webpack_require__(8);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * This is a special EventHandle, that is responsible for dom delegated events
		 * (only the ones that receive a target element, not a selector string).
		 * @extends {EventHandle}
		 */
		var DomDelegatedEventHandle = function (_EventHandle) {
			_inherits(DomDelegatedEventHandle, _EventHandle);
			
			/**
			 * The constructor for `DomDelegatedEventHandle`.
			 * @param {!Event} emitter Element the event was subscribed to.
			 * @param {string} event The name of the event that was subscribed to.
			 * @param {!Function} listener The listener subscribed to the event.
			 * @param {string=} opt_selector An optional selector used when delegating
			 *     the event.
			 * @constructor
			 */
			function DomDelegatedEventHandle(emitter, event, listener, opt_selector) {
				_classCallCheck(this, DomDelegatedEventHandle);
				
				var _this = _possibleConstructorReturn(this, (DomDelegatedEventHandle.__proto__ || Object.getPrototypeOf(DomDelegatedEventHandle)).call(this, emitter, event, listener));
				
				_this.selector_ = opt_selector;
				return _this;
			}
			
			/**
			 * @inheritDoc
			 */
			
			
			_createClass(DomDelegatedEventHandle, [{
				key: 'removeListener',
				value: function removeListener() {
					var delegating = _domData2.default.get(this.emitter_, 'delegating', {});
					var listeners = _domData2.default.get(this.emitter_, 'listeners', {});
					var selector = this.selector_;
					var arr = (0, _metal.isString)(selector) ? delegating[this.event_].selectors : listeners;
					var key = (0, _metal.isString)(selector) ? selector : this.event_;
					
					_metal.array.remove(arr[key] || [], this.listener_);
					if (arr[key] && arr[key].length === 0) {
						delete arr[key];
					}
				}
			}]);
			
			return DomDelegatedEventHandle;
		}(_metalEvents.EventHandle);
		
		exports.default = DomDelegatedEventHandle;
		
		/***/ }),
	/* 63 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(10);
		
		var _EventHandle = __webpack_require__(21);
		
		var _EventHandle2 = _interopRequireDefault(_EventHandle);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		var singleArray_ = [0];
		
		/**
		 * EventEmitter utility.
		 * @constructor
		 * @extends {Disposable}
		 */
		
		var EventEmitter = function (_Disposable) {
			_inherits(EventEmitter, _Disposable);
			
			function EventEmitter() {
				_classCallCheck(this, EventEmitter);
				
				/**
				 * Holds event listeners scoped by event type.
				 * @type {Object<string, !Array<!function()>>}
				 * @protected
				 */
				var _this = _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).call(this));
				
				_this.events_ = null;
				
				/**
				 * Handlers that are triggered when an event is listened to.
				 * @type {Array}
				 */
				_this.listenerHandlers_ = null;
				
				/**
				 * Configuration option which determines if an event facade should be sent
				 * as a param of listeners when emitting events. If set to true, the facade
				 * will be passed as the first argument of the listener.
				 * @type {boolean}
				 * @protected
				 */
				_this.shouldUseFacade_ = false;
				return _this;
			}
			
			/**
			 * Adds a handler to given holder variable. If the holder doesn't have a
			 * value yet, it will receive the handler directly. If the holder is an array,
			 * the value will just be added to it. Otherwise, the holder will be set to a
			 * new array containing its previous value plus the new handler.
			 * @param {*} holder
			 * @param {!function()|Object} handler
			 * @return {*} The holder's new value.
			 * @protected
			 */
			
			
			_createClass(EventEmitter, [{
				key: 'addHandler_',
				value: function addHandler_(holder, handler) {
					if (!holder) {
						holder = handler;
					} else {
						if (!Array.isArray(holder)) {
							holder = [holder];
						}
						holder.push(handler);
					}
					return holder;
				}
				
				/**
				 * Adds a listener to the end of the listeners array for the specified events.
				 * @param {!(Array|string)} event
				 * @param {!Function} listener
				 * @param {boolean} opt_default Flag indicating if this listener is a default
				 *   action for this event. Default actions are run last, and only if no previous
				 *   listener call `preventDefault()` on the received event facade.
				 * @return {!EventHandle} Can be used to remove the listener.
				 */
				
			}, {
				key: 'addListener',
				value: function addListener(event, listener, opt_default) {
					this.validateListener_(listener);
					
					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.addSingleListener_(events[i], listener, opt_default);
					}
					
					return new _EventHandle2.default(this, event, listener);
				}
				
				/**
				 * Adds a listener to the end of the listeners array for a single event.
				 * @param {string} event
				 * @param {!Function} listener
				 * @param {boolean} opt_default Flag indicating if this listener is a default
				 *   action for this event. Default actions are run last, and only if no previous
				 *   listener call `preventDefault()` on the received event facade.
				 * @return {!EventHandle} Can be used to remove the listener.
				 * @param {Function=} opt_origin The original function that was added as a
				 *   listener, if there is any.
				 * @protected
				 */
				
			}, {
				key: 'addSingleListener_',
				value: function addSingleListener_(event, listener, opt_default, opt_origin) {
					this.runListenerHandlers_(event);
					if (opt_default || opt_origin) {
						listener = {
							default: opt_default,
							fn: listener,
							origin: opt_origin
						};
					}
					this.events_ = this.events_ || {};
					this.events_[event] = this.addHandler_(this.events_[event], listener);
				}
				
				/**
				 * Builds facade for the given event.
				 * @param {string} event
				 * @return {Object}
				 * @protected
				 */
				
			}, {
				key: 'buildFacade_',
				value: function buildFacade_(event) {
					if (this.getShouldUseFacade()) {
						var facade = {
							preventDefault: function preventDefault() {
								facade.preventedDefault = true;
							},
							target: this,
							type: event
						};
						return facade;
					}
				}
				
				/**
				 * Disposes of this instance's object references.
				 * @override
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.events_ = null;
				}
				
				/**
				 * Execute each of the listeners in order with the supplied arguments.
				 * @param {string} event
				 * @param {*} opt_args [arg1], [arg2], [...]
				 * @return {boolean} Returns true if event had listeners, false otherwise.
				 */
				
			}, {
				key: 'emit',
				value: function emit(event) {
					var listeners = this.getRawListeners_(event);
					if (listeners.length === 0) {
						return false;
					}
					
					var args = _metal.array.slice(arguments, 1);
					this.runListeners_(listeners, args, this.buildFacade_(event));
					return true;
				}
				
				/**
				 * Gets the listener objects for the given event, if there are any.
				 * @param {string} event
				 * @return {!Array}
				 * @protected
				 */
				
			}, {
				key: 'getRawListeners_',
				value: function getRawListeners_(event) {
					var directListeners = toArray(this.events_ && this.events_[event]);
					return directListeners.concat(toArray(this.events_ && this.events_['*']));
				}
				
				/**
				 * Gets the configuration option which determines if an event facade should
				 * be sent as a param of listeners when emitting events. If set to true, the
				 * facade will be passed as the first argument of the listener.
				 * @return {boolean}
				 */
				
			}, {
				key: 'getShouldUseFacade',
				value: function getShouldUseFacade() {
					return this.shouldUseFacade_;
				}
				
				/**
				 * Returns an array of listeners for the specified event.
				 * @param {string} event
				 * @return {Array} Array of listeners.
				 */
				
			}, {
				key: 'listeners',
				value: function listeners(event) {
					return this.getRawListeners_(event).map(function (listener) {
						return listener.fn ? listener.fn : listener;
					});
				}
				
				/**
				 * Adds a listener that will be invoked a fixed number of times for the
				 * events. After each event is triggered the specified amount of times, the
				 * listener is removed for it.
				 * @param {!(Array|string)} event
				 * @param {number} amount The amount of times this event should be listened
				 * to.
				 * @param {!Function} listener
				 * @return {!EventHandle} Can be used to remove the listener.
				 */
				
			}, {
				key: 'many',
				value: function many(event, amount, listener) {
					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.many_(events[i], amount, listener);
					}
					
					return new _EventHandle2.default(this, event, listener);
				}
				
				/**
				 * Adds a listener that will be invoked a fixed number of times for a single
				 * event. After the event is triggered the specified amount of times, the
				 * listener is removed.
				 * @param {string} event
				 * @param {number} amount The amount of times this event should be listened
				 * to.
				 * @param {!Function} listener
				 * @protected
				 */
				
			}, {
				key: 'many_',
				value: function many_(event, amount, listener) {
					var self = this;
					
					if (amount <= 0) {
						return;
					}
					
					function handlerInternal() {
						if (--amount === 0) {
							self.removeListener(event, handlerInternal);
						}
						listener.apply(self, arguments);
					}
					
					self.addSingleListener_(event, handlerInternal, false, listener);
				}
				
				/**
				 * Checks if a listener object matches the given listener function. To match,
				 * it needs to either point to that listener or have it as its origin.
				 * @param {!Object} listenerObj
				 * @param {!Function} listener
				 * @return {boolean}
				 * @protected
				 */
				
			}, {
				key: 'matchesListener_',
				value: function matchesListener_(listenerObj, listener) {
					var fn = listenerObj.fn || listenerObj;
					return fn === listener || listenerObj.origin && listenerObj.origin === listener;
				}
				
				/**
				 * Removes a listener for the specified events.
				 * Caution: changes array indices in the listener array behind the listener.
				 * @param {!(Array|string)} events
				 * @param {!Function} listener
				 * @return {!Object} Returns emitter, so calls can be chained.
				 */
				
			}, {
				key: 'off',
				value: function off(event, listener) {
					this.validateListener_(listener);
					if (!this.events_) {
						return this;
					}
					
					var events = this.toEventsArray_(event);
					for (var i = 0; i < events.length; i++) {
						this.events_[events[i]] = this.removeMatchingListenerObjs_(toArray(this.events_[events[i]]), listener);
					}
					
					return this;
				}
				
				/**
				 * Adds a listener to the end of the listeners array for the specified events.
				 * @param {!(Array|string)} events
				 * @param {!Function} listener
				 * @return {!EventHandle} Can be used to remove the listener.
				 */
				
			}, {
				key: 'on',
				value: function on() {
					return this.addListener.apply(this, arguments);
				}
				
				/**
				 * Adds handler that gets triggered when an event is listened to on this
				 * instance.
				 * @param {!function()}
				 */
				
			}, {
				key: 'onListener',
				value: function onListener(handler) {
					this.listenerHandlers_ = this.addHandler_(this.listenerHandlers_, handler);
				}
				
				/**
				 * Adds a one time listener for the events. This listener is invoked only the
				 * next time each event is fired, after which it is removed.
				 * @param {!(Array|string)} events
				 * @param {!Function} listener
				 * @return {!EventHandle} Can be used to remove the listener.
				 */
				
			}, {
				key: 'once',
				value: function once(events, listener) {
					return this.many(events, 1, listener);
				}
				
				/**
				 * Removes all listeners, or those of the specified events. It's not a good
				 * idea to remove listeners that were added elsewhere in the code,
				 * especially when it's on an emitter that you didn't create.
				 * @param {(Array|string)=} opt_events
				 * @return {!Object} Returns emitter, so calls can be chained.
				 */
				
			}, {
				key: 'removeAllListeners',
				value: function removeAllListeners(opt_events) {
					if (this.events_) {
						if (opt_events) {
							var events = this.toEventsArray_(opt_events);
							for (var i = 0; i < events.length; i++) {
								this.events_[events[i]] = null;
							}
						} else {
							this.events_ = null;
						}
					}
					return this;
				}
				
				/**
				 * Removes all listener objects from the given array that match the given
				 * listener function.
				 * @param {Array.<Object>} listenerObjs
				 * @param {!Function} listener
				 * @return {Array.<Object>|Object} The new listeners array for this event.
				 * @protected
				 */
				
			}, {
				key: 'removeMatchingListenerObjs_',
				value: function removeMatchingListenerObjs_(listenerObjs, listener) {
					var finalListeners = [];
					for (var i = 0; i < listenerObjs.length; i++) {
						if (!this.matchesListener_(listenerObjs[i], listener)) {
							finalListeners.push(listenerObjs[i]);
						}
					}
					return finalListeners.length > 0 ? finalListeners : null;
				}
				
				/**
				 * Removes a listener for the specified events.
				 * Caution: changes array indices in the listener array behind the listener.
				 * @param {!(Array|string)} events
				 * @param {!Function} listener
				 * @return {!Object} Returns emitter, so calls can be chained.
				 */
				
			}, {
				key: 'removeListener',
				value: function removeListener() {
					return this.off.apply(this, arguments);
				}
				
				/**
				 * Runs the handlers when an event is listened to.
				 * @param {string} event
				 * @protected
				 */
				
			}, {
				key: 'runListenerHandlers_',
				value: function runListenerHandlers_(event) {
					var handlers = this.listenerHandlers_;
					if (handlers) {
						handlers = toArray(handlers);
						for (var i = 0; i < handlers.length; i++) {
							handlers[i](event);
						}
					}
				}
				
				/**
				 * Runs the given listeners.
				 * @param {!Array} listeners
				 * @param {!Array} args
				 * @param (Object) facade
				 * @protected
				 */
				
			}, {
				key: 'runListeners_',
				value: function runListeners_(listeners, args, facade) {
					if (facade) {
						args.push(facade);
					}
					
					var defaultListeners = [];
					for (var i = 0; i < listeners.length; i++) {
						var listener = listeners[i].fn || listeners[i];
						if (listeners[i].default) {
							defaultListeners.push(listener);
						} else {
							listener.apply(this, args);
						}
					}
					if (!facade || !facade.preventedDefault) {
						for (var j = 0; j < defaultListeners.length; j++) {
							defaultListeners[j].apply(this, args);
						}
					}
				}
				
				/**
				 * Sets the configuration option which determines if an event facade should
				 * be sent as a param of listeners when emitting events. If set to true, the
				 * facade will be passed as the first argument of the listener.
				 * @param {boolean} shouldUseFacade
				 * @return {!Object} Returns emitter, so calls can be chained.
				 */
				
			}, {
				key: 'setShouldUseFacade',
				value: function setShouldUseFacade(shouldUseFacade) {
					this.shouldUseFacade_ = shouldUseFacade;
					return this;
				}
				
				/**
				 * Converts the parameter to an array if only one event is given. Reuses the
				 * same array each time this conversion is done, to avoid using more memory
				 * than necessary.
				 * @param  {!(Array|string)} events
				 * @return {!Array}
				 * @protected
				 */
				
			}, {
				key: 'toEventsArray_',
				value: function toEventsArray_(events) {
					if ((0, _metal.isString)(events)) {
						singleArray_[0] = events;
						events = singleArray_;
					}
					return events;
				}
				
				/**
				 * Checks if the given listener is valid, throwing an exception when it's not.
				 * @param  {*} listener
				 * @protected
				 */
				
			}, {
				key: 'validateListener_',
				value: function validateListener_(listener) {
					if (!(0, _metal.isFunction)(listener)) {
						throw new TypeError('Listener must be a function');
					}
				}
			}]);
			
			return EventEmitter;
		}(_metal.Disposable);
		
		function toArray(val) {
			val = val || [];
			return Array.isArray(val) ? val : [val];
		}
		
		exports.default = EventEmitter;
		
		/***/ }),
	/* 64 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(process) {
			
			/**
			 * A collection of core utility functions.
			 * @const
			 */
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			exports.abstractMethod = abstractMethod;
			exports.disableCompatibilityMode = disableCompatibilityMode;
			exports.enableCompatibilityMode = enableCompatibilityMode;
			exports.getCompatibilityModeData = getCompatibilityModeData;
			exports.getFunctionName = getFunctionName;
			exports.getStaticProperty = getStaticProperty;
			exports.getUid = getUid;
			exports.identityFunction = identityFunction;
			exports.isBoolean = isBoolean;
			exports.isDef = isDef;
			exports.isDefAndNotNull = isDefAndNotNull;
			exports.isDocument = isDocument;
			exports.isDocumentFragment = isDocumentFragment;
			exports.isElement = isElement;
			exports.isFunction = isFunction;
			exports.isNull = isNull;
			exports.isNumber = isNumber;
			exports.isWindow = isWindow;
			exports.isObject = isObject;
			exports.isPromise = isPromise;
			exports.isString = isString;
			exports.isServerSide = isServerSide;
			exports.nullFunction = nullFunction;
			var compatibilityModeData_ = void 0;
			
			/**
			 * Counter for unique id.
			 * @type {Number}
			 * @private
			 */
			var uniqueIdCounter_ = 1;
			
			/**
			 * Unique id property prefix.
			 * @type {String}
			 * @protected
			 */
			var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}
			
			/**
			 * Disables Metal.js's compatibility mode.
			 */
			function disableCompatibilityMode() {
				compatibilityModeData_ = undefined;
			}
			
			/**
			 * Enables Metal.js's compatibility mode with the following features from rc
			 * and 1.x versions:
			 *     - Using "key" to reference component instances. In the current version
			 *       this should be done via "ref" instead. This allows old code still
			 *       using "key" to keep working like before. NOTE: this may cause
			 *       problems, since "key" is meant to be used differently. Only use this
			 *       if it's not possible to upgrade the code to use "ref" instead.
			 * @param {Object=} opt_data Optional object with data to specify more
			 *     details, such as:
			 *         - renderers {Array} the template renderers that should be in
			 *           compatibility mode, either their constructors or strings
			 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
			 *           that extend from IncrementalDomRenderer.
			 * @type {Object}
			 */
			function enableCompatibilityMode() {
				var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				
				compatibilityModeData_ = opt_data;
			}
			
			/**
			 * Returns the data used for compatibility mode, or nothing if it hasn't been
			 * enabled.
			 * @return {Object}
			 */
			function getCompatibilityModeData() {
				// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
				if (compatibilityModeData_ === undefined) {
					if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
						enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
					}
				}
				return compatibilityModeData_;
			}
			
			/**
			 * Returns the first argument if it's truthy, or the second otherwise.
			 * @param {*} a
			 * @param {*} b
			 * @return {*}
			 * @protected
			 */
			function getFirstTruthy_(a, b) {
				return a || b;
			}
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}
			
			/**
			 * Gets the value of a static property in the given class. The value will be
			 * inherited from ancestors as expected, unless a custom merge function is given,
			 * which can change how the super classes' value for that property will be merged
			 * together.
			 * The final merged value will be stored in another property, so that it won't
			 * be recalculated even if this function is called multiple times.
			 * @param {!function()} ctor Class constructor.
			 * @param {string} propertyName Property name to be merged.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
			 *     value of the property so far and the next value to be merged to it.
			 *     Should return these two merged together. If not passed the final property
			 *     will be the first truthy value among ancestors.
			 */
			function getStaticProperty(ctor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (!ctor.hasOwnProperty(mergedName)) {
					var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
					if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
						var mergeFn = opt_mergeFn || getFirstTruthy_;
						merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
					}
					ctor[mergedName] = merged;
				}
				return ctor[mergedName];
			}
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
				}
				return uniqueIdCounter_++;
			}
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			function isBoolean(val) {
				return typeof val === 'boolean';
			}
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			function isDef(val) {
				return val !== undefined;
			}
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDefAndNotNull(val) {
				return isDef(val) && !isNull(val);
			}
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			}
			
			/**
			 * Returns true if value is a document-fragment.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocumentFragment(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
			}
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			}
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			function isFunction(val) {
				return typeof val === 'function';
			}
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isNull(val) {
				return val === null;
			}
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			function isNumber(val) {
				return typeof val === 'number';
			}
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isWindow(val) {
				return val !== null && val === val.window;
			}
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			}
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}
			
			/**
			 * Sets to true if running inside Node.js environment with extra check for
			 * `process.browser` to skip Karma runner environment. Karma environment has
			 * `process` defined even though it runs on the browser.
			 * @return {boolean}
			 */
			function isServerSide() {
				return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
			}
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			function nullFunction() {}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))
		
		/***/ }),
	/* 65 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _core = __webpack_require__(20);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			_createClass(array, null, [{
				key: 'equal',
				
				/**
				 * Checks if the given arrays have the same content.
				 * @param {!Array<*>} arr1
				 * @param {!Array<*>} arr2
				 * @return {boolean}
				 */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}
				
				/**
				 * Returns the first value in the given array that isn't undefined.
				 * @param {!Array} arr
				 * @return {*}
				 */
				
			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}
				
				/**
				 * Transforms the input nested array to become flat.
				 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
				 * @param {Array.<*>} opt_output Optional output array.
				 * @return {Array.<*>} Flat array.
				 */
				
			}, {
				key: 'flatten',
				value: function flatten(arr, opt_output) {
					var output = opt_output || [];
					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}
				
				/**
				 * Removes the first occurrence of a particular value from an array.
				 * @param {Array.<T>} arr Array from which to remove value.
				 * @param {T} obj Object to remove.
				 * @return {boolean} True if an element was removed.
				 * @template T
				 */
				
			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}
				
				/**
				 * Removes from an array the element at index i
				 * @param {Array} arr Array or array like object from which to remove value.
				 * @param {number} i The index to remove.
				 * @return {boolean} True if an element was removed.
				 */
				
			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}
				
				/**
				 * Slices the given array, just like Array.prototype.slice, but this
				 * is faster and working on all array-like objects (like arguments).
				 * @param {!Object} arr Array-like object to slice.
				 * @param {number} start The index that should start the slice.
				 * @param {number=} opt_end The index where the slice should end, not
				 *   included in the final array. If not given, all elements after the
				 *   start index will be included.
				 * @return {!Array}
				 */
				
			}, {
				key: 'slice',
				value: function slice(arr, start, opt_end) {
					var sliced = [];
					var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 66 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel = void 0;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 67 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}
				
				/**
				 * Subclasses should override this method to implement any specific
				 * disposing logic (like clearing references and calling `dispose` on other
				 * disposables).
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}
				
				/**
				 * Checks if this instance has already been disposed.
				 * @return {boolean}
				 */
				
			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 68 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			_createClass(object, null, [{
				key: 'mixin',
				
				/**
				 * Copies all the members of a source object to a target object.
				 * @param {Object} target Target object.
				 * @param {...Object} var_args The objects from which values will be copied.
				 * @return {Object} Returns the target object reference.
				 */
				value: function mixin(target) {
					var key = void 0,
						source = void 0;
					for (var i = 1; i < arguments.length; i++) {
						source = arguments[i];
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}
				
				/**
				 * Returns an object based on its fully qualified external name.
				 * @param {string} name The fully qualified name.
				 * @param {object=} opt_obj The object within which to look; default is
				 *     <code>window</code>.
				 * @return {?} The value (object or primitive) or, if not found, undefined.
				 */
				
			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name, opt_obj) {
					var scope = opt_obj || window;
					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}
				
				/**
				 * Returns a new object with the same keys as the given one, but with
				 * their values set to the return values of the specified function.
				 * @param {!Object} obj
				 * @param {!function(string, *)} fn
				 * @return {!Object}
				 */
				
			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}
				
				/**
				 * Checks if the two given objects are equal. This is done via a shallow
				 * check, including only the keys directly contained by the 2 objects.
				 * @return {boolean}
				 */
				
			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}
					
					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}
					
					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 69 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',
				
				/**
				 * Compares the given strings without taking the case into account.
				 * @param {string|number} str1
				 * @param {string|number} str2
				 * @return {number} Either -1, 0 or 1, according to if the first string is
				 *     "smaller", equal or "bigger" than the second given string.
				 */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();
					
					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}
				
				/**
				 * Removes the breaking spaces from the left and right of the string and
				 * collapses the sequences of breaking spaces in the middle into single spaces.
				 * The original and the result strings render the same way in HTML.
				 * @param {string} str A string in which to collapse spaces.
				 * @return {string} Copy of the string with normalized breaking spaces.
				 */
				
			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}
				
				/**
				 * Escapes characters in the string that are not safe to use in a RegExp.
				 * @param {*} str The string to escape. If not a string, it will be casted
				 *     to one.
				 * @return {string} A RegExp safe, escaped copy of {@code s}.
				 */
				
			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
				}
				
				/**
				 * Returns a string with at least 64-bits of randomness.
				 * @return {string} A random string, e.g. sn1s7vb4gcic.
				 */
				
			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}
				
				/**
				 * Calculates the hashcode for a string. The hashcode value is computed by
				 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
				 * property of using 31 prime is that the multiplication can be replaced by
				 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
				 * Modern VMs do this sort of optimization automatically.
				 * @param {String} val Target string.
				 * @return {Number} Returns the string hashcode.
				 */
				
			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}
				
				/**
				 * Replaces interval into the string with specified value, e.g.
				 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
				 * @param {string} str The input string.
				 * @param {Number} start Start interval position to be replaced.
				 * @param {Number} end End interval position to be replaced.
				 * @param {string} value The value that replaces the specified interval.
				 * @return {string}
				 */
				
			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 70 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(10);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * EventEmitterProxy utility. It's responsible for linking two EventEmitter
		 * instances together, emitting events from the first emitter through the
		 * second one. That means that listening to a supported event on the target
		 * emitter will mean listening to it on the origin emitter as well.
		 * @param {EventEmitter} originEmitter Events originated on this emitter
		 *   will be fired for the target emitter's listeners as well.
		 * @param {EventEmitter} targetEmitter Event listeners attached to this emitter
		 *   will also be triggered when the event is fired by the origin emitter.
		 * @param {Object} opt_blacklist Optional blacklist of events that should not be
		 *   proxied.
		 * @constructor
		 * @extends {Disposable}
		 */
		var EventEmitterProxy = function (_Disposable) {
			_inherits(EventEmitterProxy, _Disposable);
			
			function EventEmitterProxy(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {
				_classCallCheck(this, EventEmitterProxy);
				
				/**
				 * Map of events that should not be proxied.
				 * @type {Object}
				 * @protected
				 */
				var _this = _possibleConstructorReturn(this, (EventEmitterProxy.__proto__ || Object.getPrototypeOf(EventEmitterProxy)).call(this));
				
				_this.blacklist_ = opt_blacklist;
				
				/**
				 * The origin emitter. This emitter's events will be proxied through the
				 * target emitter.
				 * @type {EventEmitter}
				 * @protected
				 */
				_this.originEmitter_ = originEmitter;
				
				/**
				 * A list of events that are pending to be listened by an actual origin
				 * emitter. Events are stored here when the origin doesn't exist, so they
				 * can be set on a new origin when one is set.
				 * @type {Array}
				 * @protected
				 */
				_this.pendingEvents_ = null;
				
				/**
				 * Holds a map of events from the origin emitter that are already being proxied.
				 * @type {Object<string, !EventHandle>}
				 * @protected
				 */
				_this.proxiedEvents_ = null;
				
				/**
				 * The target emitter. This emitter will emit all events that come from
				 * the origin emitter.
				 * @type {EventEmitter}
				 * @protected
				 */
				_this.targetEmitter_ = targetEmitter;
				
				/**
				 * Map of events that should be proxied. If whitelist is set blacklist is ignored.
				 * @type {Object}
				 * @protected
				 */
				_this.whitelist_ = opt_whitelist;
				
				_this.startProxy_();
				return _this;
			}
			
			/**
			 * Adds the given listener for the given event.
			 * @param {string} event
			 * @param {!function()} listener
			 * @return {!EventHandle} The listened event's handle.
			 * @protected
			 */
			
			
			_createClass(EventEmitterProxy, [{
				key: 'addListener_',
				value: function addListener_(event, listener) {
					return this.originEmitter_.on(event, listener);
				}
				
				/**
				 * @inheritDoc
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.removeListeners_();
					this.proxiedEvents_ = null;
					this.originEmitter_ = null;
					this.targetEmitter_ = null;
				}
				
				/**
				 * Emits the specified event type on the target emitter.
				 * @protected
				 */
				
			}, {
				key: 'emitOnTarget_',
				value: function emitOnTarget_() {
					this.targetEmitter_.emit.apply(this.targetEmitter_, arguments);
				}
				
				/**
				 * Proxies the given event from the origin to the target emitter.
				 * @param {string} event
				 */
				
			}, {
				key: 'proxyEvent',
				value: function proxyEvent(event) {
					if (this.shouldProxyEvent_(event)) {
						this.tryToAddListener_(event);
					}
				}
				
				/**
				 * Removes the proxy listener for all events.
				 * @protected
				 */
				
			}, {
				key: 'removeListeners_',
				value: function removeListeners_() {
					if (this.proxiedEvents_) {
						var events = Object.keys(this.proxiedEvents_);
						for (var i = 0; i < events.length; i++) {
							this.proxiedEvents_[events[i]].removeListener();
						}
						this.proxiedEvents_ = null;
					}
					this.pendingEvents_ = null;
				}
				
				/**
				 * Changes the origin emitter. This automatically detaches any events that
				 * were already being proxied from the previous emitter, and starts proxying
				 * them on the new emitter instead.
				 * @param {!EventEmitter} originEmitter
				 */
				
			}, {
				key: 'setOriginEmitter',
				value: function setOriginEmitter(originEmitter) {
					var _this2 = this;
					
					var events = this.originEmitter_ && this.proxiedEvents_ ? Object.keys(this.proxiedEvents_) : this.pendingEvents_;
					this.originEmitter_ = originEmitter;
					if (events) {
						this.removeListeners_();
						events.forEach(function (event) {
							return _this2.proxyEvent(event);
						});
					}
				}
				
				/**
				 * Checks if the given event should be proxied.
				 * @param {string} event
				 * @return {boolean}
				 * @protected
				 */
				
			}, {
				key: 'shouldProxyEvent_',
				value: function shouldProxyEvent_(event) {
					if (this.whitelist_ && !this.whitelist_[event]) {
						return false;
					}
					if (this.blacklist_ && this.blacklist_[event]) {
						return false;
					}
					return !this.proxiedEvents_ || !this.proxiedEvents_[event];
				}
				
				/**
				 * Starts proxying all events from the origin to the target emitter.
				 * @protected
				 */
				
			}, {
				key: 'startProxy_',
				value: function startProxy_() {
					this.targetEmitter_.onListener(this.proxyEvent.bind(this));
				}
				
				/**
				 * Adds a listener to the origin emitter, if it exists. Otherwise, stores
				 * the pending listener so it can be used on a future origin emitter.
				 * @param {string} event
				 * @protected
				 */
				
			}, {
				key: 'tryToAddListener_',
				value: function tryToAddListener_(event) {
					if (this.originEmitter_) {
						this.proxiedEvents_ = this.proxiedEvents_ || {};
						this.proxiedEvents_[event] = this.addListener_(event, this.emitOnTarget_.bind(this, event));
					} else {
						this.pendingEvents_ = this.pendingEvents_ || [];
						this.pendingEvents_.push(event);
					}
				}
			}]);
			
			return EventEmitterProxy;
		}(_metal.Disposable);
		
		exports.default = EventEmitterProxy;
		
		/***/ }),
	/* 71 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(10);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * EventHandler utility. It's useful for easily removing a group of
		 * listeners from different EventEmitter instances.
		 * @constructor
		 * @extends {Disposable}
		 */
		var EventHandler = function (_Disposable) {
			_inherits(EventHandler, _Disposable);
			
			function EventHandler() {
				_classCallCheck(this, EventHandler);
				
				/**
				 * An array that holds the added event handles, so the listeners can be
				 * removed later.
				 * @type {Array.<EventHandle>}
				 * @protected
				 */
				var _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this));
				
				_this.eventHandles_ = [];
				return _this;
			}
			
			/**
			 * Adds event handles to be removed later through the `removeAllListeners`
			 * method.
			 * @param {...(!EventHandle)} var_args
			 */
			
			
			_createClass(EventHandler, [{
				key: 'add',
				value: function add() {
					for (var i = 0; i < arguments.length; i++) {
						this.eventHandles_.push(arguments[i]);
					}
				}
				
				/**
				 * Disposes of this instance's object references.
				 * @override
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					this.eventHandles_ = null;
				}
				
				/**
				 * Removes all listeners that have been added through the `add` method.
				 */
				
			}, {
				key: 'removeAllListeners',
				value: function removeAllListeners() {
					for (var i = 0; i < this.eventHandles_.length; i++) {
						this.eventHandles_[i].removeListener();
					}
					
					this.eventHandles_ = [];
				}
			}]);
			
			return EventHandler;
		}(_metal.Disposable);
		
		exports.default = EventHandler;
		
		/***/ }),
	/* 72 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _dom = __webpack_require__(4);
		
		var _metalEvents = __webpack_require__(8);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * DomEventEmitterProxy utility. It extends `EventEmitterProxy` to also accept
		 * dom elements as origin emitters.
		 * @extends {EventEmitterProxy}
		 */
		var DomEventEmitterProxy = function (_EventEmitterProxy) {
			_inherits(DomEventEmitterProxy, _EventEmitterProxy);
			
			function DomEventEmitterProxy() {
				_classCallCheck(this, DomEventEmitterProxy);
				
				return _possibleConstructorReturn(this, (DomEventEmitterProxy.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy)).apply(this, arguments));
			}
			
			_createClass(DomEventEmitterProxy, [{
				key: 'addListener_',
				
				/**
				 * Adds the given listener for the given event.
				 * @param {string} event
				 * @param {!function()} listener
				 * @return {!EventHandle} The listened event's handle.
				 * @protected
				 * @override
				 */
				value: function addListener_(event, listener) {
					if (this.originEmitter_.addEventListener) {
						if (this.isDelegateEvent_(event)) {
							var index = event.indexOf(':', 9);
							var eventName = event.substring(9, index);
							var selector = event.substring(index + 1);
							return (0, _dom.delegate)(this.originEmitter_, eventName, selector, listener);
						} else {
							return (0, _dom.on)(this.originEmitter_, event, listener);
						}
					} else {
						return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'addListener_', this).call(this, event, listener);
					}
				}
				
				/**
				 * Checks if the given event is of the delegate type.
				 * @param {string} event
				 * @return {boolean}
				 * @protected
				 */
				
			}, {
				key: 'isDelegateEvent_',
				value: function isDelegateEvent_(event) {
					return event.substr(0, 9) === 'delegate:';
				}
				
				/**
				 * Checks if the given event is supported by the origin element.
				 * @param {string} event
				 * @protected
				 */
				
			}, {
				key: 'isSupportedDomEvent_',
				value: function isSupportedDomEvent_(event) {
					if (!this.originEmitter_ || !this.originEmitter_.addEventListener) {
						return true;
					}
					return this.isDelegateEvent_(event) && event.indexOf(':', 9) !== -1 || (0, _dom.supportsEvent)(this.originEmitter_, event);
				}
				
				/**
				 * Checks if the given event should be proxied.
				 * @param {string} event
				 * @return {boolean}
				 * @protected
				 * @override
				 */
				
			}, {
				key: 'shouldProxyEvent_',
				value: function shouldProxyEvent_(event) {
					return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'shouldProxyEvent_', this).call(this, event) && this.isSupportedDomEvent_(event);
				}
			}]);
			
			return DomEventEmitterProxy;
		}(_metalEvents.EventEmitterProxy);
		
		exports.default = DomEventEmitterProxy;
		
		/***/ }),
	/* 73 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(7);
		
		var _dom = __webpack_require__(4);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		/**
		 * Utility functions for running javascript code in the global scope.
		 */
		var globalEval = function () {
			function globalEval() {
				_classCallCheck(this, globalEval);
			}
			
			_createClass(globalEval, null, [{
				key: 'run',
				
				/**
				 * Evaluates the given string in the global scope.
				 * @param {string} text
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 * @return {Element} script
				 */
				value: function run(text, opt_appendFn) {
					var script = document.createElement('script');
					script.text = text;
					if (opt_appendFn) {
						opt_appendFn(script);
					} else {
						document.head.appendChild(script);
					}
					(0, _dom.exitDocument)(script);
					return script;
				}
				
				/**
				 * Evaluates the given javascript file in the global scope.
				 * @param {string} src The file's path.
				 * @param {function()=} opt_callback Optional function to be called
				 *   when the script has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 * @return {Element} script
				 */
				
			}, {
				key: 'runFile',
				value: function runFile(src, opt_callback, opt_appendFn) {
					var script = document.createElement('script');
					script.src = src;
					
					var callback = function callback() {
						(0, _dom.exitDocument)(script);
						opt_callback && opt_callback();
					};
					(0, _dom.once)(script, 'load', callback);
					(0, _dom.once)(script, 'error', callback);
					
					if (opt_appendFn) {
						opt_appendFn(script);
					} else {
						document.head.appendChild(script);
					}
					
					return script;
				}
				
				/**
				 * Evaluates the code referenced by the given script element.
				 * @param {!Element} script
				 * @param {function()=} opt_callback Optional function to be called
				 *   when the script has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 * @return {Element} script
				 */
				
			}, {
				key: 'runScript',
				value: function runScript(script, opt_callback, opt_appendFn) {
					var callback = function callback() {
						opt_callback && opt_callback();
					};
					if (script.type && script.type !== 'text/javascript') {
						_metal.async.nextTick(callback);
						return;
					}
					(0, _dom.exitDocument)(script);
					if (script.src) {
						return globalEval.runFile(script.src, opt_callback, opt_appendFn);
					} else {
						_metal.async.nextTick(callback);
						return globalEval.run(script.text, opt_appendFn);
					}
				}
				
				/**
				 * Evaluates any script tags present in the given element.
				 * @param {!Element} element
				 * @param {function()=} opt_callback Optional function to be called
				 *   when the script has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 */
				
			}, {
				key: 'runScriptsInElement',
				value: function runScriptsInElement(element, opt_callback, opt_appendFn) {
					var scripts = element.querySelectorAll('script');
					if (scripts.length) {
						globalEval.runScriptsInOrder(scripts, 0, opt_callback, opt_appendFn);
					} else if (opt_callback) {
						_metal.async.nextTick(opt_callback);
					}
				}
				
				/**
				 * Runs the given scripts elements in the order that they appear.
				 * @param {!NodeList} scripts
				 * @param {number} index
				 * @param {function()=} opt_callback Optional function to be called
				 *   when the script has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 */
				
			}, {
				key: 'runScriptsInOrder',
				value: function runScriptsInOrder(scripts, index, opt_callback, opt_appendFn) {
					globalEval.runScript(scripts.item(index), function () {
						if (index < scripts.length - 1) {
							globalEval.runScriptsInOrder(scripts, index + 1, opt_callback, opt_appendFn);
						} else if (opt_callback) {
							_metal.async.nextTick(opt_callback);
						}
					}, opt_appendFn);
				}
			}]);
			
			return globalEval;
		}();
		
		exports.default = globalEval;
		
		/***/ }),
	/* 74 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(7);
		
		var _dom = __webpack_require__(4);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		/**
		 * Utility functions for running styles.
		 */
		var globalEvalStyles = function () {
			function globalEvalStyles() {
				_classCallCheck(this, globalEvalStyles);
			}
			
			_createClass(globalEvalStyles, null, [{
				key: 'run',
				
				/**
				 * Evaluates the given style.
				 * @param {string} text
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 * @return {Element} style
				 */
				value: function run(text, opt_appendFn) {
					var style = document.createElement('style');
					style.innerHTML = text;
					if (opt_appendFn) {
						opt_appendFn(style);
					} else {
						document.head.appendChild(style);
					}
					return style;
				}
				
				/**
				 * Evaluates the given style file.
				 * @param {string} href The file's path.
				 * @param {function()=} opt_callback Optional function to be called
				 *   when the styles has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 * @return {Element} style
				 */
				
			}, {
				key: 'runFile',
				value: function runFile(href, opt_callback, opt_appendFn) {
					var link = document.createElement('link');
					link.rel = 'stylesheet';
					link.href = href;
					globalEvalStyles.runStyle(link, opt_callback, opt_appendFn);
					return link;
				}
				
				/**
				 * Evaluates the code referenced by the given style/link element.
				 * @param {!Element} style
				 * @param {function()=} opt_callback Optional function to be called
				 *   when the script has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 *  @return {Element} style
				 */
				
			}, {
				key: 'runStyle',
				value: function runStyle(style, opt_callback, opt_appendFn) {
					var callback = function callback() {
						opt_callback && opt_callback();
					};
					if (style.rel && style.rel !== 'stylesheet') {
						_metal.async.nextTick(callback);
						return;
					}
					
					if (style.tagName === 'STYLE') {
						_metal.async.nextTick(callback);
					} else {
						(0, _dom.once)(style, 'load', callback);
						(0, _dom.once)(style, 'error', callback);
					}
					
					if (opt_appendFn) {
						opt_appendFn(style);
					} else {
						document.head.appendChild(style);
					}
					
					return style;
				}
				
				/**
				 * Evaluates any style present in the given element.
				 * @param {!Element} element
				 * @param {function()=} opt_callback Optional function to be called when the
				 *   style has been run.
				 * @param {function()=} opt_appendFn Optional function to append the node
				 *   into document.
				 */
				
			}, {
				key: 'runStylesInElement',
				value: function runStylesInElement(element, opt_callback, opt_appendFn) {
					var styles = element.querySelectorAll('style,link');
					if (styles.length === 0 && opt_callback) {
						_metal.async.nextTick(opt_callback);
						return;
					}
					
					var loadCount = 0;
					var callback = function callback() {
						if (opt_callback && ++loadCount === styles.length) {
							_metal.async.nextTick(opt_callback);
						}
					};
					for (var i = 0; i < styles.length; i++) {
						globalEvalStyles.runStyle(styles[i], callback, opt_appendFn);
					}
				}
			}]);
			
			return globalEvalStyles;
		}();
		
		exports.default = globalEvalStyles;
		
		/***/ }),
	/* 75 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		var _dom = __webpack_require__(4);
		
		var _features = __webpack_require__(23);
		
		var _features2 = _interopRequireDefault(_features);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		var mouseEventMap = {
			mouseenter: 'mouseover',
			mouseleave: 'mouseout',
			pointerenter: 'pointerover',
			pointerleave: 'pointerout'
		};
		Object.keys(mouseEventMap).forEach(function (eventName) {
			(0, _dom.registerCustomEvent)(eventName, {
				delegate: true,
				handler: function handler(callback, event) {
					var related = event.relatedTarget;
					var target = event.delegateTarget;
					if (!related || related !== target && !(0, _dom.contains)(target, related)) {
						event.customType = eventName;
						return callback(event);
					}
				},
				originalEvent: mouseEventMap[eventName]
			});
		});
		
		var animationEventMap = {
			animation: 'animationend',
			transition: 'transitionend'
		};
		Object.keys(animationEventMap).forEach(function (eventType) {
			var eventName = animationEventMap[eventType];
			(0, _dom.registerCustomEvent)(eventName, {
				event: true,
				delegate: true,
				handler: function handler(callback, event) {
					event.customType = eventName;
					return callback(event);
				},
				originalEvent: _features2.default.checkAnimationEventName()[eventType]
			});
		});
		
		/***/ }),
	/* 76 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(process) {
			
			/**
			 * A collection of core utility functions.
			 * @const
			 */
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			exports.abstractMethod = abstractMethod;
			exports.disableCompatibilityMode = disableCompatibilityMode;
			exports.enableCompatibilityMode = enableCompatibilityMode;
			exports.getCompatibilityModeData = getCompatibilityModeData;
			exports.getFunctionName = getFunctionName;
			exports.getStaticProperty = getStaticProperty;
			exports.getUid = getUid;
			exports.identityFunction = identityFunction;
			exports.isBoolean = isBoolean;
			exports.isDef = isDef;
			exports.isDefAndNotNull = isDefAndNotNull;
			exports.isDocument = isDocument;
			exports.isDocumentFragment = isDocumentFragment;
			exports.isElement = isElement;
			exports.isFunction = isFunction;
			exports.isNull = isNull;
			exports.isNumber = isNumber;
			exports.isWindow = isWindow;
			exports.isObject = isObject;
			exports.isPromise = isPromise;
			exports.isString = isString;
			exports.isServerSide = isServerSide;
			exports.nullFunction = nullFunction;
			var compatibilityModeData_ = void 0;
			
			/**
			 * Counter for unique id.
			 * @type {Number}
			 * @private
			 */
			var uniqueIdCounter_ = 1;
			
			/**
			 * Unique id property prefix.
			 * @type {String}
			 * @protected
			 */
			var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}
			
			/**
			 * Disables Metal.js's compatibility mode.
			 */
			function disableCompatibilityMode() {
				compatibilityModeData_ = undefined;
			}
			
			/**
			 * Enables Metal.js's compatibility mode with the following features from rc
			 * and 1.x versions:
			 *     - Using "key" to reference component instances. In the current version
			 *       this should be done via "ref" instead. This allows old code still
			 *       using "key" to keep working like before. NOTE: this may cause
			 *       problems, since "key" is meant to be used differently. Only use this
			 *       if it's not possible to upgrade the code to use "ref" instead.
			 * @param {Object=} opt_data Optional object with data to specify more
			 *     details, such as:
			 *         - renderers {Array} the template renderers that should be in
			 *           compatibility mode, either their constructors or strings
			 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
			 *           that extend from IncrementalDomRenderer.
			 * @type {Object}
			 */
			function enableCompatibilityMode() {
				var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				
				compatibilityModeData_ = opt_data;
			}
			
			/**
			 * Returns the data used for compatibility mode, or nothing if it hasn't been
			 * enabled.
			 * @return {Object}
			 */
			function getCompatibilityModeData() {
				// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
				if (compatibilityModeData_ === undefined) {
					if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
						enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
					}
				}
				return compatibilityModeData_;
			}
			
			/**
			 * Returns the first argument if it's truthy, or the second otherwise.
			 * @param {*} a
			 * @param {*} b
			 * @return {*}
			 * @protected
			 */
			function getFirstTruthy_(a, b) {
				return a || b;
			}
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}
			
			/**
			 * Gets the value of a static property in the given class. The value will be
			 * inherited from ancestors as expected, unless a custom merge function is given,
			 * which can change how the super classes' value for that property will be merged
			 * together.
			 * The final merged value will be stored in another property, so that it won't
			 * be recalculated even if this function is called multiple times.
			 * @param {!function()} ctor Class constructor.
			 * @param {string} propertyName Property name to be merged.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
			 *     value of the property so far and the next value to be merged to it.
			 *     Should return these two merged together. If not passed the final property
			 *     will be the first truthy value among ancestors.
			 */
			function getStaticProperty(ctor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (!ctor.hasOwnProperty(mergedName)) {
					var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
					if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
						var mergeFn = opt_mergeFn || getFirstTruthy_;
						merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
					}
					ctor[mergedName] = merged;
				}
				return ctor[mergedName];
			}
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
				}
				return uniqueIdCounter_++;
			}
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			function isBoolean(val) {
				return typeof val === 'boolean';
			}
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			function isDef(val) {
				return val !== undefined;
			}
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDefAndNotNull(val) {
				return isDef(val) && !isNull(val);
			}
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			}
			
			/**
			 * Returns true if value is a document-fragment.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocumentFragment(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
			}
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			}
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			function isFunction(val) {
				return typeof val === 'function';
			}
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isNull(val) {
				return val === null;
			}
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			function isNumber(val) {
				return typeof val === 'number';
			}
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isWindow(val) {
				return val !== null && val === val.window;
			}
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			}
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}
			
			/**
			 * Sets to true if running inside Node.js environment with extra check for
			 * `process.browser` to skip Karma runner environment. Karma environment has
			 * `process` defined even though it runs on the browser.
			 * @return {boolean}
			 */
			function isServerSide() {
				return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
			}
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			function nullFunction() {}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))
		
		/***/ }),
	/* 77 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _core = __webpack_require__(27);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			_createClass(array, null, [{
				key: 'equal',
				
				/**
				 * Checks if the given arrays have the same content.
				 * @param {!Array<*>} arr1
				 * @param {!Array<*>} arr2
				 * @return {boolean}
				 */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}
				
				/**
				 * Returns the first value in the given array that isn't undefined.
				 * @param {!Array} arr
				 * @return {*}
				 */
				
			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}
				
				/**
				 * Transforms the input nested array to become flat.
				 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
				 * @param {Array.<*>} opt_output Optional output array.
				 * @return {Array.<*>} Flat array.
				 */
				
			}, {
				key: 'flatten',
				value: function flatten(arr, opt_output) {
					var output = opt_output || [];
					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}
				
				/**
				 * Removes the first occurrence of a particular value from an array.
				 * @param {Array.<T>} arr Array from which to remove value.
				 * @param {T} obj Object to remove.
				 * @return {boolean} True if an element was removed.
				 * @template T
				 */
				
			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}
				
				/**
				 * Removes from an array the element at index i
				 * @param {Array} arr Array or array like object from which to remove value.
				 * @param {number} i The index to remove.
				 * @return {boolean} True if an element was removed.
				 */
				
			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}
				
				/**
				 * Slices the given array, just like Array.prototype.slice, but this
				 * is faster and working on all array-like objects (like arguments).
				 * @param {!Object} arr Array-like object to slice.
				 * @param {number} start The index that should start the slice.
				 * @param {number=} opt_end The index where the slice should end, not
				 *   included in the final array. If not given, all elements after the
				 *   start index will be included.
				 * @return {!Array}
				 */
				
			}, {
				key: 'slice',
				value: function slice(arr, start, opt_end) {
					var sliced = [];
					var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 78 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel = void 0;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 79 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}
				
				/**
				 * Subclasses should override this method to implement any specific
				 * disposing logic (like clearing references and calling `dispose` on other
				 * disposables).
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}
				
				/**
				 * Checks if this instance has already been disposed.
				 * @return {boolean}
				 */
				
			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 80 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			_createClass(object, null, [{
				key: 'mixin',
				
				/**
				 * Copies all the members of a source object to a target object.
				 * @param {Object} target Target object.
				 * @param {...Object} var_args The objects from which values will be copied.
				 * @return {Object} Returns the target object reference.
				 */
				value: function mixin(target) {
					var key = void 0,
						source = void 0;
					for (var i = 1; i < arguments.length; i++) {
						source = arguments[i];
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}
				
				/**
				 * Returns an object based on its fully qualified external name.
				 * @param {string} name The fully qualified name.
				 * @param {object=} opt_obj The object within which to look; default is
				 *     <code>window</code>.
				 * @return {?} The value (object or primitive) or, if not found, undefined.
				 */
				
			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name, opt_obj) {
					var scope = opt_obj || window;
					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}
				
				/**
				 * Returns a new object with the same keys as the given one, but with
				 * their values set to the return values of the specified function.
				 * @param {!Object} obj
				 * @param {!function(string, *)} fn
				 * @return {!Object}
				 */
				
			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}
				
				/**
				 * Checks if the two given objects are equal. This is done via a shallow
				 * check, including only the keys directly contained by the 2 objects.
				 * @return {boolean}
				 */
				
			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}
					
					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}
					
					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 81 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',
				
				/**
				 * Compares the given strings without taking the case into account.
				 * @param {string|number} str1
				 * @param {string|number} str2
				 * @return {number} Either -1, 0 or 1, according to if the first string is
				 *     "smaller", equal or "bigger" than the second given string.
				 */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();
					
					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}
				
				/**
				 * Removes the breaking spaces from the left and right of the string and
				 * collapses the sequences of breaking spaces in the middle into single spaces.
				 * The original and the result strings render the same way in HTML.
				 * @param {string} str A string in which to collapse spaces.
				 * @return {string} Copy of the string with normalized breaking spaces.
				 */
				
			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}
				
				/**
				 * Escapes characters in the string that are not safe to use in a RegExp.
				 * @param {*} str The string to escape. If not a string, it will be casted
				 *     to one.
				 * @return {string} A RegExp safe, escaped copy of {@code s}.
				 */
				
			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
				}
				
				/**
				 * Returns a string with at least 64-bits of randomness.
				 * @return {string} A random string, e.g. sn1s7vb4gcic.
				 */
				
			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}
				
				/**
				 * Calculates the hashcode for a string. The hashcode value is computed by
				 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
				 * property of using 31 prime is that the multiplication can be replaced by
				 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
				 * Modern VMs do this sort of optimization automatically.
				 * @param {String} val Target string.
				 * @return {Number} Returns the string hashcode.
				 */
				
			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}
				
				/**
				 * Replaces interval into the string with specified value, e.g.
				 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
				 * @param {string} str The input string.
				 * @param {Number} start Start interval position to be replaced.
				 * @param {Number} end End interval position to be replaced.
				 * @param {string} value The value that replaces the specified interval.
				 * @return {string}
				 */
				
			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 82 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _metal = __webpack_require__(14);
		
		var _validators = __webpack_require__(26);
		
		var _validators2 = _interopRequireDefault(_validators);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		/**
		 * Sugar api that can be used as an alternative for manually building `State`
		 * configuration in the expected format. For example, instead of having
		 * something like this:
		 *
		 * ```js
		 * MyClass.STATE = {
 *   foo: {
 *     required: true,
 *     validator: validators.number,
 *     value: 13
 *   }
 * };
		 * ```
		 *
		 * You could instead do:
		 *
		 * ```js
		 * MyClass.STATE = {
 *   foo: Config.required().number().value(13)
 * };
		 * ```
		 */
		var Config = {
			/**
			 * An object that contains a validator function.
			 * @typedef {!Object} ConfigWithValidator
			 */
			
			/**
			 * Function that creates `State` object with an `any` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			any: setPrimitiveValidators('any'),
			
			/**
			 * Function that creates `State` object with an `array` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			array: setPrimitiveValidators('array'),
			
			/**
			 * Function that creates `State` object with an `arrayOf` validator.
			 * @param {ConfigWithValidator} stateConfig `State` configuration object
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			arrayOf: setNestedValidators('arrayOf'),
			
			/**
			 * Function that creates `State` object with a `bool` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			bool: setPrimitiveValidators('bool'),
			
			/**
			 * Function that creates `State` object with a `func` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			func: setPrimitiveValidators('func'),
			
			/**
			 * Function that creates `State` object with an `instanceOf` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			instanceOf: setExplicitValueValidators('instanceOf'),
			
			/**
			 * Function that creates `State` object with a `number` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			number: setPrimitiveValidators('number'),
			
			/**
			 * Function that creates `State` object with an `object` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			object: setPrimitiveValidators('object'),
			
			/**
			 * Function that creates `State` object with an `objectOf` validator.
			 * @param {ConfigWithValidator} stateConfig `State` configuration object
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			objectOf: setNestedValidators('objectOf'),
			
			/**
			 * Function that creates `State` object with an `oneOf` validator.
			 * @param {!Array} values `State` configuration object
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			oneOf: setExplicitValueValidators('oneOf'),
			
			/**
			 * Creates `State` configuration object with an `oneOfType` validator.
			 * @param {ConfigWithValidator[]} validatorArray Array of `State` configuration objects.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			oneOfType: function oneOfType(validatorArray) {
				validatorArray = validatorArray.map(function (configObj) {
					return configObj.config.validator;
				});
				
				return this.validator(_validators2.default.oneOfType(validatorArray));
			},
			
			
			/**
			 * Creates `State` configuration object with a `shapeOf` validator.
			 * @param {!Object.<string, ConfigWithValidator>} shapeObj Values being `State` configuration objects.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			shapeOf: function shapeOf(shapeObj) {
				shapeObj = destructShapeOfConfigs(shapeObj);
				
				return this.validator(_validators2.default.shapeOf(shapeObj));
			},
			
			
			/**
			 * Function that creates `State` object with an `string` validator.
			 * @return {ConfigWithValidator} `State` configuration object.
			 */
			string: setPrimitiveValidators('string'),
			
			/**
			 * Adds the `internal` flag to the `State` configuration.
			 * @param {boolean} required Flag to set "internal" to. True by default.
			 * @return {!Object} `State` configuration object.
			 */
			internal: function internal() {
				var _internal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
				
				return mergeConfig(this, {
					internal: _internal
				});
			},
			
			
			/**
			 * Adds the `required` flag to the `State` configuration.
			 * @param {boolean} required Flag to set "required" to. True by default.
			 * @return {!Object} `State` configuration object.
			 */
			required: function required() {
				var _required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
				
				return mergeConfig(this, {
					required: _required
				});
			},
			
			
			/**
			 * Adds a setter to the `State` configuration.
			 * @param {!function()} setter
			 * @return {!Object} `State` configuration object.
			 */
			setter: function setter(_setter) {
				return mergeConfig(this, {
					setter: _setter
				});
			},
			
			
			/**
			 * Adds a validator to the `State` configuration.
			 * @param {!function()} validator
			 * @return {!Object} `State` configuration object.
			 */
			validator: function validator(_validator) {
				return mergeConfig(this, {
					validator: _validator
				});
			},
			
			
			/**
			 * Adds a default value to the `State` configuration.
			 * @param {*} value
			 * @return {!Object} `State` configuration object.
			 */
			value: function value(_value) {
				return mergeConfig(this, {
					value: _value
				});
			},
			
			
			/**
			 * Adds a valueFn that will return a default value for the `State` configuration.
			 * @param {!function()} valueFn
			 * @return {!Object} `State` configuration object.
			 */
			valueFn: function valueFn(_valueFn) {
				return mergeConfig(this, {
					valueFn: _valueFn
				});
			}
		};
		
		/**
		 * Recursively sets validators for shapeOf.
		 * @param {!Object} shape The shape of specific types.
		 * @return {!Object} Shape object with validators as values.
		 */
		function destructShapeOfConfigs(shape) {
			var keys = Object.keys(shape);
			
			var retShape = {};
			
			keys.forEach(function (key) {
				var value = shape[key];
				
				retShape[key] = value.config && value.config.validator ? value.config.validator : destructShapeOfConfigs(value);
			});
			
			return retShape;
		}
		
		/**
		 * Merges the given config object into the one that has been built so far.
		 * @param {!Object} context The object calling this function.
		 * @param {!Object} config The object to merge to the built config.
		 * @return {!Object} The final object containing the built config.
		 */
		function mergeConfig(context, config) {
			var obj = context;
			if (obj === Config) {
				obj = Object.create(Config);
				obj.config = {};
			}
			_metal.object.mixin(obj.config, config);
			return obj;
		}
		
		/**
		 * Calls validators with provided argument.
		 * @param {string} name The name of the validator.
		 * @param {!function()}
		 */
		function setExplicitValueValidators(name) {
			return function (arg) {
				return this.validator(_validators2.default[name](arg));
			};
		}
		
		/**
		 * Calls validators with a single nested config.
		 * @param {string} name The name of the validator.
		 * @return {!function()}
		 */
		function setNestedValidators(name) {
			return function (arg) {
				return this.validator(_validators2.default[name](arg.config.validator));
			};
		}
		
		/**
		 * Adds primitive type validators to the config object.
		 * @param {string} name The name of the validator.
		 * @return {!function()}
		 */
		function setPrimitiveValidators(name) {
			return function () {
				return this.validator(_validators2.default[name]);
			};
		}
		
		exports.default = Config;
		
		/***/ }),
	/* 83 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
		
		var _metal = __webpack_require__(14);
		
		var _metalEvents = __webpack_require__(8);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
		
		function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
		
		/**
		 * State adds support for having object properties that can be watched for
		 * changes, as well as configured with validators, setters and other options.
		 * See the `configState` method for a complete list of available configuration
		 * options for each state key.
		 * @extends {EventEmitter}
		 */
		var State = function (_EventEmitter) {
			_inherits(State, _EventEmitter);
			
			/**
			 * Constructor function for `State`.
			 * @param {Object=} opt_config Optional config object with initial values to
			 *     set state properties to.
			 * @param {Object=} opt_obj Optional object that should hold the state
			 *     properties. If none is given, they will be added directly to `this`
			 *     instead.
			 * @param {Object=} opt_context Optional context to call functions (like
			 *     validators and setters) on. Defaults to `this`.
			 */
			function State(opt_config, opt_obj, opt_context) {
				_classCallCheck(this, State);
				
				/**
				 * Context to call functions (like validators and setters) on.
				 * @type {!Object}
				 * @protected
				 */
				var _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));
				
				_this.context_ = opt_context || _this;
				
				/**
				 * Map of keys that can not be used as state keys.
				 * @type {Object<string, boolean>}
				 * @protected
				 */
				_this.keysBlacklist_ = null;
				
				/**
				 * Object that should hold the state properties.
				 * @type {!Object}
				 * @protected
				 */
				_this.obj_ = opt_obj || _this;
				
				_this.eventData_ = null;
				
				/**
				 * Object with information about the batch event that is currently
				 * scheduled, or null if none is.
				 * @type {Object}
				 * @protected
				 */
				_this.scheduledBatchData_ = null;
				
				/**
				 * Object that contains information about all this instance's state keys.
				 * @type {!Object<string, !Object>}
				 * @protected
				 */
				_this.stateInfo_ = {};
				
				_this.stateConfigs_ = {};
				
				_this.initialValues_ = _metal.object.mixin({}, opt_config);
				
				_this.setShouldUseFacade(true);
				_this.configStateFromStaticHint_();
				
				Object.defineProperty(_this.obj_, State.STATE_REF_KEY, {
					configurable: true,
					enumerable: false,
					value: _this
				});
				return _this;
			}
			
			/**
			 * Logs an error if the given property is required but wasn't given.
			 * @param {string} name
			 * @protected
			 */
			
			
			_createClass(State, [{
				key: 'assertGivenIfRequired_',
				value: function assertGivenIfRequired_(name) {
					var config = this.stateConfigs_[name];
					if (config.required) {
						var info = this.getStateInfo(name);
						var value = info.state === State.KeyStates.INITIALIZED ? this.get(name) : this.initialValues_[name];
						if (!(0, _metal.isDefAndNotNull)(value)) {
							var errorMessage = 'The property called "' + name + '" is required but didn\'t receive a value.';
							if (this.shouldThrowValidationError()) {
								throw new Error(errorMessage);
							} else {
								console.error(errorMessage);
							}
						}
					}
				}
				
				/**
				 * Logs an error if the `validatorReturn` is instance of `Error`.
				 * @param {*} validatorReturn
				 * @protected
				 */
				
			}, {
				key: 'assertValidatorReturnInstanceOfError_',
				value: function assertValidatorReturnInstanceOfError_(validatorReturn) {
					if (validatorReturn instanceof Error) {
						if (this.shouldThrowValidationError()) {
							throw validatorReturn;
						} else {
							console.error('Warning: ' + validatorReturn);
						}
					}
				}
				
				/**
				 * Checks that the given name is a valid state key name. If it's not, an error
				 * will be thrown.
				 * @param {string} name The name to be validated.
				 * @throws {Error}
				 * @protected
				 */
				
			}, {
				key: 'assertValidStateKeyName_',
				value: function assertValidStateKeyName_(name) {
					if (this.keysBlacklist_ && this.keysBlacklist_[name]) {
						throw new Error('It\'s not allowed to create a state key with the name "' + name + '".');
					}
				}
				
				/**
				 * Builds the property definition object for the specified state key.
				 * @param {string} name The name of the key.
				 * @return {!Object}
				 * @protected
				 */
				
			}, {
				key: 'buildKeyPropertyDef_',
				value: function buildKeyPropertyDef_(name) {
					return {
						configurable: true,
						enumerable: true,
						get: function get() {
							return this[State.STATE_REF_KEY].getStateKeyValue_(name);
						},
						set: function set(val) {
							this[State.STATE_REF_KEY].setStateKeyValue_(name, val);
						}
					};
				}
				
				/**
				 * Calls the requested function, running the appropriate code for when it's
				 * passed as an actual function object or just the function's name.
				 * @param {!Function|string} fn Function, or name of the function to run.
				 * @param {!Array} An optional array of parameters to be passed to the
				 *   function that will be called.
				 * @return {*} The return value of the called function.
				 * @protected
				 */
				
			}, {
				key: 'callFunction_',
				value: function callFunction_(fn, args) {
					if ((0, _metal.isString)(fn)) {
						return this.context_[fn].apply(this.context_, args);
					} else if ((0, _metal.isFunction)(fn)) {
						return fn.apply(this.context_, args);
					}
				}
				
				/**
				 * Calls the state key's setter, if there is one.
				 * @param {string} name The name of the key.
				 * @param {*} value The value to be set.
				 * @param {*} currentValue The current value.
				 * @return {*} The final value to be set.
				 * @protected
				 */
				
			}, {
				key: 'callSetter_',
				value: function callSetter_(name, value, currentValue) {
					var config = this.stateConfigs_[name];
					if (config.setter) {
						value = this.callFunction_(config.setter, [value, currentValue]);
					}
					return value;
				}
				
				/**
				 * Calls the state key's validator, if there is one. Emits console
				 * warning if validator returns a string.
				 * @param {string} name The name of the key.
				 * @param {*} value The value to be validated.
				 * @return {boolean} Flag indicating if value is valid or not.
				 * @protected
				 */
				
			}, {
				key: 'callValidator_',
				value: function callValidator_(name, value) {
					var config = this.stateConfigs_[name];
					if (config.validator) {
						var validatorReturn = this.callFunction_(config.validator, [value, name, this.context_]);
						this.assertValidatorReturnInstanceOfError_(validatorReturn);
						return validatorReturn;
					}
					return true;
				}
				
				/**
				 * Checks if the it's allowed to write on the requested state key.
				 * @param {string} name The name of the key.
				 * @return {boolean}
				 */
				
			}, {
				key: 'canSetState',
				value: function canSetState(name) {
					var info = this.getStateInfo(name);
					return !this.stateConfigs_[name].writeOnce || !info.written;
				}
				
				/**
				 * Adds the given key(s) to the state, together with its(their) configs.
				 * Config objects support the given settings:
				 *     required - When set to `true`, causes errors to be printed (via
				 *     `console.error`) if no value is given for the property.
				 *
				 *     setter - Function for normalizing state key values. It receives the new
				 *     value that was set, and returns the value that should be stored.
				 *
				 *     validator - Function that validates state key values. When it returns
				 *     false, the new value is ignored. When it returns an instance of Error,
				 *     it will emit the error to the console.
				 *
				 *     value - The default value for the state key. Note that setting this to
				 *     an object will cause all class instances to use the same reference to
				 *     the object. To have each instance use a different reference for objects,
				 *     use the `valueFn` option instead.
				 *
				 *     valueFn - A function that returns the default value for a state key.
				 *
				 *     writeOnce - Ignores writes to the state key after it's been first
				 *     written to. That is, allows writes only when setting the value for the
				 *     first time.
				 * @param {!Object.<string, !Object>|string} configs An object that maps
				 *     configuration options for keys to be added to the state.
				 * @param {boolean|Object|*=} opt_context The context where the added state
				 *     keys will be defined (defaults to `this`), or false if they shouldn't
				 *     be defined at all.
				 */
				
			}, {
				key: 'configState',
				value: function configState(configs, opt_context) {
					var names = Object.keys(configs);
					if (names.length === 0) {
						return;
					}
					
					if (opt_context !== false) {
						var props = {};
						for (var i = 0; i < names.length; i++) {
							var name = names[i];
							this.assertValidStateKeyName_(name);
							props[name] = this.buildKeyPropertyDef_(name);
						}
						Object.defineProperties(opt_context || this.obj_, props);
					}
					
					this.stateConfigs_ = configs;
					for (var _i = 0; _i < names.length; _i++) {
						var _name = names[_i];
						configs[_name] = configs[_name].config ? configs[_name].config : configs[_name];
						this.assertGivenIfRequired_(names[_i]);
						this.validateInitialValue_(names[_i]);
					}
				}
				
				/**
				 * Adds state keys from super classes static hint `MyClass.STATE = {};`.
				 * @param {Object.<string, !Object>=} opt_config An object that maps all the
				 *     configurations for state keys.
				 * @protected
				 */
				
			}, {
				key: 'configStateFromStaticHint_',
				value: function configStateFromStaticHint_() {
					var ctor = this.constructor;
					if (ctor !== State) {
						var defineContext = void 0;
						if (this.obj_ === this) {
							defineContext = ctor.hasConfiguredState_ ? false : ctor.prototype;
							ctor.hasConfiguredState_ = true;
						}
						this.configState(State.getStateStatic(ctor), defineContext);
					}
				}
				
				/**
				 * @inheritDoc
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {
					_get(State.prototype.__proto__ || Object.getPrototypeOf(State.prototype), 'disposeInternal', this).call(this);
					this.initialValues_ = null;
					this.stateInfo_ = null;
					this.stateConfigs_ = null;
					this.scheduledBatchData_ = null;
				}
				
				/**
				 * Emits the state change batch event.
				 * @protected
				 */
				
			}, {
				key: 'emitBatchEvent_',
				value: function emitBatchEvent_() {
					if (!this.isDisposed()) {
						var data = this.scheduledBatchData_;
						this.scheduledBatchData_ = null;
						this.context_.emit('stateChanged', data);
					}
				}
				
				/**
				 * Returns the value of the requested state key.
				 * Note: this can and should be accomplished by accessing the value as a
				 * regular property. This should only be used in cases where a function is
				 * actually needed.
				 * @param {string} name
				 * @return {*}
				 */
				
			}, {
				key: 'get',
				value: function get(name) {
					return this.obj_[name];
				}
				
				/**
				 * Returns an object that maps state keys to their values.
				 * @param {Array<string>=} opt_names A list of names of the keys that should
				 *   be returned. If none is given, the whole state will be returned.
				 * @return {Object.<string, *>}
				 */
				
			}, {
				key: 'getState',
				value: function getState(opt_names) {
					var state = {};
					var names = opt_names || this.getStateKeys();
					
					for (var i = 0; i < names.length; i++) {
						state[names[i]] = this.get(names[i]);
					}
					
					return state;
				}
				
				/**
				 * Gets information about the specified state property.
				 * @param {string} name
				 * @return {!Object}
				 */
				
			}, {
				key: 'getStateInfo',
				value: function getStateInfo(name) {
					if (!this.stateInfo_[name]) {
						this.stateInfo_[name] = {};
					}
					return this.stateInfo_[name];
				}
				
				/**
				 * Gets the config object for the requested state key.
				 * @param {string} name The key's name.
				 * @return {Object}
				 * @protected
				 */
				
			}, {
				key: 'getStateKeyConfig',
				value: function getStateKeyConfig(name) {
					return this.stateConfigs_ ? this.stateConfigs_[name] : null;
				}
				
				/**
				 * Returns an array with all state keys.
				 * @return {!Array.<string>}
				 */
				
			}, {
				key: 'getStateKeys',
				value: function getStateKeys() {
					return this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];
				}
				
				/**
				 * Gets the value of the specified state key. This is passed as that key's
				 * getter to the `Object.defineProperty` call inside the `addKeyToState` method.
				 * @param {string} name The name of the key.
				 * @return {*}
				 * @protected
				 */
				
			}, {
				key: 'getStateKeyValue_',
				value: function getStateKeyValue_(name) {
					if (!this.warnIfDisposed_(name)) {
						this.initStateKey_(name);
						return this.getStateInfo(name).value;
					}
				}
				
				/**
				 * Merges the STATE static variable for the given constructor function.
				 * @param  {!Function} ctor Constructor function.
				 * @return {boolean} Returns true if merge happens, false otherwise.
				 * @static
				 */
				
			}, {
				key: 'hasBeenSet',
				
				
				/**
				 * Checks if the value of the state key with the given name has already been
				 * set. Note that this doesn't run the key's getter.
				 * @param {string} name The name of the key.
				 * @return {boolean}
				 */
				value: function hasBeenSet(name) {
					var info = this.getStateInfo(name);
					return info.state === State.KeyStates.INITIALIZED || this.hasInitialValue_(name);
				}
				
				/**
				 * Checks if an initial value was given to the specified state property.
				 * @param {string} name The name of the key.
				 * @return {boolean}
				 * @protected
				 */
				
			}, {
				key: 'hasInitialValue_',
				value: function hasInitialValue_(name) {
					return this.initialValues_.hasOwnProperty(name);
				}
				
				/**
				 * Checks if the given key is present in this instance's state.
				 * @param {string} key
				 * @return {boolean}
				 */
				
			}, {
				key: 'hasStateKey',
				value: function hasStateKey(key) {
					if (!this.warnIfDisposed_(key)) {
						return !!this.stateConfigs_[key];
					}
				}
				
				/**
				 * Informs of changes to a state key's value through an event. Won't trigger
				 * the event if the value hasn't changed or if it's being initialized.
				 * @param {string} name The name of the key.
				 * @param {*} prevVal The previous value of the key.
				 * @protected
				 */
				
			}, {
				key: 'informChange_',
				value: function informChange_(name, prevVal) {
					if (this.shouldInformChange_(name, prevVal)) {
						var data = _metal.object.mixin({
							key: name,
							newVal: this.get(name),
							prevVal: prevVal
						}, this.eventData_);
						this.context_.emit(name + 'Changed', data);
						this.context_.emit('stateKeyChanged', data);
						this.scheduleBatchEvent_(data);
					}
				}
				
				/**
				 * Initializes the specified state key, giving it a first value.
				 * @param {string} name The name of the key.
				 * @protected
				 */
				
			}, {
				key: 'initStateKey_',
				value: function initStateKey_(name) {
					var info = this.getStateInfo(name);
					if (info.state !== State.KeyStates.UNINITIALIZED) {
						return;
					}
					
					info.state = State.KeyStates.INITIALIZING;
					this.setInitialValue_(name);
					if (!info.written) {
						this.setDefaultValue(name);
					}
					info.state = State.KeyStates.INITIALIZED;
				}
				
				/**
				 * Merges two values for the STATE property into a single object.
				 * @param {Object} mergedVal
				 * @param {Object} currVal
				 * @return {!Object} The merged value.
				 * @static
				 */
				
			}, {
				key: 'removeStateKey',
				
				
				/**
				 * Removes the requested state key.
				 * @param {string} name The name of the key.
				 */
				value: function removeStateKey(name) {
					this.stateInfo_[name] = null;
					this.stateConfigs_[name] = null;
					delete this.obj_[name];
				}
				
				/**
				 * Schedules a state change batch event to be emitted asynchronously.
				 * @param {!Object} changeData Information about a state key's update.
				 * @protected
				 */
				
			}, {
				key: 'scheduleBatchEvent_',
				value: function scheduleBatchEvent_(changeData) {
					if (!this.scheduledBatchData_) {
						_metal.async.nextTick(this.emitBatchEvent_, this);
						this.scheduledBatchData_ = _metal.object.mixin({
							changes: {}
						}, this.eventData_);
					}
					
					var name = changeData.key;
					var changes = this.scheduledBatchData_.changes;
					if (changes[name]) {
						changes[name].newVal = changeData.newVal;
					} else {
						changes[name] = changeData;
					}
				}
				
				/**
				 * Sets the value of the requested state key.
				 * Note: this can and should be accomplished by setting the state key as a
				 * regular property. This should only be used in cases where a function is
				 * actually needed.
				 * @param {string} name
				 * @param {*} value
				 * @return {*}
				 */
				
			}, {
				key: 'set',
				value: function set(name, value) {
					if (this.hasStateKey(name)) {
						this.obj_[name] = value;
					}
				}
				
				/**
				 * Sets the default value of the requested state key.
				 * @param {string} name The name of the key.
				 * @return {*}
				 */
				
			}, {
				key: 'setDefaultValue',
				value: function setDefaultValue(name) {
					var config = this.stateConfigs_[name];
					
					if (config.value !== undefined) {
						this.set(name, config.value);
					} else {
						this.set(name, this.callFunction_(config.valueFn));
					}
				}
				
				/**
				 * Sets data to be sent with all events emitted from this instance.
				 * @param {Object}
				 */
				
			}, {
				key: 'setEventData',
				value: function setEventData(data) {
					this.eventData_ = data;
				}
				
				/**
				 * Sets the initial value of the requested state key.
				 * @param {string} name The name of the key.
				 * @return {*}
				 * @protected
				 */
				
			}, {
				key: 'setInitialValue_',
				value: function setInitialValue_(name) {
					if (this.hasInitialValue_(name)) {
						this.set(name, this.initialValues_[name]);
						this.initialValues_[name] = undefined;
					}
				}
				
				/**
				 * Sets a map of keys that are not valid state keys.
				 * @param {!Object<string, boolean>}
				 */
				
			}, {
				key: 'setKeysBlacklist',
				value: function setKeysBlacklist(blacklist) {
					this.keysBlacklist_ = blacklist;
				}
				
				/**
				 * Sets the value of all the specified state keys.
				 * @param {!Object.<string,*>} values A map of state keys to the values they
				 *   should be set to.
				 * @param {function()=} opt_callback An optional function that will be run
				 *   after the next batched update is triggered.
				 */
				
			}, {
				key: 'setState',
				value: function setState(values, opt_callback) {
					var _this2 = this;
					
					Object.keys(values).forEach(function (name) {
						return _this2.set(name, values[name]);
					});
					if (opt_callback && this.scheduledBatchData_) {
						this.context_.once('stateChanged', opt_callback);
					}
				}
				
				/**
				 * Sets the value of the specified state key. This is passed as that key's
				 * setter to the `Object.defineProperty` call inside the `addKeyToState`
				 * method.
				 * @param {string} name The name of the key.
				 * @param {*} value The new value of the key.
				 * @protected
				 */
				
			}, {
				key: 'setStateKeyValue_',
				value: function setStateKeyValue_(name, value) {
					if (this.warnIfDisposed_(name) || !this.canSetState(name) || !this.validateKeyValue_(name, value)) {
						return;
					}
					
					var prevVal = this.get(name);
					var info = this.getStateInfo(name);
					info.value = this.callSetter_(name, value, prevVal);
					this.assertGivenIfRequired_(name);
					info.written = true;
					this.informChange_(name, prevVal);
				}
				
				/**
				 * Checks if we should inform about a state update. Updates are ignored during
				 * state initialization. Otherwise, updates to primitive values are only
				 * informed when the new value is different from the previous one. Updates to
				 * objects (which includes functions and arrays) are always informed outside
				 * initialization though, since we can't be sure if all of the internal data
				 * has stayed the same.
				 * @param {string} name The name of the key.
				 * @param {*} prevVal The previous value of the key.
				 * @return {boolean}
				 * @protected
				 */
				
			}, {
				key: 'shouldInformChange_',
				value: function shouldInformChange_(name, prevVal) {
					var info = this.getStateInfo(name);
					return info.state === State.KeyStates.INITIALIZED && ((0, _metal.isObject)(prevVal) || prevVal !== this.get(name));
				}
				
				/**
				 * Returns a boolean that determines whether or not should throw error when
				 * vaildator functions returns an `Error` instance.
				 * @return {boolean} By default returns false.
				 */
				
			}, {
				key: 'shouldThrowValidationError',
				value: function shouldThrowValidationError() {
					return false;
				}
				
				/**
				 * Validates the initial value for the state property with the given name.
				 * @param {string} name
				 * @protected
				 */
				
			}, {
				key: 'validateInitialValue_',
				value: function validateInitialValue_(name) {
					if (this.hasInitialValue_(name) && !this.callValidator_(name, this.initialValues_[name])) {
						delete this.initialValues_[name];
					}
				}
				
				/**
				 * Validates the state key's value, which includes calling the validator
				 * defined in the key's configuration object, if there is one.
				 * @param {string} name The name of the key.
				 * @param {*} value The value to be validated.
				 * @return {boolean} Flag indicating if value is valid or not.
				 * @protected
				 */
				
			}, {
				key: 'validateKeyValue_',
				value: function validateKeyValue_(name, value) {
					var info = this.getStateInfo(name);
					return info.state === State.KeyStates.INITIALIZING || this.callValidator_(name, value);
				}
				
				/**
				 * Warns if this instance has already been disposed.
				 * @param {string} name Name of the property to be accessed if not disposed.
				 * @return {boolean} True if disposed, or false otherwise.
				 * @protected
				 */
				
			}, {
				key: 'warnIfDisposed_',
				value: function warnIfDisposed_(name) {
					var disposed = this.isDisposed();
					if (disposed) {
						console.warn('Error. Trying to access property "' + name + '" on disposed instance');
					}
					return disposed;
				}
			}], [{
				key: 'getStateStatic',
				value: function getStateStatic(ctor) {
					return (0, _metal.getStaticProperty)(ctor, 'STATE', State.mergeState);
				}
			}, {
				key: 'mergeState',
				value: function mergeState(mergedVal, currVal) {
					return _metal.object.mixin({}, currVal, mergedVal);
				}
			}]);
			
			return State;
		}(_metalEvents.EventEmitter);
		
		State.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';
		
		/**
		 * Constants that represent the states that a state key can be in.
		 * @type {!Object}
		 */
		State.KeyStates = {
			UNINITIALIZED: undefined,
			INITIALIZING: 1,
			INITIALIZED: 2
		};
		
		exports.default = State;
		
		/***/ }),
	/* 84 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _metal = __webpack_require__(5);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		/**
		 * The component registry is used to register components, so they can
		 * be accessible by name.
		 * @type {Object}
		 */
		var ComponentRegistry = function () {
			function ComponentRegistry() {
				_classCallCheck(this, ComponentRegistry);
			}
			
			_createClass(ComponentRegistry, null, [{
				key: 'getConstructor',
				
				/**
				 * Gets the constructor function for the given component name, or
				 * undefined if it hasn't been registered yet.
				 * @param {string} name The component's name.
				 * @return {?function()}
				 * @static
				 */
				value: function getConstructor(name) {
					var constructorFn = ComponentRegistry.components_[name];
					if (!constructorFn) {
						console.error('There\'s no constructor registered for the component named ' + name + '.\n\t\t\t\tComponents need to be registered via ComponentRegistry.register.');
					}
					return constructorFn;
				}
				
				/**
				 * Registers a component, so it can be found by its name.
				 * @param {!Function} constructorFn The component's constructor function.
				 * @param {string=} opt_name Name of the registered component. If none is given
				 *   the name defined by the NAME static variable will be used instead. If that
				 *   isn't set as well, the name of the constructor function will be used.
				 * @static
				 */
				
			}, {
				key: 'register',
				value: function register(constructorFn, opt_name) {
					var name = opt_name;
					if (!name) {
						if (constructorFn.hasOwnProperty('NAME')) {
							name = constructorFn.NAME;
						} else {
							name = (0, _metal.getFunctionName)(constructorFn);
						}
					}
					constructorFn.NAME = name;
					ComponentRegistry.components_[name] = constructorFn;
				}
			}]);
			
			return ComponentRegistry;
		}();
		
		/**
		 * Holds all registered components, indexed by their names.
		 * @type {!Object<string, function()>}
		 * @protected
		 * @static
		 */
		
		
		ComponentRegistry.components_ = {};
		
		exports.default = ComponentRegistry;
		
		/***/ }),
	/* 85 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(global) {var require;
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			__webpack_require__(29);
			
			(function () {
				this.CLOSURE_NO_DEPS = true;
				this.goog = this.goog || {};
				
				// Copyright 2006 The Closure Library Authors. All Rights Reserved.
				//
				// Licensed under the Apache License, Version 2.0 (the "License");
				// you may not use this file except in compliance with the License.
				// You may obtain a copy of the License at
				//
				//      http://www.apache.org/licenses/LICENSE-2.0
				//
				// Unless required by applicable law or agreed to in writing, software
				// distributed under the License is distributed on an "AS-IS" BASIS,
				// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
				// See the License for the specific language governing permissions and
				// limitations under the License.
				
				/**
				 * @fileoverview Bootstrap for the Google JS Library (Closure).
				 *
				 * In uncompiled mode base.js will write out Closure's deps file, unless the
				 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
				 * include their own deps file(s) from different locations.
				 *
				 * @author arv@google.com (Erik Arvidsson)
				 *
				 * @provideGoog
				 */
				
				/**
				 * @define {boolean} Overridden to true by the compiler when
				 *     --process_closure_primitives is specified.
				 */
				var COMPILED = false;
				
				/**
				 * Base namespace for the Closure library.  Checks to see goog is already
				 * defined in the current scope before assigning to prevent clobbering if
				 * base.js is loaded more than once.
				 *
				 * @const
				 */
				var goog = this.goog || {};
				
				/**
				 * Reference to the global context.  In most cases this will be 'window'.
				 */
				goog.global = this;
				
				/**
				 * A hook for overriding the define values in uncompiled mode.
				 *
				 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
				 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
				 * {@code goog.define} will use the value instead of the default value.  This
				 * allows flags to be overwritten without compilation (this is normally
				 * accomplished with the compiler's "define" flag).
				 *
				 * Example:
				 * <pre>
				 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
				 * </pre>
				 *
				 * @type {Object<string, (string|number|boolean)>|undefined}
				 */
				goog.global.CLOSURE_UNCOMPILED_DEFINES;
				
				/**
				 * A hook for overriding the define values in uncompiled or compiled mode,
				 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
				 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
				 *
				 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
				 * string literals or the compiler will emit an error.
				 *
				 * While any @define value may be set, only those set with goog.define will be
				 * effective for uncompiled code.
				 *
				 * Example:
				 * <pre>
				 *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
				 * </pre>
				 *
				 * @type {Object<string, (string|number|boolean)>|undefined}
				 */
				goog.global.CLOSURE_DEFINES;
				
				/**
				 * Returns true if the specified value is not undefined.
				 * WARNING: Do not use this to test if an object has a property. Use the in
				 * operator instead.
				 *
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is defined.
				 */
				goog.isDef = function (val) {
					// void 0 always evaluates to undefined and hence we do not need to depend on
					// the definition of the global variable named 'undefined'.
					return val !== void 0;
				};
				
				/**
				 * Builds an object structure for the provided namespace path, ensuring that
				 * names that already exist are not overwritten. For example:
				 * "a.b.c" -> a = {};a.b={};a.b.c={};
				 * Used by goog.provide and goog.exportSymbol.
				 * @param {string} name name of the object that this file defines.
				 * @param {*=} opt_object the object to expose at the end of the path.
				 * @param {Object=} opt_objectToExportTo The object to add the path to; default
				 *     is |goog.global|.
				 * @private
				 */
				goog.exportPath_ = function (name, opt_object, opt_objectToExportTo) {
					var parts = name.split('.');
					var cur = opt_objectToExportTo || goog.global;
					
					// Internet Explorer exhibits strange behavior when throwing errors from
					// methods externed in this manner.  See the testExportSymbolExceptions in
					// base_test.html for an example.
					if (!(parts[0] in cur) && cur.execScript) {
						cur.execScript('var ' + parts[0]);
					}
					
					// Certain browsers cannot parse code in the form for((a in b); c;);
					// This pattern is produced by the JSCompiler when it collapses the
					// statement above into the conditional loop below. To prevent this from
					// happening, use a for-loop and reserve the init logic as below.
					
					// Parentheses added to eliminate strict JS warning in Firefox.
					for (var part; parts.length && (part = parts.shift());) {
						if (!parts.length && goog.isDef(opt_object)) {
							// last part and we have an object; use it
							cur[part] = opt_object;
						} else if (cur[part]) {
							cur = cur[part];
						} else {
							cur = cur[part] = {};
						}
					}
				};
				
				/**
				 * Defines a named value. In uncompiled mode, the value is retrieved from
				 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
				 * has the property specified, and otherwise used the defined defaultValue.
				 * When compiled the default can be overridden using the compiler
				 * options or the value set in the CLOSURE_DEFINES object.
				 *
				 * @param {string} name The distinguished name to provide.
				 * @param {string|number|boolean} defaultValue
				 */
				goog.define = function (name, defaultValue) {
					var value = defaultValue;
					if (!COMPILED) {
						if (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
							value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
						} else if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, name)) {
							value = goog.global.CLOSURE_DEFINES[name];
						}
					}
					goog.exportPath_(name, value);
				};
				
				/**
				 * @define {boolean} DEBUG is provided as a convenience so that debugging code
				 * that should not be included in a production js_binary can be easily stripped
				 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
				 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
				 * because they are generally used for debugging purposes and it is difficult
				 * for the JSCompiler to statically determine whether they are used.
				 */
				goog.define('goog.DEBUG', true);
				
				/**
				 * @define {string} LOCALE defines the locale being used for compilation. It is
				 * used to select locale specific data to be compiled in js binary. BUILD rule
				 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
				 * option.
				 *
				 * Take into account that the locale code format is important. You should use
				 * the canonical Unicode format with hyphen as a delimiter. Language must be
				 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
				 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
				 *
				 * See more info about locale codes here:
				 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
				 *
				 * For language codes you should use values defined by ISO 693-1. See it here
				 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
				 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
				 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
				 */
				goog.define('goog.LOCALE', 'en'); // default to en
				
				
				/**
				 * @define {boolean} Whether this code is running on trusted sites.
				 *
				 * On untrusted sites, several native functions can be defined or overridden by
				 * external libraries like Prototype, Datejs, and JQuery and setting this flag
				 * to false forces closure to use its own implementations when possible.
				 *
				 * If your JavaScript can be loaded by a third party site and you are wary about
				 * relying on non-standard implementations, specify
				 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
				 */
				goog.define('goog.TRUSTED_SITE', true);
				
				/**
				 * @define {boolean} Whether a project is expected to be running in strict mode.
				 *
				 * This define can be used to trigger alternate implementations compatible with
				 * running in EcmaScript Strict mode or warn about unavailable functionality.
				 * @see https://goo.gl/g5EoHI
				 *
				 */
				goog.define('goog.STRICT_MODE_COMPATIBLE', false);
				
				/**
				 * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
				 *     be disallowed in the compilation unit.
				 */
				goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);
				
				/**
				 * @define {boolean} Whether to use a Chrome app CSP-compliant method for
				 *     loading scripts via goog.require. @see appendScriptSrcNode_.
				 */
				goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);
				
				/**
				 * Defines a namespace in Closure.
				 *
				 * A namespace may only be defined once in a codebase. It may be defined using
				 * goog.provide() or goog.module().
				 *
				 * The presence of one or more goog.provide() calls in a file indicates
				 * that the file defines the given objects/namespaces.
				 * Provided symbols must not be null or undefined.
				 *
				 * In addition, goog.provide() creates the object stubs for a namespace
				 * (for example, goog.provide("goog.foo.bar") will create the object
				 * goog.foo.bar if it does not already exist).
				 *
				 * Build tools also scan for provide/require/module statements
				 * to discern dependencies, build dependency files (see deps.js), etc.
				 *
				 * @see goog.require
				 * @see goog.module
				 * @param {string} name Namespace provided by this file in the form
				 *     "goog.package.part".
				 */
				goog.provide = function (name) {
					if (!COMPILED) {
						// Ensure that the same namespace isn't provided twice.
						// A goog.module/goog.provide maps a goog.require to a specific file
						if (goog.isProvided_(name)) {
							throw Error('Namespace "' + name + '" already declared.');
						}
					}
					
					goog.constructNamespace_(name);
				};
				
				/**
				 * @param {string} name Namespace provided by this file in the form
				 *     "goog.package.part".
				 * @param {Object=} opt_obj The object to embed in the namespace.
				 * @private
				 */
				goog.constructNamespace_ = function (name, opt_obj) {
					if (!COMPILED) {
						delete goog.implicitNamespaces_[name];
						
						var namespace = name;
						while (namespace = namespace.substring(0, namespace.lastIndexOf('.'))) {
							if (goog.getObjectByName(namespace)) {
								break;
							}
							goog.implicitNamespaces_[namespace] = true;
						}
					}
					
					goog.exportPath_(name, opt_obj);
				};
				
				/**
				 * Module identifier validation regexp.
				 * Note: This is a conservative check, it is very possible to be more lenient,
				 *   the primary exclusion here is "/" and "\" and a leading ".", these
				 *   restrictions are intended to leave the door open for using goog.require
				 *   with relative file paths rather than module identifiers.
				 * @private
				 */
				goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
				
				/**
				 * Defines a module in Closure.
				 *
				 * Marks that this file must be loaded as a module and claims the namespace.
				 *
				 * A namespace may only be defined once in a codebase. It may be defined using
				 * goog.provide() or goog.module().
				 *
				 * goog.module() has three requirements:
				 * - goog.module may not be used in the same file as goog.provide.
				 * - goog.module must be the first statement in the file.
				 * - only one goog.module is allowed per file.
				 *
				 * When a goog.module annotated file is loaded, it is enclosed in
				 * a strict function closure. This means that:
				 * - any variables declared in a goog.module file are private to the file
				 * (not global), though the compiler is expected to inline the module.
				 * - The code must obey all the rules of "strict" JavaScript.
				 * - the file will be marked as "use strict"
				 *
				 * NOTE: unlike goog.provide, goog.module does not declare any symbols by
				 * itself. If declared symbols are desired, use
				 * goog.module.declareLegacyNamespace().
				 *
				 *
				 * See the public goog.module proposal: http://goo.gl/Va1hin
				 *
				 * @param {string} name Namespace provided by this file in the form
				 *     "goog.package.part", is expected but not required.
				 */
				goog.module = function (name) {
					if (!goog.isString(name) || !name || name.search(goog.VALID_MODULE_RE_) == -1) {
						throw Error('Invalid module identifier');
					}
					if (!goog.isInModuleLoader_()) {
						throw Error('Module ' + name + ' has been loaded incorrectly.');
					}
					if (goog.moduleLoaderState_.moduleName) {
						throw Error('goog.module may only be called once per module.');
					}
					
					// Store the module name for the loader.
					goog.moduleLoaderState_.moduleName = name;
					if (!COMPILED) {
						// Ensure that the same namespace isn't provided twice.
						// A goog.module/goog.provide maps a goog.require to a specific file
						if (goog.isProvided_(name)) {
							throw Error('Namespace "' + name + '" already declared.');
						}
						delete goog.implicitNamespaces_[name];
					}
				};
				
				/**
				 * @param {string} name The module identifier.
				 * @return {?} The module exports for an already loaded module or null.
				 *
				 * Note: This is not an alternative to goog.require, it does not
				 * indicate a hard dependency, instead it is used to indicate
				 * an optional dependency or to access the exports of a module
				 * that has already been loaded.
				 * @suppress {missingProvide}
				 */
				goog.module.get = function (name) {
					return goog.module.getInternal_(name);
				};
				
				/**
				 * @param {string} name The module identifier.
				 * @return {?} The module exports for an already loaded module or null.
				 * @private
				 */
				goog.module.getInternal_ = function (name) {
					if (!COMPILED) {
						if (goog.isProvided_(name)) {
							// goog.require only return a value with-in goog.module files.
							return name in goog.loadedModules_ ? goog.loadedModules_[name] : goog.getObjectByName(name);
						} else {
							return null;
						}
					}
				};
				
				/**
				 * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}
				 */
				goog.moduleLoaderState_ = null;
				
				/**
				 * @private
				 * @return {boolean} Whether a goog.module is currently being initialized.
				 */
				goog.isInModuleLoader_ = function () {
					return goog.moduleLoaderState_ != null;
				};
				
				/**
				 * Provide the module's exports as a globally accessible object under the
				 * module's declared name.  This is intended to ease migration to goog.module
				 * for files that have existing usages.
				 * @suppress {missingProvide}
				 */
				goog.module.declareLegacyNamespace = function () {
					if (!COMPILED && !goog.isInModuleLoader_()) {
						throw new Error('goog.module.declareLegacyNamespace must be called from ' + 'within a goog.module');
					}
					if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
						throw Error('goog.module must be called prior to ' + 'goog.module.declareLegacyNamespace.');
					}
					goog.moduleLoaderState_.declareLegacyNamespace = true;
				};
				
				/**
				 * Marks that the current file should only be used for testing, and never for
				 * live code in production.
				 *
				 * In the case of unit tests, the message may optionally be an exact namespace
				 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
				 * provide (if not explicitly defined in the code).
				 *
				 * @param {string=} opt_message Optional message to add to the error that's
				 *     raised when used in production code.
				 */
				goog.setTestOnly = function (opt_message) {
					if (goog.DISALLOW_TEST_ONLY_CODE) {
						opt_message = opt_message || '';
						throw Error('Importing test-only code into non-debug environment' + (opt_message ? ': ' + opt_message : '.'));
					}
				};
				
				if (!COMPILED) {
					/**
					 * Check if the given name has been goog.provided. This will return false for
					 * names that are available only as implicit namespaces.
					 * @param {string} name name of the object to look for.
					 * @return {boolean} Whether the name has been provided.
					 * @private
					 */
					goog.isProvided_ = function (name) {
						return name in goog.loadedModules_ || !goog.implicitNamespaces_[name] && goog.isDefAndNotNull(goog.getObjectByName(name));
					};
					
					/**
					 * Namespaces implicitly defined by goog.provide. For example,
					 * goog.provide('goog.events.Event') implicitly declares that 'goog' and
					 * 'goog.events' must be namespaces.
					 *
					 * @type {!Object<string, (boolean|undefined)>}
					 * @private
					 */
					goog.implicitNamespaces_ = { 'goog.module': true };
					
					// NOTE: We add goog.module as an implicit namespace as goog.module is defined
					// here and because the existing module package has not been moved yet out of
					// the goog.module namespace. This satisifies both the debug loader and
					// ahead-of-time dependency management.
				}
				
				/**
				 * Returns an object based on its fully qualified external name.  The object
				 * is not found if null or undefined.  If you are using a compilation pass that
				 * renames property names beware that using this function will not find renamed
				 * properties.
				 *
				 * @param {string} name The fully qualified name.
				 * @param {Object=} opt_obj The object within which to look; default is
				 *     |goog.global|.
				 * @return {?} The value (object or primitive) or, if not found, null.
				 */
				goog.getObjectByName = function (name, opt_obj) {
					var parts = name.split('.');
					var cur = opt_obj || goog.global;
					for (var part; part = parts.shift();) {
						if (goog.isDefAndNotNull(cur[part])) {
							cur = cur[part];
						} else {
							return null;
						}
					}
					return cur;
				};
				
				/**
				 * Globalizes a whole namespace, such as goog or goog.lang.
				 *
				 * @param {!Object} obj The namespace to globalize.
				 * @param {Object=} opt_global The object to add the properties to.
				 * @deprecated Properties may be explicitly exported to the global scope, but
				 *     this should no longer be done in bulk.
				 */
				goog.globalize = function (obj, opt_global) {
					var global = opt_global || goog.global;
					for (var x in obj) {
						global[x] = obj[x];
					}
				};
				
				/**
				 * Adds a dependency from a file to the files it requires.
				 * @param {string} relPath The path to the js file.
				 * @param {!Array<string>} provides An array of strings with
				 *     the names of the objects this file provides.
				 * @param {!Array<string>} requires An array of strings with
				 *     the names of the objects this file requires.
				 * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
				 *     how the file must be loaded.  The boolean 'true' is equivalent
				 *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
				 *     and values include {'module': 'goog'} and {'lang': 'es6'}.
				 */
				goog.addDependency = function (relPath, provides, requires, opt_loadFlags) {
					if (goog.DEPENDENCIES_ENABLED) {
						var provide, require;
						var path = relPath.replace(/\\/g, '/');
						var deps = goog.dependencies_;
						if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
							opt_loadFlags = opt_loadFlags ? { 'module': 'goog' } : {};
						}
						for (var i = 0; provide = provides[i]; i++) {
							deps.nameToPath[provide] = path;
							deps.pathIsModule[path] = opt_loadFlags['module'] == 'goog';
						}
						for (var j = 0; require = requires[j]; j++) {
							if (!(path in deps.requires)) {
								deps.requires[path] = {};
							}
							deps.requires[path][require] = true;
						}
					}
				};
				
				// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
				// to do "debug-mode" development.  The dependency system can sometimes be
				// confusing, as can the debug DOM loader's asynchronous nature.
				//
				// With the DOM loader, a call to goog.require() is not blocking -- the script
				// will not load until some point after the current script.  If a namespace is
				// needed at runtime, it needs to be defined in a previous script, or loaded via
				// require() with its registered dependencies.
				//
				// User-defined namespaces may need their own deps file. For a reference on
				// creating a deps file, see:
				// Externally: https://developers.google.com/closure/library/docs/depswriter
				//
				// Because of legacy clients, the DOM loader can't be easily removed from
				// base.js.  Work is being done to make it disableable or replaceable for
				// different environments (DOM-less JavaScript interpreters like Rhino or V8,
				// for example). See bootstrap/ for more information.
				
				
				/**
				 * @define {boolean} Whether to enable the debug loader.
				 *
				 * If enabled, a call to goog.require() will attempt to load the namespace by
				 * appending a script tag to the DOM (if the namespace has been registered).
				 *
				 * If disabled, goog.require() will simply assert that the namespace has been
				 * provided (and depend on the fact that some outside tool correctly ordered
				 * the script).
				 */
				goog.define('goog.ENABLE_DEBUG_LOADER', true);
				
				/**
				 * @param {string} msg
				 * @private
				 */
				goog.logToConsole_ = function (msg) {
					if (goog.global.console) {
						goog.global.console['error'](msg);
					}
				};
				
				/**
				 * Implements a system for the dynamic resolution of dependencies that works in
				 * parallel with the BUILD system. Note that all calls to goog.require will be
				 * stripped by the JSCompiler when the --process_closure_primitives option is
				 * used.
				 * @see goog.provide
				 * @param {string} name Namespace to include (as was given in goog.provide()) in
				 *     the form "goog.package.part".
				 * @return {?} If called within a goog.module file, the associated namespace or
				 *     module otherwise null.
				 */
				goog.require = function (name) {
					// If the object already exists we do not need do do anything.
					if (!COMPILED) {
						if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
							goog.maybeProcessDeferredDep_(name);
						}
						
						if (goog.isProvided_(name)) {
							if (goog.isInModuleLoader_()) {
								return goog.module.getInternal_(name);
							} else {
								return null;
							}
						}
						
						if (goog.ENABLE_DEBUG_LOADER) {
							var path = goog.getPathFromDeps_(name);
							if (path) {
								goog.writeScripts_(path);
								return null;
							}
						}
						
						var errorMessage = 'goog.require could not find: ' + name;
						goog.logToConsole_(errorMessage);
						
						throw Error(errorMessage);
					}
				};
				
				/**
				 * Path for included scripts.
				 * @type {string}
				 */
				goog.basePath = '';
				
				/**
				 * A hook for overriding the base path.
				 * @type {string|undefined}
				 */
				goog.global.CLOSURE_BASE_PATH;
				
				/**
				 * Whether to write out Closure's deps file. By default, the deps are written.
				 * @type {boolean|undefined}
				 */
				goog.global.CLOSURE_NO_DEPS;
				
				/**
				 * A function to import a single script. This is meant to be overridden when
				 * Closure is being run in non-HTML contexts, such as web workers. It's defined
				 * in the global scope so that it can be set before base.js is loaded, which
				 * allows deps.js to be imported properly.
				 *
				 * The function is passed the script source, which is a relative URI. It should
				 * return true if the script was imported, false otherwise.
				 * @type {(function(string): boolean)|undefined}
				 */
				goog.global.CLOSURE_IMPORT_SCRIPT;
				
				/**
				 * Null function used for default values of callbacks, etc.
				 * @return {void} Nothing.
				 */
				goog.nullFunction = function () {};
				
				/**
				 * When defining a class Foo with an abstract method bar(), you can do:
				 * Foo.prototype.bar = goog.abstractMethod
				 *
				 * Now if a subclass of Foo fails to override bar(), an error will be thrown
				 * when bar() is invoked.
				 *
				 * Note: This does not take the name of the function to override as an argument
				 * because that would make it more difficult to obfuscate our JavaScript code.
				 *
				 * @type {!Function}
				 * @throws {Error} when invoked to indicate the method should be overridden.
				 */
				goog.abstractMethod = function () {
					throw Error('unimplemented abstract method');
				};
				
				/**
				 * Adds a {@code getInstance} static method that always returns the same
				 * instance object.
				 * @param {!Function} ctor The constructor for the class to add the static
				 *     method to.
				 */
				goog.addSingletonGetter = function (ctor) {
					ctor.getInstance = function () {
						if (ctor.instance_) {
							return ctor.instance_;
						}
						if (goog.DEBUG) {
							// NOTE: JSCompiler can't optimize away Array#push.
							goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
						}
						return ctor.instance_ = new ctor();
					};
				};
				
				/**
				 * All singleton classes that have been instantiated, for testing. Don't read
				 * it directly, use the {@code goog.testing.singleton} module. The compiler
				 * removes this variable if unused.
				 * @type {!Array<!Function>}
				 * @private
				 */
				goog.instantiatedSingletons_ = [];
				
				/**
				 * @define {boolean} Whether to load goog.modules using {@code eval} when using
				 * the debug loader.  This provides a better debugging experience as the
				 * source is unmodified and can be edited using Chrome Workspaces or similar.
				 * However in some environments the use of {@code eval} is banned
				 * so we provide an alternative.
				 */
				goog.define('goog.LOAD_MODULE_USING_EVAL', true);
				
				/**
				 * @define {boolean} Whether the exports of goog.modules should be sealed when
				 * possible.
				 */
				goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);
				
				/**
				 * The registry of initialized modules:
				 * the module identifier to module exports map.
				 * @private @const {!Object<string, ?>}
				 */
				goog.loadedModules_ = {};
				
				/**
				 * True if goog.dependencies_ is available.
				 * @const {boolean}
				 */
				goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
				
				if (goog.DEPENDENCIES_ENABLED) {
					/**
					 * This object is used to keep track of dependencies and other data that is
					 * used for loading scripts.
					 * @private
					 * @type {{
     *   pathIsModule: !Object<string, boolean>,
     *   nameToPath: !Object<string, string>,
     *   requires: !Object<string, !Object<string, boolean>>,
     *   visited: !Object<string, boolean>,
     *   written: !Object<string, boolean>,
     *   deferred: !Object<string, string>
     * }}
					 */
					goog.dependencies_ = {
						pathIsModule: {}, // 1 to 1
						
						nameToPath: {}, // 1 to 1
						
						requires: {}, // 1 to many
						
						// Used when resolving dependencies to prevent us from visiting file twice.
						visited: {},
						
						written: {}, // Used to keep track of script files we have written.
						
						deferred: {} // Used to track deferred module evaluations in old IEs
					};
					
					/**
					 * Tries to detect whether is in the context of an HTML document.
					 * @return {boolean} True if it looks like HTML document.
					 * @private
					 */
					goog.inHtmlDocument_ = function () {
						/** @type {Document} */
						var doc = goog.global.document;
						return doc != null && 'write' in doc; // XULDocument misses write.
					};
					
					/**
					 * Tries to detect the base path of base.js script that bootstraps Closure.
					 * @private
					 */
					goog.findBasePath_ = function () {
						if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {
							goog.basePath = goog.global.CLOSURE_BASE_PATH;
							return;
						} else if (!goog.inHtmlDocument_()) {
							return;
						}
						/** @type {Document} */
						var doc = goog.global.document;
						var scripts = doc.getElementsByTagName('SCRIPT');
						// Search backwards since the current script is in almost all cases the one
						// that has base.js.
						for (var i = scripts.length - 1; i >= 0; --i) {
							var script = /** @type {!HTMLScriptElement} */scripts[i];
							var src = script.src;
							var qmark = src.lastIndexOf('?');
							var l = qmark == -1 ? src.length : qmark;
							if (src.substr(l - 7, 7) == 'base.js') {
								goog.basePath = src.substr(0, l - 7);
								return;
							}
						}
					};
					
					/**
					 * Imports a script if, and only if, that script hasn't already been imported.
					 * (Must be called at execution time)
					 * @param {string} src Script source.
					 * @param {string=} opt_sourceText The optionally source text to evaluate
					 * @private
					 */
					goog.importScript_ = function (src, opt_sourceText) {
						var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
						if (importScript(src, opt_sourceText)) {
							goog.dependencies_.written[src] = true;
						}
					};
					
					/** @const @private {boolean} */
					goog.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document && goog.global.document.all);
					
					/**
					 * Given a URL initiate retrieval and execution of the module.
					 * @param {string} src Script source URL.
					 * @private
					 */
					goog.importModule_ = function (src) {
						// In an attempt to keep browsers from timing out loading scripts using
						// synchronous XHRs, put each load in its own script block.
						var bootstrap = 'goog.retrieveAndExecModule_("' + src + '");';
						
						if (goog.importScript_('', bootstrap)) {
							goog.dependencies_.written[src] = true;
						}
					};
					
					/** @private {!Array<string>} */
					goog.queuedModules_ = [];
					
					/**
					 * Return an appropriate module text. Suitable to insert into
					 * a script tag (that is unescaped).
					 * @param {string} srcUrl
					 * @param {string} scriptText
					 * @return {string}
					 * @private
					 */
					goog.wrapModule_ = function (srcUrl, scriptText) {
						if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
							return '' + 'goog.loadModule(function(exports) {' + '"use strict";' + scriptText + '\n' + // terminate any trailing single line comment.
								';return exports' + '});' + '\n//# sourceURL=' + srcUrl + '\n';
						} else {
							return '' + 'goog.loadModule(' + goog.global.JSON.stringify(scriptText + '\n//# sourceURL=' + srcUrl + '\n') + ');';
						}
					};
					
					// On IE9 and earlier, it is necessary to handle
					// deferred module loads. In later browsers, the
					// code to be evaluated is simply inserted as a script
					// block in the correct order. To eval deferred
					// code at the right time, we piggy back on goog.require to call
					// goog.maybeProcessDeferredDep_.
					//
					// The goog.requires are used both to bootstrap
					// the loading process (when no deps are available) and
					// declare that they should be available.
					//
					// Here we eval the sources, if all the deps are available
					// either already eval'd or goog.require'd.  This will
					// be the case when all the dependencies have already
					// been loaded, and the dependent module is loaded.
					//
					// But this alone isn't sufficient because it is also
					// necessary to handle the case where there is no root
					// that is not deferred.  For that there we register for an event
					// and trigger goog.loadQueuedModules_ handle any remaining deferred
					// evaluations.
					
					/**
					 * Handle any remaining deferred goog.module evals.
					 * @private
					 */
					goog.loadQueuedModules_ = function () {
						var count = goog.queuedModules_.length;
						if (count > 0) {
							var queue = goog.queuedModules_;
							goog.queuedModules_ = [];
							for (var i = 0; i < count; i++) {
								var path = queue[i];
								goog.maybeProcessDeferredPath_(path);
							}
						}
					};
					
					/**
					 * Eval the named module if its dependencies are
					 * available.
					 * @param {string} name The module to load.
					 * @private
					 */
					goog.maybeProcessDeferredDep_ = function (name) {
						if (goog.isDeferredModule_(name) && goog.allDepsAreAvailable_(name)) {
							var path = goog.getPathFromDeps_(name);
							goog.maybeProcessDeferredPath_(goog.basePath + path);
						}
					};
					
					/**
					 * @param {string} name The module to check.
					 * @return {boolean} Whether the name represents a
					 *     module whose evaluation has been deferred.
					 * @private
					 */
					goog.isDeferredModule_ = function (name) {
						var path = goog.getPathFromDeps_(name);
						if (path && goog.dependencies_.pathIsModule[path]) {
							var abspath = goog.basePath + path;
							return abspath in goog.dependencies_.deferred;
						}
						return false;
					};
					
					/**
					 * @param {string} name The module to check.
					 * @return {boolean} Whether the name represents a
					 *     module whose declared dependencies have all been loaded
					 *     (eval'd or a deferred module load)
					 * @private
					 */
					goog.allDepsAreAvailable_ = function (name) {
						var path = goog.getPathFromDeps_(name);
						if (path && path in goog.dependencies_.requires) {
							for (var requireName in goog.dependencies_.requires[path]) {
								if (!goog.isProvided_(requireName) && !goog.isDeferredModule_(requireName)) {
									return false;
								}
							}
						}
						return true;
					};
					
					/**
					 * @param {string} abspath
					 * @private
					 */
					goog.maybeProcessDeferredPath_ = function (abspath) {
						if (abspath in goog.dependencies_.deferred) {
							var src = goog.dependencies_.deferred[abspath];
							delete goog.dependencies_.deferred[abspath];
							goog.globalEval(src);
						}
					};
					
					/**
					 * Load a goog.module from the provided URL.  This is not a general purpose
					 * code loader and does not support late loading code, that is it should only
					 * be used during page load. This method exists to support unit tests and
					 * "debug" loaders that would otherwise have inserted script tags. Under the
					 * hood this needs to use a synchronous XHR and is not recommeneded for
					 * production code.
					 *
					 * The module's goog.requires must have already been satisified; an exception
					 * will be thrown if this is not the case. This assumption is that no
					 * "deps.js" file exists, so there is no way to discover and locate the
					 * module-to-be-loaded's dependencies and no attempt is made to do so.
					 *
					 * There should only be one attempt to load a module.  If
					 * "goog.loadModuleFromUrl" is called for an already loaded module, an
					 * exception will be throw.
					 *
					 * @param {string} url The URL from which to attempt to load the goog.module.
					 */
					goog.loadModuleFromUrl = function (url) {
						// Because this executes synchronously, we don't need to do any additional
						// bookkeeping. When "goog.loadModule" the namespace will be marked as
						// having been provided which is sufficient.
						goog.retrieveAndExecModule_(url);
					};
					
					/**
					 * @param {function(?):?|string} moduleDef The module definition.
					 */
					goog.loadModule = function (moduleDef) {
						// NOTE: we allow function definitions to be either in the from
						// of a string to eval (which keeps the original source intact) or
						// in a eval forbidden environment (CSP) we allow a function definition
						// which in its body must call {@code goog.module}, and return the exports
						// of the module.
						var previousState = goog.moduleLoaderState_;
						try {
							goog.moduleLoaderState_ = {
								moduleName: undefined,
								declareLegacyNamespace: false
							};
							var exports;
							if (goog.isFunction(moduleDef)) {
								exports = moduleDef.call(goog.global, {});
							} else if (goog.isString(moduleDef)) {
								exports = goog.loadModuleFromSource_.call(goog.global, moduleDef);
							} else {
								throw Error('Invalid module definition');
							}
							
							var moduleName = goog.moduleLoaderState_.moduleName;
							if (!goog.isString(moduleName) || !moduleName) {
								throw Error('Invalid module name \"' + moduleName + '\"');
							}
							
							// Don't seal legacy namespaces as they may be uses as a parent of
							// another namespace
							if (goog.moduleLoaderState_.declareLegacyNamespace) {
								goog.constructNamespace_(moduleName, exports);
							} else if (goog.SEAL_MODULE_EXPORTS && Object.seal) {
								Object.seal(exports);
							}
							
							goog.loadedModules_[moduleName] = exports;
						} finally {
							goog.moduleLoaderState_ = previousState;
						}
					};
					
					/**
					 * @private @const {function(string):?}
					 *
					 * The new type inference warns because this function has no formal
					 * parameters, but its jsdoc says that it takes one argument.
					 * (The argument is used via arguments[0], but NTI does not detect this.)
					 * @suppress {newCheckTypes}
					 */
					goog.loadModuleFromSource_ = function () {
						// NOTE: we avoid declaring parameters or local variables here to avoid
						// masking globals or leaking values into the module definition.
						'use strict';
						
						var exports = {};
						eval(arguments[0]);
						return exports;
					};
					
					/**
					 * Writes a new script pointing to {@code src} directly into the DOM.
					 *
					 * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
					 * the fallback mechanism.
					 *
					 * @param {string} src The script URL.
					 * @private
					 */
					goog.writeScriptSrcNode_ = function (src) {
						goog.global.document.write('<script type="text/javascript" src="' + src + '"></' + 'script>');
					};
					
					/**
					 * Appends a new script node to the DOM using a CSP-compliant mechanism. This
					 * method exists as a fallback for document.write (which is not allowed in a
					 * strict CSP context, e.g., Chrome apps).
					 *
					 * NOTE: This method is not analogous to using document.write to insert a
					 * <script> tag; specifically, the user agent will execute a script added by
					 * document.write immediately after the current script block finishes
					 * executing, whereas the DOM-appended script node will not be executed until
					 * the entire document is parsed and executed. That is to say, this script is
					 * added to the end of the script execution queue.
					 *
					 * The page must not attempt to call goog.required entities until after the
					 * document has loaded, e.g., in or after the window.onload callback.
					 *
					 * @param {string} src The script URL.
					 * @private
					 */
					goog.appendScriptSrcNode_ = function (src) {
						/** @type {Document} */
						var doc = goog.global.document;
						var scriptEl =
							/** @type {HTMLScriptElement} */doc.createElement('script');
						scriptEl.type = 'text/javascript';
						scriptEl.src = src;
						scriptEl.defer = false;
						scriptEl.async = false;
						doc.head.appendChild(scriptEl);
					};
					
					/**
					 * The default implementation of the import function. Writes a script tag to
					 * import the script.
					 *
					 * @param {string} src The script url.
					 * @param {string=} opt_sourceText The optionally source text to evaluate
					 * @return {boolean} True if the script was imported, false otherwise.
					 * @private
					 */
					goog.writeScriptTag_ = function (src, opt_sourceText) {
						if (goog.inHtmlDocument_()) {
							/** @type {!HTMLDocument} */
							var doc = goog.global.document;
							
							// If the user tries to require a new symbol after document load,
							// something has gone terribly wrong. Doing a document.write would
							// wipe out the page. This does not apply to the CSP-compliant method
							// of writing script tags.
							if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && doc.readyState == 'complete') {
								// Certain test frameworks load base.js multiple times, which tries
								// to write deps.js each time. If that happens, just fail silently.
								// These frameworks wipe the page between each load of base.js, so this
								// is OK.
								var isDeps = /\bdeps.js$/.test(src);
								if (isDeps) {
									return false;
								} else {
									throw Error('Cannot write "' + src + '" after document load');
								}
							}
							
							var isOldIE = goog.IS_OLD_IE_;
							
							if (opt_sourceText === undefined) {
								if (!isOldIE) {
									if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
										goog.appendScriptSrcNode_(src);
									} else {
										goog.writeScriptSrcNode_(src);
									}
								} else {
									var state = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ";
									doc.write('<script type="text/javascript" src="' + src + '"' + state + '></' + 'script>');
								}
							} else {
								doc.write('<script type="text/javascript">' + opt_sourceText + '</' + 'script>');
							}
							return true;
						} else {
							return false;
						}
					};
					
					/** @private {number} */
					goog.lastNonModuleScriptIndex_ = 0;
					
					/**
					 * A readystatechange handler for legacy IE
					 * @param {!HTMLScriptElement} script
					 * @param {number} scriptIndex
					 * @return {boolean}
					 * @private
					 */
					goog.onScriptLoad_ = function (script, scriptIndex) {
						// for now load the modules when we reach the last script,
						// later allow more inter-mingling.
						if (script.readyState == 'complete' && goog.lastNonModuleScriptIndex_ == scriptIndex) {
							goog.loadQueuedModules_();
						}
						return true;
					};
					
					/**
					 * Resolves dependencies based on the dependencies added using addDependency
					 * and calls importScript_ in the correct order.
					 * @param {string} pathToLoad The path from which to start discovering
					 *     dependencies.
					 * @private
					 */
					goog.writeScripts_ = function (pathToLoad) {
						/** @type {!Array<string>} The scripts we need to write this time. */
						var scripts = [];
						var seenScript = {};
						var deps = goog.dependencies_;
						
						/** @param {string} path */
						function visitNode(path) {
							if (path in deps.written) {
								return;
							}
							
							// We have already visited this one. We can get here if we have cyclic
							// dependencies.
							if (path in deps.visited) {
								return;
							}
							
							deps.visited[path] = true;
							
							if (path in deps.requires) {
								for (var requireName in deps.requires[path]) {
									// If the required name is defined, we assume that it was already
									// bootstrapped by other means.
									if (!goog.isProvided_(requireName)) {
										if (requireName in deps.nameToPath) {
											visitNode(deps.nameToPath[requireName]);
										} else {
											throw Error('Undefined nameToPath for ' + requireName);
										}
									}
								}
							}
							
							if (!(path in seenScript)) {
								seenScript[path] = true;
								scripts.push(path);
							}
						}
						
						visitNode(pathToLoad);
						
						// record that we are going to load all these scripts.
						for (var i = 0; i < scripts.length; i++) {
							var path = scripts[i];
							goog.dependencies_.written[path] = true;
						}
						
						// If a module is loaded synchronously then we need to
						// clear the current inModuleLoader value, and restore it when we are
						// done loading the current "requires".
						var moduleState = goog.moduleLoaderState_;
						goog.moduleLoaderState_ = null;
						
						for (var i = 0; i < scripts.length; i++) {
							var path = scripts[i];
							if (path) {
								if (!deps.pathIsModule[path]) {
									goog.importScript_(goog.basePath + path);
								} else {
									goog.importModule_(goog.basePath + path);
								}
							} else {
								goog.moduleLoaderState_ = moduleState;
								throw Error('Undefined script input');
							}
						}
						
						// restore the current "module loading state"
						goog.moduleLoaderState_ = moduleState;
					};
					
					/**
					 * Looks at the dependency rules and tries to determine the script file that
					 * fulfills a particular rule.
					 * @param {string} rule In the form goog.namespace.Class or project.script.
					 * @return {?string} Url corresponding to the rule, or null.
					 * @private
					 */
					goog.getPathFromDeps_ = function (rule) {
						if (rule in goog.dependencies_.nameToPath) {
							return goog.dependencies_.nameToPath[rule];
						} else {
							return null;
						}
					};
					
					goog.findBasePath_();
					
					// Allow projects to manage the deps files themselves.
					if (!goog.global.CLOSURE_NO_DEPS) {
						goog.importScript_(goog.basePath + 'deps.js');
					}
				}
				
				/**
				 * Normalize a file path by removing redundant ".." and extraneous "." file
				 * path components.
				 * @param {string} path
				 * @return {string}
				 * @private
				 */
				goog.normalizePath_ = function (path) {
					var components = path.split('/');
					var i = 0;
					while (i < components.length) {
						if (components[i] == '.') {
							components.splice(i, 1);
						} else if (i && components[i] == '..' && components[i - 1] && components[i - 1] != '..') {
							components.splice(--i, 2);
						} else {
							i++;
						}
					}
					return components.join('/');
				};
				
				/**
				 * Loads file by synchronous XHR. Should not be used in production environments.
				 * @param {string} src Source URL.
				 * @return {string} File contents.
				 * @private
				 */
				goog.loadFileSync_ = function (src) {
					if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
						return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
					} else {
						/** @type {XMLHttpRequest} */
						var xhr = new goog.global['XMLHttpRequest']();
						xhr.open('get', src, false);
						xhr.send();
						return xhr.responseText;
					}
				};
				
				/**
				 * Retrieve and execute a module.
				 * @param {string} src Script source URL.
				 * @private
				 */
				goog.retrieveAndExecModule_ = function (src) {
					if (!COMPILED) {
						// The full but non-canonicalized URL for later use.
						var originalPath = src;
						// Canonicalize the path, removing any /./ or /../ since Chrome's debugging
						// console doesn't auto-canonicalize XHR loads as it does <script> srcs.
						src = goog.normalizePath_(src);
						
						var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
						
						var scriptText = goog.loadFileSync_(src);
						
						if (scriptText != null) {
							var execModuleScript = goog.wrapModule_(src, scriptText);
							var isOldIE = goog.IS_OLD_IE_;
							if (isOldIE) {
								goog.dependencies_.deferred[originalPath] = execModuleScript;
								goog.queuedModules_.push(originalPath);
							} else {
								importScript(src, execModuleScript);
							}
						} else {
							throw new Error('load of ' + src + 'failed');
						}
					}
				};
				
				//==============================================================================
				// Language Enhancements
				//==============================================================================
				
				
				/**
				 * This is a "fixed" version of the typeof operator.  It differs from the typeof
				 * operator in such a way that null returns 'null' and arrays return 'array'.
				 * @param {?} value The value to get the type of.
				 * @return {string} The name of the type.
				 */
				goog.typeOf = function (value) {
					var s = typeof value === 'undefined' ? 'undefined' : _typeof(value);
					if (s == 'object') {
						if (value) {
							// Check these first, so we can avoid calling Object.prototype.toString if
							// possible.
							//
							// IE improperly marshals typeof across execution contexts, but a
							// cross-context object will still return false for "instanceof Object".
							if (value instanceof Array) {
								return 'array';
							} else if (value instanceof Object) {
								return s;
							}
							
							// HACK: In order to use an Object prototype method on the arbitrary
							//   value, the compiler requires the value be cast to type Object,
							//   even though the ECMA spec explicitly allows it.
							var className = Object.prototype.toString.call(
								/** @type {!Object} */value);
							// In Firefox 3.6, attempting to access iframe window objects' length
							// property throws an NS_ERROR_FAILURE, so we need to special-case it
							// here.
							if (className == '[object Window]') {
								return 'object';
							}
							
							// We cannot always use constructor == Array or instanceof Array because
							// different frames have different Array objects. In IE6, if the iframe
							// where the array was created is destroyed, the array loses its
							// prototype. Then dereferencing val.splice here throws an exception, so
							// we can't use goog.isFunction. Calling typeof directly returns 'unknown'
							// so that will work. In this case, this function will return false and
							// most array functions will still work because the array is still
							// array-like (supports length and []) even though it has lost its
							// prototype.
							// Mark Miller noticed that Object.prototype.toString
							// allows access to the unforgeable [[Class]] property.
							//  15.2.4.2 Object.prototype.toString ( )
							//  When the toString method is called, the following steps are taken:
							//      1. Get the [[Class]] property of this object.
							//      2. Compute a string value by concatenating the three strings
							//         "[object ", Result(1), and "]".
							//      3. Return Result(2).
							// and this behavior survives the destruction of the execution context.
							if (className == '[object Array]' ||
								// In IE all non value types are wrapped as objects across window
								// boundaries (not iframe though) so we have to do object detection
								// for this edge case.
								typeof value.length == 'number' && typeof value.splice != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')) {
								return 'array';
							}
							// HACK: There is still an array case that fails.
							//     function ArrayImpostor() {}
							//     ArrayImpostor.prototype = [];
							//     var impostor = new ArrayImpostor;
							// this can be fixed by getting rid of the fast path
							// (value instanceof Array) and solely relying on
							// (value && Object.prototype.toString.vall(value) === '[object Array]')
							// but that would require many more function calls and is not warranted
							// unless closure code is receiving objects from untrusted sources.
							
							// IE in cross-window calls does not correctly marshal the function type
							// (it appears just as an object) so we cannot use just typeof val ==
							// 'function'. However, if the object has a call property, it is a
							// function.
							if (className == '[object Function]' || typeof value.call != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('call')) {
								return 'function';
							}
						} else {
							return 'null';
						}
					} else if (s == 'function' && typeof value.call == 'undefined') {
						// In Safari typeof nodeList returns 'function', and on Firefox typeof
						// behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
						// would like to return object for those and we can detect an invalid
						// function by making sure that the function object has a call method.
						return 'object';
					}
					return s;
				};
				
				/**
				 * Returns true if the specified value is null.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is null.
				 */
				goog.isNull = function (val) {
					return val === null;
				};
				
				/**
				 * Returns true if the specified value is defined and not null.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is defined and not null.
				 */
				goog.isDefAndNotNull = function (val) {
					// Note that undefined == null.
					return val != null;
				};
				
				/**
				 * Returns true if the specified value is an array.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is an array.
				 */
				goog.isArray = function (val) {
					return goog.typeOf(val) == 'array';
				};
				
				/**
				 * Returns true if the object looks like an array. To qualify as array like
				 * the value needs to be either a NodeList or an object with a Number length
				 * property. As a special case, a function value is not array like, because its
				 * length property is fixed to correspond to the number of expected arguments.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is an array.
				 */
				goog.isArrayLike = function (val) {
					var type = goog.typeOf(val);
					// We do not use goog.isObject here in order to exclude function values.
					return type == 'array' || type == 'object' && typeof val.length == 'number';
				};
				
				/**
				 * Returns true if the object looks like a Date. To qualify as Date-like the
				 * value needs to be an object and have a getFullYear() function.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is a like a Date.
				 */
				goog.isDateLike = function (val) {
					return goog.isObject(val) && typeof val.getFullYear == 'function';
				};
				
				/**
				 * Returns true if the specified value is a string.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is a string.
				 */
				goog.isString = function (val) {
					return typeof val == 'string';
				};
				
				/**
				 * Returns true if the specified value is a boolean.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is boolean.
				 */
				goog.isBoolean = function (val) {
					return typeof val == 'boolean';
				};
				
				/**
				 * Returns true if the specified value is a number.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is a number.
				 */
				goog.isNumber = function (val) {
					return typeof val == 'number';
				};
				
				/**
				 * Returns true if the specified value is a function.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is a function.
				 */
				goog.isFunction = function (val) {
					return goog.typeOf(val) == 'function';
				};
				
				/**
				 * Returns true if the specified value is an object.  This includes arrays and
				 * functions.
				 * @param {?} val Variable to test.
				 * @return {boolean} Whether variable is an object.
				 */
				goog.isObject = function (val) {
					var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
					return type == 'object' && val != null || type == 'function';
					// return Object(val) === val also works, but is slower, especially if val is
					// not an object.
				};
				
				/**
				 * Gets a unique ID for an object. This mutates the object so that further calls
				 * with the same object as a parameter returns the same value. The unique ID is
				 * guaranteed to be unique across the current session amongst objects that are
				 * passed into {@code getUid}. There is no guarantee that the ID is unique or
				 * consistent across sessions. It is unsafe to generate unique ID for function
				 * prototypes.
				 *
				 * @param {Object} obj The object to get the unique ID for.
				 * @return {number} The unique ID for the object.
				 */
				goog.getUid = function (obj) {
					// TODO(arv): Make the type stricter, do not accept null.
					
					// In Opera window.hasOwnProperty exists but always returns false so we avoid
					// using it. As a consequence the unique ID generated for BaseClass.prototype
					// and SubClass.prototype will be the same.
					return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
				};
				
				/**
				 * Whether the given object is already assigned a unique ID.
				 *
				 * This does not modify the object.
				 *
				 * @param {!Object} obj The object to check.
				 * @return {boolean} Whether there is an assigned unique id for the object.
				 */
				goog.hasUid = function (obj) {
					return !!obj[goog.UID_PROPERTY_];
				};
				
				/**
				 * Removes the unique ID from an object. This is useful if the object was
				 * previously mutated using {@code goog.getUid} in which case the mutation is
				 * undone.
				 * @param {Object} obj The object to remove the unique ID field from.
				 */
				goog.removeUid = function (obj) {
					// TODO(arv): Make the type stricter, do not accept null.
					
					// In IE, DOM nodes are not instances of Object and throw an exception if we
					// try to delete.  Instead we try to use removeAttribute.
					if (obj !== null && 'removeAttribute' in obj) {
						obj.removeAttribute(goog.UID_PROPERTY_);
					}
					/** @preserveTry */
					try {
						delete obj[goog.UID_PROPERTY_];
					} catch (ex) {}
				};
				
				/**
				 * Name for unique ID property. Initialized in a way to help avoid collisions
				 * with other closure JavaScript on the same page.
				 * @type {string}
				 * @private
				 */
				goog.UID_PROPERTY_ = 'closure_uid_' + (Math.random() * 1e9 >>> 0);
				
				/**
				 * Counter for UID.
				 * @type {number}
				 * @private
				 */
				goog.uidCounter_ = 0;
				
				/**
				 * Adds a hash code field to an object. The hash code is unique for the
				 * given object.
				 * @param {Object} obj The object to get the hash code for.
				 * @return {number} The hash code for the object.
				 * @deprecated Use goog.getUid instead.
				 */
				goog.getHashCode = goog.getUid;
				
				/**
				 * Removes the hash code field from an object.
				 * @param {Object} obj The object to remove the field from.
				 * @deprecated Use goog.removeUid instead.
				 */
				goog.removeHashCode = goog.removeUid;
				
				/**
				 * Clones a value. The input may be an Object, Array, or basic type. Objects and
				 * arrays will be cloned recursively.
				 *
				 * WARNINGS:
				 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
				 * refer to themselves will cause infinite recursion.
				 *
				 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
				 * UIDs created by <code>getUid</code> into cloned results.
				 *
				 * @param {*} obj The value to clone.
				 * @return {*} A clone of the input value.
				 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
				 */
				goog.cloneObject = function (obj) {
					var type = goog.typeOf(obj);
					if (type == 'object' || type == 'array') {
						if (obj.clone) {
							return obj.clone();
						}
						var clone = type == 'array' ? [] : {};
						for (var key in obj) {
							clone[key] = goog.cloneObject(obj[key]);
						}
						return clone;
					}
					
					return obj;
				};
				
				/**
				 * A native implementation of goog.bind.
				 * @param {Function} fn A function to partially apply.
				 * @param {Object|undefined} selfObj Specifies the object which this should
				 *     point to when the function is run.
				 * @param {...*} var_args Additional arguments that are partially applied to the
				 *     function.
				 * @return {!Function} A partially-applied form of the function bind() was
				 *     invoked as a method of.
				 * @private
				 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
				 *     deprecated because some people have declared a pure-JS version.
				 *     Only the pure-JS version is truly deprecated.
				 */
				goog.bindNative_ = function (fn, selfObj, var_args) {
					return (/** @type {!Function} */fn.call.apply(fn.bind, arguments)
					);
				};
				
				/**
				 * A pure-JS implementation of goog.bind.
				 * @param {Function} fn A function to partially apply.
				 * @param {Object|undefined} selfObj Specifies the object which this should
				 *     point to when the function is run.
				 * @param {...*} var_args Additional arguments that are partially applied to the
				 *     function.
				 * @return {!Function} A partially-applied form of the function bind() was
				 *     invoked as a method of.
				 * @private
				 */
				goog.bindJs_ = function (fn, selfObj, var_args) {
					if (!fn) {
						throw new Error();
					}
					
					if (arguments.length > 2) {
						var boundArgs = Array.prototype.slice.call(arguments, 2);
						return function () {
							// Prepend the bound arguments to the current arguments.
							var newArgs = Array.prototype.slice.call(arguments);
							Array.prototype.unshift.apply(newArgs, boundArgs);
							return fn.apply(selfObj, newArgs);
						};
					} else {
						return function () {
							return fn.apply(selfObj, arguments);
						};
					}
				};
				
				/**
				 * Partially applies this function to a particular 'this object' and zero or
				 * more arguments. The result is a new function with some arguments of the first
				 * function pre-filled and the value of this 'pre-specified'.
				 *
				 * Remaining arguments specified at call-time are appended to the pre-specified
				 * ones.
				 *
				 * Also see: {@link #partial}.
				 *
				 * Usage:
				 * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
				 * barMethBound('arg3', 'arg4');</pre>
				 *
				 * @param {?function(this:T, ...)} fn A function to partially apply.
				 * @param {T} selfObj Specifies the object which this should point to when the
				 *     function is run.
				 * @param {...*} var_args Additional arguments that are partially applied to the
				 *     function.
				 * @return {!Function} A partially-applied form of the function goog.bind() was
				 *     invoked as a method of.
				 * @template T
				 * @suppress {deprecated} See above.
				 */
				goog.bind = function (fn, selfObj, var_args) {
					// TODO(nicksantos): narrow the type signature.
					if (Function.prototype.bind &&
						// NOTE(nicksantos): Somebody pulled base.js into the default Chrome
						// extension environment. This means that for Chrome extensions, they get
						// the implementation of Function.prototype.bind that calls goog.bind
						// instead of the native one. Even worse, we don't want to introduce a
						// circular dependency between goog.bind and Function.prototype.bind, so
						// we have to hack this to make sure it works correctly.
						Function.prototype.bind.toString().indexOf('native code') != -1) {
						goog.bind = goog.bindNative_;
					} else {
						goog.bind = goog.bindJs_;
					}
					return goog.bind.apply(null, arguments);
				};
				
				/**
				 * Like goog.bind(), except that a 'this object' is not required. Useful when
				 * the target function is already bound.
				 *
				 * Usage:
				 * var g = goog.partial(f, arg1, arg2);
				 * g(arg3, arg4);
				 *
				 * @param {Function} fn A function to partially apply.
				 * @param {...*} var_args Additional arguments that are partially applied to fn.
				 * @return {!Function} A partially-applied form of the function goog.partial()
				 *     was invoked as a method of.
				 */
				goog.partial = function (fn, var_args) {
					var args = Array.prototype.slice.call(arguments, 1);
					return function () {
						// Clone the array (with slice()) and append additional arguments
						// to the existing arguments.
						var newArgs = args.slice();
						newArgs.push.apply(newArgs, arguments);
						return fn.apply(this, newArgs);
					};
				};
				
				/**
				 * Copies all the members of a source object to a target object. This method
				 * does not work on all browsers for all objects that contain keys such as
				 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
				 * @param {Object} target Target.
				 * @param {Object} source Source.
				 */
				goog.mixin = function (target, source) {
					for (var x in source) {
						target[x] = source[x];
					}
					
					// For IE7 or lower, the for-in-loop does not contain any properties that are
					// not enumerable on the prototype object (for example, isPrototypeOf from
					// Object.prototype) but also it will not include 'replace' on objects that
					// extend String and change 'replace' (not that it is common for anyone to
					// extend anything except Object).
				};
				
				/**
				 * @return {number} An integer value representing the number of milliseconds
				 *     between midnight, January 1, 1970 and the current time.
				 */
				goog.now = goog.TRUSTED_SITE && Date.now || function () {
						// Unary plus operator converts its operand to a number which in
						// the case of
						// a date is done by calling getTime().
						return +new Date();
					};
				
				/**
				 * Evals JavaScript in the global scope.  In IE this uses execScript, other
				 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
				 * global scope (for example, in Safari), appends a script tag instead.
				 * Throws an exception if neither execScript or eval is defined.
				 * @param {string} script JavaScript string.
				 */
				goog.globalEval = function (script) {
					if (goog.global.execScript) {
						goog.global.execScript(script, 'JavaScript');
					} else if (goog.global.eval) {
						// Test to see if eval works
						if (goog.evalWorksForGlobals_ == null) {
							goog.global.eval('var _evalTest_ = 1;');
							if (typeof goog.global['_evalTest_'] != 'undefined') {
								try {
									delete goog.global['_evalTest_'];
								} catch (ignore) {
									// Microsoft edge fails the deletion above in strict mode.
								}
								goog.evalWorksForGlobals_ = true;
							} else {
								goog.evalWorksForGlobals_ = false;
							}
						}
						
						if (goog.evalWorksForGlobals_) {
							goog.global.eval(script);
						} else {
							/** @type {Document} */
							var doc = goog.global.document;
							var scriptElt =
								/** @type {!HTMLScriptElement} */doc.createElement('SCRIPT');
							scriptElt.type = 'text/javascript';
							scriptElt.defer = false;
							// Note(user): can't use .innerHTML since "t('<test>')" will fail and
							// .text doesn't work in Safari 2.  Therefore we append a text node.
							scriptElt.appendChild(doc.createTextNode(script));
							doc.body.appendChild(scriptElt);
							doc.body.removeChild(scriptElt);
						}
					} else {
						throw Error('goog.globalEval not available');
					}
				};
				
				/**
				 * Indicates whether or not we can call 'eval' directly to eval code in the
				 * global scope. Set to a Boolean by the first call to goog.globalEval (which
				 * empirically tests whether eval works for globals). @see goog.globalEval
				 * @type {?boolean}
				 * @private
				 */
				goog.evalWorksForGlobals_ = null;
				
				/**
				 * Optional map of CSS class names to obfuscated names used with
				 * goog.getCssName().
				 * @private {!Object<string, string>|undefined}
				 * @see goog.setCssNameMapping
				 */
				goog.cssNameMapping_;
				
				/**
				 * Optional obfuscation style for CSS class names. Should be set to either
				 * 'BY_WHOLE' or 'BY_PART' if defined.
				 * @type {string|undefined}
				 * @private
				 * @see goog.setCssNameMapping
				 */
				goog.cssNameMappingStyle_;
				
				/**
				 * Handles strings that are intended to be used as CSS class names.
				 *
				 * This function works in tandem with @see goog.setCssNameMapping.
				 *
				 * Without any mapping set, the arguments are simple joined with a hyphen and
				 * passed through unaltered.
				 *
				 * When there is a mapping, there are two possible styles in which these
				 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
				 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
				 * style, the full css name is looked up in the map directly. If a rewrite is
				 * not specified by the map, the compiler will output a warning.
				 *
				 * When the mapping is passed to the compiler, it will replace calls to
				 * goog.getCssName with the strings from the mapping, e.g.
				 *     var x = goog.getCssName('foo');
				 *     var y = goog.getCssName(this.baseClass, 'active');
				 *  becomes:
				 *     var x = 'foo';
				 *     var y = this.baseClass + '-active';
				 *
				 * If one argument is passed it will be processed, if two are passed only the
				 * modifier will be processed, as it is assumed the first argument was generated
				 * as a result of calling goog.getCssName.
				 *
				 * @param {string} className The class name.
				 * @param {string=} opt_modifier A modifier to be appended to the class name.
				 * @return {string} The class name or the concatenation of the class name and
				 *     the modifier.
				 */
				goog.getCssName = function (className, opt_modifier) {
					var getMapping = function getMapping(cssName) {
						return goog.cssNameMapping_[cssName] || cssName;
					};
					
					var renameByParts = function renameByParts(cssName) {
						// Remap all the parts individually.
						var parts = cssName.split('-');
						var mapped = [];
						for (var i = 0; i < parts.length; i++) {
							mapped.push(getMapping(parts[i]));
						}
						return mapped.join('-');
					};
					
					var rename;
					if (goog.cssNameMapping_) {
						rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
					} else {
						rename = function rename(a) {
							return a;
						};
					}
					
					if (opt_modifier) {
						return className + '-' + rename(opt_modifier);
					} else {
						return rename(className);
					}
				};
				
				/**
				 * Sets the map to check when returning a value from goog.getCssName(). Example:
				 * <pre>
				 * goog.setCssNameMapping({
   *   "goog": "a",
   *   "disabled": "b",
   * });
				 *
				 * var x = goog.getCssName('goog');
				 * // The following evaluates to: "a a-b".
				 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
				 * </pre>
				 * When declared as a map of string literals to string literals, the JSCompiler
				 * will replace all calls to goog.getCssName() using the supplied map if the
				 * --process_closure_primitives flag is set.
				 *
				 * @param {!Object} mapping A map of strings to strings where keys are possible
				 *     arguments to goog.getCssName() and values are the corresponding values
				 *     that should be returned.
				 * @param {string=} opt_style The style of css name mapping. There are two valid
				 *     options: 'BY_PART', and 'BY_WHOLE'.
				 * @see goog.getCssName for a description.
				 */
				goog.setCssNameMapping = function (mapping, opt_style) {
					goog.cssNameMapping_ = mapping;
					goog.cssNameMappingStyle_ = opt_style;
				};
				
				/**
				 * To use CSS renaming in compiled mode, one of the input files should have a
				 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
				 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
				 * mode, JavaScript code should be loaded before this base.js file that declares
				 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
				 * to ensure that the mapping is loaded before any calls to goog.getCssName()
				 * are made in uncompiled mode.
				 *
				 * A hook for overriding the CSS name mapping.
				 * @type {!Object<string, string>|undefined}
				 */
				goog.global.CLOSURE_CSS_NAME_MAPPING;
				
				if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
					// This does not call goog.setCssNameMapping() because the JSCompiler
					// requires that goog.setCssNameMapping() be called with an object literal.
					goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
				}
				
				/**
				 * Gets a localized message.
				 *
				 * This function is a compiler primitive. If you give the compiler a localized
				 * message bundle, it will replace the string at compile-time with a localized
				 * version, and expand goog.getMsg call to a concatenated string.
				 *
				 * Messages must be initialized in the form:
				 * <code>
				 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
				 * </code>
				 *
				 * @param {string} str Translatable string, places holders in the form {$foo}.
				 * @param {Object<string, string>=} opt_values Maps place holder name to value.
				 * @return {string} message with placeholders filled.
				 */
				goog.getMsg = function (str, opt_values) {
					if (opt_values) {
						str = str.replace(/\{\$([^}]+)}/g, function (match, key) {
							return opt_values != null && key in opt_values ? opt_values[key] : match;
						});
					}
					return str;
				};
				
				/**
				 * Gets a localized message. If the message does not have a translation, gives a
				 * fallback message.
				 *
				 * This is useful when introducing a new message that has not yet been
				 * translated into all languages.
				 *
				 * This function is a compiler primitive. Must be used in the form:
				 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
				 * where MSG_A and MSG_B were initialized with goog.getMsg.
				 *
				 * @param {string} a The preferred message.
				 * @param {string} b The fallback message.
				 * @return {string} The best translated message.
				 */
				goog.getMsgWithFallback = function (a, b) {
					return a;
				};
				
				/**
				 * Exposes an unobfuscated global namespace path for the given object.
				 * Note that fields of the exported object *will* be obfuscated, unless they are
				 * exported in turn via this function or goog.exportProperty.
				 *
				 * Also handy for making public items that are defined in anonymous closures.
				 *
				 * ex. goog.exportSymbol('public.path.Foo', Foo);
				 *
				 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
				 *     public.path.Foo.staticFunction();
				 *
				 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
				 *                       Foo.prototype.myMethod);
				 *     new public.path.Foo().myMethod();
				 *
				 * @param {string} publicPath Unobfuscated name to export.
				 * @param {*} object Object the name should point to.
				 * @param {Object=} opt_objectToExportTo The object to add the path to; default
				 *     is goog.global.
				 */
				goog.exportSymbol = function (publicPath, object, opt_objectToExportTo) {
					goog.exportPath_(publicPath, object, opt_objectToExportTo);
				};
				
				/**
				 * Exports a property unobfuscated into the object's namespace.
				 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
				 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
				 * @param {Object} object Object whose static property is being exported.
				 * @param {string} publicName Unobfuscated name to export.
				 * @param {*} symbol Object the name should point to.
				 */
				goog.exportProperty = function (object, publicName, symbol) {
					object[publicName] = symbol;
				};
				
				/**
				 * Inherit the prototype methods from one constructor into another.
				 *
				 * Usage:
				 * <pre>
				 * function ParentClass(a, b) { }
				 * ParentClass.prototype.foo = function(a) { };
				 *
				 * function ChildClass(a, b, c) {
   *   ChildClass.base(this, 'constructor', a, b);
   * }
				 * goog.inherits(ChildClass, ParentClass);
				 *
				 * var child = new ChildClass('a', 'b', 'see');
				 * child.foo(); // This works.
				 * </pre>
				 *
				 * @param {!Function} childCtor Child class.
				 * @param {!Function} parentCtor Parent class.
				 */
				goog.inherits = function (childCtor, parentCtor) {
					/** @constructor */
					function tempCtor() {}
					tempCtor.prototype = parentCtor.prototype;
					childCtor.superClass_ = parentCtor.prototype;
					childCtor.prototype = new tempCtor();
					/** @override */
					childCtor.prototype.constructor = childCtor;
					
					/**
					 * Calls superclass constructor/method.
					 *
					 * This function is only available if you use goog.inherits to
					 * express inheritance relationships between classes.
					 *
					 * NOTE: This is a replacement for goog.base and for superClass_
					 * property defined in childCtor.
					 *
					 * @param {!Object} me Should always be "this".
					 * @param {string} methodName The method name to call. Calling
					 *     superclass constructor can be done with the special string
					 *     'constructor'.
					 * @param {...*} var_args The arguments to pass to superclass
					 *     method/constructor.
					 * @return {*} The return value of the superclass method/constructor.
					 */
					childCtor.base = function (me, methodName, var_args) {
						// Copying using loop to avoid deop due to passing arguments object to
						// function. This is faster in many JS engines as of late 2014.
						var args = new Array(arguments.length - 2);
						for (var i = 2; i < arguments.length; i++) {
							args[i - 2] = arguments[i];
						}
						return parentCtor.prototype[methodName].apply(me, args);
					};
				};
				
				/**
				 * Call up to the superclass.
				 *
				 * If this is called from a constructor, then this calls the superclass
				 * constructor with arguments 1-N.
				 *
				 * If this is called from a prototype method, then you must pass the name of the
				 * method as the second argument to this function. If you do not, you will get a
				 * runtime error. This calls the superclass' method with arguments 2-N.
				 *
				 * This function only works if you use goog.inherits to express inheritance
				 * relationships between your classes.
				 *
				 * This function is a compiler primitive. At compile-time, the compiler will do
				 * macro expansion to remove a lot of the extra overhead that this function
				 * introduces. The compiler will also enforce a lot of the assumptions that this
				 * function makes, and treat it as a compiler error if you break them.
				 *
				 * @param {!Object} me Should always be "this".
				 * @param {*=} opt_methodName The method name if calling a super method.
				 * @param {...*} var_args The rest of the arguments.
				 * @return {*} The return value of the superclass method.
				 * @suppress {es5Strict} This method can not be used in strict mode, but
				 *     all Closure Library consumers must depend on this file.
				 */
				goog.base = function (me, opt_methodName, var_args) {
					var caller = arguments.callee.caller;
					
					if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !caller) {
						throw Error('arguments.caller not defined.  goog.base() cannot be used ' + 'with strict mode code. See ' + 'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
					}
					
					if (caller.superClass_) {
						// Copying using loop to avoid deop due to passing arguments object to
						// function. This is faster in many JS engines as of late 2014.
						var ctorArgs = new Array(arguments.length - 1);
						for (var i = 1; i < arguments.length; i++) {
							ctorArgs[i - 1] = arguments[i];
						}
						// This is a constructor. Call the superclass constructor.
						return caller.superClass_.constructor.apply(me, ctorArgs);
					}
					
					// Copying using loop to avoid deop due to passing arguments object to
					// function. This is faster in many JS engines as of late 2014.
					var args = new Array(arguments.length - 2);
					for (var i = 2; i < arguments.length; i++) {
						args[i - 2] = arguments[i];
					}
					var foundCaller = false;
					for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
						if (ctor.prototype[opt_methodName] === caller) {
							foundCaller = true;
						} else if (foundCaller) {
							return ctor.prototype[opt_methodName].apply(me, args);
						}
					}
					
					// If we did not find the caller in the prototype chain, then one of two
					// things happened:
					// 1) The caller is an instance method.
					// 2) This method was not called by the right caller.
					if (me[opt_methodName] === caller) {
						return me.constructor.prototype[opt_methodName].apply(me, args);
					} else {
						throw Error('goog.base called from a method of one name ' + 'to a method of a different name');
					}
				};
				
				/**
				 * Allow for aliasing within scope functions.  This function exists for
				 * uncompiled code - in compiled code the calls will be inlined and the aliases
				 * applied.  In uncompiled code the function is simply run since the aliases as
				 * written are valid JavaScript.
				 *
				 *
				 * @param {function()} fn Function to call.  This function can contain aliases
				 *     to namespaces (e.g. "var dom = goog.dom") or classes
				 *     (e.g. "var Timer = goog.Timer").
				 */
				goog.scope = function (fn) {
					fn.call(goog.global);
				};
				
				/*
				 * To support uncompiled, strict mode bundles that use eval to divide source
				 * like so:
				 *    eval('someSource;//# sourceUrl sourcefile.js');
				 * We need to export the globally defined symbols "goog" and "COMPILED".
				 * Exporting "goog" breaks the compiler optimizations, so we required that
				 * be defined externally.
				 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
				 * extern generation when that compiler option is enabled.
				 */
				if (!COMPILED) {
					goog.global['COMPILED'] = COMPILED;
				}
				
				goog.provide('goog.string');
				
				/**
				 * Does simple python-style string substitution.
				 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
				 * @param {string} str The string containing the pattern.
				 * @param {...*} var_args The items to substitute into the pattern.
				 * @return {string} A copy of {@code str} in which each occurrence of
				 *     {@code %s} has been replaced an argument from {@code var_args}.
				 */
				goog.string.subs = function (str, var_args) {
					var splitParts = str.split('%s');
					var returnString = '';
					
					var subsArguments = Array.prototype.slice.call(arguments, 1);
					while (subsArguments.length &&
					// Replace up to the last split part. We are inserting in the
					// positions between split parts.
					splitParts.length > 1) {
						returnString += splitParts.shift() + subsArguments.shift();
					}
					
					return returnString + splitParts.join('%s'); // Join unused '%s'
				};
				
				/**
				 * Regular expression that matches an ampersand, for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.AMP_RE_ = /&/g;
				
				/**
				 * Regular expression that matches a less than sign, for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.LT_RE_ = /</g;
				
				/**
				 * Regular expression that matches a greater than sign, for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.GT_RE_ = />/g;
				
				/**
				 * Regular expression that matches a double quote, for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.QUOT_RE_ = /"/g;
				
				/**
				 * Regular expression that matches a single quote, for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.SINGLE_QUOTE_RE_ = /'/g;
				
				/**
				 * Regular expression that matches null character, for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.NULL_RE_ = /\x00/g;
				
				/**
				 * Regular expression that matches a lowercase letter "e", for use in escaping.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.E_RE_ = /e/g;
				
				/**
				 * Regular expression that matches any character that needs to be escaped.
				 * @const {!RegExp}
				 * @private
				 */
				goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/;
				
				/**
				 * Unescapes an HTML string.
				 *
				 * @param {string} str The string to unescape.
				 * @return {string} An unescaped copy of {@code str}.
				 */
				goog.string.unescapeEntities = function (str) {
					if (goog.string.contains(str, '&')) {
						// We are careful not to use a DOM if we do not have one or we explicitly
						// requested non-DOM html unescaping.
						if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING && 'document' in goog.global) {
							return goog.string.unescapeEntitiesUsingDom_(str);
						} else {
							// Fall back on pure XML entities
							return goog.string.unescapePureXmlEntities_(str);
						}
					}
					return str;
				};
				
				/**
				 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
				 * entities. This function is XSS-safe and whitespace-preserving.
				 * @private
				 * @param {string} str The string to unescape.
				 * @param {Document=} opt_document An optional document to use for creating
				 *     elements. If this is not specified then the default window.document
				 *     will be used.
				 * @return {string} The unescaped {@code str} string.
				 */
				goog.string.unescapeEntitiesUsingDom_ = function (str, opt_document) {
					/** @type {!Object<string, string>} */
					var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
					var div;
					if (opt_document) {
						div = opt_document.createElement('div');
					} else {
						div = goog.global.document.createElement('div');
					}
					// Match as many valid entity characters as possible. If the actual entity
					// happens to be shorter, it will still work as innerHTML will return the
					// trailing characters unchanged. Since the entity characters do not include
					// open angle bracket, there is no chance of XSS from the innerHTML use.
					// Since no whitespace is passed to innerHTML, whitespace is preserved.
					return str.replace(goog.string.HTML_ENTITY_PATTERN_, function (s, entity) {
						// Check for cached entity.
						var value = seen[s];
						if (value) {
							return value;
						}
						// Check for numeric entity.
						if (entity.charAt(0) == '#') {
							// Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
							var n = Number('0' + entity.substr(1));
							if (!isNaN(n)) {
								value = String.fromCharCode(n);
							}
						}
						// Fall back to innerHTML otherwise.
						if (!value) {
							// Append a non-entity character to avoid a bug in Webkit that parses
							// an invalid entity at the end of innerHTML text as the empty string.
							div.innerHTML = s + ' ';
							// Then remove the trailing character from the result.
							value = div.firstChild.nodeValue.slice(0, -1);
						}
						// Cache and return.
						return seen[s] = value;
					});
				};
				
				/**
				 * Unescapes XML entities.
				 * @private
				 * @param {string} str The string to unescape.
				 * @return {string} An unescaped copy of {@code str}.
				 */
				goog.string.unescapePureXmlEntities_ = function (str) {
					return str.replace(/&([^;]+);/g, function (s, entity) {
						switch (entity) {
							case 'amp':
								return '&';
							case 'lt':
								return '<';
							case 'gt':
								return '>';
							case 'quot':
								return '"';
							default:
								if (entity.charAt(0) == '#') {
									// Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
									var n = Number('0' + entity.substr(1));
									if (!isNaN(n)) {
										return String.fromCharCode(n);
									}
								}
								// For invalid entities we just return the entity
								return s;
						}
					});
				};
				
				/**
				 * Regular expression that matches an HTML entity.
				 * See also HTML5: Tokenization / Tokenizing character references.
				 * @private
				 * @type {!RegExp}
				 */
				goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
				
				/**
				 * Determines whether a string contains a substring.
				 * @param {string} str The string to search.
				 * @param {string} subString The substring to search for.
				 * @return {boolean} Whether {@code str} contains {@code subString}.
				 */
				goog.string.contains = function (str, subString) {
					return str.indexOf(subString) != -1;
				};
				
				/**
				 * Escapes double quote '"' and single quote '\'' characters in addition to
				 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
				 * value within double or single quotes.
				 *
				 * It should be noted that > doesn't need to be escaped for the HTML or XML to
				 * be valid, but it has been decided to escape it for consistency with other
				 * implementations.
				 *
				 * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
				 * lowercase letter "e".
				 *
				 * NOTE(user):
				 * HtmlEscape is often called during the generation of large blocks of HTML.
				 * Using statics for the regular expressions and strings is an optimization
				 * that can more than half the amount of time IE spends in this function for
				 * large apps, since strings and regexes both contribute to GC allocations.
				 *
				 * Testing for the presence of a character before escaping increases the number
				 * of function calls, but actually provides a speed increase for the average
				 * case -- since the average case often doesn't require the escaping of all 4
				 * characters and indexOf() is much cheaper than replace().
				 * The worst case does suffer slightly from the additional calls, therefore the
				 * opt_isLikelyToContainHtmlChars option has been included for situations
				 * where all 4 HTML entities are very likely to be present and need escaping.
				 *
				 * Some benchmarks (times tended to fluctuate +-0.05ms):
				 *                                     FireFox                     IE6
				 * (no chars / average (mix of cases) / all 4 chars)
				 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
				 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
				 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
				 *
				 * An additional advantage of checking if replace actually needs to be called
				 * is a reduction in the number of object allocations, so as the size of the
				 * application grows the difference between the various methods would increase.
				 *
				 * @param {string} str string to be escaped.
				 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
				 *     if the character needs replacing - use this option if you expect each of
				 *     the characters to appear often. Leave false if you expect few html
				 *     characters to occur in your strings, such as if you are escaping HTML.
				 * @return {string} An escaped copy of {@code str}.
				 */
				goog.string.htmlEscape = function (str, opt_isLikelyToContainHtmlChars) {
					
					if (opt_isLikelyToContainHtmlChars) {
						str = str.replace(goog.string.AMP_RE_, '&amp;').replace(goog.string.LT_RE_, '&lt;').replace(goog.string.GT_RE_, '&gt;').replace(goog.string.QUOT_RE_, '&quot;').replace(goog.string.SINGLE_QUOTE_RE_, '&#39;').replace(goog.string.NULL_RE_, '&#0;');
						if (goog.string.DETECT_DOUBLE_ESCAPING) {
							str = str.replace(goog.string.E_RE_, '&#101;');
						}
						return str;
					} else {
						// quick test helps in the case when there are no chars to replace, in
						// worst case this makes barely a difference to the time taken
						if (!goog.string.ALL_RE_.test(str)) return str;
						
						// str.indexOf is faster than regex.test in this case
						if (str.indexOf('&') != -1) {
							str = str.replace(goog.string.AMP_RE_, '&amp;');
						}
						if (str.indexOf('<') != -1) {
							str = str.replace(goog.string.LT_RE_, '&lt;');
						}
						if (str.indexOf('>') != -1) {
							str = str.replace(goog.string.GT_RE_, '&gt;');
						}
						if (str.indexOf('"') != -1) {
							str = str.replace(goog.string.QUOT_RE_, '&quot;');
						}
						if (str.indexOf('\'') != -1) {
							str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');
						}
						if (str.indexOf('\x00') != -1) {
							str = str.replace(goog.string.NULL_RE_, '&#0;');
						}
						if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {
							str = str.replace(goog.string.E_RE_, '&#101;');
						}
						return str;
					}
				};
				
				goog.debug = {};
				
				/**
				 * Returns the type of a value. If a constructor is passed, and a suitable
				 * string cannot be found, 'unknown type name' will be returned.
				 *
				 * <p>Forked rather than moved from {@link goog.asserts.getType_}
				 * to avoid adding a dependency to goog.asserts.
				 * @param {*} value A constructor, object, or primitive.
				 * @return {string} The best display name for the value, or 'unknown type name'.
				 */
				goog.debug.runtimeType = function (value) {
					if (value instanceof Function) {
						return value.displayName || value.name || 'unknown type name';
					} else if (value instanceof Object) {
						return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
					} else {
						return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
					}
				};
				
				// Copyright 2009 The Closure Library Authors. All Rights Reserved.
				//
				// Licensed under the Apache License, Version 2.0 (the "License");
				// you may not use this file except in compliance with the License.
				// You may obtain a copy of the License at
				//
				//      http://www.apache.org/licenses/LICENSE-2.0
				//
				// Unless required by applicable law or agreed to in writing, software
				// distributed under the License is distributed on an "AS-IS" BASIS,
				// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
				// See the License for the specific language governing permissions and
				// limitations under the License.
				
				/**
				 * @fileoverview Provides a base class for custom Error objects such that the
				 * stack is correctly maintained.
				 *
				 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
				 * sufficient.
				 *
				 */
				
				/**
				 * Base class for custom error objects.
				 * @param {*=} opt_msg The message associated with the error.
				 * @constructor
				 * @extends {Error}
				 */
				goog.debug.Error = function (opt_msg) {
					
					// Attempt to ensure there is a stack trace.
					if (Error.captureStackTrace) {
						Error.captureStackTrace(this, goog.debug.Error);
					} else {
						var stack = new Error().stack;
						if (stack) {
							this.stack = stack;
						}
					}
					
					if (opt_msg) {
						this.message = String(opt_msg);
					}
					
					/**
					 * Whether to report this error to the server. Setting this to false will
					 * cause the error reporter to not report the error back to the server,
					 * which can be useful if the client knows that the error has already been
					 * logged on the server.
					 * @type {boolean}
					 */
					this.reportErrorToServer = true;
				};
				goog.inherits(goog.debug.Error, Error);
				
				/** @override */
				goog.debug.Error.prototype.name = 'CustomError';
				
				/**
				 * @fileoverview Definition of goog.dom.NodeType.
				 */
				
				goog.dom = {};
				
				/**
				 * Constants for the nodeType attribute in the Node interface.
				 *
				 * These constants match those specified in the Node interface. These are
				 * usually present on the Node object in recent browsers, but not in older
				 * browsers (specifically, early IEs) and thus are given here.
				 *
				 * In some browsers (early IEs), these are not defined on the Node object,
				 * so they are provided here.
				 *
				 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
				 * @enum {number}
				 */
				goog.dom.NodeType = {
					ELEMENT: 1,
					ATTRIBUTE: 2,
					TEXT: 3,
					CDATA_SECTION: 4,
					ENTITY_REFERENCE: 5,
					ENTITY: 6,
					PROCESSING_INSTRUCTION: 7,
					COMMENT: 8,
					DOCUMENT: 9,
					DOCUMENT_TYPE: 10,
					DOCUMENT_FRAGMENT: 11,
					NOTATION: 12
				};
				
				// Copyright 2007 The Closure Library Authors. All Rights Reserved.
				//
				// Licensed under the Apache License, Version 2.0 (the "License");
				// you may not use this file except in compliance with the License.
				// You may obtain a copy of the License at
				//
				//      http://www.apache.org/licenses/LICENSE-2.0
				//
				// Unless required by applicable law or agreed to in writing, software
				// distributed under the License is distributed on an "AS-IS" BASIS,
				// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
				// See the License for the specific language governing permissions and
				// limitations under the License.
				
				/**
				 * @fileoverview Utility functions for supporting Bidi issues.
				 */
				
				/**
				 * Namespace for bidi supporting functions.
				 */
				goog.provide('goog.i18n.bidi');
				goog.provide('goog.i18n.bidi.Dir');
				goog.provide('goog.i18n.bidi.DirectionalString');
				goog.provide('goog.i18n.bidi.Format');
				
				/**
				 * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
				 * to say that the current locale is a RTL locale.  This should only be used
				 * if you want to override the default behavior for deciding whether the
				 * current locale is RTL or not.
				 *
				 * {@see goog.i18n.bidi.IS_RTL}
				 */
				goog.define('goog.i18n.bidi.FORCE_RTL', false);
				
				/**
				 * Constant that defines whether or not the current locale is a RTL locale.
				 * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
				 * to check that {@link goog.LOCALE} is one of a few major RTL locales.
				 *
				 * <p>This is designed to be a maximally efficient compile-time constant. For
				 * example, for the default goog.LOCALE, compiling
				 * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
				 * is this design consideration that limits the implementation to only
				 * supporting a few major RTL locales, as opposed to the broader repertoire of
				 * something like goog.i18n.bidi.isRtlLanguage.
				 *
				 * <p>Since this constant refers to the directionality of the locale, it is up
				 * to the caller to determine if this constant should also be used for the
				 * direction of the UI.
				 *
				 * {@see goog.LOCALE}
				 *
				 * @type {boolean}
				 *
				 * TODO(user): write a test that checks that this is a compile-time constant.
				 */
				goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' || goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' || goog.LOCALE.substring(0, 2).toLowerCase() == 'he' || goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' || goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' || goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' || goog.LOCALE.substring(2, 3) == '_') || goog.LOCALE.length >= 3 && goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' || goog.LOCALE.substring(3, 4) == '_');
				
				/**
				 * Unicode formatting characters and directionality string constants.
				 * @enum {string}
				 */
				goog.i18n.bidi.Format = {
					/** Unicode "Left-To-Right Embedding" (LRE) character. */
					LRE: '\u202A',
					/** Unicode "Right-To-Left Embedding" (RLE) character. */
					RLE: '\u202B',
					/** Unicode "Pop Directional Formatting" (PDF) character. */
					PDF: '\u202C',
					/** Unicode "Left-To-Right Mark" (LRM) character. */
					LRM: '\u200E',
					/** Unicode "Right-To-Left Mark" (RLM) character. */
					RLM: '\u200F'
				};
				
				/**
				 * Directionality enum.
				 * @enum {number}
				 */
				goog.i18n.bidi.Dir = {
					/**
					 * Left-to-right.
					 */
					LTR: 1,
					
					/**
					 * Right-to-left.
					 */
					RTL: -1,
					
					/**
					 * Neither left-to-right nor right-to-left.
					 */
					NEUTRAL: 0
				};
				
				/**
				 * 'right' string constant.
				 * @type {string}
				 */
				goog.i18n.bidi.RIGHT = 'right';
				
				/**
				 * 'left' string constant.
				 * @type {string}
				 */
				goog.i18n.bidi.LEFT = 'left';
				
				/**
				 * 'left' if locale is RTL, 'right' if not.
				 * @type {string}
				 */
				goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;
				
				/**
				 * 'right' if locale is RTL, 'left' if not.
				 * @type {string}
				 */
				goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
				
				/**
				 * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
				 * constant. Useful for interaction with different standards of directionality
				 * representation.
				 *
				 * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
				 *     in one of the following formats:
				 *     1. A goog.i18n.bidi.Dir constant.
				 *     2. A number (positive = LTR, negative = RTL, 0 = neutral).
				 *     3. A boolean (true = RTL, false = LTR).
				 *     4. A null for unknown directionality.
				 * @param {boolean=} opt_noNeutral Whether a givenDir of zero or
				 *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
				 *     order to preserve legacy behavior.
				 * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
				 *     given directionality. If given null, returns null (i.e. unknown).
				 */
				goog.i18n.bidi.toDir = function (givenDir, opt_noNeutral) {
					if (typeof givenDir == 'number') {
						// This includes the non-null goog.i18n.bidi.Dir case.
						return givenDir > 0 ? goog.i18n.bidi.Dir.LTR : givenDir < 0 ? goog.i18n.bidi.Dir.RTL : opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
					} else if (givenDir == null) {
						return null;
					} else {
						// Must be typeof givenDir == 'boolean'.
						return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
					}
				};
				
				/**
				 * A practical pattern to identify strong LTR characters. This pattern is not
				 * theoretically correct according to the Unicode standard. It is simplified for
				 * performance and small code size.
				 * @type {string}
				 * @private
				 */
				goog.i18n.bidi.ltrChars_ = 'A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF' + '\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';
				
				/**
				 * A practical pattern to identify strong RTL character. This pattern is not
				 * theoretically correct according to the Unicode standard. It is simplified
				 * for performance and small code size.
				 * @type {string}
				 * @private
				 */
				goog.i18n.bidi.rtlChars_ = '\u0591-\u06EF\u06FA-\u07FF\u200F\uFB1D-\uFDFF\uFE70-\uFEFC';
				
				/**
				 * Simplified regular expression for an HTML tag (opening or closing) or an HTML
				 * escape. We might want to skip over such expressions when estimating the text
				 * directionality.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;
				
				/**
				 * Returns the input text with spaces instead of HTML tags or HTML escapes, if
				 * opt_isStripNeeded is true. Else returns the input as is.
				 * Useful for text directionality estimation.
				 * Note: the function should not be used in other contexts; it is not 100%
				 * correct, but rather a good-enough implementation for directionality
				 * estimation purposes.
				 * @param {string} str The given string.
				 * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
				 *     Default: false (to retain consistency with calling functions).
				 * @return {string} The given string cleaned of HTML tags / escapes.
				 * @private
				 */
				goog.i18n.bidi.stripHtmlIfNeeded_ = function (str, opt_isStripNeeded) {
					return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;
				};
				
				/**
				 * Regular expression to check for RTL characters.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');
				
				/**
				 * Regular expression to check for LTR characters.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');
				
				/**
				 * Test whether the given string has any RTL characters in it.
				 * @param {string} str The given string that need to be tested.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether the string contains RTL characters.
				 */
				goog.i18n.bidi.hasAnyRtl = function (str, opt_isHtml) {
					return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
				};
				
				/**
				 * Test whether the given string has any RTL characters in it.
				 * @param {string} str The given string that need to be tested.
				 * @return {boolean} Whether the string contains RTL characters.
				 * @deprecated Use hasAnyRtl.
				 */
				goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;
				
				/**
				 * Test whether the given string has any LTR characters in it.
				 * @param {string} str The given string that need to be tested.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether the string contains LTR characters.
				 */
				goog.i18n.bidi.hasAnyLtr = function (str, opt_isHtml) {
					return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
				};
				
				/**
				 * Regular expression pattern to check if the first character in the string
				 * is LTR.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');
				
				/**
				 * Regular expression pattern to check if the first character in the string
				 * is RTL.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');
				
				/**
				 * Check if the first character in the string is RTL or not.
				 * @param {string} str The given string that need to be tested.
				 * @return {boolean} Whether the first character in str is an RTL char.
				 */
				goog.i18n.bidi.isRtlChar = function (str) {
					return goog.i18n.bidi.rtlRe_.test(str);
				};
				
				/**
				 * Check if the first character in the string is LTR or not.
				 * @param {string} str The given string that need to be tested.
				 * @return {boolean} Whether the first character in str is an LTR char.
				 */
				goog.i18n.bidi.isLtrChar = function (str) {
					return goog.i18n.bidi.ltrRe_.test(str);
				};
				
				/**
				 * Check if the first character in the string is neutral or not.
				 * @param {string} str The given string that need to be tested.
				 * @return {boolean} Whether the first character in str is a neutral char.
				 */
				goog.i18n.bidi.isNeutralChar = function (str) {
					return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
				};
				
				/**
				 * Regular expressions to check if a piece of text is of LTR directionality
				 * on first character with strong directionality.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.ltrDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');
				
				/**
				 * Regular expressions to check if a piece of text is of RTL directionality
				 * on first character with strong directionality.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.rtlDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');
				
				/**
				 * Check whether the first strongly directional character (if any) is RTL.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether RTL directionality is detected using the first
				 *     strongly-directional character method.
				 */
				goog.i18n.bidi.startsWithRtl = function (str, opt_isHtml) {
					return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
				};
				
				/**
				 * Check whether the first strongly directional character (if any) is RTL.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether RTL directionality is detected using the first
				 *     strongly-directional character method.
				 * @deprecated Use startsWithRtl.
				 */
				goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;
				
				/**
				 * Check whether the first strongly directional character (if any) is LTR.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether LTR directionality is detected using the first
				 *     strongly-directional character method.
				 */
				goog.i18n.bidi.startsWithLtr = function (str, opt_isHtml) {
					return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
				};
				
				/**
				 * Check whether the first strongly directional character (if any) is LTR.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether LTR directionality is detected using the first
				 *     strongly-directional character method.
				 * @deprecated Use startsWithLtr.
				 */
				goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;
				
				/**
				 * Regular expression to check if a string looks like something that must
				 * always be LTR even in RTL text, e.g. a URL. When estimating the
				 * directionality of text containing these, we treat these as weakly LTR,
				 * like numbers.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;
				
				/**
				 * Check whether the input string either contains no strongly directional
				 * characters or looks like a url.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether neutral directionality is detected.
				 */
				goog.i18n.bidi.isNeutralText = function (str, opt_isHtml) {
					str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
					return goog.i18n.bidi.isRequiredLtrRe_.test(str) || !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
				};
				
				/**
				 * Regular expressions to check if the last strongly-directional character in a
				 * piece of text is LTR.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + '][^' + goog.i18n.bidi.rtlChars_ + ']*$');
				
				/**
				 * Regular expressions to check if the last strongly-directional character in a
				 * piece of text is RTL.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + '][^' + goog.i18n.bidi.ltrChars_ + ']*$');
				
				/**
				 * Check if the exit directionality a piece of text is LTR, i.e. if the last
				 * strongly-directional character in the string is LTR.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether LTR exit directionality was detected.
				 */
				goog.i18n.bidi.endsWithLtr = function (str, opt_isHtml) {
					return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
				};
				
				/**
				 * Check if the exit directionality a piece of text is LTR, i.e. if the last
				 * strongly-directional character in the string is LTR.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether LTR exit directionality was detected.
				 * @deprecated Use endsWithLtr.
				 */
				goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;
				
				/**
				 * Check if the exit directionality a piece of text is RTL, i.e. if the last
				 * strongly-directional character in the string is RTL.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether RTL exit directionality was detected.
				 */
				goog.i18n.bidi.endsWithRtl = function (str, opt_isHtml) {
					return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
				};
				
				/**
				 * Check if the exit directionality a piece of text is RTL, i.e. if the last
				 * strongly-directional character in the string is RTL.
				 * @param {string} str String being checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether RTL exit directionality was detected.
				 * @deprecated Use endsWithRtl.
				 */
				goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;
				
				/**
				 * A regular expression for matching right-to-left language codes.
				 * See {@link #isRtlLanguage} for the design.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.rtlLocalesRe_ = new RegExp('^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' + '.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))' + '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)', 'i');
				
				/**
				 * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
				 * - a language code explicitly specifying one of the right-to-left scripts,
				 *   e.g. "az-Arab", or<p>
				 * - a language code specifying one of the languages normally written in a
				 *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
				 *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
				 * The list of right-to-left scripts appears in the 100-199 range in
				 * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
				 * Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
				 * Tifinagh, which also have significant modern usage. The rest (Syriac,
				 * Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
				 * and are not recognized to save on code size.
				 * The languages usually written in a right-to-left script are taken as those
				 * with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
				 * http://www.iana.org/assignments/language-subtag-registry,
				 * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
				 * Other subtags of the language code, e.g. regions like EG (Egypt), are
				 * ignored.
				 * @param {string} lang BCP 47 (a.k.a III) language code.
				 * @return {boolean} Whether the language code is an RTL language.
				 */
				goog.i18n.bidi.isRtlLanguage = function (lang) {
					return goog.i18n.bidi.rtlLocalesRe_.test(lang);
				};
				
				/**
				 * Regular expression for bracket guard replacement in text.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
				
				/**
				 * Apply bracket guard using LRM and RLM. This is to address the problem of
				 * messy bracket display frequently happens in RTL layout.
				 * This function works for plain text, not for HTML. In HTML, the opening
				 * bracket might be in a different context than the closing bracket (such as
				 * an attribute value).
				 * @param {string} s The string that need to be processed.
				 * @param {boolean=} opt_isRtlContext specifies default direction (usually
				 *     direction of the UI).
				 * @return {string} The processed string, with all bracket guarded.
				 */
				goog.i18n.bidi.guardBracketInText = function (s, opt_isRtlContext) {
					var useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
					var mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
					return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);
				};
				
				/**
				 * Enforce the html snippet in RTL directionality regardless overall context.
				 * If the html piece was enclosed by tag, dir will be applied to existing
				 * tag, otherwise a span tag will be added as wrapper. For this reason, if
				 * html snippet start with with tag, this tag must enclose the whole piece. If
				 * the tag already has a dir specified, this new one will override existing
				 * one in behavior (tested on FF and IE).
				 * @param {string} html The string that need to be processed.
				 * @return {string} The processed string, with directionality enforced to RTL.
				 */
				goog.i18n.bidi.enforceRtlInHtml = function (html) {
					if (html.charAt(0) == '<') {
						return html.replace(/<\w+/, '$& dir=rtl');
					}
					// '\n' is important for FF so that it won't incorrectly merge span groups
					return '\n<span dir=rtl>' + html + '</span>';
				};
				
				/**
				 * Enforce RTL on both end of the given text piece using unicode BiDi formatting
				 * characters RLE and PDF.
				 * @param {string} text The piece of text that need to be wrapped.
				 * @return {string} The wrapped string after process.
				 */
				goog.i18n.bidi.enforceRtlInText = function (text) {
					return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
				};
				
				/**
				 * Enforce the html snippet in RTL directionality regardless overall context.
				 * If the html piece was enclosed by tag, dir will be applied to existing
				 * tag, otherwise a span tag will be added as wrapper. For this reason, if
				 * html snippet start with with tag, this tag must enclose the whole piece. If
				 * the tag already has a dir specified, this new one will override existing
				 * one in behavior (tested on FF and IE).
				 * @param {string} html The string that need to be processed.
				 * @return {string} The processed string, with directionality enforced to RTL.
				 */
				goog.i18n.bidi.enforceLtrInHtml = function (html) {
					if (html.charAt(0) == '<') {
						return html.replace(/<\w+/, '$& dir=ltr');
					}
					// '\n' is important for FF so that it won't incorrectly merge span groups
					return '\n<span dir=ltr>' + html + '</span>';
				};
				
				/**
				 * Enforce LTR on both end of the given text piece using unicode BiDi formatting
				 * characters LRE and PDF.
				 * @param {string} text The piece of text that need to be wrapped.
				 * @return {string} The wrapped string after process.
				 */
				goog.i18n.bidi.enforceLtrInText = function (text) {
					return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
				};
				
				/**
				 * Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;
				
				/**
				 * Regular expression for left.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.leftRe_ = /left/gi;
				
				/**
				 * Regular expression for right.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.rightRe_ = /right/gi;
				
				/**
				 * Placeholder regular expression for swapping.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.tempRe_ = /%%%%/g;
				
				/**
				 * Swap location parameters and 'left'/'right' in CSS specification. The
				 * processed string will be suited for RTL layout. Though this function can
				 * cover most cases, there are always exceptions. It is suggested to put
				 * those exceptions in separate group of CSS string.
				 * @param {string} cssStr CSS spefication string.
				 * @return {string} Processed CSS specification string.
				 */
				goog.i18n.bidi.mirrorCSS = function (cssStr) {
					return cssStr.
					// reverse dimensions
					replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2').replace(goog.i18n.bidi.leftRe_, '%%%%'). // swap left and right
					replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
				};
				
				/**
				 * Regular expression for hebrew double quote substitution, finding quote
				 * directly after hebrew characters.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;
				
				/**
				 * Regular expression for hebrew single quote substitution, finding quote
				 * directly after hebrew characters.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;
				
				/**
				 * Replace the double and single quote directly after a Hebrew character with
				 * GERESH and GERSHAYIM. In such case, most likely that's user intention.
				 * @param {string} str String that need to be processed.
				 * @return {string} Processed string with double/single quote replaced.
				 */
				goog.i18n.bidi.normalizeHebrewQuote = function (str) {
					return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\u05F4').replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\u05F3');
				};
				
				/**
				 * Regular expression to split a string into "words" for directionality
				 * estimation based on relative word counts.
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.wordSeparatorRe_ = /\s+/;
				
				/**
				 * Regular expression to check if a string contains any numerals. Used to
				 * differentiate between completely neutral strings and those containing
				 * numbers, which are weakly LTR.
				 *
				 * Native Arabic digits (\u0660 - \u0669) are not included because although they
				 * do flow left-to-right inside a number, this is the case even if the  overall
				 * directionality is RTL, and a mathematical expression using these digits is
				 * supposed to flow right-to-left overall, including unary plus and minus
				 * appearing to the right of a number, and this does depend on the overall
				 * directionality being RTL. The digits used in Farsi (\u06F0 - \u06F9), on the
				 * other hand, are included, since Farsi math (including unary plus and minus)
				 * does flow left-to-right.
				 *
				 * @type {RegExp}
				 * @private
				 */
				goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;
				
				/**
				 * This constant controls threshold of RTL directionality.
				 * @type {number}
				 * @private
				 */
				goog.i18n.bidi.rtlDetectionThreshold_ = 0.40;
				
				/**
				 * Estimates the directionality of a string based on relative word counts.
				 * If the number of RTL words is above a certain percentage of the total number
				 * of strongly directional words, returns RTL.
				 * Otherwise, if any words are strongly or weakly LTR, returns LTR.
				 * Otherwise, returns UNKNOWN, which is used to mean "neutral".
				 * Numbers are counted as weakly LTR.
				 * @param {string} str The string to be checked.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
				 */
				goog.i18n.bidi.estimateDirection = function (str, opt_isHtml) {
					var rtlCount = 0;
					var totalCount = 0;
					var hasWeaklyLtr = false;
					var tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_);
					for (var i = 0; i < tokens.length; i++) {
						var token = tokens[i];
						if (goog.i18n.bidi.startsWithRtl(token)) {
							rtlCount++;
							totalCount++;
						} else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {
							hasWeaklyLtr = true;
						} else if (goog.i18n.bidi.hasAnyLtr(token)) {
							totalCount++;
						} else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {
							hasWeaklyLtr = true;
						}
					}
					
					return totalCount == 0 ? hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
				};
				
				/**
				 * Check the directionality of a piece of text, return true if the piece of
				 * text should be laid out in RTL direction.
				 * @param {string} str The piece of text that need to be detected.
				 * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
				 *     Default: false.
				 * @return {boolean} Whether this piece of text should be laid out in RTL.
				 */
				goog.i18n.bidi.detectRtlDirectionality = function (str, opt_isHtml) {
					return goog.i18n.bidi.estimateDirection(str, opt_isHtml) == goog.i18n.bidi.Dir.RTL;
				};
				
				/**
				 * Sets text input element's directionality and text alignment based on a
				 * given directionality. Does nothing if the given directionality is unknown or
				 * neutral.
				 * @param {Element} element Input field element to set directionality to.
				 * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
				 *     given in one of the following formats:
				 *     1. A goog.i18n.bidi.Dir constant.
				 *     2. A number (positive = LRT, negative = RTL, 0 = neutral).
				 *     3. A boolean (true = RTL, false = LTR).
				 *     4. A null for unknown directionality.
				 */
				goog.i18n.bidi.setElementDirAndAlign = function (element, dir) {
					if (element) {
						dir = goog.i18n.bidi.toDir(dir);
						if (dir) {
							element.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
							element.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
						}
					}
				};
				
				/**
				 * Sets element dir based on estimated directionality of the given text.
				 * @param {!Element} element
				 * @param {string} text
				 */
				goog.i18n.bidi.setElementDirByTextDirectionality = function (element, text) {
					switch (goog.i18n.bidi.estimateDirection(text)) {
						case goog.i18n.bidi.Dir.LTR:
							element.dir = 'ltr';
							break;
						case goog.i18n.bidi.Dir.RTL:
							element.dir = 'rtl';
							break;
						default:
							// Default for no direction, inherit from document.
							element.removeAttribute('dir');
					}
				};
				
				/**
				 * Strings that have an (optional) known direction.
				 *
				 * Implementations of this interface are string-like objects that carry an
				 * attached direction, if known.
				 * @interface
				 */
				goog.i18n.bidi.DirectionalString = function () {};
				
				/**
				 * Interface marker of the DirectionalString interface.
				 *
				 * This property can be used to determine at runtime whether or not an object
				 * implements this interface.  All implementations of this interface set this
				 * property to {@code true}.
				 * @type {boolean}
				 */
				goog.i18n.bidi.DirectionalString.prototype.implementsGoogI18nBidiDirectionalString;
				
				/**
				 * Retrieves this object's known direction (if any).
				 * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.
				 */
				goog.i18n.bidi.DirectionalString.prototype.getDirection;
				
				// Copyright 2008 The Closure Library Authors. All Rights Reserved.
				//
				// Licensed under the Apache License, Version 2.0 (the "License");
				// you may not use this file except in compliance with the License.
				// You may obtain a copy of the License at
				//
				//      http://www.apache.org/licenses/LICENSE-2.0
				//
				// Unless required by applicable law or agreed to in writing, software
				// distributed under the License is distributed on an "AS-IS" BASIS,
				// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
				// See the License for the specific language governing permissions and
				// limitations under the License.
				
				/**
				 * @fileoverview Utilities to check the preconditions, postconditions and
				 * invariants runtime.
				 *
				 * Methods in this package should be given special treatment by the compiler
				 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
				 * will restrict <code>foo</code> to a truthy value.
				 *
				 * The compiler has an option to disable asserts. So code like:
				 * <code>
				 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
				 * </code>
				 * will be transformed into:
				 * <code>
				 * var x = foo();
				 * </code>
				 * The compiler will leave in foo() (because its return value is used),
				 * but it will remove bar() because it assumes it does not have side-effects.
				 *
				 * @author agrieve@google.com (Andrew Grieve)
				 */
				
				goog.provide('goog.asserts');
				
				/**
				 * @define {boolean} Whether to strip out asserts or to leave them in.
				 */
				goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);
				
				/**
				 * Error object for failed assertions.
				 * @param {string} messagePattern The pattern that was used to form message.
				 * @param {!Array<*>} messageArgs The items to substitute into the pattern.
				 * @constructor
				 * @extends {goog.debug.Error}
				 * @final
				 */
				goog.asserts.AssertionError = function (messagePattern, messageArgs) {
					messageArgs.unshift(messagePattern);
					goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
					// Remove the messagePattern afterwards to avoid permanently modifying the
					// passed in array.
					messageArgs.shift();
					
					/**
					 * The message pattern used to format the error message. Error handlers can
					 * use this to uniquely identify the assertion.
					 * @type {string}
					 */
					this.messagePattern = messagePattern;
				};
				goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
				
				/** @override */
				goog.asserts.AssertionError.prototype.name = 'AssertionError';
				
				/**
				 * The default error handler.
				 * @param {!goog.asserts.AssertionError} e The exception to be handled.
				 */
				goog.asserts.DEFAULT_ERROR_HANDLER = function (e) {
					throw e;
				};
				
				/**
				 * The handler responsible for throwing or logging assertion errors.
				 * @private {function(!goog.asserts.AssertionError)}
				 */
				goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;
				
				/**
				 * Throws an exception with the given message and "Assertion failed" prefixed
				 * onto it.
				 * @param {string} defaultMessage The message to use if givenMessage is empty.
				 * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
				 * @param {string|undefined} givenMessage Message supplied by the caller.
				 * @param {Array<*>} givenArgs The substitution arguments for givenMessage.
				 * @throws {goog.asserts.AssertionError} When the value is not a number.
				 * @private
				 */
				goog.asserts.doAssertFailure_ = function (defaultMessage, defaultArgs, givenMessage, givenArgs) {
					var message = 'Assertion failed';
					if (givenMessage) {
						message += ': ' + givenMessage;
						var args = givenArgs;
					} else if (defaultMessage) {
						message += ': ' + defaultMessage;
						args = defaultArgs;
					}
					// The '' + works around an Opera 10 bug in the unit tests. Without it,
					// a stack trace is added to var message above. With this, a stack trace is
					// not added until this line (it causes the extra garbage to be added after
					// the assertion message instead of in the middle of it).
					var e = new goog.asserts.AssertionError('' + message, args || []);
					goog.asserts.errorHandler_(e);
				};
				
				/**
				 * Sets a custom error handler that can be used to customize the behavior of
				 * assertion failures, for example by turning all assertion failures into log
				 * messages.
				 * @param {function(!goog.asserts.AssertionError)} errorHandler
				 */
				goog.asserts.setErrorHandler = function (errorHandler) {
					if (goog.asserts.ENABLE_ASSERTS) {
						goog.asserts.errorHandler_ = errorHandler;
					}
				};
				
				/**
				 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
				 * true.
				 * @template T
				 * @param {T} condition The condition to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {T} The value of the condition.
				 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
				 */
				goog.asserts.assert = function (condition, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !condition) {
						goog.asserts.doAssertFailure_('', null, opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return condition;
				};
				
				/**
				 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
				 * when we want to add a check in the unreachable area like switch-case
				 * statement:
				 *
				 * <pre>
				 *  switch(type) {
   *    case FOO: doSomething(); break;
   *    case BAR: doSomethingElse(); break;
   *    default: goog.assert.fail('Unrecognized type: ' + type);
   *      // We have only 2 types - "default:" section is unreachable code.
   *  }
				 * </pre>
				 *
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @throws {goog.asserts.AssertionError} Failure.
				 */
				goog.asserts.fail = function (opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS) {
						goog.asserts.errorHandler_(new goog.asserts.AssertionError('Failure' + (opt_message ? ': ' + opt_message : ''), Array.prototype.slice.call(arguments, 1)));
					}
				};
				
				/**
				 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {number} The value, guaranteed to be a number when asserts enabled.
				 * @throws {goog.asserts.AssertionError} When the value is not a number.
				 */
				goog.asserts.assertNumber = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
						goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {number} */value
					);
				};
				
				/**
				 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {string} The value, guaranteed to be a string when asserts enabled.
				 * @throws {goog.asserts.AssertionError} When the value is not a string.
				 */
				goog.asserts.assertString = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
						goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {string} */value
					);
				};
				
				/**
				 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {!Function} The value, guaranteed to be a function when asserts
				 *     enabled.
				 * @throws {goog.asserts.AssertionError} When the value is not a function.
				 */
				goog.asserts.assertFunction = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
						goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {!Function} */value
					);
				};
				
				/**
				 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {!Object} The value, guaranteed to be a non-null object.
				 * @throws {goog.asserts.AssertionError} When the value is not an object.
				 */
				goog.asserts.assertObject = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
						goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {!Object} */value
					);
				};
				
				/**
				 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {!Array<?>} The value, guaranteed to be a non-null array.
				 * @throws {goog.asserts.AssertionError} When the value is not an array.
				 */
				goog.asserts.assertArray = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
						goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {!Array<?>} */value
					);
				};
				
				/**
				 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {boolean} The value, guaranteed to be a boolean when asserts are
				 *     enabled.
				 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
				 */
				goog.asserts.assertBoolean = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
						goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {boolean} */value
					);
				};
				
				/**
				 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
				 * @param {*} value The value to check.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @return {!Element} The value, likely to be a DOM Element when asserts are
				 *     enabled.
				 * @throws {goog.asserts.AssertionError} When the value is not an Element.
				 */
				goog.asserts.assertElement = function (value, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) {
						goog.asserts.doAssertFailure_('Expected Element but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
					}
					return (/** @type {!Element} */value
					);
				};
				
				/**
				 * Checks if the value is an instance of the user-defined type if
				 * goog.asserts.ENABLE_ASSERTS is true.
				 *
				 * The compiler may tighten the type returned by this function.
				 *
				 * @param {?} value The value to check.
				 * @param {function(new: T, ...)} type A user-defined constructor.
				 * @param {string=} opt_message Error message in case of failure.
				 * @param {...*} var_args The items to substitute into the failure message.
				 * @throws {goog.asserts.AssertionError} When the value is not an instance of
				 *     type.
				 * @return {T}
				 * @template T
				 */
				goog.asserts.assertInstanceof = function (value, type, opt_message, var_args) {
					if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
						goog.asserts.doAssertFailure_('Expected instanceof %s but got %s.', [goog.asserts.getType_(type), goog.asserts.getType_(value)], opt_message, Array.prototype.slice.call(arguments, 3));
					}
					return value;
				};
				
				/**
				 * Checks that no enumerable keys are present in Object.prototype. Such keys
				 * would break most code that use {@code for (var ... in ...)} loops.
				 */
				goog.asserts.assertObjectPrototypeIsIntact = function () {
					for (var key in Object.prototype) {
						goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
					}
				};
				
				/**
				 * Returns the type of a value. If a constructor is passed, and a suitable
				 * string cannot be found, 'unknown type name' will be returned.
				 * @param {*} value A constructor, object, or primitive.
				 * @return {string} The best display name for the value, or 'unknown type name'.
				 * @private
				 */
				goog.asserts.getType_ = function (value) {
					if (value instanceof Function) {
						return value.displayName || value.name || 'unknown type name';
					} else if (value instanceof Object) {
						return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
					} else {
						return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
					}
				};
				
				/**
				 * @fileoverview Utility for fast string concatenation.
				 */
				
				/**
				 * Utility class to facilitate string concatenation.
				 *
				 * @param {*=} opt_a1 Optional first initial item to append.
				 * @param {...*} var_args Other initial items to
				 *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
				 * @constructor
				 */
				goog.string.StringBuffer = function (opt_a1, var_args) {
					if (opt_a1 != null) {
						this.append.apply(this, arguments);
					}
				};
				
				/**
				 * Internal buffer for the string to be concatenated.
				 * @type {string}
				 * @private
				 */
				goog.string.StringBuffer.prototype.buffer_ = '';
				
				/**
				 * Sets the contents of the string buffer object, replacing what's currently
				 * there.
				 *
				 * @param {*} s String to set.
				 */
				goog.string.StringBuffer.prototype.set = function (s) {
					this.buffer_ = '' + s;
				};
				
				/**
				 * Appends one or more items to the buffer.
				 *
				 * Calling this with null, undefined, or empty arguments is an error.
				 *
				 * @param {*} a1 Required first string.
				 * @param {*=} opt_a2 Optional second string.
				 * @param {...?} var_args Other items to append,
				 *     e.g., sb.append('foo', 'bar', 'baz').
				 * @return {!goog.string.StringBuffer} This same StringBuffer object.
				 * @suppress {duplicate}
				 */
				goog.string.StringBuffer.prototype.append = function (a1, opt_a2, var_args) {
					// Use a1 directly to avoid arguments instantiation for single-arg case.
					this.buffer_ += String(a1);
					if (opt_a2 != null) {
						// second argument is undefined (null == undefined)
						for (var i = 1; i < arguments.length; i++) {
							this.buffer_ += arguments[i];
						}
					}
					return this;
				};
				
				/**
				 * Clears the internal buffer.
				 */
				goog.string.StringBuffer.prototype.clear = function () {
					this.buffer_ = '';
				};
				
				/**
				 * @return {number} the length of the current contents of the buffer.
				 */
				goog.string.StringBuffer.prototype.getLength = function () {
					return this.buffer_.length;
				};
				
				/**
				 * @return {string} The concatenated string.
				 * @override
				 */
				goog.string.StringBuffer.prototype.toString = function () {
					return this.buffer_;
				};
				
				// Copyright 2012 The Closure Library Authors. All Rights Reserved.
				//
				// Licensed under the Apache License, Version 2.0 (the "License");
				// you may not use this file except in compliance with the License.
				// You may obtain a copy of the License at
				//
				//      http://www.apache.org/licenses/LICENSE-2.0
				//
				// Unless required by applicable law or agreed to in writing, software
				// distributed under the License is distributed on an "AS-IS" BASIS,
				// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
				// See the License for the specific language governing permissions and
				// limitations under the License.
				
				/**
				 * @fileoverview Soy data primitives.
				 *
				 * The goal is to encompass data types used by Soy, especially to mark content
				 * as known to be "safe".
				 *
				 * @author gboyer@google.com (Garrett Boyer)
				 */
				
				goog.soy = {};
				goog.soy.data = {};
				
				/**
				 * A type of textual content.
				 *
				 * This is an enum of type Object so that these values are unforgeable.
				 *
				 * @enum {!Object}
				 */
				goog.soy.data.SanitizedContentKind = {
					
					/**
					 * A snippet of HTML that does not start or end inside a tag, comment, entity,
					 * or DOCTYPE; and that does not contain any executable code
					 * (JS, {@code <object>}s, etc.) from a different trust domain.
					 */
					HTML: goog.DEBUG ? { sanitizedContentKindHtml: true } : {},
					
					/**
					 * Executable Javascript code or expression, safe for insertion in a
					 * script-tag or event handler context, known to be free of any
					 * attacker-controlled scripts. This can either be side-effect-free
					 * Javascript (such as JSON) or Javascript that's entirely under Google's
					 * control.
					 */
					JS: goog.DEBUG ? { sanitizedContentJsChars: true } : {},
					
					/** A properly encoded portion of a URI. */
					URI: goog.DEBUG ? { sanitizedContentUri: true } : {},
					
					/** A resource URI not under attacker control. */
					TRUSTED_RESOURCE_URI: goog.DEBUG ? { sanitizedContentTrustedResourceUri: true } : {},
					
					/**
					 * Repeated attribute names and values. For example,
					 * {@code dir="ltr" foo="bar" onclick="trustedFunction()" checked}.
					 */
					ATTRIBUTES: goog.DEBUG ? { sanitizedContentHtmlAttribute: true } : {},
					
					// TODO: Consider separating rules, declarations, and values into
					// separate types, but for simplicity, we'll treat explicitly blessed
					// SanitizedContent as allowed in all of these contexts.
					/**
					 * A CSS3 declaration, property, value or group of semicolon separated
					 * declarations.
					 */
					CSS: goog.DEBUG ? { sanitizedContentCss: true } : {},
					
					/**
					 * Unsanitized plain-text content.
					 *
					 * This is effectively the "null" entry of this enum, and is sometimes used
					 * to explicitly mark content that should never be used unescaped. Since any
					 * string is safe to use as text, being of ContentKind.TEXT makes no
					 * guarantees about its safety in any other context such as HTML.
					 */
					TEXT: goog.DEBUG ? { sanitizedContentKindText: true } : {}
				};
				
				/**
				 * A string-like object that carries a content-type and a content direction.
				 *
				 * IMPORTANT! Do not create these directly, nor instantiate the subclasses.
				 * Instead, use a trusted, centrally reviewed library as endorsed by your team
				 * to generate these objects. Otherwise, you risk accidentally creating
				 * SanitizedContent that is attacker-controlled and gets evaluated unescaped in
				 * templates.
				 *
				 * @constructor
				 */
				goog.soy.data.SanitizedContent = function () {
					throw Error('Do not instantiate directly');
				};
				
				/**
				 * The context in which this content is safe from XSS attacks.
				 * @type {goog.soy.data.SanitizedContentKind}
				 */
				goog.soy.data.SanitizedContent.prototype.contentKind;
				
				/**
				 * The content's direction; null if unknown and thus to be estimated when
				 * necessary.
				 * @type {?goog.i18n.bidi.Dir}
				 */
				goog.soy.data.SanitizedContent.prototype.contentDir = null;
				
				/**
				 * The already-safe content.
				 * @protected {string}
				 */
				goog.soy.data.SanitizedContent.prototype.content;
				
				/**
				 * Gets the already-safe content.
				 * @return {string}
				 */
				goog.soy.data.SanitizedContent.prototype.getContent = function () {
					return this.content;
				};
				
				/** @override */
				goog.soy.data.SanitizedContent.prototype.toString = function () {
					return this.content;
				};
				
				/**
				 * An intermediary base class to allow the type system to sepcify text templates
				 * without referencing the soydata package.
				 * @extends {goog.soy.data.SanitizedContent}
				 * @constructor
				 */
				goog.soy.data.UnsanitizedText = function () {
					// TODO(gboyer): Delete this class after moving soydata to Closure.
					goog.soy.data.UnsanitizedText.base(this, 'constructor');
				};
				
				goog.inherits(goog.soy.data.UnsanitizedText, goog.soy.data.SanitizedContent);
				
				/**
				 * Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
				 *
				 * The content is a string of HTML that can safely be embedded in a PCDATA
				 * context in your app.  If you would be surprised to find that an HTML
				 * sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
				 * you wouldn't write a template that produces {@code s} on security or privacy
				 * grounds, then don't pass {@code s} here. The default content direction is
				 * unknown, i.e. to be estimated when necessary.
				 *
				 * @extends {goog.soy.data.SanitizedContent}
				 * @constructor
				 */
				goog.soy.data.SanitizedHtml = function () {
					goog.soy.data.SanitizedHtml.base(this, 'constructor');
				};
				goog.inherits(goog.soy.data.SanitizedHtml, goog.soy.data.SanitizedContent);
				
				/** @override */
				goog.soy.data.SanitizedHtml.prototype.contentKind = goog.soy.data.SanitizedContentKind.HTML;
				
				/**
				 * Checks if the value could be used as the Soy type {html}.
				 * @param {*} value
				 * @return {boolean}
				 */
				goog.soy.data.SanitizedHtml.isCompatibleWith = function (value) {
					return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtml || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeHtml;
				};
				
				/*
				 * Copyright 2008 Google Inc.
				 *
				 * Licensed under the Apache License, Version 2.0 (the "License");
				 * you may not use this file except in compliance with the License.
				 * You may obtain a copy of the License at
				 *
				 *     http://www.apache.org/licenses/LICENSE-2.0
				 *
				 * Unless required by applicable law or agreed to in writing, software
				 * distributed under the License is distributed on an "AS IS" BASIS,
				 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
				 * See the License for the specific language governing permissions and
				 * limitations under the License.
				 */
				
				/**
				 * @fileoverview
				 * Utility functions and classes for Soy.
				 *
				 * <p>
				 * The top portion of this file contains utilities for Soy users:<ul>
				 *   <li> soy.StringBuilder: Compatible with the 'stringbuilder' code style.
				 * </ul>
				 *
				 * <p>
				 * The bottom portion of this file contains utilities that should only be called
				 * by Soy-generated JS code. Please do not use these functions directly from
				 * your hand-writen code. Their names all start with '$$'.
				 *
				 */
				
				// -----------------------------------------------------------------------------
				// StringBuilder (compatible with the 'stringbuilder' code style).
				
				(function () {
					var soy = {};
					soy.asserts = {};
					soy.esc = {};
					var soydata = {};
					
					/**
					 * Utility class to facilitate much faster string concatenation in IE,
					 * using Array.join() rather than the '+' operator. For other browsers
					 * we simply use the '+' operator.
					 *
					 * @param {Object} var_args Initial items to append,
					 *     e.g., new soy.StringBuilder('foo', 'bar').
					 * @constructor
					 */
					soy.StringBuilder = goog.string.StringBuffer;
					
					// -----------------------------------------------------------------------------
					// soydata: Defines typed strings, e.g. an HTML string {@code "a<b>c"} is
					// semantically distinct from the plain text string {@code "a<b>c"} and smart
					// templates can take that distinction into account.
					
					/**
					 * A type of textual content.
					 *
					 * This is an enum of type Object so that these values are unforgeable.
					 *
					 * @enum {!Object}
					 */
					soydata.SanitizedContentKind = goog.soy.data.SanitizedContentKind;
					
					/**
					 * Checks whether a given value is of a given content kind.
					 *
					 * @param {*} value The value to be examined.
					 * @param {soydata.SanitizedContentKind} contentKind The desired content
					 *     kind.
					 * @return {boolean} Whether the given value is of the given kind.
					 * @private
					 */
					soydata.isContentKind = function (value, contentKind) {
						// TODO(user): This function should really include the assert on
						// value.constructor that is currently sprinkled at most of the call sites.
						// Unfortunately, that would require a (debug-mode-only) switch statement.
						// TODO(user): Perhaps we should get rid of the contentKind property
						// altogether and only at the constructor.
						return value != null && value.contentKind === contentKind;
					};
					
					/**
					 * Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
					 *
					 * The content is a string of HTML that can safely be embedded in a PCDATA
					 * context in your app.  If you would be surprised to find that an HTML
					 * sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
					 * you wouldn't write a template that produces {@code s} on security or privacy
					 * grounds, then don't pass {@code s} here. The default content direction is
					 * unknown, i.e. to be estimated when necessary.
					 *
					 * @constructor
					 * @extends {goog.soy.data.SanitizedHtml}
					 */
					soydata.SanitizedHtml = function () {
						soydata.SanitizedHtml.base(this, 'constructor'); // Throws an exception.
					};
					goog.inherits(soydata.SanitizedHtml, goog.soy.data.SanitizedHtml);
					
					/**
					 * Returns a SanitizedHtml object for a particular value. The content direction
					 * is preserved.
					 *
					 * This HTML-escapes the value unless it is already SanitizedHtml or SafeHtml.
					 *
					 * @param {*} value The value to convert. If it is already a SanitizedHtml
					 *     object, it is left alone.
					 * @return {!soydata.SanitizedHtml} A SanitizedHtml object derived from the
					 *     stringified value. It is escaped unless the input is SanitizedHtml or
					 *     SafeHtml.
					 */
					soydata.SanitizedHtml.from = function (value) {
						// The check is soydata.isContentKind_() inlined for performance.
						if (value != null && value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
							goog.asserts.assert(value.constructor === goog.soy.data.SanitizedHtml || value.constructor === soydata.SanitizedHtml);
							return (/** @type {!soydata.SanitizedHtml} */value
							);
						}
						if (value instanceof goog.html.SafeHtml) {
							return soydata.VERY_UNSAFE.ordainSanitizedHtml(goog.html.SafeHtml.unwrap(value), value.getDirection());
						}
						return soydata.VERY_UNSAFE.ordainSanitizedHtml(soy.esc.$$escapeHtmlHelper(String(value)), soydata.getContentDir(value));
					};
					
					/**
					 * Checks if the value could be used as the Soy type {html}.
					 * @param {*} value
					 * @return {boolean}
					 */
					soydata.SanitizedHtml.isCompatibleWith = function (value) {
						return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtml || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeHtml;
					};
					
					/**
					 * Content of type {@link soydata.SanitizedContentKind.URI}.
					 *
					 * The content is a URI chunk that the caller knows is safe to emit in a
					 * template. The content direction is LTR.
					 *
					 * @constructor
					 * @extends {goog.soy.data.SanitizedContent}
					 */
					soydata.SanitizedUri = function () {
						goog.soy.data.SanitizedContent.call(this); // Throws an exception.
					};
					goog.inherits(soydata.SanitizedUri, goog.soy.data.SanitizedContent);
					
					/** @override */
					soydata.SanitizedUri.prototype.contentKind = soydata.SanitizedContentKind.URI;
					
					/** @override */
					soydata.SanitizedUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;
					
					/**
					 * Unsanitized plain text string.
					 *
					 * While all strings are effectively safe to use as a plain text, there are no
					 * guarantees about safety in any other context such as HTML. This is
					 * sometimes used to mark that should never be used unescaped.
					 *
					 * @param {*} content Plain text with no guarantees.
					 * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
					 *     unknown and thus to be estimated when necessary. Default: null.
					 * @constructor
					 * @extends {goog.soy.data.UnsanitizedText}
					 */
					soydata.UnsanitizedText = function (content, opt_contentDir) {
						/** @override */
						this.content = String(content);
						this.contentDir = opt_contentDir != null ? opt_contentDir : null;
					};
					goog.inherits(soydata.UnsanitizedText, goog.soy.data.UnsanitizedText);
					
					/** @override */
					soydata.UnsanitizedText.prototype.contentKind = soydata.SanitizedContentKind.TEXT;
					
					/**
					 * Empty string, used as a type in Soy templates.
					 * @enum {string}
					 * @private
					 */
					soydata.$$EMPTY_STRING_ = {
						VALUE: ''
					};
					
					/**
					 * Creates a factory for SanitizedContent types.
					 *
					 * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
					 * instantiate Sanitized* classes, without making the Sanitized* constructors
					 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
					 * helps callers and their reviewers easily tell that creating SanitizedContent
					 * is not always safe and calls for careful review.
					 *
					 * @param {function(new: T)} ctor A constructor.
					 * @return {!function(*, ?goog.i18n.bidi.Dir=): T} A factory that takes
					 *     content and an optional content direction and returns a new instance. If
					 *     the content direction is undefined, ctor.prototype.contentDir is used.
					 * @template T
					 * @private
					 */
					soydata.$$makeSanitizedContentFactory_ = function (ctor) {
						/**
						 * @param {string} content
						 * @constructor
						 * @extends {goog.soy.data.SanitizedContent}
						 */
						function InstantiableCtor(content) {
							/** @override */
							this.content = content;
						}
						InstantiableCtor.prototype = ctor.prototype;
						/**
						 * Creates a ctor-type SanitizedContent instance.
						 *
						 * @param {*} content The content to put in the instance.
						 * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction. If
						 *     undefined, ctor.prototype.contentDir is used.
						 * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
						 *     of type T above (ctor's type, a descendant of SanitizedContent), but
						 *     there is no way to express that here.
						 */
						function sanitizedContentFactory(content, opt_contentDir) {
							var result = new InstantiableCtor(String(content));
							if (opt_contentDir !== undefined) {
								result.contentDir = opt_contentDir;
							}
							return result;
						}
						return sanitizedContentFactory;
					};
					
					/**
					 * Creates a factory for SanitizedContent types that should always have their
					 * default directionality.
					 *
					 * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
					 * instantiate Sanitized* classes, without making the Sanitized* constructors
					 * publicly usable. Requiring all construction to use the VERY_UNSAFE names
					 * helps callers and their reviewers easily tell that creating SanitizedContent
					 * is not always safe and calls for careful review.
					 *
					 * @param {function(new: T, string)} ctor A constructor.
					 * @return {!function(*): T} A factory that takes content and returns a new
					 *     instance (with default directionality, i.e. ctor.prototype.contentDir).
					 * @template T
					 * @private
					 */
					soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_ = function (ctor) {
						/**
						 * @param {string} content
						 * @constructor
						 * @extends {goog.soy.data.SanitizedContent}
						 */
						function InstantiableCtor(content) {
							/** @override */
							this.content = content;
						}
						InstantiableCtor.prototype = ctor.prototype;
						/**
						 * Creates a ctor-type SanitizedContent instance.
						 *
						 * @param {*} content The content to put in the instance.
						 * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
						 *     of type T above (ctor's type, a descendant of SanitizedContent), but
						 *     there is no way to express that here.
						 */
						function sanitizedContentFactory(content) {
							var result = new InstantiableCtor(String(content));
							return result;
						}
						return sanitizedContentFactory;
					};
					
					// -----------------------------------------------------------------------------
					// Sanitized content ordainers. Please use these with extreme caution (with the
					// exception of markUnsanitizedText). A good recommendation is to limit usage
					// of these to just a handful of files in your source tree where usages can be
					// carefully audited.
					
					
					/**
					 * Protects a string from being used in an noAutoescaped context.
					 *
					 * This is useful for content where there is significant risk of accidental
					 * unescaped usage in a Soy template. A great case is for user-controlled
					 * data that has historically been a source of vulernabilities.
					 *
					 * @param {*} content Text to protect.
					 * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
					 *     unknown and thus to be estimated when necessary. Default: null.
					 * @return {!soydata.UnsanitizedText} A wrapper that is rejected by the
					 *     Soy noAutoescape print directive.
					 */
					soydata.markUnsanitizedText = function (content, opt_contentDir) {
						return new soydata.UnsanitizedText(content, opt_contentDir);
					};
					
					soydata.VERY_UNSAFE = {};
					
					/**
					 * Takes a leap of faith that the provided content is "safe" to use as a URI
					 * in a Soy template.
					 *
					 * This creates a Soy SanitizedContent object which indicates to Soy there is
					 * no need to escape it when printed as a URI (e.g. in an href or src
					 * attribute), such as if it's already been encoded or  if it's a Javascript:
					 * URI.
					 *
					 * @param {*} content A chunk of URI that the caller knows is safe to
					 *     emit in a template.
					 * @return {!soydata.SanitizedUri} Sanitized content wrapper that indicates to
					 *     Soy not to escape or filter when printed in URI context.
					 */
					soydata.VERY_UNSAFE.ordainSanitizedUri = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedUri);
					
					// -----------------------------------------------------------------------------
					// Below are private utilities to be used by Soy-generated code only.
					
					/**
					 * Builds an augmented map. The returned map will contain mappings from both
					 * the base map and the additional map. If the same key appears in both, then
					 * the value from the additional map will be visible, while the value from the
					 * base map will be hidden. The base map will be used, but not modified.
					 *
					 * @param {!Object} baseMap The original map to augment.
					 * @param {!Object} additionalMap A map containing the additional mappings.
					 * @return {!Object} An augmented map containing both the original and
					 *     additional mappings.
					 */
					soy.$$augmentMap = function (baseMap, additionalMap) {
						return soy.$$assignDefaults(soy.$$assignDefaults({}, additionalMap), baseMap);
					};
					
					/**
					 * Copies extra properties into an object if they do not already exist. The
					 * destination object is mutated in the process.
					 *
					 * @param {!Object} obj The destination object to update.
					 * @param {!Object} defaults An object with default properties to apply.
					 * @return {!Object} The destination object for convenience.
					 */
					soy.$$assignDefaults = function (obj, defaults) {
						for (var key in defaults) {
							if (!(key in obj)) {
								obj[key] = defaults[key];
							}
						}
						
						return obj;
					};
					
					/**
					 * Checks that the given map key is a string.
					 * @param {*} key Key to check.
					 * @return {string} The given key.
					 */
					soy.$$checkMapKey = function (key) {
						// TODO: Support map literal with nonstring key.
						if (typeof key != 'string') {
							throw Error('Map literal\'s key expression must evaluate to string' + ' (encountered type "' + (typeof key === 'undefined' ? 'undefined' : _typeof(key)) + '").');
						}
						return key;
					};
					
					/**
					 * Gets the keys in a map as an array. There are no guarantees on the order.
					 * @param {Object} map The map to get the keys of.
					 * @return {!Array<string>} The array of keys in the given map.
					 */
					soy.$$getMapKeys = function (map) {
						var mapKeys = [];
						for (var key in map) {
							mapKeys.push(key);
						}
						return mapKeys;
					};
					
					/**
					 * Returns the argument if it is not null.
					 *
					 * @param {T} val The value to check
					 * @return {T} val if is isn't null
					 * @template T
					 */
					soy.$$checkNotNull = function (val) {
						if (val == null) {
							throw Error('unexpected null value');
						}
						return val;
					};
					
					/**
					 * Gets a consistent unique id for the given delegate template name. Two calls
					 * to this function will return the same id if and only if the input names are
					 * the same.
					 *
					 * <p> Important: This function must always be called with a string constant.
					 *
					 * <p> If Closure Compiler is not being used, then this is just this identity
					 * function. If Closure Compiler is being used, then each call to this function
					 * will be replaced with a short string constant, which will be consistent per
					 * input name.
					 *
					 * @param {string} delTemplateName The delegate template name for which to get a
					 *     consistent unique id.
					 * @return {string} A unique id that is consistent per input name.
					 *
					 * @consistentIdGenerator
					 */
					soy.$$getDelTemplateId = function (delTemplateName) {
						return delTemplateName;
					};
					
					/**
					 * Map from registered delegate template key to the priority of the
					 * implementation.
					 * @type {Object}
					 * @private
					 */
					soy.$$DELEGATE_REGISTRY_PRIORITIES_ = {};
					
					/**
					 * Map from registered delegate template key to the implementation function.
					 * @type {Object}
					 * @private
					 */
					soy.$$DELEGATE_REGISTRY_FUNCTIONS_ = {};
					
					/**
					 * Registers a delegate implementation. If the same delegate template key (id
					 * and variant) has been registered previously, then priority values are
					 * compared and only the higher priority implementation is stored (if
					 * priorities are equal, an error is thrown).
					 *
					 * @param {string} delTemplateId The delegate template id.
					 * @param {string} delTemplateVariant The delegate template variant (can be
					 *     empty string).
					 * @param {number} delPriority The implementation's priority value.
					 * @param {Function} delFn The implementation function.
					 */
					soy.$$registerDelegateFn = function (delTemplateId, delTemplateVariant, delPriority, delFn) {
						
						var mapKey = 'key_' + delTemplateId + ':' + delTemplateVariant;
						var currPriority = soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey];
						if (currPriority === undefined || delPriority > currPriority) {
							// Registering new or higher-priority function: replace registry entry.
							soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey] = delPriority;
							soy.$$DELEGATE_REGISTRY_FUNCTIONS_[mapKey] = delFn;
						} else if (delPriority == currPriority) {
							// Registering same-priority function: error.
							throw Error('Encountered two active delegates with the same priority ("' + delTemplateId + ':' + delTemplateVariant + '").');
						} else {
							// Registering lower-priority function: do nothing.
						}
					};
					
					/**
					 * Retrieves the (highest-priority) implementation that has been registered for
					 * a given delegate template key (id and variant). If no implementation has
					 * been registered for the key, then the fallback is the same id with empty
					 * variant. If the fallback is also not registered, and allowsEmptyDefault is
					 * true, then returns an implementation that is equivalent to an empty template
					 * (i.e. rendered output would be empty string).
					 *
					 * @param {string} delTemplateId The delegate template id.
					 * @param {string} delTemplateVariant The delegate template variant (can be
					 *     empty string).
					 * @param {boolean} allowsEmptyDefault Whether to default to the empty template
					 *     function if there's no active implementation.
					 * @return {Function} The retrieved implementation function.
					 */
					soy.$$getDelegateFn = function (delTemplateId, delTemplateVariant, allowsEmptyDefault) {
						
						var delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':' + delTemplateVariant];
						if (!delFn && delTemplateVariant != '') {
							// Fallback to empty variant.
							delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':'];
						}
						
						if (delFn) {
							return delFn;
						} else if (allowsEmptyDefault) {
							return soy.$$EMPTY_TEMPLATE_FN_;
						} else {
							throw Error('Found no active impl for delegate call to "' + delTemplateId + ':' + delTemplateVariant + '" (and not allowemptydefault="true").');
						}
					};
					
					/**
					 * Private helper soy.$$getDelegateFn(). This is the empty template function
					 * that is returned whenever there's no delegate implementation found.
					 *
					 * @param {Object<string, *>=} opt_data
					 * @param {soy.StringBuilder=} opt_sb
					 * @param {Object<string, *>=} opt_ijData
					 * @return {string}
					 * @private
					 */
					soy.$$EMPTY_TEMPLATE_FN_ = function (opt_data, opt_sb, opt_ijData) {
						return '';
					};
					
					// -----------------------------------------------------------------------------
					// Basic directives/functions.
					
					
					/**
					 * Truncates a string to a given max length (if it's currently longer),
					 * optionally adding ellipsis at the end.
					 *
					 * @param {*} str The string to truncate. Can be other types, but the value will
					 *     be coerced to a string.
					 * @param {number} maxLen The maximum length of the string after truncation
					 *     (including ellipsis, if applicable).
					 * @param {boolean} doAddEllipsis Whether to add ellipsis if the string needs
					 *     truncation.
					 * @return {string} The string after truncation.
					 */
					soy.$$truncate = function (str, maxLen, doAddEllipsis) {
						
						str = String(str);
						if (str.length <= maxLen) {
							return str; // no need to truncate
						}
						
						// If doAddEllipsis, either reduce maxLen to compensate, or else if maxLen is
						// too small, just turn off doAddEllipsis.
						if (doAddEllipsis) {
							if (maxLen > 3) {
								maxLen -= 3;
							} else {
								doAddEllipsis = false;
							}
						}
						
						// Make sure truncating at maxLen doesn't cut up a unicode surrogate pair.
						if (soy.$$isHighSurrogate_(str.charAt(maxLen - 1)) && soy.$$isLowSurrogate_(str.charAt(maxLen))) {
							maxLen -= 1;
						}
						
						// Truncate.
						str = str.substring(0, maxLen);
						
						// Add ellipsis.
						if (doAddEllipsis) {
							str += '...';
						}
						
						return str;
					};
					
					/**
					 * Private helper for $$truncate() to check whether a char is a high surrogate.
					 * @param {string} ch The char to check.
					 * @return {boolean} Whether the given char is a unicode high surrogate.
					 * @private
					 */
					soy.$$isHighSurrogate_ = function (ch) {
						return 0xD800 <= ch && ch <= 0xDBFF;
					};
					
					/**
					 * Private helper for $$truncate() to check whether a char is a low surrogate.
					 * @param {string} ch The char to check.
					 * @return {boolean} Whether the given char is a unicode low surrogate.
					 * @private
					 */
					soy.$$isLowSurrogate_ = function (ch) {
						return 0xDC00 <= ch && ch <= 0xDFFF;
					};
					
					// -----------------------------------------------------------------------------
					// Assertion methods used by runtime.
					
					/**
					 * Checks if the type assertion is true if goog.asserts.ENABLE_ASSERTS is
					 * true. Report errors on runtime types if goog.DEBUG is true.
					 * @param {boolean} condition The type check condition.
					 * @param {string} paramName The Soy name of the parameter.
					 * @param {?} param The JS object for the parameter.
					 * @param {!string} jsDocTypeStr SoyDoc type str.
					 * @return {?} the param value
					 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
					 */
					soy.asserts.assertType = function (condition, paramName, param, jsDocTypeStr) {
						if (goog.asserts.ENABLE_ASSERTS && !condition) {
							var msg = 'expected param ' + paramName + ' of type ' + jsDocTypeStr + (goog.DEBUG ? ', but got ' + goog.debug.runtimeType(param) : '') + '.';
							goog.asserts.fail(msg);
						}
						return param;
					};
					
					// -----------------------------------------------------------------------------
					// Generated code.
					
					
					// START GENERATED CODE FOR ESCAPERS.
					
					/**
					 * @type {function (*) : string}
					 */
					soy.esc.$$escapeHtmlHelper = function (v) {
						return goog.string.htmlEscape(String(v));
					};
					
					/**
					 * Allows only data-protocol image URI's.
					 *
					 * @param {*} value The value to process. May not be a string, but the value
					 *     will be coerced to a string.
					 * @return {!soydata.SanitizedUri} An escaped version of value.
					 */
					soy.$$filterImageDataUri = function (value) {
						// NOTE: Even if it's a SanitizedUri, we will still filter it.
						return soydata.VERY_UNSAFE.ordainSanitizedUri(soy.esc.$$filterImageDataUriHelper(value));
					};
					
					/**
					 * A pattern that vets values produced by the named directives.
					 * @private {!RegExp}
					 */
					soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_ = /^data:image\/(?:bmp|gif|jpe?g|png|tiff|webp);base64,[a-z0-9+\/]+=*$/i;
					
					/**
					 * A helper for the Soy directive |filterImageDataUri
					 * @param {*} value Can be of any type but will be coerced to a string.
					 * @return {string} The escaped text.
					 */
					soy.esc.$$filterImageDataUriHelper = function (value) {
						var str = String(value);
						if (!soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_.test(str)) {
							goog.asserts.fail('Bad value `%s` for |filterImageDataUri', [str]);
							return 'data:image/gif;base64,zSoyz';
						}
						return str;
					};
					
					var incrementaldom = IncrementalDOM;
					var soyIDOM = {};
					
					/**
					 * Calls an expression in case of a function or outputs it as text content.
					 * @param {string|number|boolean|function()?} expr
					 */
					soyIDOM.renderDynamicContent = function (expr) {
						if (goog.isFunction(expr)) {
							expr();
						} else if (expr != null) {
							incrementaldom.text(expr);
						}
					};
					
					/**
					 * Prints an expression depending on its type.
					 * @param {!SanitizedHtml|string|number|boolean|function()} expr
					 */
					soyIDOM.print = function (expr) {
						if (expr instanceof soydata.SanitizedHtml) {
							// For HTML content we need to insert a custom element where we can place
							// the content without incremental dom modifying it.
							var el = incrementaldom.elementOpen('html-blob');
							var content = expr.toString();
							if (el.__innerHTML !== content) {
								soy.renderHtml(el, expr);
								el.__innerHTML = content;
							}
							incrementaldom.skip();
							incrementaldom.elementClose('html-blob');
						} else {
							soyIDOM.renderDynamicContent(expr);
						}
					};
					
					goog.loadModule(function () {
						goog.module('soy.idom');
						return soyIDOM;
					});
					
					// END GENERATED CODE
					
					goog.loadModule(function () {
						goog.module('soy');
						return soy;
					});
					
					goog.loadModule(function () {
						goog.module('soydata');
						return soydata;
					});
					
					goog.loadModule(function () {
						goog.module('soy.asserts');
						return soy;
					});
				})();
				
				goog.loadModule(function () {
					goog.module('incrementaldom');
					return IncrementalDOM;
				});
			}).call(typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window);
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))
		
		/***/ }),
	/* 86 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		/**
		 * @license
		 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS-IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		
		
		
		/**
		 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS-IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		
		/**
		 * A cached reference to the hasOwnProperty function.
		 */
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		
		/**
		 * A constructor function that will create blank objects.
		 * @constructor
		 */
		function Blank() {}
		
		Blank.prototype = Object.create(null);
		
		/**
		 * Used to prevent property collisions between our "map" and its prototype.
		 * @param {!Object<string, *>} map The map to check.
		 * @param {string} property The property to check.
		 * @return {boolean} Whether map has property.
		 */
		var has = function (map, property) {
			return hasOwnProperty.call(map, property);
		};
		
		/**
		 * Creates an map object without a prototype.
		 * @return {!Object}
		 */
		var createMap = function () {
			return new Blank();
		};
		
		/**
		 * Keeps track of information needed to perform diffs for a given DOM node.
		 * @param {!string} nodeName
		 * @param {?string=} key
		 * @constructor
		 */
		function NodeData(nodeName, key) {
			/**
			 * The attributes and their values.
			 * @const {!Object<string, *>}
			 */
			this.attrs = createMap();
			
			/**
			 * An array of attribute name/value pairs, used for quickly diffing the
			 * incomming attributes to see if the DOM node's attributes need to be
			 * updated.
			 * @const {Array<*>}
			 */
			this.attrsArr = [];
			
			/**
			 * The incoming attributes for this Node, before they are updated.
			 * @const {!Object<string, *>}
			 */
			this.newAttrs = createMap();
			
			/**
			 * Whether or not the statics have been applied for the node yet.
			 * {boolean}
			 */
			this.staticsApplied = false;
			
			/**
			 * The key used to identify this node, used to preserve DOM nodes when they
			 * move within their parent.
			 * @const
			 */
			this.key = key;
			
			/**
			 * Keeps track of children within this node by their key.
			 * {!Object<string, !Element>}
			 */
			this.keyMap = createMap();
			
			/**
			 * Whether or not the keyMap is currently valid.
			 * @type {boolean}
			 */
			this.keyMapValid = true;
			
			/**
			 * Whether or the associated node is, or contains, a focused Element.
			 * @type {boolean}
			 */
			this.focused = false;
			
			/**
			 * The node name for this node.
			 * @const {string}
			 */
			this.nodeName = nodeName;
			
			/**
			 * @type {?string}
			 */
			this.text = null;
		}
		
		/**
		 * Initializes a NodeData object for a Node.
		 *
		 * @param {Node} node The node to initialize data for.
		 * @param {string} nodeName The node name of node.
		 * @param {?string=} key The key that identifies the node.
		 * @return {!NodeData} The newly initialized data object
		 */
		var initData = function (node, nodeName, key) {
			var data = new NodeData(nodeName, key);
			node['__incrementalDOMData'] = data;
			return data;
		};
		
		/**
		 * Retrieves the NodeData object for a Node, creating it if necessary.
		 *
		 * @param {?Node} node The Node to retrieve the data for.
		 * @return {!NodeData} The NodeData for this Node.
		 */
		var getData = function (node) {
			importNode(node);
			return node['__incrementalDOMData'];
		};
		
		/**
		 * Imports node and its subtree, initializing caches.
		 *
		 * @param {?Node} node The Node to import.
		 */
		var importNode = function (node) {
			if (node['__incrementalDOMData']) {
				return;
			}
			
			var isElement = node instanceof Element;
			var nodeName = isElement ? node.localName : node.nodeName;
			var key = isElement ? node.getAttribute('key') : null;
			var data = initData(node, nodeName, key);
			
			if (key) {
				getData(node.parentNode).keyMap[key] = node;
			}
			
			if (isElement) {
				var attributes = node.attributes;
				var attrs = data.attrs;
				var newAttrs = data.newAttrs;
				var attrsArr = data.attrsArr;
				
				for (var i = 0; i < attributes.length; i += 1) {
					var attr = attributes[i];
					var name = attr.name;
					var value = attr.value;
					
					attrs[name] = value;
					newAttrs[name] = undefined;
					attrsArr.push(name);
					attrsArr.push(value);
				}
			}
			
			for (var child = node.firstChild; child; child = child.nextSibling) {
				importNode(child);
			}
		};
		
		/**
		 * Gets the namespace to create an element (of a given tag) in.
		 * @param {string} tag The tag to get the namespace for.
		 * @param {?Node} parent
		 * @return {?string} The namespace to create the tag in.
		 */
		var getNamespaceForTag = function (tag, parent) {
			if (tag === 'svg') {
				return 'http://www.w3.org/2000/svg';
			}
			
			if (getData(parent).nodeName === 'foreignObject') {
				return null;
			}
			
			return parent.namespaceURI;
		};
		
		/**
		 * Creates an Element.
		 * @param {Document} doc The document with which to create the Element.
		 * @param {?Node} parent
		 * @param {string} tag The tag for the Element.
		 * @param {?string=} key A key to identify the Element.
		 * @return {!Element}
		 */
		var createElement = function (doc, parent, tag, key) {
			var namespace = getNamespaceForTag(tag, parent);
			var el = undefined;
			
			if (namespace) {
				el = doc.createElementNS(namespace, tag);
			} else {
				el = doc.createElement(tag);
			}
			
			initData(el, tag, key);
			
			return el;
		};
		
		/**
		 * Creates a Text Node.
		 * @param {Document} doc The document with which to create the Element.
		 * @return {!Text}
		 */
		var createText = function (doc) {
			var node = doc.createTextNode('');
			initData(node, '#text', null);
			return node;
		};
		
		/**
		 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS-IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		
		/** @const */
		var notifications = {
			/**
			 * Called after patch has compleated with any Nodes that have been created
			 * and added to the DOM.
			 * @type {?function(Array<!Node>)}
			 */
			nodesCreated: null,
			
			/**
			 * Called after patch has compleated with any Nodes that have been removed
			 * from the DOM.
			 * Note it's an applications responsibility to handle any childNodes.
			 * @type {?function(Array<!Node>)}
			 */
			nodesDeleted: null
		};
		
		/**
		 * Keeps track of the state of a patch.
		 * @constructor
		 */
		function Context() {
			/**
			 * @type {(Array<!Node>|undefined)}
			 */
			this.created = notifications.nodesCreated && [];
			
			/**
			 * @type {(Array<!Node>|undefined)}
			 */
			this.deleted = notifications.nodesDeleted && [];
		}
		
		/**
		 * @param {!Node} node
		 */
		Context.prototype.markCreated = function (node) {
			if (this.created) {
				this.created.push(node);
			}
		};
		
		/**
		 * @param {!Node} node
		 */
		Context.prototype.markDeleted = function (node) {
			if (this.deleted) {
				this.deleted.push(node);
			}
		};
		
		/**
		 * Notifies about nodes that were created during the patch opearation.
		 */
		Context.prototype.notifyChanges = function () {
			if (this.created && this.created.length > 0) {
				notifications.nodesCreated(this.created);
			}
			
			if (this.deleted && this.deleted.length > 0) {
				notifications.nodesDeleted(this.deleted);
			}
		};
		
		/**
		 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS-IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		
		/**
		 * Keeps track whether or not we are in an attributes declaration (after
		 * elementOpenStart, but before elementOpenEnd).
		 * @type {boolean}
		 */
		var inAttributes = false;
		
		/**
		 * Keeps track whether or not we are in an element that should not have its
		 * children cleared.
		 * @type {boolean}
		 */
		var inSkip = false;
		
		/**
		 * Makes sure that there is a current patch context.
		 * @param {string} functionName
		 * @param {*} context
		 */
		var assertInPatch = function (functionName, context) {
			if (!context) {
				throw new Error('Cannot call ' + functionName + '() unless in patch.');
			}
		};
		
		/**
		 * Makes sure that a patch closes every node that it opened.
		 * @param {?Node} openElement
		 * @param {!Node|!DocumentFragment} root
		 */
		var assertNoUnclosedTags = function (openElement, root) {
			if (openElement === root) {
				return;
			}
			
			var currentElement = openElement;
			var openTags = [];
			while (currentElement && currentElement !== root) {
				openTags.push(currentElement.nodeName.toLowerCase());
				currentElement = currentElement.parentNode;
			}
			
			throw new Error('One or more tags were not closed:\n' + openTags.join('\n'));
		};
		
		/**
		 * Makes sure that the caller is not where attributes are expected.
		 * @param {string} functionName
		 */
		var assertNotInAttributes = function (functionName) {
			if (inAttributes) {
				throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');
			}
		};
		
		/**
		 * Makes sure that the caller is not inside an element that has declared skip.
		 * @param {string} functionName
		 */
		var assertNotInSkip = function (functionName) {
			if (inSkip) {
				throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');
			}
		};
		
		/**
		 * Makes sure that the caller is where attributes are expected.
		 * @param {string} functionName
		 */
		var assertInAttributes = function (functionName) {
			if (!inAttributes) {
				throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');
			}
		};
		
		/**
		 * Makes sure the patch closes virtual attributes call
		 */
		var assertVirtualAttributesClosed = function () {
			if (inAttributes) {
				throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');
			}
		};
		
		/**
		 * Makes sure that tags are correctly nested.
		 * @param {string} nodeName
		 * @param {string} tag
		 */
		var assertCloseMatchesOpenTag = function (nodeName, tag) {
			if (nodeName !== tag) {
				throw new Error('Received a call to close "' + tag + '" but "' + nodeName + '" was open.');
			}
		};
		
		/**
		 * Makes sure that no children elements have been declared yet in the current
		 * element.
		 * @param {string} functionName
		 * @param {?Node} previousNode
		 */
		var assertNoChildrenDeclaredYet = function (functionName, previousNode) {
			if (previousNode !== null) {
				throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');
			}
		};
		
		/**
		 * Checks that a call to patchOuter actually patched the element.
		 * @param {?Node} startNode The value for the currentNode when the patch
		 *     started.
		 * @param {?Node} currentNode The currentNode when the patch finished.
		 * @param {?Node} expectedNextNode The Node that is expected to follow the
		 *    currentNode after the patch;
		 * @param {?Node} expectedPrevNode The Node that is expected to preceed the
		 *    currentNode after the patch.
		 */
		var assertPatchElementNoExtras = function (startNode, currentNode, expectedNextNode, expectedPrevNode) {
			var wasUpdated = currentNode.nextSibling === expectedNextNode && currentNode.previousSibling === expectedPrevNode;
			var wasChanged = currentNode.nextSibling === startNode.nextSibling && currentNode.previousSibling === expectedPrevNode;
			var wasRemoved = currentNode === startNode;
			
			if (!wasUpdated && !wasChanged && !wasRemoved) {
				throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');
			}
		};
		
		/**
		 * Updates the state of being in an attribute declaration.
		 * @param {boolean} value
		 * @return {boolean} the previous value.
		 */
		var setInAttributes = function (value) {
			var previous = inAttributes;
			inAttributes = value;
			return previous;
		};
		
		/**
		 * Updates the state of being in a skip element.
		 * @param {boolean} value
		 * @return {boolean} the previous value.
		 */
		var setInSkip = function (value) {
			var previous = inSkip;
			inSkip = value;
			return previous;
		};
		
		/**
		 * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS-IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		
		/**
		 * @param {!Node} node
		 * @return {boolean} True if the node the root of a document, false otherwise.
		 */
		var isDocumentRoot = function (node) {
			// For ShadowRoots, check if they are a DocumentFragment instead of if they
			// are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are
			// not supported.
			return node instanceof Document || node instanceof DocumentFragment;
		};
		
		/**
		 * @param {!Node} node The node to start at, inclusive.
		 * @param {?Node} root The root ancestor to get until, exclusive.
		 * @return {!Array<!Node>} The ancestry of DOM nodes.
		 */
		var getAncestry = function (node, root) {
			var ancestry = [];
			var cur = node;
			
			while (cur !== root) {
				ancestry.push(cur);
				cur = cur.parentNode;
			}
			
			return ancestry;
		};
		
		/**
		 * @param {!Node} node
		 * @return {!Node} The root node of the DOM tree that contains node.
		 */
		var getRoot = function (node) {
			var cur = node;
			var prev = cur;
			
			while (cur) {
				prev = cur;
				cur = cur.parentNode;
			}
			
			return prev;
		};
		
		/**
		 * @param {!Node} node The node to get the activeElement for.
		 * @return {?Element} The activeElement in the Document or ShadowRoot
		 *     corresponding to node, if present.
		 */
		var getActiveElement = function (node) {
			var root = getRoot(node);
			return isDocumentRoot(root) ? root.activeElement : null;
		};
		
		/**
		 * Gets the path of nodes that contain the focused node in the same document as
		 * a reference node, up until the root.
		 * @param {!Node} node The reference node to get the activeElement for.
		 * @param {?Node} root The root to get the focused path until.
		 * @return {!Array<Node>}
		 */
		var getFocusedPath = function (node, root) {
			var activeElement = getActiveElement(node);
			
			if (!activeElement || !node.contains(activeElement)) {
				return [];
			}
			
			return getAncestry(activeElement, root);
		};
		
		/**
		 * Like insertBefore, but instead instead of moving the desired node, instead
		 * moves all the other nodes after.
		 * @param {?Node} parentNode
		 * @param {!Node} node
		 * @param {?Node} referenceNode
		 */
		var moveBefore = function (parentNode, node, referenceNode) {
			var insertReferenceNode = node.nextSibling;
			var cur = referenceNode;
			
			while (cur !== node) {
				var next = cur.nextSibling;
				parentNode.insertBefore(cur, insertReferenceNode);
				cur = next;
			}
		};
		
		/** @type {?Context} */
		var context = null;
		
		/** @type {?Node} */
		var currentNode = null;
		
		/** @type {?Node} */
		var currentParent = null;
		
		/** @type {?Document} */
		var doc = null;
		
		/**
		 * @param {!Array<Node>} focusPath The nodes to mark.
		 * @param {boolean} focused Whether or not they are focused.
		 */
		var markFocused = function (focusPath, focused) {
			for (var i = 0; i < focusPath.length; i += 1) {
				getData(focusPath[i]).focused = focused;
			}
		};
		
		/**
		 * Returns a patcher function that sets up and restores a patch context,
		 * running the run function with the provided data.
		 * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run
		 * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}
		 * @template T
		 */
		var patchFactory = function (run) {
			/**
			 * TODO(moz): These annotations won't be necessary once we switch to Closure
			 * Compiler's new type inference. Remove these once the switch is done.
			 *
			 * @param {(!Element|!DocumentFragment)} node
			 * @param {!function(T)} fn
			 * @param {T=} data
			 * @return {?Node} node
			 * @template T
			 */
			var f = function (node, fn, data) {
				var prevContext = context;
				var prevDoc = doc;
				var prevCurrentNode = currentNode;
				var prevCurrentParent = currentParent;
				var previousInAttributes = false;
				var previousInSkip = false;
				
				context = new Context();
				doc = node.ownerDocument;
				currentParent = node.parentNode;
				
				if (false) {
					previousInAttributes = setInAttributes(false);
					previousInSkip = setInSkip(false);
				}
				
				var focusPath = getFocusedPath(node, currentParent);
				markFocused(focusPath, true);
				var retVal = run(node, fn, data);
				markFocused(focusPath, false);
				
				if (false) {
					assertVirtualAttributesClosed();
					setInAttributes(previousInAttributes);
					setInSkip(previousInSkip);
				}
				
				context.notifyChanges();
				
				context = prevContext;
				doc = prevDoc;
				currentNode = prevCurrentNode;
				currentParent = prevCurrentParent;
				
				return retVal;
			};
			return f;
		};
		
		/**
		 * Patches the document starting at node with the provided function. This
		 * function may be called during an existing patch operation.
		 * @param {!Element|!DocumentFragment} node The Element or Document
		 *     to patch.
		 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
		 *     calls that describe the DOM.
		 * @param {T=} data An argument passed to fn to represent DOM state.
		 * @return {!Node} The patched node.
		 * @template T
		 */
		var patchInner = patchFactory(function (node, fn, data) {
			currentNode = node;
			
			enterNode();
			fn(data);
			exitNode();
			
			if (false) {
				assertNoUnclosedTags(currentNode, node);
			}
			
			return node;
		});
		
		/**
		 * Patches an Element with the the provided function. Exactly one top level
		 * element call should be made corresponding to `node`.
		 * @param {!Element} node The Element where the patch should start.
		 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
		 *     calls that describe the DOM. This should have at most one top level
		 *     element call.
		 * @param {T=} data An argument passed to fn to represent DOM state.
		 * @return {?Node} The node if it was updated, its replacedment or null if it
		 *     was removed.
		 * @template T
		 */
		var patchOuter = patchFactory(function (node, fn, data) {
			var startNode = /** @type {!Element} */{ nextSibling: node };
			var expectedNextNode = null;
			var expectedPrevNode = null;
			
			if (false) {
				expectedNextNode = node.nextSibling;
				expectedPrevNode = node.previousSibling;
			}
			
			currentNode = startNode;
			fn(data);
			
			if (false) {
				assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);
			}
			
			if (node !== currentNode && node.parentNode) {
				removeChild(currentParent, node, getData(currentParent).keyMap);
			}
			
			return startNode === currentNode ? null : currentNode;
		});
		
		/**
		 * Checks whether or not the current node matches the specified nodeName and
		 * key.
		 *
		 * @param {!Node} matchNode A node to match the data to.
		 * @param {?string} nodeName The nodeName for this node.
		 * @param {?string=} key An optional key that identifies a node.
		 * @return {boolean} True if the node matches, false otherwise.
		 */
		var matches = function (matchNode, nodeName, key) {
			var data = getData(matchNode);
			
			// Key check is done using double equals as we want to treat a null key the
			// same as undefined. This should be okay as the only values allowed are
			// strings, null and undefined so the == semantics are not too weird.
			return nodeName === data.nodeName && key == data.key;
		};
		
		/**
		 * Aligns the virtual Element definition with the actual DOM, moving the
		 * corresponding DOM node to the correct location or creating it if necessary.
		 * @param {string} nodeName For an Element, this should be a valid tag string.
		 *     For a Text, this should be #text.
		 * @param {?string=} key The key used to identify this element.
		 */
		var alignWithDOM = function (nodeName, key) {
			if (currentNode && matches(currentNode, nodeName, key)) {
				return;
			}
			
			var parentData = getData(currentParent);
			var currentNodeData = currentNode && getData(currentNode);
			var keyMap = parentData.keyMap;
			var node = undefined;
			
			// Check to see if the node has moved within the parent.
			if (key) {
				var keyNode = keyMap[key];
				if (keyNode) {
					if (matches(keyNode, nodeName, key)) {
						node = keyNode;
					} else if (keyNode === currentNode) {
						context.markDeleted(keyNode);
					} else {
						removeChild(currentParent, keyNode, keyMap);
					}
				}
			}
			
			// Create the node if it doesn't exist.
			if (!node) {
				if (nodeName === '#text') {
					node = createText(doc);
				} else {
					node = createElement(doc, currentParent, nodeName, key);
				}
				
				if (key) {
					keyMap[key] = node;
				}
				
				context.markCreated(node);
			}
			
			// Re-order the node into the right position, preserving focus if either
			// node or currentNode are focused by making sure that they are not detached
			// from the DOM.
			if (getData(node).focused) {
				// Move everything else before the node.
				moveBefore(currentParent, node, currentNode);
			} else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {
				// Remove the currentNode, which can always be added back since we hold a
				// reference through the keyMap. This prevents a large number of moves when
				// a keyed item is removed or moved backwards in the DOM.
				currentParent.replaceChild(node, currentNode);
				parentData.keyMapValid = false;
			} else {
				currentParent.insertBefore(node, currentNode);
			}
			
			currentNode = node;
		};
		
		/**
		 * @param {?Node} node
		 * @param {?Node} child
		 * @param {?Object<string, !Element>} keyMap
		 */
		var removeChild = function (node, child, keyMap) {
			node.removeChild(child);
			context.markDeleted( /** @type {!Node}*/child);
			
			var key = getData(child).key;
			if (key) {
				delete keyMap[key];
			}
		};
		
		/**
		 * Clears out any unvisited Nodes, as the corresponding virtual element
		 * functions were never called for them.
		 */
		var clearUnvisitedDOM = function () {
			var node = currentParent;
			var data = getData(node);
			var keyMap = data.keyMap;
			var keyMapValid = data.keyMapValid;
			var child = node.lastChild;
			var key = undefined;
			
			if (child === currentNode && keyMapValid) {
				return;
			}
			
			while (child !== currentNode) {
				removeChild(node, child, keyMap);
				child = node.lastChild;
			}
			
			// Clean the keyMap, removing any unusued keys.
			if (!keyMapValid) {
				for (key in keyMap) {
					child = keyMap[key];
					if (child.parentNode !== node) {
						context.markDeleted(child);
						delete keyMap[key];
					}
				}
				
				data.keyMapValid = true;
			}
		};
		
		/**
		 * Changes to the first child of the current node.
		 */
		var enterNode = function () {
			currentParent = currentNode;
			currentNode = null;
		};
		
		/**
		 * @return {?Node} The next Node to be patched.
		 */
		var getNextNode = function () {
			if (currentNode) {
				return currentNode.nextSibling;
			} else {
				return currentParent.firstChild;
			}
		};
		
		/**
		 * Changes to the next sibling of the current node.
		 */
		var nextNode = function () {
			currentNode = getNextNode();
		};
		
		/**
		 * Changes to the parent of the current node, removing any unvisited children.
		 */
		var exitNode = function () {
			clearUnvisitedDOM();
			
			currentNode = currentParent;
			currentParent = currentParent.parentNode;
		};
		
		/**
		 * Makes sure that the current node is an Element with a matching tagName and
		 * key.
		 *
		 * @param {string} tag The element's tag.
		 * @param {?string=} key The key used to identify this element. This can be an
		 *     empty string, but performance may be better if a unique value is used
		 *     when iterating over an array of items.
		 * @return {!Element} The corresponding Element.
		 */
		var coreElementOpen = function (tag, key) {
			nextNode();
			alignWithDOM(tag, key);
			enterNode();
			return (/** @type {!Element} */currentParent
			);
		};
		
		/**
		 * Closes the currently open Element, removing any unvisited children if
		 * necessary.
		 *
		 * @return {!Element} The corresponding Element.
		 */
		var coreElementClose = function () {
			if (false) {
				setInSkip(false);
			}
			
			exitNode();
			return (/** @type {!Element} */currentNode
			);
		};
		
		/**
		 * Makes sure the current node is a Text node and creates a Text node if it is
		 * not.
		 *
		 * @return {!Text} The corresponding Text Node.
		 */
		var coreText = function () {
			nextNode();
			alignWithDOM('#text', null);
			return (/** @type {!Text} */currentNode
			);
		};
		
		/**
		 * Gets the current Element being patched.
		 * @return {!Element}
		 */
		var currentElement = function () {
			if (false) {
				assertInPatch('currentElement', context);
				assertNotInAttributes('currentElement');
			}
			return (/** @type {!Element} */currentParent
			);
		};
		
		/**
		 * @return {Node} The Node that will be evaluated for the next instruction.
		 */
		var currentPointer = function () {
			if (false) {
				assertInPatch('currentPointer', context);
				assertNotInAttributes('currentPointer');
			}
			return getNextNode();
		};
		
		/**
		 * Skips the children in a subtree, allowing an Element to be closed without
		 * clearing out the children.
		 */
		var skip = function () {
			if (false) {
				assertNoChildrenDeclaredYet('skip', currentNode);
				setInSkip(true);
			}
			currentNode = currentParent.lastChild;
		};
		
		/**
		 * Skips the next Node to be patched, moving the pointer forward to the next
		 * sibling of the current pointer.
		 */
		var skipNode = nextNode;
		
		/**
		 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License");
		 * you may not use this file except in compliance with the License.
		 * You may obtain a copy of the License at
		 *
		 *      http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * Unless required by applicable law or agreed to in writing, software
		 * distributed under the License is distributed on an "AS-IS" BASIS,
		 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		 * See the License for the specific language governing permissions and
		 * limitations under the License.
		 */
		
		/** @const */
		var symbols = {
			default: '__default'
		};
		
		/**
		 * @param {string} name
		 * @return {string|undefined} The namespace to use for the attribute.
		 */
		var getNamespace = function (name) {
			if (name.lastIndexOf('xml:', 0) === 0) {
				return 'http://www.w3.org/XML/1998/namespace';
			}
			
			if (name.lastIndexOf('xlink:', 0) === 0) {
				return 'http://www.w3.org/1999/xlink';
			}
		};
		
		/**
		 * Applies an attribute or property to a given Element. If the value is null
		 * or undefined, it is removed from the Element. Otherwise, the value is set
		 * as an attribute.
		 * @param {!Element} el
		 * @param {string} name The attribute's name.
		 * @param {?(boolean|number|string)=} value The attribute's value.
		 */
		var applyAttr = function (el, name, value) {
			if (value == null) {
				el.removeAttribute(name);
			} else {
				var attrNS = getNamespace(name);
				if (attrNS) {
					el.setAttributeNS(attrNS, name, value);
				} else {
					el.setAttribute(name, value);
				}
			}
		};
		
		/**
		 * Applies a property to a given Element.
		 * @param {!Element} el
		 * @param {string} name The property's name.
		 * @param {*} value The property's value.
		 */
		var applyProp = function (el, name, value) {
			el[name] = value;
		};
		
		/**
		 * Applies a value to a style declaration. Supports CSS custom properties by
		 * setting properties containing a dash using CSSStyleDeclaration.setProperty.
		 * @param {CSSStyleDeclaration} style
		 * @param {!string} prop
		 * @param {*} value
		 */
		var setStyleValue = function (style, prop, value) {
			if (prop.indexOf('-') >= 0) {
				style.setProperty(prop, /** @type {string} */value);
			} else {
				style[prop] = value;
			}
		};
		
		/**
		 * Applies a style to an Element. No vendor prefix expansion is done for
		 * property names/values.
		 * @param {!Element} el
		 * @param {string} name The attribute's name.
		 * @param {*} style The style to set. Either a string of css or an object
		 *     containing property-value pairs.
		 */
		var applyStyle = function (el, name, style) {
			if (typeof style === 'string') {
				el.style.cssText = style;
			} else {
				el.style.cssText = '';
				var elStyle = el.style;
				var obj = /** @type {!Object<string,string>} */style;
				
				for (var prop in obj) {
					if (has(obj, prop)) {
						setStyleValue(elStyle, prop, obj[prop]);
					}
				}
			}
		};
		
		/**
		 * Updates a single attribute on an Element.
		 * @param {!Element} el
		 * @param {string} name The attribute's name.
		 * @param {*} value The attribute's value. If the value is an object or
		 *     function it is set on the Element, otherwise, it is set as an HTML
		 *     attribute.
		 */
		var applyAttributeTyped = function (el, name, value) {
			var type = typeof value;
			
			if (type === 'object' || type === 'function') {
				applyProp(el, name, value);
			} else {
				applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
			}
		};
		
		/**
		 * Calls the appropriate attribute mutator for this attribute.
		 * @param {!Element} el
		 * @param {string} name The attribute's name.
		 * @param {*} value The attribute's value.
		 */
		var updateAttribute = function (el, name, value) {
			var data = getData(el);
			var attrs = data.attrs;
			
			if (attrs[name] === value) {
				return;
			}
			
			var mutator = attributes[name] || attributes[symbols.default];
			mutator(el, name, value);
			
			attrs[name] = value;
		};
		
		/**
		 * A publicly mutable object to provide custom mutators for attributes.
		 * @const {!Object<string, function(!Element, string, *)>}
		 */
		var attributes = createMap();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
		attributes[symbols.default] = applyAttributeTyped;
		
		attributes['style'] = applyStyle;
		
		/**
		 * The offset in the virtual element declaration where the attributes are
		 * specified.
		 * @const
		 */
		var ATTRIBUTES_OFFSET = 3;
		
		/**
		 * Builds an array of arguments for use with elementOpenStart, attr and
		 * elementOpenEnd.
		 * @const {Array<*>}
		 */
		var argsBuilder = [];
		
		/**
		 * @param {string} tag The element's tag.
		 * @param {?string=} key The key used to identify this element. This can be an
		 *     empty string, but performance may be better if a unique value is used
		 *     when iterating over an array of items.
		 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
		 *     static attributes for the Element. These will only be set once when the
		 *     Element is created.
		 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
		 *     for the Element.
		 * @return {!Element} The corresponding Element.
		 */
		var elementOpen = function (tag, key, statics, var_args) {
			if (false) {
				assertNotInAttributes('elementOpen');
				assertNotInSkip('elementOpen');
			}
			
			var node = coreElementOpen(tag, key);
			var data = getData(node);
			
			if (!data.staticsApplied) {
				if (statics) {
					for (var _i = 0; _i < statics.length; _i += 2) {
						var name = /** @type {string} */statics[_i];
						var value = statics[_i + 1];
						updateAttribute(node, name, value);
					}
				}
				// Down the road, we may want to keep track of the statics array to use it
				// as an additional signal about whether a node matches or not. For now,
				// just use a marker so that we do not reapply statics.
				data.staticsApplied = true;
			}
			
			/*
			 * Checks to see if one or more attributes have changed for a given Element.
			 * When no attributes have changed, this is much faster than checking each
			 * individual argument. When attributes have changed, the overhead of this is
			 * minimal.
			 */
			var attrsArr = data.attrsArr;
			var newAttrs = data.newAttrs;
			var isNew = !attrsArr.length;
			var i = ATTRIBUTES_OFFSET;
			var j = 0;
			
			for (; i < arguments.length; i += 2, j += 2) {
				var _attr = arguments[i];
				if (isNew) {
					attrsArr[j] = _attr;
					newAttrs[_attr] = undefined;
				} else if (attrsArr[j] !== _attr) {
					break;
				}
				
				var value = arguments[i + 1];
				if (isNew || attrsArr[j + 1] !== value) {
					attrsArr[j + 1] = value;
					updateAttribute(node, _attr, value);
				}
			}
			
			if (i < arguments.length || j < attrsArr.length) {
				for (; i < arguments.length; i += 1, j += 1) {
					attrsArr[j] = arguments[i];
				}
				
				if (j < attrsArr.length) {
					attrsArr.length = j;
				}
				
				/*
				 * Actually perform the attribute update.
				 */
				for (i = 0; i < attrsArr.length; i += 2) {
					var name = /** @type {string} */attrsArr[i];
					var value = attrsArr[i + 1];
					newAttrs[name] = value;
				}
				
				for (var _attr2 in newAttrs) {
					updateAttribute(node, _attr2, newAttrs[_attr2]);
					newAttrs[_attr2] = undefined;
				}
			}
			
			return node;
		};
		
		/**
		 * Declares a virtual Element at the current location in the document. This
		 * corresponds to an opening tag and a elementClose tag is required. This is
		 * like elementOpen, but the attributes are defined using the attr function
		 * rather than being passed as arguments. Must be folllowed by 0 or more calls
		 * to attr, then a call to elementOpenEnd.
		 * @param {string} tag The element's tag.
		 * @param {?string=} key The key used to identify this element. This can be an
		 *     empty string, but performance may be better if a unique value is used
		 *     when iterating over an array of items.
		 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
		 *     static attributes for the Element. These will only be set once when the
		 *     Element is created.
		 */
		var elementOpenStart = function (tag, key, statics) {
			if (false) {
				assertNotInAttributes('elementOpenStart');
				setInAttributes(true);
			}
			
			argsBuilder[0] = tag;
			argsBuilder[1] = key;
			argsBuilder[2] = statics;
		};
		
		/***
		 * Defines a virtual attribute at this point of the DOM. This is only valid
		 * when called between elementOpenStart and elementOpenEnd.
		 *
		 * @param {string} name
		 * @param {*} value
		 */
		var attr = function (name, value) {
			if (false) {
				assertInAttributes('attr');
			}
			
			argsBuilder.push(name);
			argsBuilder.push(value);
		};
		
		/**
		 * Closes an open tag started with elementOpenStart.
		 * @return {!Element} The corresponding Element.
		 */
		var elementOpenEnd = function () {
			if (false) {
				assertInAttributes('elementOpenEnd');
				setInAttributes(false);
			}
			
			var node = elementOpen.apply(null, argsBuilder);
			argsBuilder.length = 0;
			return node;
		};
		
		/**
		 * Closes an open virtual Element.
		 *
		 * @param {string} tag The element's tag.
		 * @return {!Element} The corresponding Element.
		 */
		var elementClose = function (tag) {
			if (false) {
				assertNotInAttributes('elementClose');
			}
			
			var node = coreElementClose();
			
			if (false) {
				assertCloseMatchesOpenTag(getData(node).nodeName, tag);
			}
			
			return node;
		};
		
		/**
		 * Declares a virtual Element at the current location in the document that has
		 * no children.
		 * @param {string} tag The element's tag.
		 * @param {?string=} key The key used to identify this element. This can be an
		 *     empty string, but performance may be better if a unique value is used
		 *     when iterating over an array of items.
		 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
		 *     static attributes for the Element. These will only be set once when the
		 *     Element is created.
		 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
		 *     for the Element.
		 * @return {!Element} The corresponding Element.
		 */
		var elementVoid = function (tag, key, statics, var_args) {
			elementOpen.apply(null, arguments);
			return elementClose(tag);
		};
		
		/**
		 * Declares a virtual Text at this point in the document.
		 *
		 * @param {string|number|boolean} value The value of the Text.
		 * @param {...(function((string|number|boolean)):string)} var_args
		 *     Functions to format the value which are called only when the value has
		 *     changed.
		 * @return {!Text} The corresponding text node.
		 */
		var text = function (value, var_args) {
			if (false) {
				assertNotInAttributes('text');
				assertNotInSkip('text');
			}
			
			var node = coreText();
			var data = getData(node);
			
			if (data.text !== value) {
				data.text = /** @type {string} */value;
				
				var formatted = value;
				for (var i = 1; i < arguments.length; i += 1) {
					/*
					 * Call the formatter function directly to prevent leaking arguments.
					 * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
					 */
					var fn = arguments[i];
					formatted = fn(formatted);
				}
				
				node.data = formatted;
			}
			
			return node;
		};
		
		exports.patch = patchInner;
		exports.patchInner = patchInner;
		exports.patchOuter = patchOuter;
		exports.currentElement = currentElement;
		exports.currentPointer = currentPointer;
		exports.skip = skip;
		exports.skipNode = skipNode;
		exports.elementVoid = elementVoid;
		exports.elementOpenStart = elementOpenStart;
		exports.elementOpenEnd = elementOpenEnd;
		exports.elementOpen = elementOpen;
		exports.elementClose = elementClose;
		exports.text = text;
		exports.attr = attr;
		exports.symbols = symbols;
		exports.attributes = attributes;
		exports.applyAttr = applyAttr;
		exports.applyProp = applyProp;
		exports.notifications = notifications;
		exports.importNode = importNode;

//# sourceMappingURL=incremental-dom-cjs.js.map
		
		/***/ }),
	/* 87 */
	/***/ (function(module, exports, __webpack_require__) {
		
		(function (global, factory) {
			true ? factory(exports) :
				typeof define === 'function' && define.amd ? define(['exports'], factory) :
					(factory((global.IncrementalDOM = global.IncrementalDOM || {})));
		}(this, (function (exports) { 'use strict';
			
			/**
			 * An array used to store the strings generated by calls to
			 * elementOpen, elementOpenStart, elementOpenEnd, elementEnd and elementVoid
			 */
			exports.buffer = [];
			
			/** @type {?Object} */
			exports.currentParent = null;
			
			/**
			 * Gets the current Element being patched.
			 * @return {!Element}
			 */
			var currentElement = function currentElement() {
				return exports.currentParent;
			};
			
			/**
			 * @return {Node} The Node that will be evaluated for the next instruction.
			 */
			var currentPointer = function currentPointer() {
				return {};
			};
			
			/**
			 * Patches an Element with the the provided function. Exactly one top level
			 * element call should be made corresponding to `node`.
			 *
			 * @param {?object} node The Element where the patch should start.
			 * @param {!function(T)} fn A function containing open/close/etc. calls that
			 *     describe the DOM. This should have at most one top level element call.
			 * @param {T=} data An argument passed to fn to represent DOM state.
			 * @return {void} Nothing.
			 */
			var patch = function patch(node, fn, data) {
				exports.currentParent = node;
				fn(data);
				exports.currentParent.innerHTML = exports.buffer.join('');
				exports.buffer = [];
				return exports.currentParent;
			};
			
			var patchOuter = patch;
			var patchInner = patch;
			
			/**
			 * Declares a virtual Text at this point in the document.
			 *
			 * @param {string|number|boolean} value The value of the Text.
			 * @param {...(function((string|number|boolean)):string)} var_args
			 *     Functions to format the value which are called only when the value has
			 *     changed.
			 *
			 * @return {void} Nothing.
			 */
			var text = function text(value, var_args) {
				var formatted = value;
				for (var i = 1; i < arguments.length; i += 1) {
					var fn = arguments[i];
					formatted = fn(formatted);
				}
				exports.buffer.push(formatted);
			};
			
			/** @const */
			var symbols = {
				default: '__default'
			};
			
			/** @const */
			var attributes = {};
			
			/**
			 * Calls the appropriate attribute mutator for this attribute.
			 * @param {!Array.<string>} el Buffer to append element attributes.
			 * @param {string} name The attribute's name.
			 * @param {*} value The attribute's value.
			 */
			var updateAttribute = function updateAttribute(el, name, value) {
				var mutator = attributes[name] || attributes[symbols.default];
				mutator(el, name, value);
			};

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
			attributes[symbols.default] = function (el, name, value) {
				if (Array.isArray(el)) {
					el.push(' ' + name + '="' + value + '"');
				}
			};
			
			/**
			 * Truncates an array, removing items up until length.
			 * @param {!Array<*>} arr The array to truncate.
			 * @param {number} length The new length of the array.
			 */
			var truncateArray = function truncateArray(arr, length) {
				while (arr.length > length) {
					arr.pop();
				}
			};
			
			/**
			 * The offset in the virtual element declaration where the attributes are
			 * specified.
			 * @const
			 */
			var ATTRIBUTES_OFFSET = 3;
			
			/**
			 * Builds an array of arguments for use with elementOpenStart, attr and
			 * elementOpenEnd.
			 * @const {!Array<*>}
			 */
			var argsBuilder = [];
			
			/**
			 * Defines a virtual attribute at this point of the DOM. This is only valid
			 * when called between elementOpenStart and elementOpenEnd.
			 *
			 * @param {string} name The attribute's name.
			 * @param {*} value The attribute's value.
			 * @return {void} Nothing.
			 */
			var attr = function attr(name, value) {
				argsBuilder.push(name);
				argsBuilder.push(value);
			};
			
			/**
			 * Closes an open virtual Element.
			 *
			 * @param {string} The Element's tag.
			 * @return {void} Nothing.
			 */
			var elementClose = function elementClose(nameOrCtor) {
				if (typeof nameOrCtor === 'function') {
					new nameOrCtor();
					return;
				}
				exports.buffer.push('</' + nameOrCtor + '>');
			};
			
			/**
			 * Declares a virtual Element at the current location in the document that has
			 * no children.
			 *
			 * @param {string} The Element's tag or constructor.
			 * @param {?string=} key The key used to identify this element. This can be an
			 *     empty string, but performance may be better if a unique value is used
			 *     when iterating over an array of items.
			 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
			 *     static attributes for the Element. These will only be set once when the
			 *     Element is created.
			 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
			 *     for the Element.
			 * @return {void} Nothing.
			 */
			var elementVoid = function elementVoid(nameOrCtor, key, statics, var_args) {
				elementOpen.apply(null, arguments);
				return elementClose(nameOrCtor);
			};
			
			/**
			 * @param {!string} nameOrCtor The Element's tag or constructor.
			 * @param {?string=} key The key used to identify this element. This can be an
			 *     empty string, but performance may be better if a unique value is used
			 *     when iterating over an array of items.
			 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
			 *     static attributes for the Element. These will only be set once when the
			 *     Element is created.
			 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
			 *     for the Element.
			 * @return {void} Nothing.
			 */
			var elementOpen = function elementOpen(nameOrCtor, key, statics, var_args) {
				if (typeof nameOrCtor === 'function') {
					new nameOrCtor();
					return exports.currentParent;
				}
				
				exports.buffer.push('<' + nameOrCtor);
				
				if (statics) {
					for (var _i = 0; _i < statics.length; _i += 2) {
						var name = /** @type {string} */statics[_i];
						var value = statics[_i + 1];
						updateAttribute(exports.buffer, name, value);
					}
				}
				
				var i = ATTRIBUTES_OFFSET;
				var j = 0;
				
				for (; i < arguments.length; i += 2, j += 2) {
					var _name = arguments[i];
					var _value = arguments[i + 1];
					updateAttribute(exports.buffer, _name, _value);
				}
				
				exports.buffer.push('>');
				
				return exports.currentParent;
			};
			
			/**
			 * Closes an open tag started with elementOpenStart.
			 *
			 * @return {void} Nothing.
			 */
			var elementOpenEnd = function elementOpenEnd() {
				elementOpen.apply(null, argsBuilder);
				truncateArray(argsBuilder, 0);
			};
			
			/**
			 * Declares a virtual Element at the current location in the document. This
			 * corresponds to an opening tag and a elementClose tag is required. This is
			 * like elementOpen, but the attributes are defined using the attr function
			 * rather than being passed as arguments. Must be folllowed by 0 or more calls
			 * to attr, then a call to elementOpenEnd.
			 * @param {string} nameOrCtor The Element's tag or constructor.
			 * @param {?string=} key The key used to identify this element. This can be an
			 *     empty string, but performance may be better if a unique value is used
			 *     when iterating over an array of items.
			 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
			 *     static attributes for the Element. These will only be set once when the
			 *     Element is created.
			 * @return {void} Nothing.
			 */
			var elementOpenStart = function elementOpenStart(nameOrCtor, key, statics) {
				argsBuilder[0] = nameOrCtor;
				argsBuilder[1] = key;
				argsBuilder[2] = statics;
			};
			
			/**
			 * Returns the constructred DOM string at this point.
			 * @param {function} fn
			 * @return {string} The constructed DOM string.
			 */
			var renderToString = function renderToString(fn) {
				patch({}, fn);
				return currentElement().innerHTML;
			};
			
			exports.currentElement = currentElement;
			exports.currentPointer = currentPointer;
			exports.patch = patch;
			exports.patchInner = patchInner;
			exports.patchOuter = patchOuter;
			exports.text = text;
			exports.attr = attr;
			exports.elementClose = elementClose;
			exports.elementOpen = elementOpen;
			exports.elementOpenEnd = elementOpenEnd;
			exports.elementOpenStart = elementOpenStart;
			exports.elementVoid = elementVoid;
			exports.renderToString = renderToString;
			exports.symbols = symbols;
			exports.attributes = attributes;
			exports.updateAttribute = updateAttribute;
			
			Object.defineProperty(exports, '__esModule', { value: true });
			
		})));
		
		
		/***/ }),
	/* 88 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(process) {
			
			/**
			 * A collection of core utility functions.
			 * @const
			 */
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			exports.abstractMethod = abstractMethod;
			exports.disableCompatibilityMode = disableCompatibilityMode;
			exports.enableCompatibilityMode = enableCompatibilityMode;
			exports.getCompatibilityModeData = getCompatibilityModeData;
			exports.getFunctionName = getFunctionName;
			exports.getStaticProperty = getStaticProperty;
			exports.getUid = getUid;
			exports.identityFunction = identityFunction;
			exports.isBoolean = isBoolean;
			exports.isDef = isDef;
			exports.isDefAndNotNull = isDefAndNotNull;
			exports.isDocument = isDocument;
			exports.isDocumentFragment = isDocumentFragment;
			exports.isElement = isElement;
			exports.isFunction = isFunction;
			exports.isNull = isNull;
			exports.isNumber = isNumber;
			exports.isWindow = isWindow;
			exports.isObject = isObject;
			exports.isPromise = isPromise;
			exports.isString = isString;
			exports.isServerSide = isServerSide;
			exports.nullFunction = nullFunction;
			var compatibilityModeData_ = void 0;
			
			/**
			 * Counter for unique id.
			 * @type {Number}
			 * @private
			 */
			var uniqueIdCounter_ = 1;
			
			/**
			 * Unique id property prefix.
			 * @type {String}
			 * @protected
			 */
			var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}
			
			/**
			 * Disables Metal.js's compatibility mode.
			 */
			function disableCompatibilityMode() {
				compatibilityModeData_ = undefined;
			}
			
			/**
			 * Enables Metal.js's compatibility mode with the following features from rc
			 * and 1.x versions:
			 *     - Using "key" to reference component instances. In the current version
			 *       this should be done via "ref" instead. This allows old code still
			 *       using "key" to keep working like before. NOTE: this may cause
			 *       problems, since "key" is meant to be used differently. Only use this
			 *       if it's not possible to upgrade the code to use "ref" instead.
			 * @param {Object=} opt_data Optional object with data to specify more
			 *     details, such as:
			 *         - renderers {Array} the template renderers that should be in
			 *           compatibility mode, either their constructors or strings
			 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
			 *           that extend from IncrementalDomRenderer.
			 * @type {Object}
			 */
			function enableCompatibilityMode() {
				var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				
				compatibilityModeData_ = opt_data;
			}
			
			/**
			 * Returns the data used for compatibility mode, or nothing if it hasn't been
			 * enabled.
			 * @return {Object}
			 */
			function getCompatibilityModeData() {
				// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
				if (compatibilityModeData_ === undefined) {
					if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
						enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
					}
				}
				return compatibilityModeData_;
			}
			
			/**
			 * Returns the first argument if it's truthy, or the second otherwise.
			 * @param {*} a
			 * @param {*} b
			 * @return {*}
			 * @protected
			 */
			function getFirstTruthy_(a, b) {
				return a || b;
			}
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}
			
			/**
			 * Gets the value of a static property in the given class. The value will be
			 * inherited from ancestors as expected, unless a custom merge function is given,
			 * which can change how the super classes' value for that property will be merged
			 * together.
			 * The final merged value will be stored in another property, so that it won't
			 * be recalculated even if this function is called multiple times.
			 * @param {!function()} ctor Class constructor.
			 * @param {string} propertyName Property name to be merged.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
			 *     value of the property so far and the next value to be merged to it.
			 *     Should return these two merged together. If not passed the final property
			 *     will be the first truthy value among ancestors.
			 */
			function getStaticProperty(ctor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (!ctor.hasOwnProperty(mergedName)) {
					var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
					if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
						var mergeFn = opt_mergeFn || getFirstTruthy_;
						merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
					}
					ctor[mergedName] = merged;
				}
				return ctor[mergedName];
			}
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
				}
				return uniqueIdCounter_++;
			}
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			function isBoolean(val) {
				return typeof val === 'boolean';
			}
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			function isDef(val) {
				return val !== undefined;
			}
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDefAndNotNull(val) {
				return isDef(val) && !isNull(val);
			}
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			}
			
			/**
			 * Returns true if value is a document-fragment.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocumentFragment(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
			}
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			}
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			function isFunction(val) {
				return typeof val === 'function';
			}
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isNull(val) {
				return val === null;
			}
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			function isNumber(val) {
				return typeof val === 'number';
			}
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isWindow(val) {
				return val !== null && val === val.window;
			}
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			}
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}
			
			/**
			 * Sets to true if running inside Node.js environment with extra check for
			 * `process.browser` to skip Karma runner environment. Karma environment has
			 * `process` defined even though it runs on the browser.
			 * @return {boolean}
			 */
			function isServerSide() {
				return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
			}
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			function nullFunction() {}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))
		
		/***/ }),
	/* 89 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _core = __webpack_require__(31);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			_createClass(array, null, [{
				key: 'equal',
				
				/**
				 * Checks if the given arrays have the same content.
				 * @param {!Array<*>} arr1
				 * @param {!Array<*>} arr2
				 * @return {boolean}
				 */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}
				
				/**
				 * Returns the first value in the given array that isn't undefined.
				 * @param {!Array} arr
				 * @return {*}
				 */
				
			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}
				
				/**
				 * Transforms the input nested array to become flat.
				 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
				 * @param {Array.<*>} opt_output Optional output array.
				 * @return {Array.<*>} Flat array.
				 */
				
			}, {
				key: 'flatten',
				value: function flatten(arr, opt_output) {
					var output = opt_output || [];
					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}
				
				/**
				 * Removes the first occurrence of a particular value from an array.
				 * @param {Array.<T>} arr Array from which to remove value.
				 * @param {T} obj Object to remove.
				 * @return {boolean} True if an element was removed.
				 * @template T
				 */
				
			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}
				
				/**
				 * Removes from an array the element at index i
				 * @param {Array} arr Array or array like object from which to remove value.
				 * @param {number} i The index to remove.
				 * @return {boolean} True if an element was removed.
				 */
				
			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}
				
				/**
				 * Slices the given array, just like Array.prototype.slice, but this
				 * is faster and working on all array-like objects (like arguments).
				 * @param {!Object} arr Array-like object to slice.
				 * @param {number} start The index that should start the slice.
				 * @param {number=} opt_end The index where the slice should end, not
				 *   included in the final array. If not given, all elements after the
				 *   start index will be included.
				 * @return {!Array}
				 */
				
			}, {
				key: 'slice',
				value: function slice(arr, start, opt_end) {
					var sliced = [];
					var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 90 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel = void 0;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 91 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}
				
				/**
				 * Subclasses should override this method to implement any specific
				 * disposing logic (like clearing references and calling `dispose` on other
				 * disposables).
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}
				
				/**
				 * Checks if this instance has already been disposed.
				 * @return {boolean}
				 */
				
			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 92 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			_createClass(object, null, [{
				key: 'mixin',
				
				/**
				 * Copies all the members of a source object to a target object.
				 * @param {Object} target Target object.
				 * @param {...Object} var_args The objects from which values will be copied.
				 * @return {Object} Returns the target object reference.
				 */
				value: function mixin(target) {
					var key = void 0,
						source = void 0;
					for (var i = 1; i < arguments.length; i++) {
						source = arguments[i];
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}
				
				/**
				 * Returns an object based on its fully qualified external name.
				 * @param {string} name The fully qualified name.
				 * @param {object=} opt_obj The object within which to look; default is
				 *     <code>window</code>.
				 * @return {?} The value (object or primitive) or, if not found, undefined.
				 */
				
			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name, opt_obj) {
					var scope = opt_obj || window;
					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}
				
				/**
				 * Returns a new object with the same keys as the given one, but with
				 * their values set to the return values of the specified function.
				 * @param {!Object} obj
				 * @param {!function(string, *)} fn
				 * @return {!Object}
				 */
				
			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}
				
				/**
				 * Checks if the two given objects are equal. This is done via a shallow
				 * check, including only the keys directly contained by the 2 objects.
				 * @return {boolean}
				 */
				
			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}
					
					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}
					
					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 93 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',
				
				/**
				 * Compares the given strings without taking the case into account.
				 * @param {string|number} str1
				 * @param {string|number} str2
				 * @return {number} Either -1, 0 or 1, according to if the first string is
				 *     "smaller", equal or "bigger" than the second given string.
				 */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();
					
					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}
				
				/**
				 * Removes the breaking spaces from the left and right of the string and
				 * collapses the sequences of breaking spaces in the middle into single spaces.
				 * The original and the result strings render the same way in HTML.
				 * @param {string} str A string in which to collapse spaces.
				 * @return {string} Copy of the string with normalized breaking spaces.
				 */
				
			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}
				
				/**
				 * Escapes characters in the string that are not safe to use in a RegExp.
				 * @param {*} str The string to escape. If not a string, it will be casted
				 *     to one.
				 * @return {string} A RegExp safe, escaped copy of {@code s}.
				 */
				
			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
				}
				
				/**
				 * Returns a string with at least 64-bits of randomness.
				 * @return {string} A random string, e.g. sn1s7vb4gcic.
				 */
				
			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}
				
				/**
				 * Calculates the hashcode for a string. The hashcode value is computed by
				 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
				 * property of using 31 prime is that the multiplication can be replaced by
				 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
				 * Modern VMs do this sort of optimization automatically.
				 * @param {String} val Target string.
				 * @return {Number} Returns the string hashcode.
				 */
				
			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}
				
				/**
				 * Replaces interval into the string with specified value, e.g.
				 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
				 * @param {string} str The input string.
				 * @param {Number} start Start interval position to be replaced.
				 * @param {Number} end End interval position to be replaced.
				 * @param {string} value The value that replaces the specified interval.
				 * @return {string}
				 */
				
			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 94 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.getPatchingComponent = getPatchingComponent;
		exports.patch = patch;
		
		var _metalDom = __webpack_require__(6);
		
		var _data = __webpack_require__(9);
		
		var _render = __webpack_require__(35);
		
		var patchingComponents_ = [];
		
		/**
		 * Guarantees that the component's element has a parent. That's necessary
		 * when calling incremental dom's `patchOuter` for now, as otherwise it will
		 * throw an error if the element needs to be replaced.
		 * @return {Element} The parent, in case it was added.
		 * @private
		 */
		function buildParentIfNecessary_(element) {
			if (!element || !element.parentNode) {
				var parent = document.createElement('div');
				if (element) {
					(0, _metalDom.append)(parent, element);
				}
				return parent;
			}
		}
		
		/**
		 * Calls incremental dom's patch function.
		 * @param {!Component} component The component to patch.
		 * @param {!Element} element The element the component should be patched on.
		 * @param {boolean=} opt_outer Flag indicating if `patchOuter` should be used
		 *     instead of `patch`.
		 * @private
		 */
		function callPatch_(component, element, opt_outer) {
			patchingComponents_.push(component);
			
			var data = (0, _data.getData)(component);
			if (!data.render) {
				// Store reference to avoid binds on every patch.
				data.render = _render.render.bind(null, component);
			}
			
			var patchFn = opt_outer ? IncrementalDOM.patchOuter : IncrementalDOM.patch;
			patchFn(element, data.render);
			
			patchingComponents_.pop();
		}
		
		/**
		 * Gets the component that triggered the current patch operation.
		 * @return {Component}
		 */
		function getPatchingComponent() {
			return patchingComponents_[patchingComponents_.length - 1];
		}
		
		/**
		 * Patches the component with incremental dom function calls.
		 * @param {!Component} component
		 */
		function patch(component) {
			if (!tryPatchEmptyWithParent_(component)) {
				if (!tryPatchWithNoParent_(component)) {
					var element = component.element;
					callPatch_(component, element, true);
				}
			}
		}
		
		/**
		 * Checks if the component has no content but was rendered from another
		 * component. If so, we'll need to patch this parent to make sure that any new
		 * content will be added in the right position.
		 * @param {!Component} component
		 * @return {?boolean} True if the patch happened. Nothing otherwise.
		 * @private
		 */
		function tryPatchEmptyWithParent_(component) {
			var data = (0, _data.getData)(component);
			if (!component.element && data.parent) {
				data.parent.getRenderer().patch(data.parent);
				return true;
			}
		}
		
		/**
		 * Checks if the component's element exists and has a parent. If that's not the
		 * case, a temporary parent will be created and passed to the `patch` function,
		 * since incremental dom requires it. Once the patch is done the temporary
		 * parent is removed and the component's content is reattached to the correct
		 * final position.
		 * @param {!Component} component
		 * @return {?boolean} True if the patch happened. Nothing otherwise.
		 * @private
		 */
		function tryPatchWithNoParent_(component) {
			var tempParent = buildParentIfNecessary_(component.element);
			if (tempParent) {
				callPatch_(component, tempParent);
				(0, _metalDom.exitDocument)(component.element);
				if (component.element && component.inDocument) {
					var attach = component.getAttachData();
					component.attachElement(attach.parent, attach.sibling);
				}
				return true;
			}
		}
		
		/***/ }),
	/* 95 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.applyAttribute = applyAttribute;
		exports.convertListenerNamesToFns = convertListenerNamesToFns;
		
		var _metal = __webpack_require__(11);
		
		var _metalDom = __webpack_require__(6);
		
		var _metalComponent = __webpack_require__(0);
		
		var _incrementalDomAop = __webpack_require__(15);
		
		var HANDLE_SUFFIX = '__handle__';
		var LISTENER_REGEX = /^(?:on([A-Z].+))|(?:data-on(.+))$/;
		
		/**
		 * Applies an attribute to a specified element owned by the given component.
		 * @param {!Component} component
		 * @param {!Element} element
		 * @param {string} name
		 * @param {*} value
		 */
		function applyAttribute(component, element, name, value) {
			var eventName = getEventFromListenerAttr_(name);
			if (eventName) {
				attachEvent_(component, element, name, eventName, value);
				return;
			}
			
			value = fixCheckedAttr_(name, value);
			setValueAttrAsProperty_(element, name, value);
			
			if ((0, _metal.isBoolean)(value)) {
				setBooleanAttr_(element, name, value);
			} else {
				(0, _incrementalDomAop.getOriginalFn)('attributes')(element, name, value);
			}
		}
		
		/**
		 * Listens to the specified event, attached via incremental dom calls.
		 * @param {!Component} component
		 * @param {!Element} element
		 * @param {string} attr
		 * @param {string} eventName
		 * @param {function()} fn
		 * @private
		 */
		function attachEvent_(component, element, attr, eventName, fn) {
			if ((0, _metal.isServerSide)()) {
				return;
			}
			var handleKey = eventName + HANDLE_SUFFIX;
			if (element[handleKey]) {
				element[handleKey].removeListener();
				element[handleKey] = null;
			}
			if (fn) {
				element[attr] = fn;
				element[handleKey] = (0, _metalDom.delegate)(document, eventName, element, fn);
			}
		}
		
		/**
		 * Converts all event listener attributes given as function names to actual
		 * function references. It's important to do this before calling the real
		 * incremental dom `elementOpen` function, otherwise if a component passes
		 * the same function name that an element was already using for another
		 * component, that event won't be reattached as incremental dom will think that
		 * the value hasn't changed. Passing the function references as the value will
		 * guarantee that different functions will cause events to be reattached,
		 * regardless of their original names.
		 * @param {!Component} component
		 * @param {!Object} config
		 */
		function convertListenerNamesToFns(component, config) {
			var keys = Object.keys(config);
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				config[key] = convertListenerNameToFn_(component, key, config[key]);
			}
		}
		
		/**
		 * Converts the given attribute's value to a function reference, if it's
		 * currently a listener name. It also register the listener name for
		 * further usage.
		 * @param {!Component} component
		 * @param {string} name
		 * @param {*} value
		 * @return {*}
		 * @private
		 */
		function convertListenerNameToFn_(component, name, value) {
			if ((0, _metal.isString)(value)) {
				var eventName = getEventFromListenerAttr_(name);
				if (eventName) {
					var fn = (0, _metalComponent.getComponentFn)(component, value);
					if (fn) {
						return fn;
					}
				}
			}
			return value;
		}
		
		/**
		 * Changes the value of the `checked` attribute to be a boolean.
		 * NOTE: This is a temporary fix to account for incremental dom setting
		 * "checked" as an attribute only, which can cause bugs since that won't
		 * necessarily check/uncheck the element it's set on. See
		 * https://github.com/google/incremental-dom/issues/198 for more details.
		 * @param {string} name
		 * @param {*} value
		 * @return {*}
		 * @private
		 */
		function fixCheckedAttr_(name, value) {
			if (name === 'checked') {
				value = (0, _metal.isDefAndNotNull)(value) && value !== false;
			}
			return value;
		}
		
		/**
		 * Returns the event name if the given attribute is a listener (matching the
		 * `LISTENER_REGEX` regex), or null if it isn't.
		 * @param {string} attr
		 * @return {?string}
		 * @private
		 */
		function getEventFromListenerAttr_(attr) {
			var matches = LISTENER_REGEX.exec(attr);
			var eventName = matches ? matches[1] ? matches[1] : matches[2] : null;
			return eventName ? eventName.toLowerCase() : null;
		}
		
		/**
		 * Sets boolean attributes manually. This is done because incremental dom sets
		 * boolean values as string data attributes by default, which is counter
		 * intuitive. This changes the behavior to use the actual boolean value.
		 * @param {!Element} element
		 * @param {string} name
		 * @param {*} value
		 * @private
		 */
		function setBooleanAttr_(element, name, value) {
			if ((0, _metal.isServerSide)()) {
				return;
			}
			element[name] = value;
			if (value) {
				element.setAttribute(name, '');
			} else {
				element.removeAttribute(name);
			}
		}
		
		/**
		 * Sets the value of the `value` attribute directly in the element.
		 * NOTE: This is a temporary fix to account for incremental dom setting "value"
		 * as an attribute only, which can cause bugs since that won't necessarily
		 * update the input's content it's set on. See
		 * https://github.com/google/incremental-dom/issues/239 for more details. We
		 * only do this if the new value is different though, as otherwise the browser
		 * will automatically move the typing cursor to the end of the field.
		 * @param {!Element} element
		 * @param {string} name
		 * @param {*} value
		 * @private
		 */
		function setValueAttrAsProperty_(element, name, value) {
			if ((0, _metal.isServerSide)()) {
				return;
			}
			if (name === 'value' && element.value !== value) {
				element[name] = value;
			}
		}
		
		/***/ }),
	/* 96 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.disposeUnused = disposeUnused;
		exports.schedule = schedule;
		
		var _data = __webpack_require__(9);
		
		var comps_ = [];
		var disposing_ = false;
		
		/**
		 * Disposes all sub components that were not rerendered since the last
		 * time this function was scheduled.
		 */
		function disposeUnused() {
			if (disposing_) {
				return;
			}
			disposing_ = true;
			
			for (var i = 0; i < comps_.length; i++) {
				var comp = comps_[i];
				if (!comp.isDisposed() && !(0, _data.getData)(comp).parent) {
					// Don't let disposing cause the element to be removed, since it may
					// be currently being reused by another component.
					comp.element = null;
					comp.dispose();
				}
			}
			comps_ = [];
			disposing_ = false;
		}
		
		/**
		 * Schedules the given components to be checked and disposed if not used
		 * anymore when `disposeUnused` is called.
		 * @param {!Array<!Component>} comps
		 */
		function schedule(comps) {
			for (var i = 0; i < comps.length; i++) {
				if (!comps[i].isDisposed()) {
					(0, _data.getData)(comps[i]).parent = null;
					comps_.push(comps[i]);
				}
			}
		}
		
		/***/ }),
	/* 97 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;
		
		var _core = __webpack_require__(36);
		
		Object.keys(_core).forEach(function (key) {
			if (key === "default" || key === "__esModule") return;
			Object.defineProperty(exports, key, {
				enumerable: true,
				get: function get() {
					return _core[key];
				}
			});
		});
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(99);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(100);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(101);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(102);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(103);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		exports.default = _core2.default;
		
		/***/ }),
	/* 98 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(process) {
			
			/**
			 * A collection of core utility functions.
			 * @const
			 */
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			
			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
			
			exports.abstractMethod = abstractMethod;
			exports.disableCompatibilityMode = disableCompatibilityMode;
			exports.enableCompatibilityMode = enableCompatibilityMode;
			exports.getCompatibilityModeData = getCompatibilityModeData;
			exports.getFunctionName = getFunctionName;
			exports.getStaticProperty = getStaticProperty;
			exports.getUid = getUid;
			exports.identityFunction = identityFunction;
			exports.isBoolean = isBoolean;
			exports.isDef = isDef;
			exports.isDefAndNotNull = isDefAndNotNull;
			exports.isDocument = isDocument;
			exports.isDocumentFragment = isDocumentFragment;
			exports.isElement = isElement;
			exports.isFunction = isFunction;
			exports.isNull = isNull;
			exports.isNumber = isNumber;
			exports.isWindow = isWindow;
			exports.isObject = isObject;
			exports.isPromise = isPromise;
			exports.isString = isString;
			exports.isServerSide = isServerSide;
			exports.nullFunction = nullFunction;
			var compatibilityModeData_ = void 0;
			
			/**
			 * Counter for unique id.
			 * @type {Number}
			 * @private
			 */
			var uniqueIdCounter_ = 1;
			
			/**
			 * Unique id property prefix.
			 * @type {String}
			 * @protected
			 */
			var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);
			
			/**
			 * When defining a class Foo with an abstract method bar(), you can do:
			 * Foo.prototype.bar = abstractMethod
			 *
			 * Now if a subclass of Foo fails to override bar(), an error will be thrown
			 * when bar() is invoked.
			 *
			 * @type {!Function}
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function abstractMethod() {
				throw Error('Unimplemented abstract method');
			}
			
			/**
			 * Disables Metal.js's compatibility mode.
			 */
			function disableCompatibilityMode() {
				compatibilityModeData_ = undefined;
			}
			
			/**
			 * Enables Metal.js's compatibility mode with the following features from rc
			 * and 1.x versions:
			 *     - Using "key" to reference component instances. In the current version
			 *       this should be done via "ref" instead. This allows old code still
			 *       using "key" to keep working like before. NOTE: this may cause
			 *       problems, since "key" is meant to be used differently. Only use this
			 *       if it's not possible to upgrade the code to use "ref" instead.
			 * @param {Object=} opt_data Optional object with data to specify more
			 *     details, such as:
			 *         - renderers {Array} the template renderers that should be in
			 *           compatibility mode, either their constructors or strings
			 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
			 *           that extend from IncrementalDomRenderer.
			 * @type {Object}
			 */
			function enableCompatibilityMode() {
				var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
				
				compatibilityModeData_ = opt_data;
			}
			
			/**
			 * Returns the data used for compatibility mode, or nothing if it hasn't been
			 * enabled.
			 * @return {Object}
			 */
			function getCompatibilityModeData() {
				// Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
				if (compatibilityModeData_ === undefined) {
					if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
						enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
					}
				}
				return compatibilityModeData_;
			}
			
			/**
			 * Returns the first argument if it's truthy, or the second otherwise.
			 * @param {*} a
			 * @param {*} b
			 * @return {*}
			 * @protected
			 */
			function getFirstTruthy_(a, b) {
				return a || b;
			}
			
			/**
			 * Gets the name of the given function. If the current browser doesn't
			 * support the `name` property, this will calculate it from the function's
			 * content string.
			 * @param {!function()} fn
			 * @return {string}
			 */
			function getFunctionName(fn) {
				if (!fn.name) {
					var str = fn.toString();
					fn.name = str.substring(9, str.indexOf('('));
				}
				return fn.name;
			}
			
			/**
			 * Gets the value of a static property in the given class. The value will be
			 * inherited from ancestors as expected, unless a custom merge function is given,
			 * which can change how the super classes' value for that property will be merged
			 * together.
			 * The final merged value will be stored in another property, so that it won't
			 * be recalculated even if this function is called multiple times.
			 * @param {!function()} ctor Class constructor.
			 * @param {string} propertyName Property name to be merged.
			 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
			 *     value of the property so far and the next value to be merged to it.
			 *     Should return these two merged together. If not passed the final property
			 *     will be the first truthy value among ancestors.
			 */
			function getStaticProperty(ctor, propertyName, opt_mergeFn) {
				var mergedName = propertyName + '_MERGED';
				if (!ctor.hasOwnProperty(mergedName)) {
					var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
					if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
						var mergeFn = opt_mergeFn || getFirstTruthy_;
						merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
					}
					ctor[mergedName] = merged;
				}
				return ctor[mergedName];
			}
			
			/**
			 * Gets an unique id. If `opt_object` argument is passed, the object is
			 * mutated with an unique id. Consecutive calls with the same object
			 * reference won't mutate the object again, instead the current object uid
			 * returns. See {@link UID_PROPERTY}.
			 * @param {Object=} opt_object Optional object to be mutated with the uid. If
			 *     not specified this method only returns the uid.
			 * @param {boolean=} opt_noInheritance Optional flag indicating if this
			 *     object's uid property can be inherited from parents or not.
			 * @throws {Error} when invoked to indicate the method should be overridden.
			 */
			function getUid(opt_object, opt_noInheritance) {
				if (opt_object) {
					var id = opt_object[UID_PROPERTY];
					if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
						id = null;
					}
					return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
				}
				return uniqueIdCounter_++;
			}
			
			/**
			 * The identity function. Returns its first argument.
			 * @param {*=} opt_returnValue The single value that will be returned.
			 * @return {?} The first argument.
			 */
			function identityFunction(opt_returnValue) {
				return opt_returnValue;
			}
			
			/**
			 * Returns true if the specified value is a boolean.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is boolean.
			 */
			function isBoolean(val) {
				return typeof val === 'boolean';
			}
			
			/**
			 * Returns true if the specified value is not undefined.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is defined.
			 */
			function isDef(val) {
				return val !== undefined;
			}
			
			/**
			 * Returns true if value is not undefined or null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDefAndNotNull(val) {
				return isDef(val) && !isNull(val);
			}
			
			/**
			 * Returns true if value is a document.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocument(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
			}
			
			/**
			 * Returns true if value is a document-fragment.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isDocumentFragment(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
			}
			
			/**
			 * Returns true if value is a dom element.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isElement(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
			}
			
			/**
			 * Returns true if the specified value is a function.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a function.
			 */
			function isFunction(val) {
				return typeof val === 'function';
			}
			
			/**
			 * Returns true if value is null.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isNull(val) {
				return val === null;
			}
			
			/**
			 * Returns true if the specified value is a number.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is a number.
			 */
			function isNumber(val) {
				return typeof val === 'number';
			}
			
			/**
			 * Returns true if value is a window.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isWindow(val) {
				return val !== null && val === val.window;
			}
			
			/**
			 * Returns true if the specified value is an object. This includes arrays
			 * and functions.
			 * @param {?} val Variable to test.
			 * @return {boolean} Whether variable is an object.
			 */
			function isObject(val) {
				var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
				return type === 'object' && val !== null || type === 'function';
			}
			
			/**
			 * Returns true if value is a Promise.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isPromise(val) {
				return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
			}
			
			/**
			 * Returns true if value is a string.
			 * @param {*} val
			 * @return {boolean}
			 */
			function isString(val) {
				return typeof val === 'string' || val instanceof String;
			}
			
			/**
			 * Sets to true if running inside Node.js environment with extra check for
			 * `process.browser` to skip Karma runner environment. Karma environment has
			 * `process` defined even though it runs on the browser.
			 * @return {boolean}
			 */
			function isServerSide() {
				return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
			}
			
			/**
			 * Null function used for default values of callbacks, etc.
			 * @return {void} Nothing.
			 */
			function nullFunction() {}
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))
		
		/***/ }),
	/* 99 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _core = __webpack_require__(36);
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			_createClass(array, null, [{
				key: 'equal',
				
				/**
				 * Checks if the given arrays have the same content.
				 * @param {!Array<*>} arr1
				 * @param {!Array<*>} arr2
				 * @return {boolean}
				 */
				value: function equal(arr1, arr2) {
					if (arr1 === arr2) {
						return true;
					}
					if (arr1.length !== arr2.length) {
						return false;
					}
					for (var i = 0; i < arr1.length; i++) {
						if (arr1[i] !== arr2[i]) {
							return false;
						}
					}
					return true;
				}
				
				/**
				 * Returns the first value in the given array that isn't undefined.
				 * @param {!Array} arr
				 * @return {*}
				 */
				
			}, {
				key: 'firstDefinedValue',
				value: function firstDefinedValue(arr) {
					for (var i = 0; i < arr.length; i++) {
						if (arr[i] !== undefined) {
							return arr[i];
						}
					}
				}
				
				/**
				 * Transforms the input nested array to become flat.
				 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
				 * @param {Array.<*>} opt_output Optional output array.
				 * @return {Array.<*>} Flat array.
				 */
				
			}, {
				key: 'flatten',
				value: function flatten(arr, opt_output) {
					var output = opt_output || [];
					for (var i = 0; i < arr.length; i++) {
						if (Array.isArray(arr[i])) {
							array.flatten(arr[i], output);
						} else {
							output.push(arr[i]);
						}
					}
					return output;
				}
				
				/**
				 * Removes the first occurrence of a particular value from an array.
				 * @param {Array.<T>} arr Array from which to remove value.
				 * @param {T} obj Object to remove.
				 * @return {boolean} True if an element was removed.
				 * @template T
				 */
				
			}, {
				key: 'remove',
				value: function remove(arr, obj) {
					var i = arr.indexOf(obj);
					var rv = void 0;
					if (rv = i >= 0) {
						array.removeAt(arr, i);
					}
					return rv;
				}
				
				/**
				 * Removes from an array the element at index i
				 * @param {Array} arr Array or array like object from which to remove value.
				 * @param {number} i The index to remove.
				 * @return {boolean} True if an element was removed.
				 */
				
			}, {
				key: 'removeAt',
				value: function removeAt(arr, i) {
					return Array.prototype.splice.call(arr, i, 1).length === 1;
				}
				
				/**
				 * Slices the given array, just like Array.prototype.slice, but this
				 * is faster and working on all array-like objects (like arguments).
				 * @param {!Object} arr Array-like object to slice.
				 * @param {number} start The index that should start the slice.
				 * @param {number=} opt_end The index where the slice should end, not
				 *   included in the final array. If not given, all elements after the
				 *   start index will be included.
				 * @return {!Array}
				 */
				
			}, {
				key: 'slice',
				value: function slice(arr, start, opt_end) {
					var sliced = [];
					var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
					for (var i = start; i < end; i++) {
						sliced.push(arr[i]);
					}
					return sliced;
				}
			}]);
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 100 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel = void 0;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 101 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			_createClass(Disposable, [{
				key: 'dispose',
				value: function dispose() {
					if (!this.disposed_) {
						this.disposeInternal();
						this.disposed_ = true;
					}
				}
				
				/**
				 * Subclasses should override this method to implement any specific
				 * disposing logic (like clearing references and calling `dispose` on other
				 * disposables).
				 */
				
			}, {
				key: 'disposeInternal',
				value: function disposeInternal() {}
				
				/**
				 * Checks if this instance has already been disposed.
				 * @return {boolean}
				 */
				
			}, {
				key: 'isDisposed',
				value: function isDisposed() {
					return this.disposed_;
				}
			}]);
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 102 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			_createClass(object, null, [{
				key: 'mixin',
				
				/**
				 * Copies all the members of a source object to a target object.
				 * @param {Object} target Target object.
				 * @param {...Object} var_args The objects from which values will be copied.
				 * @return {Object} Returns the target object reference.
				 */
				value: function mixin(target) {
					var key = void 0,
						source = void 0;
					for (var i = 1; i < arguments.length; i++) {
						source = arguments[i];
						for (key in source) {
							target[key] = source[key];
						}
					}
					return target;
				}
				
				/**
				 * Returns an object based on its fully qualified external name.
				 * @param {string} name The fully qualified name.
				 * @param {object=} opt_obj The object within which to look; default is
				 *     <code>window</code>.
				 * @return {?} The value (object or primitive) or, if not found, undefined.
				 */
				
			}, {
				key: 'getObjectByName',
				value: function getObjectByName(name, opt_obj) {
					var scope = opt_obj || window;
					var parts = name.split('.');
					return parts.reduce(function (part, key) {
						return part[key];
					}, scope);
				}
				
				/**
				 * Returns a new object with the same keys as the given one, but with
				 * their values set to the return values of the specified function.
				 * @param {!Object} obj
				 * @param {!function(string, *)} fn
				 * @return {!Object}
				 */
				
			}, {
				key: 'map',
				value: function map(obj, fn) {
					var mappedObj = {};
					var keys = Object.keys(obj);
					for (var i = 0; i < keys.length; i++) {
						mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
					}
					return mappedObj;
				}
				
				/**
				 * Checks if the two given objects are equal. This is done via a shallow
				 * check, including only the keys directly contained by the 2 objects.
				 * @return {boolean}
				 */
				
			}, {
				key: 'shallowEqual',
				value: function shallowEqual(obj1, obj2) {
					if (obj1 === obj2) {
						return true;
					}
					
					var keys1 = Object.keys(obj1);
					var keys2 = Object.keys(obj2);
					if (keys1.length !== keys2.length) {
						return false;
					}
					
					for (var i = 0; i < keys1.length; i++) {
						if (obj1[keys1[i]] !== obj2[keys1[i]]) {
							return false;
						}
					}
					return true;
				}
			}]);
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 103 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			_createClass(string, null, [{
				key: 'caseInsensitiveCompare',
				
				/**
				 * Compares the given strings without taking the case into account.
				 * @param {string|number} str1
				 * @param {string|number} str2
				 * @return {number} Either -1, 0 or 1, according to if the first string is
				 *     "smaller", equal or "bigger" than the second given string.
				 */
				value: function caseInsensitiveCompare(str1, str2) {
					var test1 = String(str1).toLowerCase();
					var test2 = String(str2).toLowerCase();
					
					if (test1 < test2) {
						return -1;
					} else if (test1 === test2) {
						return 0;
					} else {
						return 1;
					}
				}
				
				/**
				 * Removes the breaking spaces from the left and right of the string and
				 * collapses the sequences of breaking spaces in the middle into single spaces.
				 * The original and the result strings render the same way in HTML.
				 * @param {string} str A string in which to collapse spaces.
				 * @return {string} Copy of the string with normalized breaking spaces.
				 */
				
			}, {
				key: 'collapseBreakingSpaces',
				value: function collapseBreakingSpaces(str) {
					return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
				}
				
				/**
				 * Escapes characters in the string that are not safe to use in a RegExp.
				 * @param {*} str The string to escape. If not a string, it will be casted
				 *     to one.
				 * @return {string} A RegExp safe, escaped copy of {@code s}.
				 */
				
			}, {
				key: 'escapeRegex',
				value: function escapeRegex(str) {
					return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
				}
				
				/**
				 * Returns a string with at least 64-bits of randomness.
				 * @return {string} A random string, e.g. sn1s7vb4gcic.
				 */
				
			}, {
				key: 'getRandomString',
				value: function getRandomString() {
					var x = 2147483648;
					return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
				}
				
				/**
				 * Calculates the hashcode for a string. The hashcode value is computed by
				 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
				 * property of using 31 prime is that the multiplication can be replaced by
				 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
				 * Modern VMs do this sort of optimization automatically.
				 * @param {String} val Target string.
				 * @return {Number} Returns the string hashcode.
				 */
				
			}, {
				key: 'hashCode',
				value: function hashCode(val) {
					var hash = 0;
					for (var i = 0, len = val.length; i < len; i++) {
						hash = 31 * hash + val.charCodeAt(i);
						hash %= 0x100000000;
					}
					return hash;
				}
				
				/**
				 * Replaces interval into the string with specified value, e.g.
				 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
				 * @param {string} str The input string.
				 * @param {Number} start Start interval position to be replaced.
				 * @param {Number} end End interval position to be replaced.
				 * @param {string} value The value that replaces the specified interval.
				 * @return {string}
				 */
				
			}, {
				key: 'replaceInterval',
				value: function replaceInterval(str, start, end, value) {
					return str.substring(0, start) + value + str.substring(end);
				}
			}]);
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 104 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		__webpack_require__(105);
		
		var _HTML2IncDom = __webpack_require__(106);
		
		var _HTML2IncDom2 = _interopRequireDefault(_HTML2IncDom);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _HTML2IncDom2.default;
		
		/***/ }),
	/* 105 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/* jshint ignore:start */
		
		/*
		 * HTML5 Parser By Sam Blowes
		 *
		 * Designed for HTML5 documents
		 *
		 * Original code by John Resig (ejohn.org)
		 * http://ejohn.org/blog/pure-javascript-html-parser/
		 * Original code by Erik Arvidsson, Mozilla Public License
		 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
		 *
		 * ----------------------------------------------------------------------------
		 * License
		 * ----------------------------------------------------------------------------
		 *
		 * This code is triple licensed using Apache Software License 2.0,
		 * Mozilla Public License or GNU Public License
		 *
		 * ////////////////////////////////////////////////////////////////////////////
		 *
		 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
		 * use this file except in compliance with the License.  You may obtain a copy
		 * of the License at http://www.apache.org/licenses/LICENSE-2.0
		 *
		 * ////////////////////////////////////////////////////////////////////////////
		 *
		 * The contents of this file are subject to the Mozilla Public License
		 * Version 1.1 (the "License"); you may not use this file except in
		 * compliance with the License. You may obtain a copy of the License at
		 * http://www.mozilla.org/MPL/
		 *
		 * Software distributed under the License is distributed on an "AS IS"
		 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
		 * License for the specific language governing rights and limitations
		 * under the License.
		 *
		 * The Original Code is Simple HTML Parser.
		 *
		 * The Initial Developer of the Original Code is Erik Arvidsson.
		 * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights
		 * Reserved.
		 *
		 * ////////////////////////////////////////////////////////////////////////////
		 *
		 * This program is free software; you can redistribute it and/or
		 * modify it under the terms of the GNU General Public License
		 * as published by the Free Software Foundation; either version 2
		 * of the License, or (at your option) any later version.
		 *
		 * This program is distributed in the hope that it will be useful,
		 * but WITHOUT ANY WARRANTY; without even the implied warranty of
		 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		 * GNU General Public License for more details.
		 *
		 * You should have received a copy of the GNU General Public License
		 * along with this program; if not, write to the Free Software
		 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
		 * @license
		 */
		
		/*
		 *
		 * ----------------------------------------------------------------------------
		 * Usage
		 * ----------------------------------------------------------------------------
		 *
		 * // Use like so:
		 * HTMLParser(htmlString, {
		 *     start: function(tag, attrs, unary) {},
		 *     end: function(tag) {},
		 *     chars: function(text) {},
		 *     comment: function(text) {}
		 * });
		 *
		 * // or to get an XML string:
		 * HTMLtoXML(htmlString);
		 *
		 * // or to get an XML DOM Document
		 * HTMLtoDOM(htmlString);
		 *
		 * // or to inject into an existing document/DOM node
		 * HTMLtoDOM(htmlString, document);
		 * HTMLtoDOM(htmlString, document.body);
		 *
		 */
		
		(function () {
			// Regular Expressions for parsing tags and attributes
			var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
				endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/,
				attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;
			
			// Empty Elements - HTML 5
			var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,link,meta,param,embed,command,keygen,source,track,wbr");
			
			// Block Elements - HTML 5
			var block = makeMap("a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video");
			
			// Inline Elements - HTML 5
			var inline = makeMap("abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");
			
			// Elements that you can, intentionally, leave open
			// (and which close themselves)
			var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");
			
			// Attributes that have their values filled in disabled="disabled"
			var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");
			
			// Special Elements (can contain anything)
			var special = makeMap("script,style");
			
			var HTMLParser = window.HTMLParser = function (html, handler) {
				var index,
					chars,
					match,
					stack = [],
					last = html;
				stack.last = function () {
					return this[this.length - 1];
				};
				
				while (html) {
					chars = true;
					
					// Make sure we're not in a script or style element
					if (!stack.last() || !special[stack.last()]) {
						
						// Comment
						if (html.indexOf("<!--") == 0) {
							index = html.indexOf("-->");
							
							if (index >= 0) {
								if (handler.comment) handler.comment(html.substring(4, index));
								html = html.substring(index + 3);
								chars = false;
							}
							
							// end tag
						} else if (html.indexOf("</") == 0) {
							match = html.match(endTag);
							
							if (match) {
								html = html.substring(match[0].length);
								match[0].replace(endTag, parseEndTag);
								chars = false;
							}
							
							// start tag
						} else if (html.indexOf("<") == 0) {
							match = html.match(startTag);
							
							if (match) {
								html = html.substring(match[0].length);
								match[0].replace(startTag, parseStartTag);
								chars = false;
							}
						}
						
						if (chars) {
							index = html.indexOf("<");
							
							var text = index < 0 ? html : html.substring(0, index);
							html = index < 0 ? "" : html.substring(index);
							
							if (handler.chars) handler.chars(text);
						}
					} else {
						html = html.replace(new RegExp("([\\s\\S]*?)<\/" + stack.last() + "[^>]*>"), function (all, text) {
							text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
							if (handler.chars) handler.chars(text);
							
							return "";
						});
						
						parseEndTag("", stack.last());
					}
					
					if (html == last) throw "Parse Error: " + html;
					last = html;
				}
				
				// Clean up any remaining tags
				parseEndTag();
				
				function parseStartTag(tag, tagName, rest, unary) {
					tagName = tagName.toLowerCase();
					
					if (block[tagName]) {
						// Close last tag if it's inline, except if it's a "span" (since people
						// usually add anything they want to spans, and browsers allow it).
						// Note: this exception for "span" was added manually (i.e. it's not
						// present in the original code).
						while (stack.last() && inline[stack.last()] && stack.last() !== 'span') {
							parseEndTag("", stack.last());
						}
					}
					
					if (closeSelf[tagName] && stack.last() == tagName) {
						parseEndTag("", tagName);
					}
					
					unary = empty[tagName] || !!unary;
					
					if (!unary) stack.push(tagName);
					
					if (handler.start) {
						var attrs = [];
						
						rest.replace(attr, function (match, name) {
							var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : "";
							
							attrs.push({
								name: name,
								value: value,
								escaped: value.replace(/(^|[^\\])"/g, '$1\\\"') //"
							});
						});
						
						if (handler.start) handler.start(tagName, attrs, unary);
					}
				}
				
				function parseEndTag(tag, tagName) {
					// If no tag name is provided, clean shop
					if (!tagName) var pos = 0;
					
					// Find the closest opened tag of the same type
					else for (var pos = stack.length - 1; pos >= 0; pos--) {
						if (stack[pos] == tagName) break;
					}if (pos >= 0) {
						// Close all the open elements, up the stack
						for (var i = stack.length - 1; i >= pos; i--) {
							if (handler.end) handler.end(stack[i]);
						} // Remove the open elements from the stack
						stack.length = pos;
					}
				}
			};
			
			function makeMap(str) {
				var obj = {},
					items = str.split(",");
				for (var i = 0; i < items.length; i++) {
					obj[items[i]] = true;
				}return obj;
			}
		}).call(undefined);
		
		/* jshint ignore:end */
		
		/***/ }),
	/* 106 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
		
		var _unescape = __webpack_require__(107);
		
		var _unescape2 = _interopRequireDefault(_unescape);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var parser_;
		
		var HTML2IncDom = function () {
			function HTML2IncDom() {
				_classCallCheck(this, HTML2IncDom);
			}
			
			_createClass(HTML2IncDom, null, [{
				key: 'buildFn',
				
				/**
				 * Should convert the given html string to a function with calls to
				 * incremental dom methods.
				 * @param {string} html
				 * @return {!function()} Function with incremental dom calls for building
				 *     the given html string.
				 */
				value: function buildFn(html) {
					return function () {
						return HTML2IncDom.run(html);
					};
				}
				
				/**
				 * Gets the html parser being currently used.
				 * @return {!function()}
				 */
				
			}, {
				key: 'getParser',
				value: function getParser() {
					return parser_ || window.HTMLParser;
				}
				
				/**
				 * Should convert the given html string to calls to incremental dom methods.
				 * @param {string} html
				 */
				
			}, {
				key: 'run',
				value: function run(html) {
					HTML2IncDom.getParser()(html, {
						start: function start(tag, attrs, unary) {
							var fn = unary ? IncrementalDOM.elementVoid : IncrementalDOM.elementOpen;
							var args = [tag, null, []];
							for (var i = 0; i < attrs.length; i++) {
								args.push(attrs[i].name, attrs[i].value);
							}
							fn.apply(null, args);
						},
						
						end: function end(tag) {
							IncrementalDOM.elementClose(tag);
						},
						
						chars: function chars(text) {
							IncrementalDOM.text(text, _unescape2.default);
						}
					});
				}
				
				/**
				 * Changes the function that will be used to parse html strings. By default
				 * this will use the `HTMLParser` function from
				 * https://github.com/blowsie/Pure-JavaScript-HTML5-Parser. This will accept
				 * any function that follows that same api, basically accepting the html
				 * string and an object with `start`, `end` and `chars` functions to be called
				 * during the parsing.
				 * @param {!function(string, !Object} newParser
				 */
				
			}, {
				key: 'setParser',
				value: function setParser(newParser) {
					parser_ = newParser;
				}
			}]);
			
			return HTML2IncDom;
		}();
		
		exports.default = HTML2IncDom;
		
		/***/ }),
	/* 107 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";


// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
		
		/**
		 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
		 * entities. This function is XSS-safe and whitespace-preserving.
		 * @private
		 * @param {string} str The string to unescape.
		 * @return {string} The unescaped {@code str} string.
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		function unescape(str) {
			/** @type {!Object<string, string>} */
			var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
			var div = document.createElement('div');
			
			// Match as many valid entity characters as possible. If the actual entity
			// happens to be shorter, it will still work as innerHTML will return the
			// trailing characters unchanged. Since the entity characters do not include
			// open angle bracket, there is no chance of XSS from the innerHTML use.
			// Since no whitespace is passed to innerHTML, whitespace is preserved.
			return str.replace(HTML_ENTITY_PATTERN_, function (s, entity) {
				// Check for cached entity.
				var value = seen[s];
				if (value) {
					return value;
				}
				// Check for numeric entity.
				if (entity.charAt(0) === '#') {
					// Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
					var n = Number('0' + entity.substr(1));
					if (!isNaN(n)) {
						value = String.fromCharCode(n);
					}
				}
				// Fall back to innerHTML otherwise.
				if (!value) {
					// Append a non-entity character to avoid a bug in Webkit that parses
					// an invalid entity at the end of innerHTML text as the empty string.
					div.innerHTML = s + ' ';
					// Then remove the trailing character from the result.
					value = div.firstChild.nodeValue.slice(0, -1);
				}
				// Cache and return.
				seen[s] = value;
				return value;
			});
		}
		
		exports.default = unescape;
		
		/**
		 * Regular expression that matches an HTML entity.
		 * @type {!RegExp}
		 */
		
		var HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
		
		/***/ }),
	/* 108 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		var SoyAop = {
			/**
			 * The functions that should be called instead of a template call. The last
			 * function in the array is the one that is intercepting at the moment. If the
			 * array is empty, the original function will be called instead.
			 * @type {!Array<function()>}
			 * @protected
			 */
			interceptFns_: [],
			
			/**
			 * Gets the original function of the given template function. If no original exists,
			 * returns the given function itself.
			 * @param {!function()} fn
			 * @return {!function()}
			 */
			getOriginalFn: function getOriginalFn(fn) {
				return fn.originalFn ? fn.originalFn : fn;
			},
			
			/**
			 * Handles a template call, calling the current interception function if one
			 * is set, or otherwise just calling the original function instead.
			 * @param {!function()} originalFn The original template function that was
			 *     intercepted.
			 * @param {Object} opt_data Template data object.
			 * @param {*} opt_ignored
			 * @param {Object} opt_ijData Template injected data object.
			 * @return {*} The return value of the function that is called to handle this
			 *     interception.
			 */
			handleTemplateCall_: function handleTemplateCall_(originalFn, opt_data, opt_ignored, opt_ijData) {
				var interceptFn = SoyAop.interceptFns_[SoyAop.interceptFns_.length - 1];
				if (interceptFn) {
					return interceptFn.call(null, originalFn, opt_data, opt_ignored, opt_ijData);
				} else {
					return originalFn.call(null, opt_data, opt_ignored, opt_ijData);
				}
			},
			
			/**
			 * Registers a template function that should be intercepted.
			 * @param {!Object} templates The original templates object containing the
			 *     function to be intercepted.
			 * @param {string} name The name of the template function to intercept.
			 */
			registerForInterception: function registerForInterception(templates, name) {
				var originalFn = templates[name];
				if (!originalFn.originalFn) {
					templates[name] = SoyAop.handleTemplateCall_.bind(null, originalFn);
					templates[name].originalFn = originalFn;
				}
			},
			
			/**
			 * Starts intercepting all template calls, replacing them with a call to the
			 * given function instead.
			 * @param {!function()} fn
			 */
			startInterception: function startInterception(fn) {
				SoyAop.interceptFns_.push(fn);
			},
			
			/**
			 * Stops intercepting template calls.
			 */
			stopAllInterceptions: function stopAllInterceptions() {
				SoyAop.interceptFns_ = [];
			},
			
			/**
			 * Stops intercepting template calls with the last registered function.
			 */
			stopInterception: function stopInterception() {
				SoyAop.interceptFns_.pop();
			}
		};
		
		exports.default = SoyAop;
		
		/***/ }),
	/* 109 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		exports.string = exports.object = exports.Disposable = exports.async = exports.array = exports.core = undefined;
		
		var _core = __webpack_require__(37);
		
		var _core2 = _interopRequireDefault(_core);
		
		var _array = __webpack_require__(110);
		
		var _array2 = _interopRequireDefault(_array);
		
		var _async = __webpack_require__(111);
		
		var _async2 = _interopRequireDefault(_async);
		
		var _Disposable = __webpack_require__(112);
		
		var _Disposable2 = _interopRequireDefault(_Disposable);
		
		var _object = __webpack_require__(113);
		
		var _object2 = _interopRequireDefault(_object);
		
		var _string = __webpack_require__(114);
		
		var _string2 = _interopRequireDefault(_string);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		exports.default = _core2.default;
		exports.core = _core2.default;
		exports.array = _array2.default;
		exports.async = _async2.default;
		exports.Disposable = _Disposable2.default;
		exports.object = _object2.default;
		exports.string = _string2.default;
		
		/***/ }),
	/* 110 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		var _core = __webpack_require__(37);
		
		var _core2 = _interopRequireDefault(_core);
		
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var array = function () {
			function array() {
				_classCallCheck(this, array);
			}
			
			/**
			 * Checks if the given arrays have the same content.
			 * @param {!Array<*>} arr1
			 * @param {!Array<*>} arr2
			 * @return {boolean}
			 */
			array.equal = function equal(arr1, arr2) {
				if (arr1.length !== arr2.length) {
					return false;
				}
				for (var i = 0; i < arr1.length; i++) {
					if (arr1[i] !== arr2[i]) {
						return false;
					}
				}
				return true;
			};
			
			/**
			 * Returns the first value in the given array that isn't undefined.
			 * @param {!Array} arr
			 * @return {*}
			 */
			
			
			array.firstDefinedValue = function firstDefinedValue(arr) {
				for (var i = 0; i < arr.length; i++) {
					if (arr[i] !== undefined) {
						return arr[i];
					}
				}
			};
			
			/**
			 * Transforms the input nested array to become flat.
			 * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
			 * @param {Array.<*>} opt_output Optional output array.
			 * @return {Array.<*>} Flat array.
			 */
			
			
			array.flatten = function flatten(arr, opt_output) {
				var output = opt_output || [];
				for (var i = 0; i < arr.length; i++) {
					if (Array.isArray(arr[i])) {
						array.flatten(arr[i], output);
					} else {
						output.push(arr[i]);
					}
				}
				return output;
			};
			
			/**
			 * Removes the first occurrence of a particular value from an array.
			 * @param {Array.<T>} arr Array from which to remove value.
			 * @param {T} obj Object to remove.
			 * @return {boolean} True if an element was removed.
			 * @template T
			 */
			
			
			array.remove = function remove(arr, obj) {
				var i = arr.indexOf(obj);
				var rv;
				if (rv = i >= 0) {
					array.removeAt(arr, i);
				}
				return rv;
			};
			
			/**
			 * Removes from an array the element at index i
			 * @param {Array} arr Array or array like object from which to remove value.
			 * @param {number} i The index to remove.
			 * @return {boolean} True if an element was removed.
			 */
			
			
			array.removeAt = function removeAt(arr, i) {
				return Array.prototype.splice.call(arr, i, 1).length === 1;
			};
			
			/**
			 * Slices the given array, just like Array.prototype.slice, but this
			 * is faster and working on all array-like objects (like arguments).
			 * @param {!Object} arr Array-like object to slice.
			 * @param {number} start The index that should start the slice.
			 * @param {number=} opt_end The index where the slice should end, not
			 *   included in the final array. If not given, all elements after the
			 *   start index will be included.
			 * @return {!Array}
			 */
			
			
			array.slice = function slice(arr, start, opt_end) {
				var sliced = [];
				var end = _core2.default.isDef(opt_end) ? opt_end : arr.length;
				for (var i = start; i < end; i++) {
					sliced.push(arr[i]);
				}
				return sliced;
			};
			
			return array;
		}();
		
		exports.default = array;
		
		/***/ }),
	/* 111 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
		 * Polyfill from Google's Closure Library.
		 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
		 */
			
			
			
			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var async = {};
			
			/**
			 * Throw an item without interrupting the current execution context.  For
			 * example, if processing a group of items in a loop, sometimes it is useful
			 * to report an error while still allowing the rest of the batch to be
			 * processed.
			 * @param {*} exception
			 */
			async.throwException = function (exception) {
				// Each throw needs to be in its own context.
				async.nextTick(function () {
					throw exception;
				});
			};
			
			/**
			 * Fires the provided callback just before the current callstack unwinds, or as
			 * soon as possible after the current JS execution context.
			 * @param {function(this:THIS)} callback
			 * @param {THIS=} opt_context Object to use as the "this value" when calling
			 *     the provided function.
			 * @template THIS
			 */
			async.run = function (callback, opt_context) {
				if (!async.run.workQueueScheduled_) {
					// Nothing is currently scheduled, schedule it now.
					async.nextTick(async.run.processWorkQueue);
					async.run.workQueueScheduled_ = true;
				}
				
				async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
			};
			
			/** @private {boolean} */
			async.run.workQueueScheduled_ = false;
			
			/** @private {!Array.<!async.run.WorkItem_>} */
			async.run.workQueue_ = [];
			
			/**
			 * Run any pending async.run work items. This function is not intended
			 * for general use, but for use by entry point handlers to run items ahead of
			 * async.nextTick.
			 */
			async.run.processWorkQueue = function () {
				// NOTE: additional work queue items may be pushed while processing.
				while (async.run.workQueue_.length) {
					// Don't let the work queue grow indefinitely.
					var workItems = async.run.workQueue_;
					async.run.workQueue_ = [];
					for (var i = 0; i < workItems.length; i++) {
						var workItem = workItems[i];
						try {
							workItem.fn.call(workItem.scope);
						} catch (e) {
							async.throwException(e);
						}
					}
				}
				
				// There are no more work items, reset the work queue.
				async.run.workQueueScheduled_ = false;
			};
			
			/**
			 * @constructor
			 * @final
			 * @struct
			 * @private
			 *
			 * @param {function()} fn
			 * @param {Object|null|undefined} scope
			 */
			async.run.WorkItem_ = function (fn, scope) {
				/** @const */
				this.fn = fn;
				/** @const */
				this.scope = scope;
			};
			
			/**
			 * Fires the provided callbacks as soon as possible after the current JS
			 * execution context. setTimeout(, 0) always takes at least 5ms for legacy
			 * reasons.
			 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
			 *     possible.
			 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
			 * @template SCOPE
			 */
			async.nextTick = function (callback, opt_context) {
				var cb = callback;
				if (opt_context) {
					cb = callback.bind(opt_context);
				}
				cb = async.nextTick.wrapCallback_(cb);
				// Introduced and currently only supported by IE10.
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof setImmediate === 'function') {
					setImmediate(cb);
					return;
				}
				// Look for and cache the custom fallback version of setImmediate.
				if (!async.nextTick.setImmediate_) {
					async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
				}
				async.nextTick.setImmediate_(cb);
			};
			
			/**
			 * Cache for the setImmediate implementation.
			 * @type {function(function())}
			 * @private
			 */
			async.nextTick.setImmediate_ = null;
			
			/**
			 * Determines the best possible implementation to run a function as soon as
			 * the JS event loop is idle.
			 * @return {function(function())} The "setImmediate" implementation.
			 * @private
			 */
			async.nextTick.getSetImmediateEmulator_ = function () {
				// Create a private message channel and use it to postMessage empty messages
				// to ourselves.
				var Channel;
				
				// Verify if variable is defined on the current runtime (i.e., node, browser).
				// Can't use typeof enclosed in a function (such as core.isFunction) or an
				// exception will be thrown when the function is called on an environment
				// where the variable is undefined.
				if (typeof MessageChannel === 'function') {
					Channel = MessageChannel;
				}
				
				// If MessageChannel is not available and we are in a browser, implement
				// an iframe based polyfill in browsers that have postMessage and
				// document.addEventListener. The latter excludes IE8 because it has a
				// synchronous postMessage implementation.
				if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
					/** @constructor */
					Channel = function Channel() {
						// Make an empty, invisible iframe.
						var iframe = document.createElement('iframe');
						iframe.style.display = 'none';
						iframe.src = '';
						document.documentElement.appendChild(iframe);
						var win = iframe.contentWindow;
						var doc = win.document;
						doc.open();
						doc.write('');
						doc.close();
						var message = 'callImmediate' + Math.random();
						var origin = win.location.protocol + '//' + win.location.host;
						var onmessage = function (e) {
							// Validate origin and message to make sure that this message was
							// intended for us.
							if (e.origin !== origin && e.data !== message) {
								return;
							}
							this.port1.onmessage();
						}.bind(this);
						win.addEventListener('message', onmessage, false);
						this.port1 = {};
						this.port2 = {
							postMessage: function postMessage() {
								win.postMessage(message, origin);
							}
						};
					};
				}
				if (typeof Channel !== 'undefined') {
					var channel = new Channel();
					// Use a fifo linked list to call callbacks in the right order.
					var head = {};
					var tail = head;
					channel.port1.onmessage = function () {
						head = head.next;
						var cb = head.cb;
						head.cb = null;
						cb();
					};
					return function (cb) {
						tail.next = {
							cb: cb
						};
						tail = tail.next;
						channel.port2.postMessage(0);
					};
				}
				// Implementation for IE6-8: Script elements fire an asynchronous
				// onreadystatechange event when inserted into the DOM.
				if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
					return function (cb) {
						var script = document.createElement('script');
						script.onreadystatechange = function () {
							// Clean up and call the callback.
							script.onreadystatechange = null;
							script.parentNode.removeChild(script);
							script = null;
							cb();
							cb = null;
						};
						document.documentElement.appendChild(script);
					};
				}
				// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
				// or more.
				return function (cb) {
					setTimeout(cb, 0);
				};
			};
			
			/**
			 * Helper function that is overrided to protect callbacks with entry point
			 * monitor if the application monitors entry points.
			 * @param {function()} callback Callback function to fire as soon as possible.
			 * @return {function()} The wrapped callback.
			 * @private
			 */
			async.nextTick.wrapCallback_ = function (opt_returnValue) {
				return opt_returnValue;
			};
			
			exports.default = async;
			/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))
		
		/***/ }),
	/* 112 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		/**
		 * Disposable utility. When inherited provides the `dispose` function to its
		 * subclass, which is responsible for disposing of any object references
		 * when an instance won't be used anymore. Subclasses should override
		 * `disposeInternal` to implement any specific disposing logic.
		 * @constructor
		 */
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var Disposable = function () {
			function Disposable() {
				_classCallCheck(this, Disposable);
				
				/**
				 * Flag indicating if this instance has already been disposed.
				 * @type {boolean}
				 * @protected
				 */
				this.disposed_ = false;
			}
			
			/**
			 * Disposes of this instance's object references. Calls `disposeInternal`.
			 */
			
			
			Disposable.prototype.dispose = function dispose() {
				if (!this.disposed_) {
					this.disposeInternal();
					this.disposed_ = true;
				}
			};
			
			/**
			 * Subclasses should override this method to implement any specific
			 * disposing logic (like clearing references and calling `dispose` on other
			 * disposables).
			 */
			
			
			Disposable.prototype.disposeInternal = function disposeInternal() {};
			
			/**
			 * Checks if this instance has already been disposed.
			 * @return {boolean}
			 */
			
			
			Disposable.prototype.isDisposed = function isDisposed() {
				return this.disposed_;
			};
			
			return Disposable;
		}();
		
		exports.default = Disposable;
		
		/***/ }),
	/* 113 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var object = function () {
			function object() {
				_classCallCheck(this, object);
			}
			
			/**
			 * Copies all the members of a source object to a target object.
			 * @param {Object} target Target object.
			 * @param {...Object} var_args The objects from which values will be copied.
			 * @return {Object} Returns the target object reference.
			 */
			object.mixin = function mixin(target) {
				var key, source;
				for (var i = 1; i < arguments.length; i++) {
					source = arguments[i];
					for (key in source) {
						target[key] = source[key];
					}
				}
				return target;
			};
			
			/**
			 * Returns an object based on its fully qualified external name.
			 * @param {string} name The fully qualified name.
			 * @param {object=} opt_obj The object within which to look; default is
			 *     <code>window</code>.
			 * @return {?} The value (object or primitive) or, if not found, undefined.
			 */
			
			
			object.getObjectByName = function getObjectByName(name, opt_obj) {
				var scope = opt_obj || window;
				var parts = name.split('.');
				return parts.reduce(function (part, key) {
					return part[key];
				}, scope);
			};
			
			/**
			 * Returns a new object with the same keys as the given one, but with
			 * their values set to the return values of the specified function.
			 * @param {!Object} obj
			 * @param {!function(string, *)} fn
			 * @return {!Object}
			 */
			
			
			object.map = function map(obj, fn) {
				var mappedObj = {};
				var keys = Object.keys(obj);
				for (var i = 0; i < keys.length; i++) {
					mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
				}
				return mappedObj;
			};
			
			/**
			 * Checks if the two given objects are equal. This is done via a shallow
			 * check, including only the keys directly contained by the 2 objects.
			 * @return {boolean}
			 */
			
			
			object.shallowEqual = function shallowEqual(obj1, obj2) {
				if (obj1 === obj2) {
					return true;
				}
				
				var keys1 = Object.keys(obj1);
				var keys2 = Object.keys(obj2);
				if (keys1.length !== keys2.length) {
					return false;
				}
				
				for (var i = 0; i < keys1.length; i++) {
					if (obj1[keys1[i]] !== obj2[keys1[i]]) {
						return false;
					}
				}
				return true;
			};
			
			return object;
		}();
		
		exports.default = object;
		
		/***/ }),
	/* 114 */
	/***/ (function(module, exports, __webpack_require__) {
		
		"use strict";
		
		
		Object.defineProperty(exports, "__esModule", {
			value: true
		});
		
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		
		var string = function () {
			function string() {
				_classCallCheck(this, string);
			}
			
			/**
			 * Removes the breaking spaces from the left and right of the string and
			 * collapses the sequences of breaking spaces in the middle into single spaces.
			 * The original and the result strings render the same way in HTML.
			 * @param {string} str A string in which to collapse spaces.
			 * @return {string} Copy of the string with normalized breaking spaces.
			 */
			string.collapseBreakingSpaces = function collapseBreakingSpaces(str) {
				return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
			};
			
			/**
			 * Escapes characters in the string that are not safe to use in a RegExp.
			 * @param {*} str The string to escape. If not a string, it will be casted
			 *     to one.
			 * @return {string} A RegExp safe, escaped copy of {@code s}.
			 */
			
			
			string.escapeRegex = function escapeRegex(str) {
				return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
			};
			
			/**
			 * Returns a string with at least 64-bits of randomness.
			 * @return {string} A random string, e.g. sn1s7vb4gcic.
			 */
			
			
			string.getRandomString = function getRandomString() {
				var x = 2147483648;
				return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
			};
			
			/**
			 * Calculates the hashcode for a string. The hashcode value is computed by
			 * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
			 * property of using 31 prime is that the multiplication can be replaced by
			 * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
			 * Modern VMs do this sort of optimization automatically.
			 * @param {String} val Target string.
			 * @return {Number} Returns the string hashcode.
			 */
			
			
			string.hashCode = function hashCode(val) {
				var hash = 0;
				for (var i = 0, len = val.length; i < len; i++) {
					hash = 31 * hash + val.charCodeAt(i);
					hash %= 0x100000000;
				}
				return hash;
			};
			
			/**
			 * Replaces interval into the string with specified value, e.g.
			 * `replaceInterval("abcde", 1, 4, "")` returns "ae".
			 * @param {string} str The input string.
			 * @param {Number} start Start interval position to be replaced.
			 * @param {Number} end End interval position to be replaced.
			 * @param {string} value The value that replaces the specified interval.
			 * @return {string}
			 */
			
			
			string.replaceInterval = function replaceInterval(str, start, end, value) {
				return str.substring(0, start) + value + str.substring(end);
			};
			
			return string;
		}();
		
		exports.default = string;
		
		/***/ }),
	/* 115 */
	/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
		
		function EventEmitter() {
			this._events = this._events || {};
			this._maxListeners = this._maxListeners || undefined;
		}
		module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
		EventEmitter.EventEmitter = EventEmitter;
		
		EventEmitter.prototype._events = undefined;
		EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
		EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
		EventEmitter.prototype.setMaxListeners = function(n) {
			if (!isNumber(n) || n < 0 || isNaN(n))
				throw TypeError('n must be a positive number');
			this._maxListeners = n;
			return this;
		};
		
		EventEmitter.prototype.emit = function(type) {
			var er, handler, len, args, i, listeners;
			
			if (!this._events)
				this._events = {};
			
			// If there is no 'error' event listener then throw.
			if (type === 'error') {
				if (!this._events.error ||
					(isObject(this._events.error) && !this._events.error.length)) {
					er = arguments[1];
					if (er instanceof Error) {
						throw er; // Unhandled 'error' event
					} else {
						// At least give some kind of context to the user
						var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
						err.context = er;
						throw err;
					}
				}
			}
			
			handler = this._events[type];
			
			if (isUndefined(handler))
				return false;
			
			if (isFunction(handler)) {
				switch (arguments.length) {
					// fast cases
					case 1:
						handler.call(this);
						break;
					case 2:
						handler.call(this, arguments[1]);
						break;
					case 3:
						handler.call(this, arguments[1], arguments[2]);
						break;
					// slower
					default:
						args = Array.prototype.slice.call(arguments, 1);
						handler.apply(this, args);
				}
			} else if (isObject(handler)) {
				args = Array.prototype.slice.call(arguments, 1);
				listeners = handler.slice();
				len = listeners.length;
				for (i = 0; i < len; i++)
					listeners[i].apply(this, args);
			}
			
			return true;
		};
		
		EventEmitter.prototype.addListener = function(type, listener) {
			var m;
			
			if (!isFunction(listener))
				throw TypeError('listener must be a function');
			
			if (!this._events)
				this._events = {};
			
			// To avoid recursion in the case that type === "newListener"! Before
			// adding it to the listeners, first emit "newListener".
			if (this._events.newListener)
				this.emit('newListener', type,
					isFunction(listener.listener) ?
						listener.listener : listener);
			
			if (!this._events[type])
			// Optimize the case of one listener. Don't need the extra array object.
				this._events[type] = listener;
			else if (isObject(this._events[type]))
			// If we've already got an array, just append.
				this._events[type].push(listener);
			else
			// Adding the second element, need to change to array.
				this._events[type] = [this._events[type], listener];
			
			// Check for listener leak
			if (isObject(this._events[type]) && !this._events[type].warned) {
				if (!isUndefined(this._maxListeners)) {
					m = this._maxListeners;
				} else {
					m = EventEmitter.defaultMaxListeners;
				}
				
				if (m && m > 0 && this._events[type].length > m) {
					this._events[type].warned = true;
					console.error('(node) warning: possible EventEmitter memory ' +
						'leak detected. %d listeners added. ' +
						'Use emitter.setMaxListeners() to increase limit.',
						this._events[type].length);
					if (typeof console.trace === 'function') {
						// not supported in IE 10
						console.trace();
					}
				}
			}
			
			return this;
		};
		
		EventEmitter.prototype.on = EventEmitter.prototype.addListener;
		
		EventEmitter.prototype.once = function(type, listener) {
			if (!isFunction(listener))
				throw TypeError('listener must be a function');
			
			var fired = false;
			
			function g() {
				this.removeListener(type, g);
				
				if (!fired) {
					fired = true;
					listener.apply(this, arguments);
				}
			}
			
			g.listener = listener;
			this.on(type, g);
			
			return this;
		};

// emits a 'removeListener' event iff the listener was removed
		EventEmitter.prototype.removeListener = function(type, listener) {
			var list, position, length, i;
			
			if (!isFunction(listener))
				throw TypeError('listener must be a function');
			
			if (!this._events || !this._events[type])
				return this;
			
			list = this._events[type];
			length = list.length;
			position = -1;
			
			if (list === listener ||
				(isFunction(list.listener) && list.listener === listener)) {
				delete this._events[type];
				if (this._events.removeListener)
					this.emit('removeListener', type, listener);
				
			} else if (isObject(list)) {
				for (i = length; i-- > 0;) {
					if (list[i] === listener ||
						(list[i].listener && list[i].listener === listener)) {
						position = i;
						break;
					}
				}
				
				if (position < 0)
					return this;
				
				if (list.length === 1) {
					list.length = 0;
					delete this._events[type];
				} else {
					list.splice(position, 1);
				}
				
				if (this._events.removeListener)
					this.emit('removeListener', type, listener);
			}
			
			return this;
		};
		
		EventEmitter.prototype.removeAllListeners = function(type) {
			var key, listeners;
			
			if (!this._events)
				return this;
			
			// not listening for removeListener, no need to emit
			if (!this._events.removeListener) {
				if (arguments.length === 0)
					this._events = {};
				else if (this._events[type])
					delete this._events[type];
				return this;
			}
			
			// emit removeListener for all listeners on all events
			if (arguments.length === 0) {
				for (key in this._events) {
					if (key === 'removeListener') continue;
					this.removeAllListeners(key);
				}
				this.removeAllListeners('removeListener');
				this._events = {};
				return this;
			}
			
			listeners = this._events[type];
			
			if (isFunction(listeners)) {
				this.removeListener(type, listeners);
			} else if (listeners) {
				// LIFO order
				while (listeners.length)
					this.removeListener(type, listeners[listeners.length - 1]);
			}
			delete this._events[type];
			
			return this;
		};
		
		EventEmitter.prototype.listeners = function(type) {
			var ret;
			if (!this._events || !this._events[type])
				ret = [];
			else if (isFunction(this._events[type]))
				ret = [this._events[type]];
			else
				ret = this._events[type].slice();
			return ret;
		};
		
		EventEmitter.prototype.listenerCount = function(type) {
			if (this._events) {
				var evlistener = this._events[type];
				
				if (isFunction(evlistener))
					return 1;
				else if (evlistener)
					return evlistener.length;
			}
			return 0;
		};
		
		EventEmitter.listenerCount = function(emitter, type) {
			return emitter.listenerCount(type);
		};
		
		function isFunction(arg) {
			return typeof arg === 'function';
		}
		
		function isNumber(arg) {
			return typeof arg === 'number';
		}
		
		function isObject(arg) {
			return typeof arg === 'object' && arg !== null;
		}
		
		function isUndefined(arg) {
			return arg === void 0;
		}
		
		
		/***/ }),
	/* 116 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_dom__ = __webpack_require__(6);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_metal_dom__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Utils_EventEmitter__ = __webpack_require__(16);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Dropdown_soy_js__ = __webpack_require__(117);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DropdownUtils__ = __webpack_require__(118);
		
		
		
		
		
		
		
		
		class Dropdown extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {
			/**
			 * Dropdown component.
			 */
			created(){
				let instance = this;
				
				instance.cashItemsData = __WEBPACK_IMPORTED_MODULE_5__DropdownUtils__["a" /* ITEMS_DATA */];
				instance.Listener.on('LISTEN_DROPDOWN_ERROR', err => instance.warning = err);
			}
			
			/**
			 * Set the click event when the body was pressed
			 */
			attached(){
				const showItems = this.showItems;
				document.querySelector('body').addEventListener('click', showItems.bind(this));
			}
			
			/**
			 * Show the dropdowns items
			 * @param {Object} e
			 */
			showItems(e){
				let instance = this,
					active,
					elementClass = e.target.className;
				
				if((elementClass.indexOf('dropdown-display') != -1) || (elementClass.indexOf('dropdown-input') != -1)){
					active = true;
					setTimeout(() => instance.element.querySelector('.dropdown-input').focus(), 200);
				}else {
					instance.focusOut();
				}
				
				instance.shown = active;
			}
			
			/**
			 * Change the selected item in the dropdown
			 * @param {Object} e
			 */
			changeActivePlan(e){
				let instance = this;
				const item = e.target;
				const data = instance.cashItemsData.filter(obj => obj.id == item.getAttribute('data-id'));
				
				item.classList.add('dropdown-list-item--selected');
				
				if(data.length) {
					instance.bindSelectedItemClass(data[0]);
					instance.setState({activeDropdownItem: data[0]});
					instance.emitListener(data[0]);
				}
			}
			
			/**
			 * Clear the input and remove the input focus
			 */
			focusOut(){
				let instance = this;
				const item = instance.element.querySelector('.dropdown-input');
				
				item.value = '';
				instance.items = instance.cashItemsData;
			}
			
			/**
			 * Search items through of the input interaction
			 * @param {Object} e
			 */
			searchItem(e){
				const item = e.target;
				let instance = this;
				instance.items = instance.cashItemsData.filter(obj => obj.name.toLowerCase().indexOf(item.value.toLowerCase()) != -1);
			}
			
			/**
			 * Emit an event to the other components present in the application
			 * @param {Object} data
			 */
			emitListener(data){
				let instance = this;
				instance.warning = false;
				instance.Listener.emit('LISTEN_DROPDOWN_EVENT', data);
			}
			
			/**
			 * Check the key code of the keyboard interactions
			 * @param {Object} e
			 */
			bindKeyCode(e){
				let instance = this;
				if(e.keyCode == 27) return instance.bindESCKey();
				if(e.keyCode == 13) return instance.bindENTERKey(instance.items[0]);
			}
			
			/**
			 * Leave of the dropdown search and
			 * hide the list of items
			 */
			bindESCKey(){
				let instance = this;
				instance.element.querySelector('.dropdown-input').blur();
				instance.shown = false;
			}
			
			/**
			 * Select the first item present in the sarch
			 * if the user didn't search any item
			 * select the first default item
			 */
			bindENTERKey(data){
				let instance = this;
				
				instance.setState({activeDropdownItem: data});
				instance.emitListener(data);
				instance.bindSelectedItemClass(data);
				instance.shown = false;
			}
			
			/**
			 * Change the selected item property
			 * to add the class selected in the component
			 * @param {Object} data
			 */
			bindSelectedItemClass(data){
				let instance = this;
				instance.cashItemsData.forEach(item => item.id == data.id ? item.selected = true : delete item.selected);
			}
		}
		__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Dropdown, __WEBPACK_IMPORTED_MODULE_4__Dropdown_soy_js__["a" /* default */]);
		
		/**
		 * Dropdown state definition
		 */
		Dropdown.STATE = {
			/**
			 * To show the dropdown items
			 */
			shown: {
				value: false
			},
			
			/**
			 * Active item selected in the dropdown
			 */
			activeDropdownItem: {
				value: false
			},
			
			/**
			 * List of items to the dropdown items list
			 */
			items: {
				value: __WEBPACK_IMPORTED_MODULE_5__DropdownUtils__["a" /* ITEMS_DATA */]
			},
			
			/**
			 * Message of warning of the calculator
			 */
			warning: {
				value: ''
			},
			
			/**
			 * Listener for the others components
			 */
			Listener: {
				value: new __WEBPACK_IMPORTED_MODULE_3__Utils_EventEmitter__["a" /* default */]()
			}
		};
		
		
		/* unused harmony default export */ var _unused_webpack_default_export = (Dropdown);
		
		
		/***/ }),
	/* 117 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* unused harmony export Dropdown */
		/* unused harmony export templates */
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
		/* jshint ignore:start */
		
		
		var templates;
		goog.loadModule(function(exports) {

// This file was automatically generated from Dropdown.soy.
// Please don't edit this file by hand.
			
			/**
			 * @fileoverview Templates in namespace Dropdown.
			 * @public
			 */
			
			goog.module('Dropdown.incrementaldom');
			
			/** @suppress {extraRequire} */
			var soy = goog.require('soy');
			/** @suppress {extraRequire} */
			var soydata = goog.require('soydata');
			/** @suppress {extraRequire} */
			goog.require('goog.i18n.bidi');
			/** @suppress {extraRequire} */
			goog.require('goog.asserts');
			var IncrementalDom = goog.require('incrementaldom');
			var ie_open = IncrementalDom.elementOpen;
			var ie_close = IncrementalDom.elementClose;
			var ie_void = IncrementalDom.elementVoid;
			var ie_open_start = IncrementalDom.elementOpenStart;
			var ie_open_end = IncrementalDom.elementOpenEnd;
			var itext = IncrementalDom.text;
			var iattr = IncrementalDom.attr;
			
			
			/**
			 * @param {Object<string, *>=} opt_data
			 * @param {(null|undefined)=} opt_ignored
			 * @param {Object<string, *>=} opt_ijData
			 * @return {void}
			 * @suppress {checkTypes}
			 */
			function $render(opt_data, opt_ignored, opt_ijData) {
				ie_open('div', null, null,
					'class', 'dropdown');
				ie_void('span', null, null,
					'class', 'arrow_box');
				ie_open('input', null, null,
					'type', 'text',
					'class', 'dropdown-display ' + (opt_data.warning ? 'input-error' : ''),
					'placeholder', opt_data.activeDropdownItem ? opt_data.activeDropdownItem.name : 'Select your plan',
					'readonly', 'true');
				ie_close('input');
				ie_open('span', null, null,
					'class', 'warning-label ' + (opt_data.warning ? 'show' : ''));
				itext((goog.asserts.assert((opt_data.warning) != null), opt_data.warning));
				ie_close('span');
				ie_open('div', null, null,
					'class', opt_data.shown ? 'dropdown-list-wrapper show' : 'dropdown-list-wrapper');
				ie_open('input', null, null,
					'type', 'text',
					'data-onKeydown', 'bindKeyCode',
					'data-onKeyup', 'searchItem',
					'placeholder', 'Type your search',
					'class', 'dropdown-input');
				ie_close('input');
				ie_open('ul', null, null,
					'class', 'dropdown-list');
				var itemList59 = opt_data.items;
				var itemListLen59 = itemList59.length;
				for (var itemIndex59 = 0; itemIndex59 < itemListLen59; itemIndex59++) {
					var itemData59 = itemList59[itemIndex59];
					ie_open('li', null, null,
						'class', 'dropdown-list-item',
						'data-selected', itemData59.selected,
						'data-id', itemData59.id,
						'data-onClick', 'changeActivePlan');
					itext((goog.asserts.assert((itemData59.name) != null), itemData59.name));
					itext(' (');
					itext((goog.asserts.assert((itemData59.months) != null), itemData59.months));
					itext(' meses)');
					ie_close('li');
				}
				ie_close('ul');
				ie_close('div');
				ie_close('div');
			}
			exports.render = $render;
			if (goog.DEBUG) {
				$render.soyTemplateName = 'Dropdown.render';
			}
			
			exports.render.params = ["shown","items","activeDropdownItem","warning"];
			exports.render.types = {"shown":"any","items":"any","activeDropdownItem":"any","warning":"any"};
			templates = exports;
			return exports;
			
		});
		
		class Dropdown extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
		__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Dropdown, templates);
		
		/* harmony default export */ __webpack_exports__["a"] = (templates);
		/* jshint ignore:end */
		
		
		/***/ }),
	/* 118 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		const ITEMS_DATA = [
			{id: 0, months: 12, interest:5, name: "Initial"},
			{id: 1, months: 24, interest:7, name: "Bronze"},
			{id: 2, months: 36, interest:9, name: "Gold"},
			{id: 3, months: 48, interest:15, name: "Sphere"}
		];
		/* harmony export (immutable) */ __webpack_exports__["a"] = ITEMS_DATA;
		
		
		
		/***/ }),
	/* 119 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Calculator_soy_js__ = __webpack_require__(120);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CalculatorUtils__ = __webpack_require__(121);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__ = __webpack_require__(16);
		
		
		
		
		
		
		
		
		class Calculator extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {
			/**
			 Calculator component
			 */
			created(){
				let instance = this;
				
				instance.labels.forEach(label => instance.setCalculatorButtonsEvents(label));
				instance.operators.forEach(operator => instance.setCalculatorButtonsEvents(operator));
				instance.Listener.on('LISTEN_CALCULATOR_ERROR', err => instance.warning = err);
			}
			
			/**
			 * Add events for all buttons in the calculator component
			 * located in CalculatorUtils
			 */
			setCalculatorButtonsEvents(button){
				let instance = this;
				
				if(button.isClearButton){
					button.clickFn = instance.delegateDeleteButton.bind(instance);
				}else if(button.isResultButtom){
					button.clickFn = instance.resultOfDisplayExpressions.bind(instance);
				}else {
					button.clickFn = instance.appendIntoDisplay.bind(instance);
				}
			}
			
			/**
			 * Remove digits in the calculator display
			 * to update labelDisplay
			 * and emit the listener to the others components
			 */
			delegateDeleteButton(){
				let instance = this;
				
				instance.labelDisplay = instance.removeLastDigit;
				instance.warning = false;
				instance.emitListener(instance.labelDisplay);
			}
			
			/**
			 * Append digits in the calculator display
			 */
			appendIntoDisplay(e){
				const text = e.target.dataset.text;
				
				let instance = this,labelDisplay = instance.labelDisplay,
					lastDigtOfLabelDisplay = labelDisplay[labelDisplay.length-1];
				
				if(instance.hasOperator(text) && instance.isLastDigitAnOperator(lastDigtOfLabelDisplay)){
					lastDigtOfLabelDisplay = '';
					instance.labelDisplay = instance.removeLastDigit;
				}
				
				if(instance.checkCalculatorExpressions(text, lastDigtOfLabelDisplay)){
					instance.labelDisplay += text;
				}
				
				instance.warning = false;
				return instance.emitListener(instance.labelDisplay);
			}
			
			/**
			 * Check if is not a digit or
			 * if is a digit, check if the digit
			 * comes after a number or an expression
			 */
			checkCalculatorExpressions(text, lastDigtOfLabelDisplay){
				let instance = this,labelDisplay = instance.labelDisplay;
				
				if((!instance.hasOperator(text)) ||
					(!instance.hasDoublePeriod(labelDisplay, text)) &&
					(!instance.isFirstDigitAnOperator(labelDisplay+text) &&
					instance.hasOperator(text) &&
					!instance.isLastDigitAnOperator(lastDigtOfLabelDisplay))) return true;
			}
			
			/**
			 *
			 */
			hasDoublePeriod(calculatorExpression, input){
				const numbers = calculatorExpression+input;
				const regex = /^([0-9])*\.([0-9])*\./;
				const lastNumber = numbers.split(/[+\-\/*]/);
				return regex.test(lastNumber[lastNumber.length-1]);
			}
			
			/**
			 * Emit event to the others components
			 */
			emitListener(data){
				return this.Listener.emit('LISTEN_CALCULATOR_EVENT', data);
			}
			
			/**
			 * Remove the calculator digits
			 */
			get removeLastDigit(){
				let textDisplay = this.labelDisplay;
				
				return textDisplay.substr(0, textDisplay.length - 1);
			}
			
			/**
			 * Process the result of the expressions in the calculator display
			 */
			resultOfDisplayExpressions(){
				let instance = this,
					textDisplay = instance.labelDisplay;
				
				if(!textDisplay) return;
				
				if(instance.isLastDigitAnOperator(textDisplay[textDisplay.length-1])){
					textDisplay = instance.removeLastDigit;
				}
				
				if(instance.hasDifferentNumberOfParentheses(textDisplay)) return instance.warning = "Unmatched parenthesis";
				
				try {
					instance.warning = false;
					instance.labelDisplay = Math.abs(eval(textDisplay)).toString();
					return instance.emitListener(instance.labelDisplay);
				}catch(e) {
					return instance.warning = "Please type a valid expression";
				}
			}
			
			/**
			 * Check if has different number of parentheses
			 * in the calculator display
			 */
			hasDifferentNumberOfParentheses(textDisplay){
				let instance = this,
					openParentheses = instance.countDigitOccurrences(textDisplay, '('),
					closedParentheses = instance.countDigitOccurrences(textDisplay, ')');
				
				if(openParentheses != closedParentheses) return true;
			}
			
			/**
			 * Count the number of occurrences of a determinate digit
			 */
			countDigitOccurrences(text, s1){
				return text.split(s1).length - 1;
			}
			
			/**
			 * Check if the last digit is an operator
			 */
			isLastDigitAnOperator(text){
				const regex = /[+-\/*.]$/;
				return regex.test(text);
			}
			
			/**
			 * Check if the first digit is an operator
			 */
			isFirstDigitAnOperator(text){
				const regex = /^[+-\/*.]/;
				return regex.test(text);
			}
			
			/**
			 * Check if has operator in the param
			 */
			hasOperator(text){
				const regex = /[+-\/*.]/;
				return regex.test(text);
			}
		}
		
		__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Calculator, __WEBPACK_IMPORTED_MODULE_2__Calculator_soy_js__["a" /* default */]);
		
		
		/**
		 * Alert Component definition.
		 */
		Calculator.STATE = {
			/**
			 * Array of labels that are calculator buttons
			 */
			labels: {
				value: __WEBPACK_IMPORTED_MODULE_3__CalculatorUtils__["a" /* labels */]
			},
			
			/**
			 * Message of warning of the calculator
			 */
			warning: {
				value: ''
			},
			
			/**
			 * Array of operators that are calculator buttons
			 */
			operators: {
				value: __WEBPACK_IMPORTED_MODULE_3__CalculatorUtils__["b" /* operators */]
			},
			
			/**
			 * Label where will stay the user numeric expression
			 */
			labelDisplay: {
				value: ''
			},
			
			/**
			 * Listener for the others components
			 */
			Listener: {
				value: new __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__["a" /* default */]()
			}
		};
		
		/* unused harmony default export */ var _unused_webpack_default_export = (Calculator);
		
		
		/***/ }),
	/* 120 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* unused harmony export Calculator */
		/* unused harmony export templates */
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
		/* jshint ignore:start */
		
		
		var templates;
		goog.loadModule(function(exports) {

// This file was automatically generated from Calculator.soy.
// Please don't edit this file by hand.
			
			/**
			 * @fileoverview Templates in namespace Calculator.
			 * @public
			 */
			
			goog.module('Calculator.incrementaldom');
			
			/** @suppress {extraRequire} */
			var soy = goog.require('soy');
			/** @suppress {extraRequire} */
			var soydata = goog.require('soydata');
			/** @suppress {extraRequire} */
			goog.require('goog.i18n.bidi');
			/** @suppress {extraRequire} */
			goog.require('goog.asserts');
			var IncrementalDom = goog.require('incrementaldom');
			var ie_open = IncrementalDom.elementOpen;
			var ie_close = IncrementalDom.elementClose;
			var ie_void = IncrementalDom.elementVoid;
			var ie_open_start = IncrementalDom.elementOpenStart;
			var ie_open_end = IncrementalDom.elementOpenEnd;
			var itext = IncrementalDom.text;
			var iattr = IncrementalDom.attr;
			
			var $templateAlias1 = __WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.getTemplate('CalculatorButton.incrementaldom', 'render');
			
			
			/**
			 * @param {Object<string, *>=} opt_data
			 * @param {(null|undefined)=} opt_ignored
			 * @param {Object<string, *>=} opt_ijData
			 * @return {void}
			 * @suppress {checkTypes}
			 */
			function $render(opt_data, opt_ignored, opt_ijData) {
				opt_data = opt_data || {};
				ie_open('div', null, null,
					'class', 'calculator');
				ie_open('section', null, null,
					'class', 'calculator-display ' + (opt_data.warning ? 'input-error' : ''),
					'id', 'calculator-display');
				itext((goog.asserts.assert((opt_data.labelDisplay) != null), opt_data.labelDisplay));
				ie_close('section');
				ie_open('div', null, null,
					'class', 'warning-label ' + (opt_data.warning ? 'show' : ''));
				itext((goog.asserts.assert((opt_data.warning) != null), opt_data.warning));
				ie_close('div');
				ie_open('section', null, null,
					'class', 'calculator-buttons-wrapper');
				ie_open('section', null, null,
					'class', 'calculator-digits');
				var labelList16 = opt_data.labels;
				var labelListLen16 = labelList16.length;
				for (var labelIndex16 = 0; labelIndex16 < labelListLen16; labelIndex16++) {
					var labelData16 = labelList16[labelIndex16];
					$templateAlias1({text: labelData16.text, click: labelData16.clickFn, buttonClass: labelData16.buttonClass}, null, opt_ijData);
				}
				ie_close('section');
				ie_open('section', null, null,
					'class', 'calculator-operators');
				var operatorList23 = opt_data.operators;
				var operatorListLen23 = operatorList23.length;
				for (var operatorIndex23 = 0; operatorIndex23 < operatorListLen23; operatorIndex23++) {
					var operatorData23 = operatorList23[operatorIndex23];
					$templateAlias1({text: operatorData23.text, click: operatorData23.clickFn, buttonClass: operatorData23.buttonClass}, null, opt_ijData);
				}
				ie_close('section');
				ie_close('section');
				ie_close('div');
			}
			exports.render = $render;
			if (goog.DEBUG) {
				$render.soyTemplateName = 'Calculator.render';
			}
			
			exports.render.params = ["labels","labelDisplay","operators","warning"];
			exports.render.types = {"labels":"any","labelDisplay":"any","operators":"any","warning":"any"};
			templates = exports;
			return exports;
			
		});
		
		class Calculator extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
		__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Calculator, templates);
		
		/* harmony default export */ __webpack_exports__["a"] = (templates);
		/* jshint ignore:end */
		
		
		/***/ }),
	/* 121 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		const labels = [
			{text: '<', isClearButton: true},
			{text: '('},
			{text: ')'},
			{text: '1'},
			{text: '2'},
			{text: '3'},
			{text: '4'},
			{text: '5'},
			{text: '6'},
			{text: '7'},
			{text: '8'},
			{text: '9'},
			{text: '0', buttonClass: 'calculator-button--double-size'},
			{text: '.'}
		];
		/* harmony export (immutable) */ __webpack_exports__["a"] = labels;
		
		
		const operators = [
			{text: '+'},
			{text: '-'},
			{text: '*'},
			{text: '/'},
			{text: '=', isResultButtom: true}
		];
		/* harmony export (immutable) */ __webpack_exports__["b"] = operators;
		
		
		
		/***/ }),
	/* 122 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CalculatorButton_soy_js__ = __webpack_require__(123);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_metal_soy__);
		
		
		
		
		
		
		class CalculatorButton extends __WEBPACK_IMPORTED_MODULE_1_metal_component___default.a {
		}
		
		__WEBPACK_IMPORTED_MODULE_2_metal_soy___default.a.register(CalculatorButton, __WEBPACK_IMPORTED_MODULE_0__CalculatorButton_soy_js__["a" /* default */]);
		
		/**
		 * CalculatorButton State Definition
		 */
		CalculatorButton.STATE = {
			/**
			 * Text present in button
			 */
			text: {
				value: ''
			},
			/**
			 * The action that the button will do
			 */
			click: {
				value: false
			}
		};
		
		/* unused harmony default export */ var _unused_webpack_default_export = (CalculatorButton);
		
		
		/***/ }),
	/* 123 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
		
		"use strict";
		/* unused harmony export CalculatorButton */
		/* unused harmony export templates */
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
		/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
		/* jshint ignore:start */
		
		
		var templates;
		goog.loadModule(function(exports) {

// This file was automatically generated from CalculatorButton.soy.
// Please don't edit this file by hand.
			
			/**
			 * @fileoverview Templates in namespace CalculatorButton.
			 * @public
			 */
			
			goog.module('CalculatorButton.incrementaldom');
			
			/** @suppress {extraRequire} */
			var soy = goog.require('soy');
			/** @suppress {extraRequire} */
			var soydata = goog.require('soydata');
			/** @suppress {extraRequire} */
			goog.require('goog.i18n.bidi');
			/** @suppress {extraRequire} */
			goog.require('goog.asserts');
			var IncrementalDom = goog.require('incrementaldom');
			var ie_open = IncrementalDom.elementOpen;
			var ie_close = IncrementalDom.elementClose;
			var ie_void = IncrementalDom.elementVoid;
			var ie_open_start = IncrementalDom.elementOpenStart;
			var ie_open_end = IncrementalDom.elementOpenEnd;
			var itext = IncrementalDom.text;
			var iattr = IncrementalDom.attr;
			
			
			/**
			 * @param {Object<string, *>=} opt_data
			 * @param {(null|undefined)=} opt_ignored
			 * @param {Object<string, *>=} opt_ijData
			 * @return {void}
			 * @suppress {checkTypes}
			 */
			function $render(opt_data, opt_ignored, opt_ijData) {
				ie_open('button', null, null,
					'data-text', opt_data.text,
					'class', '\t' + (opt_data.buttonClass ? opt_data.buttonClass : 'calculator-button'),
					'data-onClick', opt_data.click);
				itext((goog.asserts.assert((opt_data.text) != null), opt_data.text));
				ie_close('button');
			}
			exports.render = $render;
			if (goog.DEBUG) {
				$render.soyTemplateName = 'CalculatorButton.render';
			}
			
			exports.render.params = ["buttonClass","text","click"];
			exports.render.types = {"buttonClass":"any","text":"any","click":"any"};
			templates = exports;
			return exports;
			
		});
		
		class CalculatorButton extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
		__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(CalculatorButton, templates);
		
		/* harmony default export */ __webpack_exports__["a"] = (templates);
		/* jshint ignore:end */
		
		
		/***/ })
	/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgY2EwYzE2ZDRhMDM1NzY3MDcxMjYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvYWxsL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L2xpYi9Tb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2FsbC9kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9tZXRhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvbWV0YWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9kb21EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2luY3JlbWVudGFsLWRvbS1hb3AuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1V0aWxzL0V2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50SGFuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL0RvbUV2ZW50SGFuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2ZlYXR1cmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL0NvbXBvbmVudERhdGFNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9saWIvYWxsL3N0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9saWIvdmFsaWRhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL0NvbXBvbmVudFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL0luY3JlbWVudGFsRG9tUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvaW5jcmVtZW50YWwtZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2NoYW5nZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2hpbGRyZW4vY2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2FsbEFyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL3JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zY3NzL2FwcC5zY3NzPzFmZTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYXBwLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01ldGFsRm9ybS9NZXRhbEZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWV0YWxGb3JtL01ldGFsRm9ybS5zb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL3N5bmMvc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9kb21OYW1lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL2xpYi9FdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvRXZlbnRFbWl0dGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvRXZlbnRIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL0RvbUV2ZW50RW1pdHRlclByb3h5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2dsb2JhbEV2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZ2xvYmFsRXZhbFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9Db21wb25lbnRSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295LWJ1bmRsZS9saWIvYnVuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vZGlzdC9pbmNyZW1lbnRhbC1kb20tY2pzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20tc3RyaW5nL2Rpc3QvaW5jcmVtZW50YWwtZG9tLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9yZW5kZXIvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2xlYW51cC91bnVzZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlTmFtZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sMmluY2RvbS9saWIvd2l0aFBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL0hUTUxQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwyaW5jZG9tL2xpYi9IVE1MMkluY0RvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL3VuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbGliL1NveUFvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLnNveS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93blV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3IvQ2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DYWxjdWxhdG9yL0NhbGN1bGF0b3Iuc295LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3IvQ2FsY3VsYXRvclV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3JCdXR0b24vQ2FsY3VsYXRvckJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DYWxjdWxhdG9yQnV0dG9uL0NhbGN1bGF0b3JCdXR0b24uc295LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM3REE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEOzs7Ozs7O0FDekNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVE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Q0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsc0NBQXNDO0FBQzNELGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7OztBQ2pUQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFLG9DQUFvQztBQUNuRDtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBLEVB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Q0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUI7OztBQUdyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQy9OQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBLDJCQUEyQix5RkFBeUY7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBLDJCQUEyQixrR0FBa0c7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ1E7QUFDUjtBQUNBOzs7Ozs7OztBQy9GQTtBQUNBLEVBQUUsK0JBQStCO0FBQ2pDLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUseURBQXlEO0FBQzNELEVBQUU7QUFDRjtBQUFBO0FBQUE7O0FBRUE7QUFDQSxFQUFFLFVBQVU7QUFDWixFQUFFLFVBQVU7QUFDWixFQUFFLFVBQVU7QUFDWixFQUFFLFVBQVU7QUFDWixFQUFFO0FBQ0Y7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDdkJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1osY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ1E7QUFDUjtBQUNBIiwiZmlsZSI6ImFwcGJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBjYTBjMTZkNGEwMzU3NjcwNzEyNiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29tcG9uZW50UmVuZGVyZXIgPSBleHBvcnRzLkNvbXBvbmVudFJlZ2lzdHJ5ID0gZXhwb3J0cy5Db21wb25lbnREYXRhTWFuYWdlciA9IGV4cG9ydHMuQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoJy4uL2V2ZW50cy9ldmVudHMnKTtcblxuT2JqZWN0LmtleXMoX2V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2V2ZW50c1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9Db21wb25lbnQgPSByZXF1aXJlKCcuLi9Db21wb25lbnQnKTtcblxudmFyIF9Db21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tcG9uZW50KTtcblxudmFyIF9Db21wb25lbnREYXRhTWFuYWdlciA9IHJlcXVpcmUoJy4uL0NvbXBvbmVudERhdGFNYW5hZ2VyJyk7XG5cbnZhciBfQ29tcG9uZW50RGF0YU1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tcG9uZW50RGF0YU1hbmFnZXIpO1xuXG52YXIgX0NvbXBvbmVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50UmVnaXN0cnknKTtcblxudmFyIF9Db21wb25lbnRSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db21wb25lbnRSZWdpc3RyeSk7XG5cbnZhciBfQ29tcG9uZW50UmVuZGVyZXIgPSByZXF1aXJlKCcuLi9Db21wb25lbnRSZW5kZXJlcicpO1xuXG52YXIgX0NvbXBvbmVudFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbXBvbmVudFJlbmRlcmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbXBvbmVudDIuZGVmYXVsdDtcbmV4cG9ydHMuQ29tcG9uZW50ID0gX0NvbXBvbmVudDIuZGVmYXVsdDtcbmV4cG9ydHMuQ29tcG9uZW50RGF0YU1hbmFnZXIgPSBfQ29tcG9uZW50RGF0YU1hbmFnZXIyLmRlZmF1bHQ7XG5leHBvcnRzLkNvbXBvbmVudFJlZ2lzdHJ5ID0gX0NvbXBvbmVudFJlZ2lzdHJ5Mi5kZWZhdWx0O1xuZXhwb3J0cy5Db21wb25lbnRSZW5kZXJlciA9IF9Db21wb25lbnRSZW5kZXJlcjIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL2FsbC9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52YWxpZGF0b3JzID0gZXhwb3J0cy5Tb3lBb3AgPSBleHBvcnRzLlNveSA9IGV4cG9ydHMuQ29uZmlnID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnJlcXVpcmUoJ21ldGFsLXNveS1idW5kbGUnKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9tZXRhbFN0YXRlID0gcmVxdWlyZSgnbWV0YWwtc3RhdGUnKTtcblxudmFyIF9odG1sMmluY2RvbSA9IHJlcXVpcmUoJ2h0bWwyaW5jZG9tJyk7XG5cbnZhciBfaHRtbDJpbmNkb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaHRtbDJpbmNkb20pO1xuXG52YXIgX21ldGFsSW5jcmVtZW50YWxEb20gPSByZXF1aXJlKCdtZXRhbC1pbmNyZW1lbnRhbC1kb20nKTtcblxudmFyIF9tZXRhbEluY3JlbWVudGFsRG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ldGFsSW5jcmVtZW50YWxEb20pO1xuXG52YXIgX1NveUFvcCA9IHJlcXVpcmUoJy4vU295QW9wJyk7XG5cbnZhciBfU295QW9wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NveUFvcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gVGhlIGluamVjdGVkIGRhdGEgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBzb3kgdGVtcGxhdGVzLlxudmFyIGlqRGF0YSA9IHt9O1xuXG52YXIgU295ID0gZnVuY3Rpb24gKF9JbmNyZW1lbnRhbERvbVJlbmRlcikge1xuXHRfaW5oZXJpdHMoU295LCBfSW5jcmVtZW50YWxEb21SZW5kZXIpO1xuXG5cdGZ1bmN0aW9uIFNveSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU295KTtcblxuXHRcdHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU295Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU295KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU295LCBbe1xuXHRcdGtleTogJ2dldEV4dHJhRGF0YUNvbmZpZycsXG5cblx0XHQvKipcbiAgICogQWRkcyB0aGUgdGVtcGxhdGUgcGFyYW1zIHRvIHRoZSBjb21wb25lbnQncyBzdGF0ZSwgaWYgdGhleSBkb24ndCBleGlzdCB5ZXQuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEV4dHJhRGF0YUNvbmZpZyhjb21wb25lbnQpIHtcblx0XHRcdHZhciBlbGVtZW50VGVtcGxhdGUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuVEVNUExBVEU7XG5cdFx0XHRpZiAoISgwLCBfbWV0YWwuaXNGdW5jdGlvbikoZWxlbWVudFRlbXBsYXRlKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRUZW1wbGF0ZSA9IF9Tb3lBb3AyLmRlZmF1bHQuZ2V0T3JpZ2luYWxGbihlbGVtZW50VGVtcGxhdGUpO1xuXHRcdFx0dGhpcy5zb3lQYXJhbVR5cGVzXyA9IGVsZW1lbnRUZW1wbGF0ZS50eXBlcyB8fCB7fTtcblxuXHRcdFx0dmFyIGtleXMgPSBlbGVtZW50VGVtcGxhdGUucGFyYW1zIHx8IFtdO1xuXHRcdFx0dmFyIGNvbmZpZ3MgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIWNvbXBvbmVudFtrZXlzW2ldXSkge1xuXHRcdFx0XHRcdGNvbmZpZ3Nba2V5c1tpXV0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbmZpZ3M7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvcGllcyB0aGUgY29tcG9uZW50J3Mgc3RhdGUgdG8gYW4gb2JqZWN0IHNvIGl0IGNhbiBiZSBwYXNzZWQgYXMgaXQnc1xuICAgKiB0ZW1wbGF0ZSBjYWxsJ3MgZGF0YS4gVGhlIGNvcHlpbmcgbmVlZHMgdG8gYmUgZG9uZSBiZWNhdXNlLCBpZiB0aGUgY29tcG9uZW50XG4gICAqIGl0c2VsZiBpcyBwYXNzZWQgZGlyZWN0bHksIHNvbWUgcHJvYmxlbXMgb2NjdXIgd2hlbiBzb3kgdHJpZXMgdG8gbWVyZ2UgaXRcbiAgICogd2l0aCBvdGhlciBkYXRhLCBkdWUgdG8gcHJvcGVydHkgZ2V0dGVycyBhbmQgc2V0dGVycy4gVGhpcyBpcyBzYWZlci5cbiAgICogQWxzbyBjYWxscyB0aGUgY29tcG9uZW50J3MgXCJwcmVwYXJlU3RhdGVGb3JSZW5kZXJcIiB0byBsZXQgaXQgY2hhbmdlIHRoZVxuICAgKiBkYXRhIHBhc3NlZCB0byB0aGUgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHBhcmFtcyBUaGUgcGFyYW1zIHVzZWQgYnkgdGhpcyB0ZW1wbGF0ZS5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYnVpbGRUZW1wbGF0ZURhdGFfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYnVpbGRUZW1wbGF0ZURhdGFfKGNvbXBvbmVudCwgcGFyYW1zKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0dmFyIGRhdGEgPSBfbWV0YWwub2JqZWN0Lm1peGluKHt9LCB0aGlzLmdldENvbmZpZyhjb21wb25lbnQpKTtcblx0XHRcdGNvbXBvbmVudC5nZXRTdGF0ZUtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gY29tcG9uZW50W2tleV07XG5cdFx0XHRcdGlmIChfdGhpczIuaXNIdG1sUGFyYW1fKGNvbXBvbmVudCwga2V5KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gc295UmVuZGVyZXJfLnRvSW5jRG9tKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIWRhdGFbcGFyYW1zW2ldXSAmJiAoMCwgX21ldGFsLmlzRnVuY3Rpb24pKGNvbXBvbmVudFtwYXJhbXNbaV1dKSkge1xuXHRcdFx0XHRcdGRhdGFbcGFyYW1zW2ldXSA9IGNvbXBvbmVudFtwYXJhbXNbaV1dLmJpbmQoY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShjb21wb25lbnQucHJlcGFyZVN0YXRlRm9yUmVuZGVyKSkge1xuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50LnByZXBhcmVTdGF0ZUZvclJlbmRlcihkYXRhKSB8fCBkYXRhO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCB0ZW1wbGF0ZSBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHdyYXBwZWQgaW5cbiAgICogYW5vdGhlciB0aG91Z2gsIGp1c3QgdG8gZGVmZXIgdGhlIHJlcXVpcmVtZW50IG9mIHRoZSB0ZW1wbGF0ZSdzIG1vZHVsZVxuICAgKiBiZWluZyByZWFkeSB1bnRpbCB0aGUgZnVuY3Rpb24gaXMgYWN0dWFsbHkgY2FsbGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIFRoZSBzb3kgdGVtcGxhdGUncyBuYW1lc3BhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFRlbXBsYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VGVtcGxhdGUobmFtZXNwYWNlLCB0ZW1wbGF0ZU5hbWUpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG5cdFx0XHRcdGlmICghZ29vZy5sb2FkZWRNb2R1bGVzX1tuYW1lc3BhY2VdKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB0ZW1wbGF0ZSB3aXRoIG5hbWVzcGFjZSBcIicgKyBuYW1lc3BhY2UgKyAnXCIgaGFzIGJlZW4gbG9hZGVkIHlldC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZ29vZy5sb2FkZWRNb2R1bGVzX1tuYW1lc3BhY2VdW3RlbXBsYXRlTmFtZV0ob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJjZXB0ZWQgc295IHRlbXBsYXRlIGNhbGwuIElmIHRoZSBjYWxsIGlzIGZvciBhIGNvbXBvbmVudCdzXG4gICAqIG1haW4gdGVtcGxhdGUsIHRoZW4gaXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgY2FsbCB0aGF0IGluY3JlbWVudGFsIGRvbVxuICAgKiBjYW4gdXNlIGZvciBib3RoIGhhbmRsaW5nIGFuIGluc3RhbmNlIG9mIHRoYXQgY29tcG9uZW50IGFuZCByZW5kZXJpbmcgaXQuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgd2FzXG4gICAqICAgICBpbnRlcmNlcHRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdGhlIHRlbXBsYXRlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlSW50ZXJjZXB0ZWRDYWxsXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUludGVyY2VwdGVkQ2FsbF8ob3JpZ2luYWxGbikge1xuXHRcdFx0dmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXHRcdFx0dmFyIGFyZ3MgPSBbb3JpZ2luYWxGbi5jb21wb25lbnRDdG9yLCBudWxsLCBbXV07XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb3B0X2RhdGEpIHtcblx0XHRcdFx0YXJncy5wdXNoKGtleSwgb3B0X2RhdGFba2V5XSk7XG5cdFx0XHR9XG5cdFx0XHRJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZC5hcHBseShudWxsLCBhcmdzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBwYXJhbSB0eXBlIGlzIGh0bWwuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzSHRtbFBhcmFtXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzSHRtbFBhcmFtXyhjb21wb25lbnQsIG5hbWUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IGNvbXBvbmVudC5nZXREYXRhTWFuYWdlcigpLmdldFN0YXRlSW5zdGFuY2UoY29tcG9uZW50KTtcblx0XHRcdGlmIChzdGF0ZS5nZXRTdGF0ZUtleUNvbmZpZyhuYW1lKS5pc0h0bWwpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBlbGVtZW50VGVtcGxhdGUgPSBfU295QW9wMi5kZWZhdWx0LmdldE9yaWdpbmFsRm4oY29tcG9uZW50LmNvbnN0cnVjdG9yLlRFTVBMQVRFKTtcblx0XHRcdHZhciB0eXBlID0gKGVsZW1lbnRUZW1wbGF0ZS50eXBlcyB8fCB7fSlbbmFtZV0gfHwgJyc7XG5cdFx0XHRyZXR1cm4gdHlwZS5zcGxpdCgnfCcpLmluZGV4T2YoJ2h0bWwnKSAhPT0gLTE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gdGVtcGxhdGVzIHRvIGJlIHVzZWQgYnkgYFNveWAgZm9yIHRoZSBzcGVjaWZpZWRcbiAgICogY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29tcG9uZW50Q3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbXBvbmVudCB0aGF0XG4gICAqICAgICBzaG91bGQgdXNlIHRoZSBnaXZlbiB0ZW1wbGF0ZXMuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdGVtcGxhdGVzIE9iamVjdCBjb250YWluaW5nIHNveSB0ZW1wbGF0ZSBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbWFpblRlbXBsYXRlIFRoZSBuYW1lIG9mIHRoZSBtYWluIHRlbXBsYXRlIHRoYXQgc2hvdWxkIGJlXG4gICAqICAgICB1c2VkIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LiBEZWZhdWx0cyB0byBcInJlbmRlclwiLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVnaXN0ZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnRDdG9yLCB0ZW1wbGF0ZXMpIHtcblx0XHRcdHZhciBtYWluVGVtcGxhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdyZW5kZXInO1xuXG5cdFx0XHRjb21wb25lbnRDdG9yLlJFTkRFUkVSID0gc295UmVuZGVyZXJfO1xuXHRcdFx0Y29tcG9uZW50Q3Rvci5URU1QTEFURSA9IF9Tb3lBb3AyLmRlZmF1bHQuZ2V0T3JpZ2luYWxGbih0ZW1wbGF0ZXNbbWFpblRlbXBsYXRlXSk7XG5cdFx0XHRjb21wb25lbnRDdG9yLlRFTVBMQVRFLmNvbXBvbmVudEN0b3IgPSBjb21wb25lbnRDdG9yO1xuXHRcdFx0X1NveUFvcDIuZGVmYXVsdC5yZWdpc3RlckZvckludGVyY2VwdGlvbih0ZW1wbGF0ZXMsIG1haW5UZW1wbGF0ZSk7XG5cdFx0XHRfbWV0YWxDb21wb25lbnQuQ29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXIoY29tcG9uZW50Q3Rvcik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBtZXRob2QgZnJvbSBgSW5jcmVtZW50YWxEb21SZW5kZXJlcmAgc28gdGhlIGNvbXBvbmVudCdzXG4gICAqIHNveSB0ZW1wbGF0ZSBjYW4gYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgRGF0YSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCB3aGVuIHJlbmRlcmluZyBpdC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJJbmNEb20nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbmNEb20oY29tcG9uZW50KSB7XG5cdFx0XHR2YXIgZWxlbWVudFRlbXBsYXRlID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLlRFTVBMQVRFO1xuXHRcdFx0aWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikoZWxlbWVudFRlbXBsYXRlKSAmJiAhY29tcG9uZW50LnJlbmRlcikge1xuXHRcdFx0XHRlbGVtZW50VGVtcGxhdGUgPSBfU295QW9wMi5kZWZhdWx0LmdldE9yaWdpbmFsRm4oZWxlbWVudFRlbXBsYXRlKTtcblx0XHRcdFx0X1NveUFvcDIuZGVmYXVsdC5zdGFydEludGVyY2VwdGlvbih0aGlzLmhhbmRsZUludGVyY2VwdGVkQ2FsbF8pO1xuXHRcdFx0XHR2YXIgZGF0YSA9IHRoaXMuYnVpbGRUZW1wbGF0ZURhdGFfKGNvbXBvbmVudCwgZWxlbWVudFRlbXBsYXRlLnBhcmFtcyB8fCBbXSk7XG5cdFx0XHRcdGVsZW1lbnRUZW1wbGF0ZShkYXRhLCBudWxsLCBpakRhdGEpO1xuXHRcdFx0XHRfU295QW9wMi5kZWZhdWx0LnN0b3BJbnRlcmNlcHRpb24oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9nZXQoU295LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNveS5wcm90b3R5cGUpLCAncmVuZGVySW5jRG9tJywgdGhpcykuY2FsbCh0aGlzLCBjb21wb25lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBpbmplY3RlZCBkYXRhIG9iamVjdCB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGVtcGxhdGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0SW5qZWN0ZWREYXRhJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0SW5qZWN0ZWREYXRhKGRhdGEpIHtcblx0XHRcdGlqRGF0YSA9IGRhdGEgfHwge307XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgb3JpZ2luYWwgYEluY3JlbWVudGFsRG9tUmVuZGVyZXJgIG1ldGhvZCBzbyB0aGF0IG9ubHlcbiAgICogc3RhdGUga2V5cyB1c2VkIGJ5IHRoZSBtYWluIHRlbXBsYXRlIGNhbiBjYXVzZSB1cGRhdGVzLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hvdWxkVXBkYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hvdWxkVXBkYXRlKGNvbXBvbmVudCwgY2hhbmdlcykge1xuXHRcdFx0dmFyIHNob3VsZCA9IF9nZXQoU295LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNveS5wcm90b3R5cGUpLCAnc2hvdWxkVXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBjb21wb25lbnQsIGNoYW5nZXMpO1xuXHRcdFx0aWYgKCFzaG91bGQgfHwgY29tcG9uZW50LnNob3VsZFVwZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gc2hvdWxkO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZm4gPSBjb21wb25lbnQuY29uc3RydWN0b3IuVEVNUExBVEU7XG5cdFx0XHR2YXIgcGFyYW1zID0gZm4gPyBfU295QW9wMi5kZWZhdWx0LmdldE9yaWdpbmFsRm4oZm4pLnBhcmFtcyA6IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGNoYW5nZXMucHJvcHNbcGFyYW1zW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gaW50byBhbiBodG1sIHN0cmluZy5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gaW5jRG9tRm5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndG9IdG1sU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9IdG1sU3RyaW5nKGluY0RvbUZuKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0SW5jcmVtZW50YWxET00ucGF0Y2goZWxlbWVudCwgaW5jRG9tRm4pO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcgaW50byBhbiBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfHtjb250ZW50S2luZDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9fSB2YWx1ZVxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RvSW5jRG9tJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9JbmNEb20odmFsdWUpIHtcblx0XHRcdGlmICgoMCwgX21ldGFsLmlzT2JqZWN0KSh2YWx1ZSkgJiYgKDAsIF9tZXRhbC5pc1N0cmluZykodmFsdWUuY29udGVudCkgJiYgdmFsdWUuY29udGVudEtpbmQgPT09ICdIVE1MJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gX2h0bWwyaW5jZG9tMi5kZWZhdWx0LmJ1aWxkRm4odmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTb3k7XG59KF9tZXRhbEluY3JlbWVudGFsRG9tMi5kZWZhdWx0LmNvbnN0cnVjdG9yKTtcblxudmFyIHNveVJlbmRlcmVyXyA9IG5ldyBTb3koKTtcbnNveVJlbmRlcmVyXy5SRU5ERVJFUl9OQU1FID0gJ3NveSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHNveVJlbmRlcmVyXztcbmV4cG9ydHMuQ29uZmlnID0gX21ldGFsU3RhdGUuQ29uZmlnO1xuZXhwb3J0cy5Tb3kgPSBzb3lSZW5kZXJlcl87XG5leHBvcnRzLlNveUFvcCA9IF9Tb3lBb3AyLmRlZmF1bHQ7XG5leHBvcnRzLnZhbGlkYXRvcnMgPSBfbWV0YWxTdGF0ZS52YWxpZGF0b3JzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9saWIvU295LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZG9tID0gdW5kZWZpbmVkO1xuXG52YXIgX2RvbU5hbWVkID0gcmVxdWlyZSgnLi9kb21OYW1lZCcpO1xuXG5PYmplY3Qua2V5cyhfZG9tTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9kb21OYW1lZFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIGRvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9kb21OYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRvbTtcbmV4cG9ydHMuZG9tID0gZG9tO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2xvYmFsRXZhbFN0eWxlcyA9IGV4cG9ydHMuZ2xvYmFsRXZhbCA9IGV4cG9ydHMuZmVhdHVyZXMgPSBleHBvcnRzLkRvbUV2ZW50SGFuZGxlID0gZXhwb3J0cy5Eb21FdmVudEVtaXR0ZXJQcm94eSA9IGV4cG9ydHMuZG9tRGF0YSA9IHVuZGVmaW5lZDtcblxudmFyIF9kb20gPSByZXF1aXJlKCcuLi9kb20nKTtcblxuT2JqZWN0LmtleXMoX2RvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2RvbVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblxudmFyIF9kb21EYXRhID0gcmVxdWlyZSgnLi4vZG9tRGF0YScpO1xuXG52YXIgX2RvbURhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tRGF0YSk7XG5cbnZhciBfRG9tRXZlbnRFbWl0dGVyUHJveHkgPSByZXF1aXJlKCcuLi9Eb21FdmVudEVtaXR0ZXJQcm94eScpO1xuXG52YXIgX0RvbUV2ZW50RW1pdHRlclByb3h5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvbUV2ZW50RW1pdHRlclByb3h5KTtcblxudmFyIF9Eb21FdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4uL0RvbUV2ZW50SGFuZGxlJyk7XG5cbnZhciBfRG9tRXZlbnRIYW5kbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRG9tRXZlbnRIYW5kbGUpO1xuXG52YXIgX2ZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMnKTtcblxudmFyIF9mZWF0dXJlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mZWF0dXJlcyk7XG5cbnZhciBfZ2xvYmFsRXZhbCA9IHJlcXVpcmUoJy4uL2dsb2JhbEV2YWwnKTtcblxudmFyIF9nbG9iYWxFdmFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbEV2YWwpO1xuXG52YXIgX2dsb2JhbEV2YWxTdHlsZXMgPSByZXF1aXJlKCcuLi9nbG9iYWxFdmFsU3R5bGVzJyk7XG5cbnZhciBfZ2xvYmFsRXZhbFN0eWxlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxFdmFsU3R5bGVzKTtcblxucmVxdWlyZSgnLi4vZXZlbnRzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZG9tRGF0YSA9IF9kb21EYXRhMi5kZWZhdWx0O1xuZXhwb3J0cy5Eb21FdmVudEVtaXR0ZXJQcm94eSA9IF9Eb21FdmVudEVtaXR0ZXJQcm94eTIuZGVmYXVsdDtcbmV4cG9ydHMuRG9tRXZlbnRIYW5kbGUgPSBfRG9tRXZlbnRIYW5kbGUyLmRlZmF1bHQ7XG5leHBvcnRzLmZlYXR1cmVzID0gX2ZlYXR1cmVzMi5kZWZhdWx0O1xuZXhwb3J0cy5nbG9iYWxFdmFsID0gX2dsb2JhbEV2YWwyLmRlZmF1bHQ7XG5leHBvcnRzLmdsb2JhbEV2YWxTdHlsZXMgPSBfZ2xvYmFsRXZhbFN0eWxlczIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kb20yLmRlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9hbGwvZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRXZlbnRIYW5kbGVyID0gZXhwb3J0cy5FdmVudEhhbmRsZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyUHJveHkgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9FdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIpO1xuXG52YXIgX0V2ZW50RW1pdHRlclByb3h5ID0gcmVxdWlyZSgnLi9FdmVudEVtaXR0ZXJQcm94eScpO1xuXG52YXIgX0V2ZW50RW1pdHRlclByb3h5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50RW1pdHRlclByb3h5KTtcblxudmFyIF9FdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4vRXZlbnRIYW5kbGUnKTtcblxudmFyIF9FdmVudEhhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEhhbmRsZSk7XG5cbnZhciBfRXZlbnRIYW5kbGVyID0gcmVxdWlyZSgnLi9FdmVudEhhbmRsZXInKTtcblxudmFyIF9FdmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnRIYW5kbGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0V2ZW50RW1pdHRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gX0V2ZW50RW1pdHRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyUHJveHkgPSBfRXZlbnRFbWl0dGVyUHJveHkyLmRlZmF1bHQ7XG5leHBvcnRzLkV2ZW50SGFuZGxlID0gX0V2ZW50SGFuZGxlMi5kZWZhdWx0O1xuZXhwb3J0cy5FdmVudEhhbmRsZXIgPSBfRXZlbnRIYW5kbGVyMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xlYXJEYXRhID0gY2xlYXJEYXRhO1xuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbnZhciBSRU5ERVJFUl9EQVRBID0gJ19fTUVUQUxfSUNfUkVOREVSRVJfREFUQV9fJztcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBpbmNyZW1lbnRhbCBkb20gcmVuZGVyZXIgZGF0YSBvYmplY3QgZm9yIHRoaXMgY29tcG9uZW50LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY2xlYXJEYXRhKGNvbXBvbmVudCkge1xuICBjb21wb25lbnRbUkVOREVSRVJfREFUQV0gPSBudWxsO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluY3JlbWVudGFsIGRvbSByZW5kZXJlciBkYXRhIG9iamVjdCBmb3IgdGhpcyBjb21wb25lbnQsIGNyZWF0aW5nXG4gKiBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXREYXRhKGNvbXBvbmVudCkge1xuICBpZiAoIWNvbXBvbmVudFtSRU5ERVJFUl9EQVRBXSkge1xuICAgIGNvbXBvbmVudFtSRU5ERVJFUl9EQVRBXSA9IHt9O1xuICB9XG4gIHJldHVybiBjb21wb25lbnRbUkVOREVSRVJfREFUQV07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9kYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0cmluZyA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5hc3luYyA9IGV4cG9ydHMuYXJyYXkgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5PYmplY3Qua2V5cyhfY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hcnJheSA9IHJlcXVpcmUoJy4vYXJyYXkvYXJyYXknKTtcblxudmFyIF9hcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jL2FzeW5jJyk7XG5cbnZhciBfYXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmMpO1xuXG52YXIgX0Rpc3Bvc2FibGUgPSByZXF1aXJlKCcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZScpO1xuXG52YXIgX0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlzcG9zYWJsZSk7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3Qvb2JqZWN0Jyk7XG5cbnZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG5cbnZhciBfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcvc3RyaW5nJyk7XG5cbnZhciBfc3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuYXJyYXkgPSBfYXJyYXkyLmRlZmF1bHQ7XG5leHBvcnRzLmFzeW5jID0gX2FzeW5jMi5kZWZhdWx0O1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gX0Rpc3Bvc2FibGUyLmRlZmF1bHQ7XG5leHBvcnRzLm9iamVjdCA9IF9vYmplY3QyLmRlZmF1bHQ7XG5leHBvcnRzLnN0cmluZyA9IF9zdHJpbmcyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9tZXRhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBNRVRBTF9EQVRBID0gJ19fbWV0YWxfZGF0YV9fJztcblxudmFyIGRvbURhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGRvbURhdGEoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGRvbURhdGEpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGRvbURhdGEsIG51bGwsIFt7XG5cdFx0a2V5OiAnZ2V0JyxcblxuXHRcdC8qKlxuICAgKiBHZXRzIE1ldGFsLmpzJ3MgZGF0YSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbmFtZSBPcHRpb25hbCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHRvIGJlIHJldHVybmVkLlxuICAgKiBAcGFyYW0geyp9IG9wdF9pbml0aWFsVmFsIE9wdGluYWwgdmFsdWUgdG8gdGhlIHNldCB0aGUgcmVxdWVzdGVkIHByb3BlcnR5XG4gICAqICAgICB0byBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCBpbiB0aGUgZGF0YS5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldChlbGVtZW50LCBvcHRfbmFtZSwgb3B0X2luaXRpYWxWYWwpIHtcblx0XHRcdGlmICghZWxlbWVudFtNRVRBTF9EQVRBXSkge1xuXHRcdFx0XHRlbGVtZW50W01FVEFMX0RBVEFdID0ge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoIW9wdF9uYW1lKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50W01FVEFMX0RBVEFdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFlbGVtZW50W01FVEFMX0RBVEFdW29wdF9uYW1lXSAmJiBvcHRfaW5pdGlhbFZhbCkge1xuXHRcdFx0XHRlbGVtZW50W01FVEFMX0RBVEFdW29wdF9uYW1lXSA9IG9wdF9pbml0aWFsVmFsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRbTUVUQUxfREFUQV1bb3B0X25hbWVdO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIGRhdGEgc3RvcmVkIGluIGl0LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuICEhZWxlbWVudFtNRVRBTF9EQVRBXTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gZG9tRGF0YTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZG9tRGF0YTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2RvbURhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvbWV0YWwuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0T3JpZ2luYWxGbnMgPSBnZXRPcmlnaW5hbEZucztcbmV4cG9ydHMuZ2V0T3JpZ2luYWxGbiA9IGdldE9yaWdpbmFsRm47XG5leHBvcnRzLnN0YXJ0SW50ZXJjZXB0aW9uID0gc3RhcnRJbnRlcmNlcHRpb247XG5leHBvcnRzLnN0b3BJbnRlcmNlcHRpb24gPSBzdG9wSW50ZXJjZXB0aW9uO1xuXG5yZXF1aXJlKCcuL2luY3JlbWVudGFsLWRvbScpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb25zLlxuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JpZ2luYWxGbnMoKSB7XG5cdHJldHVybiBvcmlnaW5hbEZucztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPcmlnaW5hbEZuKG5hbWUpIHtcblx0cmV0dXJuIG9yaWdpbmFsRm5zW25hbWVdO1xufVxuXG4vKipcbiAqIFN0YXJ0cyBpbnRlcmNlcHRpbmcgY2FsbHMgdG8gaW5jcmVtZW50YWwgZG9tLCByZXBsYWNpbmcgdGhlbSB3aXRoIHRoZSBnaXZlblxuICogZnVuY3Rpb25zLiBOb3RlIHRoYXQgYGVsZW1lbnRWb2lkYCwgYGVsZW1lbnRPcGVuU3RhcnRgLCBgZWxlbWVudE9wZW5FbmRgXG4gKiBhbmQgYGF0dHJgIGFyZSB0aGUgb25seSBvbmVzIHRoYXQgY2FuJ3QgYmUgaW50ZXJjZXB0ZWQsIHNpbmNlIHRoZXknbGxcbiAqIGF1dG9tYXRpY2FsbHkgYmUgY29udmVydGVkIGludG8gZXF1aXZhbGVudCBjYWxscyB0byBgZWxlbWVudE9wZW5gIGFuZFxuICogYGVsZW1lbnRDbG9zZWAuXG4gKiBAcGFyYW0geyFPYmplY3R9IGZucyBGdW5jdGlvbnMgdG8gYmUgY2FsbGVkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIG9uZXNcbiAqICAgICBmcm9tIGluY3JlbWVudGFsIERPTS4gU2hvdWxkIGJlIGdpdmVuIGFzIGEgbWFwIGZyb20gdGhlIGZ1bmN0aW9uIG5hbWVcbiAqICAgICB0byB0aGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgaW50ZXJjZXB0IGl0LiBBbGwgaW50ZXJjZXB0b3JzIHdpbGwgcmVjZWl2ZVxuICogICAgIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhY3R1YWwgYXJndW1lbnRzIGZyb21cbiAqICAgICBmcm9tIHRoZSBvcmlnaW5hbCBjYWxsIGZvbGxvd2luZyBpdC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRJbnRlcmNlcHRpb24oZm5zKSB7XG5cdGZucy5hdHRyID0gZm5BdHRyO1xuXHRmbnMuZWxlbWVudE9wZW5FbmQgPSBmbk9wZW5FbmQ7XG5cdGZucy5lbGVtZW50T3BlblN0YXJ0ID0gZm5PcGVuU3RhcnQ7XG5cdGZucy5lbGVtZW50Vm9pZCA9IGZuVm9pZDtcblx0Zm5TdGFjay5wdXNoKGZucyk7XG59XG5cbi8qKlxuICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbCBkb20gdG8gdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBpdCB1c2VkIGJlZm9yZSB0aGUgbGFzdCBjYWxsIHRvIGBzdGFydEludGVyY2VwdGlvbmAuXG4gKi9cbmZ1bmN0aW9uIHN0b3BJbnRlcmNlcHRpb24oKSB7XG5cdGZuU3RhY2sucG9wKCk7XG59XG5cbnZhciBvcmlnaW5hbEZucyA9IHtcblx0YXR0cjogSW5jcmVtZW50YWxET00uYXR0cixcblx0YXR0cmlidXRlczogSW5jcmVtZW50YWxET00uYXR0cmlidXRlc1tJbmNyZW1lbnRhbERPTS5zeW1ib2xzLmRlZmF1bHRdLFxuXHRlbGVtZW50Q2xvc2U6IEluY3JlbWVudGFsRE9NLmVsZW1lbnRDbG9zZSxcblx0ZWxlbWVudE9wZW46IEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuLFxuXHRlbGVtZW50T3BlbkVuZDogSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW5FbmQsXG5cdGVsZW1lbnRPcGVuU3RhcnQ6IEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuU3RhcnQsXG5cdGVsZW1lbnRWb2lkOiBJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZCxcblx0dGV4dDogSW5jcmVtZW50YWxET00udGV4dFxufTtcblxudmFyIGZuU3RhY2sgPSBbXTtcblxudmFyIGNvbGxlY3RlZEFyZ3MgPSBbXTtcblxuZnVuY3Rpb24gZm5BdHRyKG5hbWUsIHZhbHVlKSB7XG5cdGNvbGxlY3RlZEFyZ3MucHVzaChuYW1lLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZuT3BlblN0YXJ0KHRhZywga2V5LCBzdGF0aWNzKSB7XG5cdGNvbGxlY3RlZEFyZ3MgPSBbdGFnLCBrZXksIHN0YXRpY3NdO1xufVxuXG5mdW5jdGlvbiBmbk9wZW5FbmQoKSB7XG5cdHZhciBfSW5jcmVtZW50YWxET007XG5cblx0cmV0dXJuIChfSW5jcmVtZW50YWxET00gPSBJbmNyZW1lbnRhbERPTSkuZWxlbWVudE9wZW4uYXBwbHkoX0luY3JlbWVudGFsRE9NLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sbGVjdGVkQXJncykpO1xufVxuXG5mdW5jdGlvbiBmblZvaWQoKSB7XG5cdEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdHJldHVybiBJbmNyZW1lbnRhbERPTS5lbGVtZW50Q2xvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2soKSB7XG5cdHJldHVybiBmblN0YWNrLmxlbmd0aCA+IDAgPyBmblN0YWNrW2ZuU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBidWlsZEhhbmRsZUNhbGwobmFtZSkge1xuXHR2YXIgZGF0YSA9IHtcblx0XHRuYW1lOiBuYW1lXG5cdH07XG5cdHZhciBmbiA9IGhhbmRsZUNhbGwuYmluZChkYXRhKTtcblx0cmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDYWxsKCkge1xuXHR2YXIgbmFtZSA9IHRoaXMubmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHR2YXIgc3RhY2sgPSBnZXRTdGFjaygpO1xuXHR2YXIgZm4gPSBzdGFjayAmJiBzdGFja1tuYW1lXSB8fCBvcmlnaW5hbEZuc1tuYW1lXTtcblx0cmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbkluY3JlbWVudGFsRE9NLmF0dHIgPSBidWlsZEhhbmRsZUNhbGwoJ2F0dHInKTtcbkluY3JlbWVudGFsRE9NLmVsZW1lbnRDbG9zZSA9IGJ1aWxkSGFuZGxlQ2FsbCgnZWxlbWVudENsb3NlJyk7XG5JbmNyZW1lbnRhbERPTS5lbGVtZW50T3BlbiA9IGJ1aWxkSGFuZGxlQ2FsbCgnZWxlbWVudE9wZW4nKTtcbkluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuRW5kID0gYnVpbGRIYW5kbGVDYWxsKCdlbGVtZW50T3BlbkVuZCcpO1xuSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW5TdGFydCA9IGJ1aWxkSGFuZGxlQ2FsbCgnZWxlbWVudE9wZW5TdGFydCcpO1xuSW5jcmVtZW50YWxET00uZWxlbWVudFZvaWQgPSBidWlsZEhhbmRsZUNhbGwoJ2VsZW1lbnRWb2lkJyk7XG5JbmNyZW1lbnRhbERPTS50ZXh0ID0gYnVpbGRIYW5kbGVDYWxsKCd0ZXh0Jyk7XG5cbkluY3JlbWVudGFsRE9NLmF0dHJpYnV0ZXNbSW5jcmVtZW50YWxET00uc3ltYm9scy5kZWZhdWx0XSA9IGJ1aWxkSGFuZGxlQ2FsbCgnYXR0cmlidXRlcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvaW5jcmVtZW50YWwtZG9tLWFvcC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEV2ZW50cyBmcm9tICdldmVudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRze1xuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHN1cGVyKCk7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL1V0aWxzL0V2ZW50RW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRMaXN0ZW5lcnNGcm9tT2JqID0gYWRkTGlzdGVuZXJzRnJvbU9iajtcbmV4cG9ydHMuZ2V0Q29tcG9uZW50Rm4gPSBnZXRDb21wb25lbnRGbjtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbi8qKlxuICogQWRkcyB0aGUgbGlzdGVuZXJzIHNwZWNpZmllZCBpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudHNcbiAqIEByZXR1cm4geyFBcnJheTwhRXZlbnRIYW5kbGU+fSBIYW5kbGVzIGZyb20gYWxsIHN1YnNjcmliZWQgZXZlbnRzLlxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnNGcm9tT2JqKGNvbXBvbmVudCwgZXZlbnRzKSB7XG5cdHZhciBldmVudE5hbWVzID0gT2JqZWN0LmtleXMoZXZlbnRzIHx8IHt9KTtcblx0dmFyIGhhbmRsZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGluZm8gPSBleHRyYWN0TGlzdGVuZXJJbmZvXyhjb21wb25lbnQsIGV2ZW50c1tldmVudE5hbWVzW2ldXSk7XG5cdFx0aWYgKGluZm8uZm4pIHtcblx0XHRcdHZhciBoYW5kbGUgPSB2b2lkIDA7XG5cdFx0XHRpZiAoaW5mby5zZWxlY3Rvcikge1xuXHRcdFx0XHRoYW5kbGUgPSBjb21wb25lbnQuZGVsZWdhdGUoZXZlbnROYW1lc1tpXSwgaW5mby5zZWxlY3RvciwgaW5mby5mbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGUgPSBjb21wb25lbnQub24oZXZlbnROYW1lc1tpXSwgaW5mby5mbik7XG5cdFx0XHR9XG5cdFx0XHRoYW5kbGVzLnB1c2goaGFuZGxlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGhhbmRsZXM7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgbGlzdGVuZXIgaW5mbyBmcm9tIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtmdW5jdGlvbigpfHN0cmluZ3x7c2VsZWN0b3I6c3RyaW5nLGZuOmZ1bmN0aW9uKCl8c3RyaW5nfX0gdmFsdWVcbiAqIEByZXR1cm4geyF7c2VsZWN0b3I6c3RyaW5nLGZuOmZ1bmN0aW9uKCl9fVxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBleHRyYWN0TGlzdGVuZXJJbmZvXyhjb21wb25lbnQsIHZhbHVlKSB7XG5cdHZhciBpbmZvID0ge1xuXHRcdGZuOiB2YWx1ZVxuXHR9O1xuXHRpZiAoKDAsIF9tZXRhbC5pc09iamVjdCkodmFsdWUpICYmICEoMCwgX21ldGFsLmlzRnVuY3Rpb24pKHZhbHVlKSkge1xuXHRcdGluZm8uc2VsZWN0b3IgPSB2YWx1ZS5zZWxlY3Rvcjtcblx0XHRpbmZvLmZuID0gdmFsdWUuZm47XG5cdH1cblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKGluZm8uZm4pKSB7XG5cdFx0aW5mby5mbiA9IGdldENvbXBvbmVudEZuKGNvbXBvbmVudCwgaW5mby5mbik7XG5cdH1cblx0cmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSBpdHMgbmFtZS4gVGhyb3dzIGFuIGVycm9yIGlmIG5vbmUgZXhpc3QuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHJldHVybiB7ZnVuY3Rpb24oKX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Rm4oY29tcG9uZW50LCBmbk5hbWUpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikoY29tcG9uZW50W2ZuTmFtZV0pKSB7XG5cdFx0cmV0dXJuIGNvbXBvbmVudFtmbk5hbWVdLmJpbmQoY29tcG9uZW50KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLmVycm9yKCdObyBmdW5jdGlvbiBuYW1lZCAnICsgZm5OYW1lICsgJyB3YXMgZm91bmQgaW4gdGhlIGNvbXBvbmVudFxcblxcdFxcdFxcdFwiJyArICgwLCBfbWV0YWwuZ2V0RnVuY3Rpb25OYW1lKShjb21wb25lbnQuY29uc3RydWN0b3IpICsgJ1wiLiBNYWtlIHN1cmUgdGhhdCB5b3Ugc3BlY2lmeVxcblxcdFxcdFxcdHZhbGlkIGZ1bmN0aW9uIG5hbWVzIHdoZW4gYWRkaW5nIGlubGluZSBsaXN0ZW5lcnMnKTtcblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlTmFtZWQgPSByZXF1aXJlKCcuL2NvcmVOYW1lZCcpO1xuXG5PYmplY3Qua2V5cyhfY29yZU5hbWVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZU5hbWVkW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlTmFtZWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuZXhwb3J0cy5jb3JlID0gY29yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBleGlzdHMganVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIG1ha2luZyBzdXJlIHRoYXQgb2xkXG4vLyBkZWZhdWx0IGltcG9ydHMgZm9yIHRoaXMgZmlsZSBzdGlsbCB3b3JrLiBJdCdzIGJlc3QgdG8gdXNlIHRoZSBuYW1lZCBleHBvcnRzXG4vLyBmb3IgZWFjaCBmdW5jdGlvbiBpbnN0ZWFkIHRob3VnaCwgc2luY2UgdGhhdCBhbGxvd3MgYnVuZGxlcnMgbGlrZSBSb2xsdXAgdG9cbi8vIHJlZHVjZSB0aGUgYnVuZGxlIHNpemUgYnkgcmVtb3ZpbmcgdW51c2VkIGNvZGUuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZU5hbWVkID0gcmVxdWlyZSgnLi9jb3JlTmFtZWQnKTtcblxuT2JqZWN0LmtleXMoX2NvcmVOYW1lZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVOYW1lZFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZU5hbWVkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY29yZTtcbmV4cG9ydHMuY29yZSA9IGNvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEV2ZW50SGFuZGxlIHV0aWxpdHkuIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGFuIGV2ZW50IHN1YnNjcmlwdGlvbiwgYW5kXG4gKiBhbGxvd3MgcmVtb3ZpbmcgdGhlbSBlYXNpbHkuXG4gKiBFdmVudEhhbmRsZSBpcyBhIERpc3Bvc2FibGUsIGJ1dCBpdCdzIGltcG9ydGFudCB0byBub3RlIHRoYXQgdGhlXG4gKiBFdmVudEVtaXR0ZXIgdGhhdCBjcmVhdGVkIGl0IGlzIG5vdCB0aGUgb25lIHJlc3BvbnNpYmxlIGZvciBkaXNwb3NpbmcgaXQuXG4gKiBUaGF0IHJlc3BvbnNpYmlsaXR5IGlzIGZvciB0aGUgY29kZSB0aGF0IGhvbGRzIGEgcmVmZXJlbmNlIHRvIGl0LlxuICogQHBhcmFtIHshRXZlbnRFbWl0dGVyfSBlbWl0dGVyIEVtaXR0ZXIgdGhlIGV2ZW50IHdhcyBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBzdWJzY3JpYmVkIHRvIHRoZSBldmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Rpc3Bvc2FibGV9XG4gKi9cbnZhciBFdmVudEhhbmRsZSA9IGZ1bmN0aW9uIChfRGlzcG9zYWJsZSkge1xuXHRfaW5oZXJpdHMoRXZlbnRIYW5kbGUsIF9EaXNwb3NhYmxlKTtcblxuXHRmdW5jdGlvbiBFdmVudEhhbmRsZShlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRIYW5kbGUpO1xuXG5cdFx0LyoqXG4gICAqIFRoZSBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdGhhdCB0aGUgZXZlbnQgd2FzIHN1YnNjcmliZWQgdG8uXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEV2ZW50SGFuZGxlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXZlbnRIYW5kbGUpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmVtaXR0ZXJfID0gZW1pdHRlcjtcblxuXHRcdC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCB3YXMgc3Vic2NyaWJlZCB0by5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5ldmVudF8gPSBldmVudDtcblxuXHRcdC8qKlxuICAgKiBUaGUgbGlzdGVuZXIgc3Vic2NyaWJlZCB0byB0aGUgZXZlbnQuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5saXN0ZW5lcl8gPSBsaXN0ZW5lcjtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuXG4gICogQG92ZXJyaWRlXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRXZlbnRIYW5kbGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdFx0dGhpcy5lbWl0dGVyXyA9IG51bGw7XG5cdFx0XHR0aGlzLmxpc3RlbmVyXyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBlbWl0dGVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlTGlzdGVuZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcblx0XHRcdGlmICghdGhpcy5lbWl0dGVyXy5pc0Rpc3Bvc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5lbWl0dGVyXy5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50XywgdGhpcy5saXN0ZW5lcl8pO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBFdmVudEhhbmRsZTtcbn0oX21ldGFsLkRpc3Bvc2FibGUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEhhbmRsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50SGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWxFdmVudHMgPSByZXF1aXJlKCdtZXRhbC1ldmVudHMnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRoaXMgaXMgYSBzcGVjaWFsIEV2ZW50SGFuZGxlLCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkb20gZXZlbnRzLCBpbnN0ZWFkXG4gKiBvZiBFdmVudEVtaXR0ZXIgZXZlbnRzLlxuICogQGV4dGVuZHMge0V2ZW50SGFuZGxlfVxuICovXG52YXIgRG9tRXZlbnRIYW5kbGUgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlKSB7XG5cdF9pbmhlcml0cyhEb21FdmVudEhhbmRsZSwgX0V2ZW50SGFuZGxlKTtcblxuXHQvKipcbiAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGBEb21FdmVudEhhbmRsZWAuXG4gICogQHBhcmFtIHshRXZlbnRFbWl0dGVyfSBlbWl0dGVyIEVtaXR0ZXIgdGhlIGV2ZW50IHdhcyBzdWJzY3JpYmVkIHRvLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCB3YXMgc3Vic2NyaWJlZCB0by5cbiAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2NhcHR1cmUgRmxhZyBpbmRpY2F0aW5nIGlmIGxpc3RlbmVyIHNob3VsZCBiZSB0cmlnZ2VyZWRcbiAgKiAgIGR1cmluZyBjYXB0dXJlIHBoYXNlLCBpbnN0ZWFkIG9mIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAqIEBjb25zdHJ1Y3RvclxuICAqL1xuXHRmdW5jdGlvbiBEb21FdmVudEhhbmRsZShlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIsIG9wdF9jYXB0dXJlKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvbUV2ZW50SGFuZGxlKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEb21FdmVudEhhbmRsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvbUV2ZW50SGFuZGxlKSkuY2FsbCh0aGlzLCBlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpKTtcblxuXHRcdF90aGlzLmNhcHR1cmVfID0gb3B0X2NhcHR1cmU7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogQGluaGVyaXREb2NcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEb21FdmVudEhhbmRsZSwgW3tcblx0XHRrZXk6ICdyZW1vdmVMaXN0ZW5lcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuXHRcdFx0dGhpcy5lbWl0dGVyXy5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRfLCB0aGlzLmxpc3RlbmVyXywgdGhpcy5jYXB0dXJlXyk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERvbUV2ZW50SGFuZGxlO1xufShfbWV0YWxFdmVudHMuRXZlbnRIYW5kbGUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEb21FdmVudEhhbmRsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL0RvbUV2ZW50SGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ2xhc3Mgd2l0aCBzdGF0aWMgbWV0aG9kcyByZXNwb25zaWJsZSBmb3IgZG9pbmcgYnJvd3NlciBmZWF0dXJlIGNoZWNrcy5cbiAqL1xudmFyIGZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBmZWF0dXJlcygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgZmVhdHVyZXMpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGZlYXR1cmVzLCBudWxsLCBbe1xuXHRcdGtleTogJ2NoZWNrQW5pbWF0aW9uRXZlbnROYW1lJyxcblxuXHRcdC8qKlxuICAgKiBTb21lIGJyb3dzZXJzIHN0aWxsIHN1cHBvcnRzIHByZWZpeGVkIGFuaW1hdGlvbiBldmVudHMuIFRoaXMgbWV0aG9kIGNhblxuICAgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBjdXJyZW50IGJyb3dzZXIgZXZlbnQgbmFtZSBmb3IgYm90aCwgYW5pbWF0aW9uXG4gICAqIGFuZCB0cmFuc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjaGVja0FuaW1hdGlvbkV2ZW50TmFtZSgpIHtcblx0XHRcdGlmIChmZWF0dXJlcy5hbmltYXRpb25FdmVudE5hbWVfID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmVhdHVyZXMuYW5pbWF0aW9uRXZlbnROYW1lXyA9IHtcblx0XHRcdFx0XHRhbmltYXRpb246IGZlYXR1cmVzLmNoZWNrQW5pbWF0aW9uRXZlbnROYW1lXygnYW5pbWF0aW9uJyksXG5cdFx0XHRcdFx0dHJhbnNpdGlvbjogZmVhdHVyZXMuY2hlY2tBbmltYXRpb25FdmVudE5hbWVfKCd0cmFuc2l0aW9uJylcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmZWF0dXJlcy5hbmltYXRpb25FdmVudE5hbWVfO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgdG8gdGVzdDogYW5pbWF0aW9uLCB0cmFuc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJyb3dzZXIgZXZlbnQgbmFtZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NoZWNrQW5pbWF0aW9uRXZlbnROYW1lXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNoZWNrQW5pbWF0aW9uRXZlbnROYW1lXyh0eXBlKSB7XG5cdFx0XHR2YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNUycsICdPJywgJyddO1xuXHRcdFx0dmFyIHR5cGVUaXRsZUNhc2UgPSBfbWV0YWwuc3RyaW5nLnJlcGxhY2VJbnRlcnZhbCh0eXBlLCAwLCAxLCB0eXBlLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpKTtcblx0XHRcdHZhciBzdWZmaXhlcyA9IFt0eXBlVGl0bGVDYXNlICsgJ0VuZCcsIHR5cGVUaXRsZUNhc2UgKyAnRW5kJywgdHlwZVRpdGxlQ2FzZSArICdFbmQnLCB0eXBlICsgJ2VuZCddO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoZmVhdHVyZXMuYW5pbWF0aW9uRWxlbWVudF8uc3R5bGVbcHJlZml4ZXNbaV0gKyB0eXBlVGl0bGVDYXNlXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZWZpeGVzW2ldLnRvTG93ZXJDYXNlKCkgKyBzdWZmaXhlc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHR5cGUgKyAnZW5kJztcblx0XHR9XG5cblx0XHQvKipcbiAgICogU29tZSBicm93c2VycyAobGlrZSBJRTkpIGNoYW5nZSB0aGUgb3JkZXIgb2YgZWxlbWVudCBhdHRyaWJ1dGVzLCB3aGVuIGh0bWxcbiAgICogaXMgcmVuZGVyZWQuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoaXMgYmVoYXZpb3IgaGFwcGVucyBvblxuICAgKiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY2hlY2tBdHRyT3JkZXJDaGFuZ2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjaGVja0F0dHJPcmRlckNoYW5nZSgpIHtcblx0XHRcdGlmIChmZWF0dXJlcy5hdHRyT3JkZXJDaGFuZ2VfID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIG9yaWdpbmFsQ29udGVudCA9ICc8ZGl2IGRhdGEtY29tcG9uZW50PVwiXCIgZGF0YS1yZWY9XCJcIj48L2Rpdj4nO1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHQoMCwgX2RvbS5hcHBlbmQpKGVsZW1lbnQsIG9yaWdpbmFsQ29udGVudCk7XG5cdFx0XHRcdGZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV8gPSBvcmlnaW5hbENvbnRlbnQgIT09IGVsZW1lbnQuaW5uZXJIVE1MO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGZlYXR1cmVzO1xufSgpO1xuXG5mZWF0dXJlcy5hbmltYXRpb25FbGVtZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZmVhdHVyZXMuYW5pbWF0aW9uRXZlbnROYW1lXyA9IHVuZGVmaW5lZDtcbmZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV8gPSB1bmRlZmluZWQ7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZlYXR1cmVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfbWV0YWxTdGF0ZSA9IHJlcXVpcmUoJ21ldGFsLXN0YXRlJyk7XG5cbnZhciBfbWV0YWxTdGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRhbFN0YXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJMQUNLTElTVCA9IHtcblx0Y29tcG9uZW50czogdHJ1ZSxcblx0Y29udGV4dDogdHJ1ZSxcblx0ZWxlbWVudDogdHJ1ZSxcblx0cmVmczogdHJ1ZSxcblx0c3RhdGU6IHRydWUsXG5cdHN0YXRlS2V5OiB0cnVlLFxuXHR3YXNSZW5kZXJlZDogdHJ1ZVxufTtcbnZhciBEQVRBX01BTkFHRVJfREFUQSA9ICdfX0RBVEFfTUFOQUdFUl9EQVRBX18nO1xuXG52YXIgQ29tcG9uZW50RGF0YU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIENvbXBvbmVudERhdGFNYW5hZ2VyKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnREYXRhTWFuYWdlcik7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoQ29tcG9uZW50RGF0YU1hbmFnZXIsIFt7XG5cdFx0a2V5OiAnY3JlYXRlU3RhdGVfJyxcblxuXHRcdC8qKlxuICAgKiBDcmVhdGVzIHRoZSBgU3RhdGVgIGluc3RhbmNlIHRoYXQgd2lsbCBoYW5kbGUgdGhlIG1haW4gY29tcG9uZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdGF0ZV8oY29tcG9uZW50LCBkYXRhKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBuZXcgX21ldGFsU3RhdGUyLmRlZmF1bHQoY29tcG9uZW50LmdldEluaXRpYWxDb25maWcoKSwgY29tcG9uZW50LCBjb21wb25lbnQpO1xuXHRcdFx0c3RhdGUuc2V0S2V5c0JsYWNrbGlzdChCTEFDS0xJU1QpO1xuXHRcdFx0c3RhdGUuY29uZmlnU3RhdGUoX21ldGFsLm9iamVjdC5taXhpbih7fSwgZGF0YSwgX21ldGFsU3RhdGUyLmRlZmF1bHQuZ2V0U3RhdGVTdGF0aWMoY29tcG9uZW50LmNvbnN0cnVjdG9yKSkpO1xuXHRcdFx0dGhpcy5nZXRNYW5hZ2VyRGF0YShjb21wb25lbnQpLnN0YXRlXyA9IHN0YXRlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBEaXNwb3NlcyBvZiBhbnkgZGF0YSBiZWluZyB1c2VkIGJ5IHRoZSBtYW5hZ2VyIGluIHRoaXMgY29tcG9uZW50LlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoY29tcG9uZW50KSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KTtcblx0XHRcdGlmIChkYXRhLnN0YXRlXykge1xuXHRcdFx0XHRkYXRhLnN0YXRlXy5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRbREFUQV9NQU5BR0VSX0RBVEFdID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgZGF0YSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0KGNvbXBvbmVudCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KS5zdGF0ZV8uZ2V0KG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBtYW5hZ2VyIGRhdGEgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE1hbmFnZXJEYXRhJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KSB7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50W0RBVEFfTUFOQUdFUl9EQVRBXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUga2V5cyBmb3Igc3RhdGUgZGF0YSB0aGF0IGNhbiBiZSBzeW5jZWQgdmlhIGBzeW5jYCBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3luY0tleXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTeW5jS2V5cyhjb21wb25lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLmdldFN0YXRlS2V5cygpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBrZXlzIGZvciBzdGF0ZSBkYXRhLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFN0YXRlS2V5cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlS2V5cyhjb21wb25lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLmdldFN0YXRlS2V5cygpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSB3aG9sZSBzdGF0ZSBkYXRhLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZShjb21wb25lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLmdldFN0YXRlKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGBTdGF0ZWAgaW5zdGFuY2UgYmVpbmcgdXNlZC5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFN0YXRlSW5zdGFuY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUluc3RhbmNlKGNvbXBvbmVudCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KS5zdGF0ZV87XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFVwZGF0ZXMgYWxsIG5vbiBpbnRlcm5hbCBkYXRhIHdpdGggdGhlIGdpdmVuIHZhbHVlcyAob3IgdG8gdGhlIGRlZmF1bHRcbiAgICogdmFsdWUgaWYgbm9uZSBpcyBnaXZlbikuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge1N0YXRlPX0gb3B0X3N0YXRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlTm9uSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlTm9uSW50ZXJuYWwoY29tcG9uZW50LCBkYXRhLCBvcHRfc3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdF9zdGF0ZSB8fCB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfO1xuXHRcdFx0dmFyIGtleXMgPSBzdGF0ZS5nZXRTdGF0ZUtleXMoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0aWYgKCFzdGF0ZS5nZXRTdGF0ZUtleUNvbmZpZyhrZXkpLmludGVybmFsKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0c3RhdGUuc2V0KGtleSwgZGF0YVtrZXldKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdGUuc2V0RGVmYXVsdFZhbHVlKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIGFsbCB0aGUgc3BlY2lmaWVkIHN0YXRlIGtleXMuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+fSB2YWx1ZXMgQSBtYXAgb2Ygc3RhdGUga2V5cyB0byB0aGUgdmFsdWVzIHRoZXlcbiAgICogICBzaG91bGQgYmUgc2V0IHRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJ1blxuICAgKiAgIGFmdGVyIHRoZSBuZXh0IGJhdGNoZWQgdXBkYXRlIGlzIHRyaWdnZXJlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGUoY29tcG9uZW50LCBzdGF0ZSwgb3B0X2NhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLnNldFN0YXRlKHN0YXRlLCBvcHRfY2FsbGJhY2spO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHVwIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50J3MgZGF0YS5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHshT2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRVcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFVwKGNvbXBvbmVudCwgZGF0YSkge1xuXHRcdFx0Y29tcG9uZW50W0RBVEFfTUFOQUdFUl9EQVRBXSA9IHt9O1xuXHRcdFx0dGhpcy5jcmVhdGVTdGF0ZV8oY29tcG9uZW50LCBkYXRhKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gQ29tcG9uZW50RGF0YU1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBDb21wb25lbnREYXRhTWFuYWdlcigpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvQ29tcG9uZW50RGF0YU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU3RhdGUgPSBleHBvcnRzLkNvbmZpZyA9IGV4cG9ydHMudmFsaWRhdG9ycyA9IHVuZGVmaW5lZDtcblxudmFyIF92YWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xuXG52YXIgX3ZhbGlkYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsaWRhdG9ycyk7XG5cbnZhciBfQ29uZmlnID0gcmVxdWlyZSgnLi4vQ29uZmlnJyk7XG5cbnZhciBfQ29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbmZpZyk7XG5cbnZhciBfU3RhdGUgPSByZXF1aXJlKCcuLi9TdGF0ZScpO1xuXG52YXIgX1N0YXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0YXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX1N0YXRlMi5kZWZhdWx0O1xuZXhwb3J0cy52YWxpZGF0b3JzID0gX3ZhbGlkYXRvcnMyLmRlZmF1bHQ7XG5leHBvcnRzLkNvbmZpZyA9IF9Db25maWcyLmRlZmF1bHQ7XG5leHBvcnRzLlN0YXRlID0gX1N0YXRlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9hbGwvc3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIEVSUk9SX0FSUkFZX09GX1RZUEUgPSAnRXhwZWN0ZWQgYW4gYXJyYXkgb2Ygc2luZ2xlIHR5cGUuJztcbnZhciBFUlJPUl9PQkpFQ1RfT0ZfVFlQRSA9ICdFeHBlY3RlZCBvYmplY3Qgb2Ygb25lIHR5cGUuJztcbnZhciBFUlJPUl9PTkVfT0YgPSAnRXhwZWN0ZWQgb25lIG9mIGdpdmVuIHZhbHVlcy4nO1xudmFyIEVSUk9SX09ORV9PRl9UWVBFID0gJ0V4cGVjdGVkIG9uZSBvZiBnaXZlbiB0eXBlcy4nO1xudmFyIEVSUk9SX1NIQVBFX09GID0gJ0V4cGVjdGVkIG9iamVjdCB3aXRoIGEgc3BlY2lmaWMgc2hhcGUuJztcblxuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdmFyaW91cyB0eXBlIHZhbGlkYXRvcnMgdGhhdCB3aWxsIHJldHVybiBhblxuICogaW5zdGFuY2Ugb2YgRXJyb3Igd2hlbiB2YWxpZGF0aW9uIGZhaWxzLiBOb3RlIHRoYXQgYWxsIHR5cGUgdmFsaWRhdG9yc1xuICogd2lsbCBhbHNvIGFjY2VwdCBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuIFRvIG5vdCBhY2NlcHQgdGhlc2UgeW91IHNob3VsZFxuICogaW5zdGVhZCBtYWtlIHlvdXIgc3RhdGUgcHJvcGVydHkgcmVxdWlyZWQuXG4gKi9cbnZhciB2YWxpZGF0b3JzID0ge1xuXHRhbnk6IGZ1bmN0aW9uIGFueSgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fSxcblx0YXJyYXk6IGJ1aWxkVHlwZVZhbGlkYXRvcignYXJyYXknKSxcblx0Ym9vbDogYnVpbGRUeXBlVmFsaWRhdG9yKCdib29sZWFuJyksXG5cdGZ1bmM6IGJ1aWxkVHlwZVZhbGlkYXRvcignZnVuY3Rpb24nKSxcblx0bnVtYmVyOiBidWlsZFR5cGVWYWxpZGF0b3IoJ251bWJlcicpLFxuXHRvYmplY3Q6IGJ1aWxkVHlwZVZhbGlkYXRvcignb2JqZWN0JyksXG5cdHN0cmluZzogYnVpbGRUeXBlVmFsaWRhdG9yKCdzdHJpbmcnKSxcblxuXHQvKipcbiAgKiBDcmVhdGVzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhlIHZhbHVlIGl0IHJlY2VpdmVzIGlzIGFuIGFycmF5XG4gICogb2YgaXRlbXMsIGFuZCB0aGF0IGFsbCBvZiB0aGUgaXRlbXMgcGFzcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHZhbGlkYXRvciBWYWxpZGF0b3IgdG8gY2hlY2sgZWFjaCBpdGVtIGFnYWluc3QuXG4gICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4gICovXG5cdGFycmF5T2Y6IGZ1bmN0aW9uIGFycmF5T2YodmFsaWRhdG9yKSB7XG5cdFx0cmV0dXJuIG1heWJlKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbGlkYXRvcnMuYXJyYXkodmFsdWUsIG5hbWUsIGNvbnRleHQpO1xuXHRcdFx0aWYgKGlzSW52YWxpZChyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsaWRhdGVBcnJheUl0ZW1zKHZhbGlkYXRvciwgdmFsdWUsIG5hbWUsIGNvbnRleHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIENyZWF0ZXMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIGdpdmVuIGNsYXNzLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGV4cGVjdGVkQ2xhc3MgQ2xhc3MgdG8gY2hlY2sgdmFsdWUgYWdhaW5zdC5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0aW5zdGFuY2VPZjogZnVuY3Rpb24gaW5zdGFuY2VPZihleHBlY3RlZENsYXNzKSB7XG5cdFx0cmV0dXJuIG1heWJlKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJyArIGV4cGVjdGVkQ2xhc3M7XG5cdFx0XHRyZXR1cm4gY29tcG9zZUVycm9yKG1zZywgbmFtZSwgY29udGV4dCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoZSB2YWx1ZSBpdCByZWNlaXZlcyBpcyBhbiBvYmplY3QsXG4gICogYW5kIHRoYXQgYWxsIHZhbHVlcyB3aXRoaW4gdGhhdCBvYmplY3QgcGFzcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHZhbGlkYXRvciBWYWxpZGF0b3IgdG8gY2hlY2sgZWFjaCBvYmplY3QgdmFsdWUgYWdhaW5zdC5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0b2JqZWN0T2Y6IGZ1bmN0aW9uIG9iamVjdE9mKHZhbGlkYXRvcikge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoaXNJbnZhbGlkKHZhbGlkYXRvcih2YWx1ZVtrZXldKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcG9zZUVycm9yKEVSUk9SX09CSkVDVF9PRl9UWVBFLCBuYW1lLCBjb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlXG4gICogZ2l2ZW4gdmFsdWVzLlxuICAqIEBwYXJhbSB7IUFycmF5fSBhcnJheU9mVmFsdWVzIEFycmF5IG9mIHZhbHVlcyB0byBjaGVjayBlcXVhbGl0eSBhZ2FpbnN0LlxuICAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuICAqL1xuXHRvbmVPZjogZnVuY3Rpb24gb25lT2YoYXJyYXlPZlZhbHVlcykge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWxpZGF0b3JzLmFycmF5KGFycmF5T2ZWYWx1ZXMsIG5hbWUsIGNvbnRleHQpO1xuXHRcdFx0aWYgKGlzSW52YWxpZChyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXJyYXlPZlZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEgPyBjb21wb3NlRXJyb3IoRVJST1JfT05FX09GLCBuYW1lLCBjb250ZXh0KSA6IHRydWU7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlXG4gICogZ2l2ZW4gdHlwZXMuXG4gICogQHBhcmFtIHshQXJyYXl9IGFycmF5T2ZUeXBlVmFsaWRhdG9ycyBBcnJheSBvZiB2YWxpZGF0b3JzIHRvIGNoZWNrIHZhbHVlXG4gICogICAgIGFnYWluc3QuXG4gICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4gICovXG5cdG9uZU9mVHlwZTogZnVuY3Rpb24gb25lT2ZUeXBlKGFycmF5T2ZUeXBlVmFsaWRhdG9ycykge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWxpZGF0b3JzLmFycmF5KGFycmF5T2ZUeXBlVmFsaWRhdG9ycywgbmFtZSwgY29udGV4dCk7XG5cdFx0XHRpZiAoaXNJbnZhbGlkKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZVZhbGlkYXRvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKCFpc0ludmFsaWQoYXJyYXlPZlR5cGVWYWxpZGF0b3JzW2ldKHZhbHVlLCBuYW1lLCBjb250ZXh0KSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbXBvc2VFcnJvcihFUlJPUl9PTkVfT0ZfVFlQRSwgbmFtZSwgY29udGV4dCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgaXMgYW4gb2JqZWN0LCBhbmRcbiAgKiB0aGF0IGl0cyBjb250ZW50cyBtYXRjaCB0aGUgZ2l2ZW4gc2hhcGUuXG4gICogQHBhcmFtIHshT2JqZWN0fSBzaGFwZSBBbiBvYmplY3QgY29udGFpbmluZyB2YWxpZGF0b3JzIGZvciBlYWNoIGtleS5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0c2hhcGVPZjogZnVuY3Rpb24gc2hhcGVPZihzaGFwZSkge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWxpZGF0b3JzLm9iamVjdChzaGFwZSwgbmFtZSwgY29udGV4dCk7XG5cdFx0XHRpZiAoaXNJbnZhbGlkKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNoYXBlKSB7XG5cdFx0XHRcdHZhciB2YWxpZGF0b3IgPSBzaGFwZVtrZXldO1xuXHRcdFx0XHR2YXIgcmVxdWlyZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHZhbGlkYXRvci5jb25maWcpIHtcblx0XHRcdFx0XHRyZXF1aXJlZCA9IHZhbGlkYXRvci5jb25maWcucmVxdWlyZWQ7XG5cdFx0XHRcdFx0dmFsaWRhdG9yID0gdmFsaWRhdG9yLmNvbmZpZy52YWxpZGF0b3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlcXVpcmVkICYmICEoMCwgX21ldGFsLmlzRGVmQW5kTm90TnVsbCkodmFsdWVba2V5XSkgfHwgaXNJbnZhbGlkKHZhbGlkYXRvcih2YWx1ZVtrZXldKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcG9zZUVycm9yKEVSUk9SX1NIQVBFX09GLCBuYW1lLCBjb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBhZ2FpbnN0IGEgc3BlY2lmaWMgcHJpbWl0aXZlIHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRUeXBlIFR5cGUgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm4geyFmdW5jdGlvbigpfSBGdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIHZhbGlkYXRvciBpZiBjYWxsZWQgd2l0aFxuICogICAgIGFyZ3VtZW50cywgb3IganVzdCByZXR1cm5zIGl0IG90aGVyd2lzZS4gVGhpcyBtZWFucyB0aGF0IHdoZW4gdXNpbmcgYVxuICogICAgIHR5cGUgdmFsaWRhdG9yIGluIGBTdGF0ZWAgaXQgbWF5IGJlIGp1c3QgcGFzc2VkIGRpcmVjdGx5IChsaWtlXG4gKiAgICAgYHZhbGlkYXRvcnMuYm9vbGApLCBvciBjYWxsZWQgd2l0aCBubyBhcmdzIChsaWtlIGB2YWxpZGF0b3JzLmJvb2woKWApLlxuICogICAgIFRoYXQncyBkb25lIHRvIGFsbG93IGFsbCB2YWxpZGF0b3JzIHRvIGJlIHVzZWQgY29uc2lzdGVudGx5LCBzaW5jZSBzb21lXG4gKiAgICAgKGxpa2UgYGFycmF5T2ZgKSBhbHdheXMgcmVxdWlyZSB0aGF0IHlvdSBjYWxsIHRoZSBmdW5jdGlvbiBiZWZvcmVcbiAqICAgICByZWNlaXZpbmcgdGhlIGFjdHVhbCB2YWxpZGF0b3IuIFR5cGUgdmFsaWRhdG9ycyBkb24ndCBuZWVkIHRoZSBjYWxsLCBidXRcbiAqICAgICB3b3JrIGlmIGl0J3MgbWFkZSBhbnl3YXkuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHlwZVZhbGlkYXRvcihleHBlY3RlZFR5cGUpIHtcblx0dmFyIHZhbGlkYXRvckZuID0gbWF5YmUodmFsaWRhdGVUeXBlLmJpbmQobnVsbCwgZXhwZWN0ZWRUeXBlKSk7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiB2YWxpZGF0b3JGbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRvckZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQ29tcG9zZXMgYSB3YXJuaW5nIGEgd2FybmluZyBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yIEVycm9yIG1lc3NhZ2UgdG8gZGlzcGxheSB0byBjb25zb2xlLlxuICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lIE5hbWUgb2Ygc3RhdGUgcHJvcGVydHkgdGhhdCBpcyBnaXZpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIHByb3BlcnR5J3Mgb3duZXIuXG4gKiBAcmV0dXJuIHshRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VFcnJvcihlcnJvciwgbmFtZSwgY29udGV4dCkge1xuXHR2YXIgY29tcE5hbWUgPSBjb250ZXh0ID8gKDAsIF9tZXRhbC5nZXRGdW5jdGlvbk5hbWUpKGNvbnRleHQuY29uc3RydWN0b3IpIDogbnVsbDtcblx0dmFyIHJlbmRlcmVyID0gY29udGV4dCAmJiBjb250ZXh0LmdldFJlbmRlcmVyICYmIGNvbnRleHQuZ2V0UmVuZGVyZXIoKTtcblx0dmFyIHBhcmVudCA9IHJlbmRlcmVyICYmIHJlbmRlcmVyLmdldFBhcmVudCAmJiByZW5kZXJlci5nZXRQYXJlbnQoKTtcblx0dmFyIHBhcmVudE5hbWUgPSBwYXJlbnQgPyAoMCwgX21ldGFsLmdldEZ1bmN0aW9uTmFtZSkocGFyZW50LmNvbnN0cnVjdG9yKSA6IG51bGw7XG5cdHZhciBsb2NhdGlvbiA9IHBhcmVudE5hbWUgPyAnQ2hlY2sgcmVuZGVyIG1ldGhvZCBvZiBcXCcnICsgcGFyZW50TmFtZSArICdcXCcuJyA6ICcnO1xuXHRyZXR1cm4gbmV3IEVycm9yKCdXYXJuaW5nOiBJbnZhbGlkIHN0YXRlIHBhc3NlZCB0byBcXCcnICsgbmFtZSArICdcXCcuICcgKyAoZXJyb3IgKyAnIFBhc3NlZCB0byBcXCcnICsgY29tcE5hbWUgKyAnXFwnLiAnICsgbG9jYXRpb24pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybiB7c3RyaW5nfSBUeXBlIG9mIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICdhcnJheScgOiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbGlkYXRvciByZXN1bHQgc2F5cyB0aGF0IHRoZSB2YWx1ZSBpcyBpbnZhbGlkLlxuICogQHBhcmFtIHtib29sZWFufCFFcnJvcn0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ludmFsaWQocmVzdWx0KSB7XG5cdHJldHVybiByZXN1bHQgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yIHNvIHRoYXQgaXQgYWxzbyBhY2NlcHRzIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cbiAqICAgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgYSB2YWx1ZSBhZ2FpbnN0IGEgc2luZ2xlIHR5cGUsIG51bGwsIG9yXG4gKiB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSB0eXBlVmFsaWRhdG9yIFZhbGlkYXRvciB0byB3cmFwLlxuICogQHJldHVybiB7IWZ1bmN0aW9uKCl9IFdyYXBwZWQgdmFsaWRhdG9yLlxuICovXG5mdW5jdGlvbiBtYXliZSh0eXBlVmFsaWRhdG9yKSB7XG5cdHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRyZXR1cm4gKDAsIF9tZXRhbC5pc0RlZkFuZE5vdE51bGwpKHZhbHVlKSA/IHR5cGVWYWxpZGF0b3IodmFsdWUsIG5hbWUsIGNvbnRleHQpIDogdHJ1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYWxsIHRoZSBpdGVtcyBvZiB0aGUgZ2l2ZW4gYXJyYXkgcGFzcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gdmFsaWRhdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhcnJheSB0byB2YWxpZGF0ZSBpdGVtcyBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXJyYXkgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29udGV4dCBPd25lciBvZiB0aGUgYXJyYXkgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEByZXR1cm4geyFFcnJvcnxib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHR5cGUgbWF0Y2hlcywgb3IgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5SXRlbXModmFsaWRhdG9yLCB2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGlzSW52YWxpZCh2YWxpZGF0b3IodmFsdWVbaV0sIG5hbWUsIGNvbnRleHQpKSkge1xuXHRcdFx0cmV0dXJuIGNvbXBvc2VFcnJvcihFUlJPUl9BUlJBWV9PRl9UWVBFLCBuYW1lLCBjb250ZXh0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBtYXRjaGVzIHRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkVHlwZSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2ggdGhlIHR5cGUgb2YuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29udGV4dCBPd25lciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEByZXR1cm4geyFFcnJvcnxib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHR5cGUgbWF0Y2hlcywgb3IgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUoZXhwZWN0ZWRUeXBlLCB2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHR2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXHRpZiAodHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG5cdFx0dmFyIG1zZyA9ICdFeHBlY3RlZCB0eXBlIFxcJycgKyBleHBlY3RlZFR5cGUgKyAnXFwnLCBidXQgcmVjZWl2ZWQgdHlwZSBcXCcnICsgdHlwZSArICdcXCcuJztcblx0XHRyZXR1cm4gY29tcG9zZUVycm9yKG1zZywgbmFtZSwgY29udGV4dCk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRvcnM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbGliL3ZhbGlkYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlTmFtZWQgPSByZXF1aXJlKCcuL2NvcmVOYW1lZCcpO1xuXG5PYmplY3Qua2V5cyhfY29yZU5hbWVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZU5hbWVkW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlTmFtZWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuZXhwb3J0cy5jb3JlID0gY29yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgY29tcG9uZW50IHJlbmRlcmVycyBzaG91bGQgZXh0ZW5kIGZyb20uIEl0IGRlZmluZXMgdGhlXG4gKiByZXF1aXJlZCBtZXRob2RzIGFsbCByZW5kZXJlcnMgc2hvdWxkIGhhdmUuXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIENvbXBvbmVudFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBDb21wb25lbnRSZW5kZXJlcigpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50UmVuZGVyZXIpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKENvbXBvbmVudFJlbmRlcmVyLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXG5cblx0XHQvKipcbiAgICogRGlzcG9zZXMgb2YgYW55IGRhdGEgc3BlY2lmaWMgdG8gdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgZXh0cmEgY29uZmlndXJhdGlvbiBmb3IgZGF0YSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFuYWdlci5cbiAgICogU3ViIGNsYXNzZXMgY2FuIG92ZXJyaWRlIHRvIHJldHVybiBgU3RhdGVgIGNvbmZpZyBmb3IgcHJvcGVydGllcyB0aGF0XG4gICAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRFeHRyYURhdGFDb25maWcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRFeHRyYURhdGFDb25maWcoKSB7fVxuXG5cdFx0LyoqXG4gICAqIFJlbmRlcnMgdGhlIHdob2xlIGNvbnRlbnQgKGluY2x1ZGluZyBpdHMgbWFpbiBlbGVtZW50KSBhbmQgaW5mb3JtcyB0aGVcbiAgICogY29tcG9uZW50IGFib3V0IGl0LiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBzdWIgY2xhc3Nlcy5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihjb21wb25lbnQpIHtcblx0XHRcdGlmICghY29tcG9uZW50LmVsZW1lbnQpIHtcblx0XHRcdFx0Y29tcG9uZW50LmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudC5pbmZvcm1SZW5kZXJlZCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgY29tcG9uZW50IHRvIGJlIHVzZWQgYnkgdGhpcyByZW5kZXJlci4gU3ViIGNsYXNzZXMgc2hvdWxkXG4gICAqIG92ZXJyaWRlIGFzIG5lZWRlZCBmb3IgbW9yZSBiZWhhdmlvci5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFVwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VXAoKSB7fVxuXG5cdFx0LyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgaHRtbC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAqIHRoZSB2YWx1ZSBvZiBhdCBsZWFzdCBvbmUgb2YgdGhlIGNvbXBvbmVudCdzIHN0YXRlIGtleXMgaGFzIGNoYW5nZWQuXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWIgY2xhc3Nlcy4gU3ViIGNsYXNzZXMgaGF2ZSB0byByZW1lbWJlciB0byBjYWxsXG4gICAqIFwiaW5mb3JtUmVuZGVyZWRcIiBvbiB0aGUgY29tcG9uZW50IHdoZW4gYW55IHVwZGF0ZSByZW5kZXJpbmcgaXMgZG9uZS5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn0gY2hhbmdlcyBPYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXNcbiAgICogICAgIG9mIGFsbCBjaGFuZ2VkIHN0YXRlIGtleXMsIGVhY2ggbWFwcGVkIHRvIGFuIG9iamVjdCB3aXRoIGl0cyBuZXdcbiAgICogICAgIChuZXdWYWwpIGFuZCBwcmV2aW91cyAocHJldlZhbCkgdmFsdWVzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndXBkYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge31cblx0fV0pO1xuXG5cdHJldHVybiBDb21wb25lbnRSZW5kZXJlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IENvbXBvbmVudFJlbmRlcmVyKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9Db21wb25lbnRSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5yZXF1aXJlKCcuL2luY3JlbWVudGFsLWRvbScpO1xuXG52YXIgX2NoYW5nZXMgPSByZXF1aXJlKCcuL2NoYW5nZXMnKTtcblxudmFyIF9kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG5cbnZhciBfY2hpbGRyZW4gPSByZXF1aXJlKCcuL2NoaWxkcmVuL2NoaWxkcmVuJyk7XG5cbnZhciBfcGF0Y2gyID0gcmVxdWlyZSgnLi9yZW5kZXIvcGF0Y2gnKTtcblxudmFyIF9yZW5kZXIgPSByZXF1aXJlKCcuL3JlbmRlci9yZW5kZXInKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSW5jcmVtZW50YWxEb21SZW5kZXJlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50UmVuZGVyZXIkY28pIHtcblx0X2luaGVyaXRzKEluY3JlbWVudGFsRG9tUmVuZGVyZXIsIF9Db21wb25lbnRSZW5kZXJlciRjbyk7XG5cblx0ZnVuY3Rpb24gSW5jcmVtZW50YWxEb21SZW5kZXJlcigpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5jcmVtZW50YWxEb21SZW5kZXJlcik7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEluY3JlbWVudGFsRG9tUmVuZGVyZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmNyZW1lbnRhbERvbVJlbmRlcmVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoSW5jcmVtZW50YWxEb21SZW5kZXJlciwgW3tcblx0XHRrZXk6ICdidWlsZFNob3VsZFVwZGF0ZUFyZ3MnLFxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgYXJncyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCdzXG4gICAqIGBzaG91bGRVcGRhdGVgIG1ldGhvZC4gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWIgY2xhc3NlcyB0byBjaGFuZ2VcbiAgICogd2hhdCB0aGUgbWV0aG9kIHNob3VsZCByZWNlaXZlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlc1xuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBidWlsZFNob3VsZFVwZGF0ZUFyZ3MoY2hhbmdlcykge1xuXHRcdFx0cmV0dXJuIFtjaGFuZ2VzLnByb3BzXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKGNvbXBvbmVudCkge1xuXHRcdFx0dmFyIGRhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KTtcblx0XHRcdHZhciByZWYgPSBkYXRhLmNvbmZpZy5yZWY7XG5cdFx0XHR2YXIgb3duZXIgPSBkYXRhLm93bmVyO1xuXHRcdFx0aWYgKG93bmVyICYmIG93bmVyLmNvbXBvbmVudHMgJiYgb3duZXIuY29tcG9uZW50c1tyZWZdID09PSBjb21wb25lbnQpIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyLmNvbXBvbmVudHNbcmVmXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuY2hpbGRDb21wb25lbnRzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5jaGlsZENvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBkYXRhLmNoaWxkQ29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRpZiAoIWNoaWxkLmlzRGlzcG9zZWQoKSkge1xuXHRcdFx0XHRcdFx0Y2hpbGQuZWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdFx0XHRjaGlsZC5kaXNwb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCgwLCBfZGF0YS5jbGVhckRhdGEpKGNvbXBvbmVudCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdlbmVyYXRlcyBhIGtleSBmb3IgdGhlIGVsZW1lbnQgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkIGluIHRoZSBnaXZlblxuICAgKiBjb21wb25lbnQuIEJ5IGRlZmF1bHQsIGp1c3QgcmV0dXJucyB0aGUgb3JpZ2luYWwga2V5LiBTdWIgY2xhc3NlcyBjYW5cbiAgICogb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZW5lcmF0ZUtleScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlS2V5KGNvbXBvbmVudCwga2V5KSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCdzIGNvbmZpZyBkYXRhLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Q29uZmlnJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uZmlnKGNvbXBvbmVudCkge1xuXHRcdFx0cmV0dXJuICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpLmNvbmZpZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQncyBpbmNyZW1lbnRhbCBkb20gcmVuZGVyZXIgZGF0YS5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldERhdGEnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhKGNvbXBvbmVudCkge1xuXHRcdFx0cmV0dXJuICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBjb21wb25lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIGN1cnJlbnQgcGF0Y2ggb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXRjaGluZ0NvbXBvbmVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhdGNoaW5nQ29tcG9uZW50KCkge1xuXHRcdFx0cmV0dXJuICgwLCBfcGF0Y2gyLmdldFBhdGNoaW5nQ29tcG9uZW50KSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBIYW5kbGVzIGEgbm9kZSBoYXZpbmcganVzdCBiZWVuIHJlbmRlcmVkLiBTdWIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpc1xuICAgKiBmb3IgY3VzdG9tIGJlaGF2aW9yLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlTm9kZVJlbmRlcmVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTm9kZVJlbmRlcmVkKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbmNyZW1lbnRhbCBkb20gbm9kZS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBub2RlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0luY0RvbU5vZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0luY0RvbU5vZGUobm9kZSkge1xuXHRcdFx0cmV0dXJuICEhKDAsIF9jaGlsZHJlbi5nZXRPd25lcikobm9kZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGxzIGluY3JlbWVudGFsIGRvbSdzIHBhdGNoIGZ1bmN0aW9uIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncGF0Y2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwYXRjaChjb21wb25lbnQpIHtcblx0XHRcdCgwLCBfcGF0Y2gyLnBhdGNoKShjb21wb25lbnQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW5kZXJzIHRoZSByZW5kZXJlcidzIGNvbXBvbmVudCBmb3IgdGhlIGZpcnN0IHRpbWUsIHBhdGNoaW5nIGl0cyBlbGVtZW50XG4gICAqIHRocm91Z2ggaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGNhbGxzLiBJZiB0aGUgZmlyc3QgYXJnIGlzIGEgZnVuY3Rpb25cbiAgICogaW5zdGVhZCBvZiBhIGNvbXBvbmVudCBpbnN0YW5jZSwgY3JlYXRlcyBhbmQgcmVuZGVycyB0aGlzIGZ1bmN0aW9uLCB3aGljaFxuICAgKiBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbiBvciBhIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHshQ29tcG9uZW50fGZ1bmN0aW9uKCl9IGNvbXBvbmVudCBDYW4gYmUgYSBjb21wb25lbnQgaW5zdGFuY2UsIGFcbiAgICogICAgIHNpbXBsZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gb3IgYSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEVsZW1lbnQ9fSBvcHRfZGF0YU9yRWxlbWVudCBPcHRpb25hbCBjb25maWcgZGF0YSBmb3IgdGhlXG4gICAqICAgICBmdW5jdGlvbiwgb3IgcGFyZW50IGZvciB0aGUgcmVuZGVyZWQgY29udGVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50PX0gb3B0X3BhcmVudCBPcHRpb25hbCBwYXJlbnQgZm9yIHRoZSByZW5kZXJlZCBjb250ZW50LlxuICAgKiBAcmV0dXJuIHshQ29tcG9uZW50fSBUaGUgcmVuZGVyZWQgY29tcG9uZW50J3MgaW5zdGFuY2UuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY29tcG9uZW50LCBvcHRfZGF0YU9yRWxlbWVudCwgb3B0X3BhcmVudCkge1xuXHRcdFx0aWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIF9tZXRhbENvbXBvbmVudC5Db21wb25lbnQpIHtcblx0XHRcdFx0dGhpcy5wYXRjaChjb21wb25lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICgwLCBfcmVuZGVyLnJlbmRlckZ1bmN0aW9uKSh0aGlzLCBjb21wb25lbnQsIG9wdF9kYXRhT3JFbGVtZW50LCBvcHRfcGFyZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gY2hpbGQgbm9kZSB2aWEgaXRzIG93bmVyIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNoaWxkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJDaGlsZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkKGNoaWxkKSB7XG5cdFx0XHQoMCwgX3JlbmRlci5yZW5kZXJDaGlsZCkoY2hpbGQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxscyBmdW5jdGlvbnMgZnJvbSBgSW5jcmVtZW50YWxET01gIHRvIGJ1aWxkIHRoZSBjb21wb25lbnQgZWxlbWVudCdzXG4gICAqIGNvbnRlbnQuIENhbiBiZSBvdmVycmlkZW4gYnkgc3ViY2xhc3NlcyAoZm9yIGludGVncmF0aW9uIHdpdGggdGVtcGxhdGVcbiAgICogZW5naW5lcyBmb3IgZXhhbXBsZSkuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJJbmNEb20nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbmNEb20oY29tcG9uZW50KSB7XG5cdFx0XHRpZiAoY29tcG9uZW50LnJlbmRlcikge1xuXHRcdFx0XHRjb21wb25lbnQucmVuZGVyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZCgnZGl2Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJ1bnMgdGhlIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbnMgZm9yIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCwgd2l0aG91dFxuICAgKiBjYWxsaW5nIGBwYXRjaGAuIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgY2FsbGVkIGluc2lkZSBhIGBwYXRjaGAuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJJbnNpZGVQYXRjaCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlckluc2lkZVBhdGNoKGNvbXBvbmVudCkge1xuXHRcdFx0dmFyIHNob3VsZFJlbmRlciA9ICFjb21wb25lbnQud2FzUmVuZGVyZWQgfHwgdGhpcy5zaG91bGRVcGRhdGUoY29tcG9uZW50LCAoMCwgX2NoYW5nZXMuZ2V0Q2hhbmdlcykoY29tcG9uZW50KSkgfHwgSW5jcmVtZW50YWxET00uY3VycmVudFBvaW50ZXIoKSAhPT0gY29tcG9uZW50LmVsZW1lbnQ7XG5cdFx0XHRpZiAoc2hvdWxkUmVuZGVyKSB7XG5cdFx0XHRcdCgwLCBfcmVuZGVyLnJlbmRlcikoY29tcG9uZW50KTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcG9uZW50LmVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5za2lwUmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdXAgdGhpcyBjb21wb25lbnQgdG8gYmUgdXNlZCBieSB0aGlzIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VXAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRVcChjb21wb25lbnQpIHtcblx0XHRcdGNvbXBvbmVudC5jb250ZXh0ID0ge307XG5cdFx0XHRjb21wb25lbnQuY29tcG9uZW50cyA9IHt9O1xuXHRcdFx0Y29tcG9uZW50LnJlZnMgPSB7fTtcblxuXHRcdFx0dmFyIGRhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KTtcblx0XHRcdGRhdGEuY29uZmlnID0gY29tcG9uZW50LmdldEluaXRpYWxDb25maWcoKTtcblx0XHRcdCgwLCBfY2hhbmdlcy50cmFja0NoYW5nZXMpKGNvbXBvbmVudCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgY2hhbmdlcy5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Nob3VsZFVwZGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShjb21wb25lbnQsIGNoYW5nZXMpIHtcblx0XHRcdGlmICghY2hhbmdlcykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29tcG9uZW50LnNob3VsZFVwZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50LnNob3VsZFVwZGF0ZS5hcHBseShjb21wb25lbnQsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmJ1aWxkU2hvdWxkVXBkYXRlQXJncyhjaGFuZ2VzKSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNraXBzIHRoZSBuZXh0IGRpc3Bvc2FsIG9mIGNoaWxkcmVuIGNvbXBvbmVudHMsIGJ5IGNsZWFyaW5nIHRoZSBhcnJheSBhc1xuICAgKiBpZiB0aGVyZSB3ZXJlIG5vIGNoaWxkcmVuIHJlbmRlcmVkIHRoZSBsYXN0IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICogYWxsb3dpbmcgY29tcG9uZW50cyB0byBiZSByZXVzZWQgYnkgb3RoZXIgcGFyZW50IGNvbXBvbmVudHMgaW4gc2VwYXJhdGVcbiAgICogcmVuZGVyIHVwZGF0ZSBjeWNsZXMuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdza2lwTmV4dENoaWxkcmVuRGlzcG9zYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBza2lwTmV4dENoaWxkcmVuRGlzcG9zYWwoY29tcG9uZW50KSB7XG5cdFx0XHQoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KS5jaGlsZENvbXBvbmVudHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTa2lwcyByZW5kZXJpbmcgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NraXBSZW5kZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBza2lwUmVuZGVyKCkge1xuXHRcdFx0SW5jcmVtZW50YWxET00uc2tpcE5vZGUoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZXIncyBjb21wb25lbnQgd2hlbiBzdGF0ZSBjaGFuZ2VzLCBwYXRjaGluZyBpdHMgZWxlbWVudFxuICAgKiB0aHJvdWdoIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbiBjYWxscy5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3VwZGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShjb21wb25lbnQpIHtcblx0XHRcdGlmICh0aGlzLnNob3VsZFVwZGF0ZShjb21wb25lbnQsICgwLCBfY2hhbmdlcy5nZXRDaGFuZ2VzKShjb21wb25lbnQpKSkge1xuXHRcdFx0XHR0aGlzLnBhdGNoKGNvbXBvbmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEluY3JlbWVudGFsRG9tUmVuZGVyZXI7XG59KF9tZXRhbENvbXBvbmVudC5Db21wb25lbnRSZW5kZXJlci5jb25zdHJ1Y3Rvcik7XG5cbnZhciByZW5kZXJlciA9IG5ldyBJbmNyZW1lbnRhbERvbVJlbmRlcmVyKCk7XG5cbi8vIE5hbWUgb2YgdGhpcyByZW5kZXJlci4gUmVuZGVyZXJzIHNob3VsZCBwcm92aWRlIHRoaXMgYXMgYSB3YXkgdG8gaWRlbnRpZnlcbi8vIHRoZW0gdmlhIGEgc2ltcGxlIHN0cmluZyAod2hlbiBjYWxsaW5nIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlIHRvIGFkZFxuLy8gc3VwcG9ydCB0byBvbGQgZmVhdHVyZXMgZm9yIHNwZWNpZmljIHJlbmRlcmVycyBmb3IgZXhhbXBsZSkuXG5yZW5kZXJlci5SRU5ERVJFUl9OQU1FID0gJ2luY3JlbWVudGFsLWRvbSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbmRlcmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvSW5jcmVtZW50YWxEb21SZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2luY3JlbWVudGFsRG9tID0gcmVxdWlyZSgnaW5jcmVtZW50YWwtZG9tJyk7XG5cbnZhciBJbmNyZW1lbnRhbERPTSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmNyZW1lbnRhbERvbSk7XG5cbnZhciBfaW5jcmVtZW50YWxEb21TdHJpbmcgPSByZXF1aXJlKCdpbmNyZW1lbnRhbC1kb20tc3RyaW5nJyk7XG5cbnZhciBJbmNyZW1lbnRhbERPTVN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmNyZW1lbnRhbERvbVN0cmluZyk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5pZiAoKDAsIF9tZXRhbC5pc1NlcnZlclNpZGUpKCkpIHtcblx0Ly8gT3ZlcnJpZGVzIGdsb2JhbC5JbmNyZW1lbnRhbERPTSB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggaW5jcmVtZW50YWwgZG9tXG5cdC8vIHN0cmluZyBpbXBsZW1lbnRhdGlvbiBmb3Igc2VydmVyIHNpZGUgcmVuZGVyaW5nLiBBdCB0aGUgbW9tZW50IGl0IGRvZXMgbm90XG5cdC8vIG92ZXJyaWRlIGZvciBOb2RlLmpzIHRlc3RzIHNpbmNlIHRlc3RzIGFyZSB1c2luZyBqc2RvbSB0byBzaW11bGF0ZSB0aGVcblx0Ly8gYnJvd3Nlci5cblx0Z2xvYmFsLkluY3JlbWVudGFsRE9NID0gSW5jcmVtZW50YWxET01TdHJpbmc7XG59IGVsc2Uge1xuXHR2YXIgc2NvcGUgPSB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG5cblx0c2NvcGUuSW5jcmVtZW50YWxET00gPSBJbmNyZW1lbnRhbERPTTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2luY3JlbWVudGFsLWRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xlYXJDaGFuZ2VzID0gY2xlYXJDaGFuZ2VzO1xuZXhwb3J0cy5nZXRDaGFuZ2VzID0gZ2V0Q2hhbmdlcztcbmV4cG9ydHMudHJhY2tDaGFuZ2VzID0gdHJhY2tDaGFuZ2VzO1xuXG52YXIgX2RhdGEgPSByZXF1aXJlKCcuL2RhdGEnKTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGNoYW5nZXMgdHJhY2tlZCBzbyBmYXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gY2xlYXJDaGFuZ2VzKGRhdGEpIHtcbiAgZGF0YS5jaGFuZ2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBgc3RhdGVLZXlDaGFuZ2VkYCBldmVudCBmcm9tIGEgY29tcG9uZW50LiBTdG9yZXMgY2hhbmdlIGRhdGEuXG4gKiBAcGFyYW0geyFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7IU9iamVjdH0gZXZlbnREYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVTdGF0ZUtleUNoYW5nZWRfKGRhdGEsIGV2ZW50RGF0YSkge1xuICBkYXRhLmNoYW5nZXMgPSBkYXRhLmNoYW5nZXMgfHwge307XG4gIHZhciB0eXBlID0gZXZlbnREYXRhLnR5cGUgfHwgJ3Byb3BzJztcbiAgZGF0YS5jaGFuZ2VzW3R5cGVdID0gZGF0YS5jaGFuZ2VzW3R5cGVdIHx8IHt9O1xuICBkYXRhLmNoYW5nZXNbdHlwZV1bZXZlbnREYXRhLmtleV0gPSBldmVudERhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjaGFuZ2VzIGluIHRoZSBnaXZlbiBjb21wb25lbnQgc2luY2UgdGhlIGxhc3QgdGltZSxcbiAqIG9yIG51bGwgaWYgdGhlcmUgd2VyZW4ndCBhbnkuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDaGFuZ2VzKGNvbXBvbmVudCkge1xuICByZXR1cm4gKDAsIF9kYXRhLmdldERhdGEpKGNvbXBvbmVudCkuY2hhbmdlcztcbn1cblxuLyoqXG4gKiBTdGFydHMgdHJhY2tpbmcgY2hhbmdlcyBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudFxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gdHJhY2tDaGFuZ2VzKGNvbXBvbmVudCkge1xuICB2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuICBjb21wb25lbnQub24oJ3N0YXRlS2V5Q2hhbmdlZCcsIGhhbmRsZVN0YXRlS2V5Q2hhbmdlZF8uYmluZChudWxsLCBkYXRhKSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9jaGFuZ2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNISUxEX09XTkVSID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5jYXB0dXJlQ2hpbGRyZW4gPSBjYXB0dXJlQ2hpbGRyZW47XG5leHBvcnRzLmlzQ2hpbGRUYWcgPSBpc0NoaWxkVGFnO1xuZXhwb3J0cy5nZXRPd25lciA9IGdldE93bmVyO1xuZXhwb3J0cy5yZW5kZXJDaGlsZFRyZWUgPSByZW5kZXJDaGlsZFRyZWU7XG5cbnZhciBfY2FsbEFyZ3MgPSByZXF1aXJlKCcuLi9jYWxsQXJncycpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9pbmNyZW1lbnRhbERvbUFvcCA9IHJlcXVpcmUoJy4uL2luY3JlbWVudGFsLWRvbS1hb3AnKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBQcm9wZXJ0eSBpZGVudGlmeWluZyBhIHNwZWNpZmljIG9iamVjdCBhcyBhIE1ldGFsLmpzIGNoaWxkIG5vZGUsIGFuZFxuICogcG9pbnRpbmcgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGNyZWF0ZWQgaXQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgQ0hJTERfT1dORVIgPSBleHBvcnRzLkNISUxEX09XTkVSID0gJ19fbWV0YWxDaGlsZE93bmVyJztcblxuLyoqXG4gKiBDYXB0dXJlcyBhbGwgY2hpbGQgZWxlbWVudHMgZnJvbSBpbmNyZW1lbnRhbCBkb20gY2FsbHMuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRoYXQgaXMgY2FwdHVyaW5nIGNoaWxkcmVuLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gY2hpbGRyZW4gaGF2ZSBhbGxcbiAqICAgICBiZWVuIGNhcHR1cmVkLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGNhbGxpbmcgaXQuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVDaGlsZHJlbihjb21wb25lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XG5cdG93bmVyXyA9IGNvbXBvbmVudDtcblx0Y2FsbGJhY2tfID0gY2FsbGJhY2s7XG5cdGNhbGxiYWNrRGF0YV8gPSBkYXRhO1xuXHR0cmVlXyA9IHtcblx0XHRwcm9wczoge1xuXHRcdFx0Y2hpbGRyZW46IFtdXG5cdFx0fVxuXHR9O1xuXHR0cmVlXy5jb25maWcgPSB0cmVlXy5wcm9wcztcblx0Y3VycmVudFBhcmVudF8gPSB0cmVlXztcblx0aXNDYXB0dXJpbmdfID0gdHJ1ZTtcblx0KDAsIF9pbmNyZW1lbnRhbERvbUFvcC5zdGFydEludGVyY2VwdGlvbikoe1xuXHRcdGVsZW1lbnRDbG9zZTogaGFuZGxlSW50ZXJjZXB0ZWRDbG9zZUNhbGxfLFxuXHRcdGVsZW1lbnRPcGVuOiBoYW5kbGVJbnRlcmNlcHRlZE9wZW5DYWxsXyxcblx0XHR0ZXh0OiBoYW5kbGVJbnRlcmNlcHRlZFRleHRDYWxsX1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRhZyB3YXMgYnVpbHQgZnJvbSBhIGNvbXBvbmVudCdzIGNoaWxkcmVuLlxuICogQHBhcmFtIHsqfSB0YWdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2hpbGRUYWcodGFnKSB7XG5cdHJldHVybiAoMCwgX21ldGFsLmlzRGVmKSh0YWcudGFnKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBub2RlJ3Mgb3JpZ2luYWwgb3duZXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0T3duZXIobm9kZSkge1xuXHRyZXR1cm4gbm9kZVtDSElMRF9PV05FUl07XG59XG5cbi8qKlxuICogUmVuZGVycyBhIGNoaWxkcmVuIHRyZWUgdGhyb3VnaCBpbmNyZW1lbnRhbCBkb20uXG4gKiBAcGFyYW0geyF7YXJnczogQXJyYXksIGNoaWxkcmVuOiAhQXJyYXksIGlzVGV4dDogP2Jvb2xlYW59fVxuICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X3NraXBOb2RlIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvclxuICogICAgIGVhY2ggbm9kZSB0byBiZSByZW5kZXJlZC4gSWYgaXQgcmV0dXJucyB0cnVlLCB0aGUgbm9kZSB3aWxsIGJlIHNraXBwZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNoaWxkVHJlZSh0cmVlLCBvcHRfc2tpcE5vZGUpIHtcblx0aWYgKGlzQ2FwdHVyaW5nXykge1xuXHRcdC8vIElmIGNhcHR1cmluZywganVzdCBhZGQgdGhlIG5vZGUgZGlyZWN0bHkgdG8gdGhlIGNhcHR1cmVkIHRyZWUuXG5cdFx0YWRkQ2hpbGRUb1RyZWUodHJlZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKG9wdF9za2lwTm9kZSAmJiBvcHRfc2tpcE5vZGUuY2FsbChudWxsLCB0cmVlKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICgoMCwgX21ldGFsLmlzRGVmKSh0cmVlLnRleHQpKSB7XG5cdFx0dmFyIGFyZ3MgPSB0cmVlLmFyZ3MgPyB0cmVlLmFyZ3MgOiBbXTtcblx0XHRhcmdzWzBdID0gdHJlZS50ZXh0O1xuXHRcdEluY3JlbWVudGFsRE9NLnRleHQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIF9hcmdzID0gKDAsIF9jYWxsQXJncy5idWlsZENhbGxGcm9tQ29uZmlnKSh0cmVlLnRhZywgdHJlZS5wcm9wcyk7XG5cdFx0X2FyZ3NbMF0gPSB7XG5cdFx0XHR0YWc6IF9hcmdzWzBdLFxuXHRcdFx0b3duZXI6IGdldE93bmVyKHRyZWUpXG5cdFx0fTtcblx0XHRJbmNyZW1lbnRhbERPTS5lbGVtZW50T3Blbi5hcHBseShudWxsLCBfYXJncyk7XG5cdFx0aWYgKHRyZWUucHJvcHMuY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5wcm9wcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZW5kZXJDaGlsZFRyZWUodHJlZS5wcm9wcy5jaGlsZHJlbltpXSwgb3B0X3NraXBOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0SW5jcmVtZW50YWxET00uZWxlbWVudENsb3NlKHRyZWUudGFnKTtcblx0fVxufVxuXG52YXIgY2FsbGJhY2tEYXRhXyA9IHZvaWQgMDtcbnZhciBjYWxsYmFja18gPSB2b2lkIDA7XG52YXIgY3VycmVudFBhcmVudF8gPSB2b2lkIDA7XG52YXIgaXNDYXB0dXJpbmdfID0gZmFsc2U7XG52YXIgb3duZXJfID0gdm9pZCAwO1xudmFyIHRyZWVfID0gdm9pZCAwO1xuXG4vKipcbiAqIEFkZHMgYSBjaGlsZCBlbGVtZW50IHRvIHRoZSB0cmVlLlxuICogQHBhcmFtIHshQXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGluY3JlbWVudGFsIGRvbSBjYWxsLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzVGV4dCBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNoaWxkIGlzIGFcbiAqICAgICB0ZXh0IGVsZW1lbnQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkQ2FsbFRvVHJlZV8oYXJncywgb3B0X2lzVGV4dCkge1xuXHR2YXIgY2hpbGQgPSBfZGVmaW5lUHJvcGVydHkoe1xuXHRcdHBhcmVudDogY3VycmVudFBhcmVudF9cblx0fSwgQ0hJTERfT1dORVIsIG93bmVyXyk7XG5cblx0aWYgKG9wdF9pc1RleHQpIHtcblx0XHRjaGlsZC50ZXh0ID0gYXJnc1swXTtcblx0XHRpZiAoYXJncy5sZW5ndGggPiAxKSB7XG5cdFx0XHRjaGlsZC5hcmdzID0gYXJncztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGQudGFnID0gYXJnc1swXTtcblx0XHRjaGlsZC5wcm9wcyA9ICgwLCBfY2FsbEFyZ3MuYnVpbGRDb25maWdGcm9tQ2FsbCkoYXJncyk7XG5cdFx0Y2hpbGQucHJvcHMuY2hpbGRyZW4gPSBbXTtcblx0XHRjaGlsZC5jb25maWcgPSBjaGlsZC5wcm9wcztcblx0fVxuXG5cdGFkZENoaWxkVG9UcmVlKGNoaWxkKTtcblx0cmV0dXJuIGNoaWxkO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZFRvVHJlZShjaGlsZCkge1xuXHRjdXJyZW50UGFyZW50Xy5wcm9wcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50Q2xvc2VgIGZ1bmN0aW9uIGZyb20gaW5jcmVtZW50YWxcbiAqIGRvbS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRDbG9zZUNhbGxfKCkge1xuXHRpZiAoY3VycmVudFBhcmVudF8gPT09IHRyZWVfKSB7XG5cdFx0KDAsIF9pbmNyZW1lbnRhbERvbUFvcC5zdG9wSW50ZXJjZXB0aW9uKSgpO1xuXHRcdGlzQ2FwdHVyaW5nXyA9IGZhbHNlO1xuXHRcdHZhciBub2RlID0gY2FsbGJhY2tfLmNhbGwob3duZXJfLCB0cmVlXywgY2FsbGJhY2tEYXRhXyk7XG5cdFx0Y2FsbGJhY2tfID0gbnVsbDtcblx0XHRjYWxsYmFja0RhdGFfID0gbnVsbDtcblx0XHRjdXJyZW50UGFyZW50XyA9IG51bGw7XG5cdFx0b3duZXJfID0gbnVsbDtcblx0XHR0cmVlXyA9IG51bGw7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0gZWxzZSB7XG5cdFx0Y3VycmVudFBhcmVudF8gPSBjdXJyZW50UGFyZW50Xy5wYXJlbnQ7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbFxuICogZG9tLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gYmVmb3JlIGludGVyY2VwdGlvbi5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF8oKSB7XG5cdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0fVxuXG5cdGN1cnJlbnRQYXJlbnRfID0gYWRkQ2hpbGRDYWxsVG9UcmVlXyhhcmdzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGB0ZXh0YCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsIGRvbS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlZm9yZSBpbnRlcmNlcHRpb24uXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUludGVyY2VwdGVkVGV4dENhbGxfKCkge1xuXHRmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHRcdGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0fVxuXG5cdGFkZENoaWxkQ2FsbFRvVHJlZV8oYXJncywgdHJ1ZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9jaGlsZHJlbi9jaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEJ1aWxkcyB0aGUgY29tcG9uZW50IGNvbmZpZyBvYmplY3QgZnJvbSBpdHMgaW5jcmVtZW50YWwgZG9tIGNhbGwnc1xuICogYXJndW1lbnRzLlxuICogQHBhcmFtIHshQXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYnVpbGRDb25maWdGcm9tQ2FsbCA9IGJ1aWxkQ29uZmlnRnJvbUNhbGw7XG5leHBvcnRzLmJ1aWxkQ2FsbEZyb21Db25maWcgPSBidWlsZENhbGxGcm9tQ29uZmlnO1xuZnVuY3Rpb24gYnVpbGRDb25maWdGcm9tQ2FsbChhcmdzKSB7XG5cdHZhciBjb25maWcgPSB7fTtcblx0aWYgKGFyZ3NbMV0pIHtcblx0XHRjb25maWcua2V5ID0gYXJnc1sxXTtcblx0fVxuXHR2YXIgYXR0cnNBcnIgPSAoYXJnc1syXSB8fCBbXSkuY29uY2F0KGFyZ3Muc2xpY2UoMykpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzQXJyLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0Y29uZmlnW2F0dHJzQXJyW2ldXSA9IGF0dHJzQXJyW2kgKyAxXTtcblx0fVxuXHRyZXR1cm4gY29uZmlnO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhbiBpbmNyZW1lbnRhbCBkb20gY2FsbCBhcnJheSBmcm9tIHRoZSBnaXZlbiB0YWcgYW5kIGNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbmZpZ1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBidWlsZENhbGxGcm9tQ29uZmlnKHRhZywgY29uZmlnKSB7XG5cdHZhciBjYWxsID0gW3RhZywgY29uZmlnLmtleSwgW11dO1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChrZXlzW2ldICE9PSAnY2hpbGRyZW4nICYmIGtleXNbaV0gIT09ICdrZXknKSB7XG5cdFx0XHRjYWxsLnB1c2goa2V5c1tpXSwgY29uZmlnW2tleXNbaV1dKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNhbGw7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9jYWxsQXJncy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmdldENvbXBvbmVudEJlaW5nUmVuZGVyZWQgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkO1xuZXhwb3J0cy5pc0NvbXBvbmVudFRhZ18gPSBpc0NvbXBvbmVudFRhZ187XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMucmVuZGVyQ2hpbGQgPSByZW5kZXJDaGlsZDtcbmV4cG9ydHMucmVuZGVyRnVuY3Rpb24gPSByZW5kZXJGdW5jdGlvbjtcblxudmFyIF9hdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG5cbnZhciBfY2FsbEFyZ3MgPSByZXF1aXJlKCcuLi9jYWxsQXJncycpO1xuXG52YXIgX2NoaWxkcmVuID0gcmVxdWlyZSgnLi4vY2hpbGRyZW4vY2hpbGRyZW4nKTtcblxudmFyIF9jaGFuZ2VzID0gcmVxdWlyZSgnLi4vY2hhbmdlcycpO1xuXG52YXIgX21ldGFsRG9tID0gcmVxdWlyZSgnbWV0YWwtZG9tJyk7XG5cbnZhciBfZGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfdW51c2VkID0gcmVxdWlyZSgnLi4vY2xlYW51cC91bnVzZWQnKTtcblxudmFyIF9pbmNyZW1lbnRhbERvbUFvcCA9IHJlcXVpcmUoJy4uL2luY3JlbWVudGFsLWRvbS1hb3AnKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciByZW5kZXJpbmdDb21wb25lbnRzXyA9IFtdO1xudmFyIGVtcHR5Q2hpbGRyZW5fID0gW107XG5cbi8qKlxuICogQWRkcyB0aGUgZ2l2ZW4gY3NzIGNsYXNzZXMgdG8gdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgZm9yIGFuIGluY3JlbWVudGFsXG4gKiBkb20gY2FsbCwgbWVyZ2luZyB3aXRoIHRoZSBleGlzdGluZyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudENsYXNzZXNcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRFbGVtZW50Q2xhc3Nlc18oZWxlbWVudENsYXNzZXMsIGNvbmZpZykge1xuXHRpZiAoY29uZmlnLmNsYXNzKSB7XG5cdFx0Y29uZmlnLmNsYXNzICs9ICcgJyArIGVsZW1lbnRDbGFzc2VzO1xuXHRcdGNvbmZpZy5jbGFzcyA9IHJlbW92ZUR1cGxpY2F0ZUNsYXNzZXNfKGNvbmZpZy5jbGFzcyk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZmlnLmNsYXNzID0gZWxlbWVudENsYXNzZXM7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIFwiY2hpbGRyZW5cIiBhcnJheSB0byBiZSBwYXNzZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHshQXJyYXk8IU9iamVjdD59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHshQXJyYXk8IU9iamVjdD59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWlsZENoaWxkcmVuXyhjaGlsZHJlbikge1xuXHRyZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gZW1wdHlDaGlsZHJlbl8gOiBjaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgcmVuZGVyIG9wZXJhdGlvbiwgZG9pbmcgc29tZSBjbGVhdXBzLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBSZW5kZXJfKGNvbXBvbmVudCkge1xuXHQoMCwgX2luY3JlbWVudGFsRG9tQW9wLnN0b3BJbnRlcmNlcHRpb24pKCk7XG5cdGlmICghKDAsIF9kYXRhLmdldERhdGEpKGNvbXBvbmVudCkucm9vdEVsZW1lbnRSZWFjaGVkKSB7XG5cdFx0Y29tcG9uZW50LmVsZW1lbnQgPSBudWxsO1xuXHR9XG5cdGNvbXBvbmVudC5pbmZvcm1SZW5kZXJlZCgpO1xuXHRmaW5pc2hlZFJlbmRlcmluZ0NvbXBvbmVudF8oKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBtb3N0IHJlY2VudCBjb21wb25lbnQgZnJvbSB0aGUgcXVldWUgb2YgcmVuZGVyaW5nIGNvbXBvbmVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmaW5pc2hlZFJlbmRlcmluZ0NvbXBvbmVudF8oKSB7XG5cdHJlbmRlcmluZ0NvbXBvbmVudHNfLnBvcCgpO1xuXHRpZiAocmVuZGVyaW5nQ29tcG9uZW50c18ubGVuZ3RoID09PSAwKSB7XG5cdFx0KDAsIF91bnVzZWQuZGlzcG9zZVVudXNlZCkoKTtcblx0fVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBmb3IgdGhlIG5leHQgZWxlbWVudCB0byBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9zdHJpbmd9IGtleSBUaGUga2V5IG9yaWdpbmFsbHkgcGFzc2VkIHRvIHRoZSBlbGVtZW50LlxuICogQHJldHVybiB7P3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5Xyhjb21wb25lbnQsIGtleSkge1xuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRpZiAoIWRhdGEucm9vdEVsZW1lbnRSZWFjaGVkICYmIGRhdGEuY29uZmlnLmtleSkge1xuXHRcdGtleSA9IGRhdGEuY29uZmlnLmtleTtcblx0fVxuXHRyZXR1cm4gY29tcG9uZW50LmdldFJlbmRlcmVyKCkuZ2VuZXJhdGVLZXkoY29tcG9uZW50LCBrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNoaWxkIGNvbXBvbmVudHMgc3RvcmVkIGluIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0geyFPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4geyFBcnJheTwhQ29tcG9uZW50Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENoaWxkQ29tcG9uZW50c18oZGF0YSkge1xuXHRkYXRhLmNoaWxkQ29tcG9uZW50cyA9IGRhdGEuY2hpbGRDb21wb25lbnRzIHx8IFtdO1xuXHRyZXR1cm4gZGF0YS5jaGlsZENvbXBvbmVudHM7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY29tcG9uZW50IGJlaW5nIGN1cnJlbnRseSByZW5kZXJlZC5cbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50QmVpbmdSZW5kZXJlZCgpIHtcblx0cmV0dXJuIHJlbmRlcmluZ0NvbXBvbmVudHNfW3JlbmRlcmluZ0NvbXBvbmVudHNfLmxlbmd0aCAtIDFdO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGN1cnJlbnRseSB1c2VkLiBUaGlzIG9iamVjdCB3aWxsIGVpdGhlclxuICogY29tZSBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcmVuZGVyZWQgYnkgaW5jcmVtZW50YWwgZG9tIG9yIGZyb21cbiAqIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgYmVpbmcgcmVuZGVyZWQgKG9ubHkgd2hlbiB0aGUgY3VycmVudCBlbGVtZW50IGlzIHRoZVxuICogY29tcG9uZW50J3MgZGlyZWN0IHBhcmVudCkuXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudERhdGEoKSB7XG5cdHZhciBlbGVtZW50ID0gSW5jcmVtZW50YWxET00uY3VycmVudEVsZW1lbnQoKTtcblx0dmFyIGNvbXAgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCk7XG5cdHZhciBvYmogPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCk7XG5cdGlmIChvYmoucm9vdEVsZW1lbnRSZWFjaGVkICYmIGVsZW1lbnQgIT09IGNvbXAuZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0b2JqID0gX21ldGFsRG9tLmRvbURhdGEuZ2V0KGVsZW1lbnQpO1xuXHR9XG5cdG9iai5pY0NvbXBvbmVudHNEYXRhID0gb2JqLmljQ29tcG9uZW50c0RhdGEgfHwge307XG5cdHJldHVybiBvYmouaWNDb21wb25lbnRzRGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcInJlZlwiIHRvIGJlIHVzZWQgZm9yIGEgY29tcG9uZW50LiBVc2VzIFwia2V5XCIgYXMgXCJyZWZcIiB3aGVuXG4gKiBjb21wYXRpYmlsaXR5IG1vZGUgaXMgb24gZm9yIHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBvd25lclxuICogQHBhcmFtIHshT2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRSZWZfKG93bmVyLCBjb25maWcpIHtcblx0dmFyIGNvbXBhdERhdGEgPSAoMCwgX21ldGFsLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSkoKTtcblx0aWYgKGNvbXBhdERhdGEpIHtcblx0XHR2YXIgb3duZXJSZW5kZXJlciA9IG93bmVyLmdldFJlbmRlcmVyKCk7XG5cdFx0dmFyIHJlbmRlcmVycyA9IGNvbXBhdERhdGEucmVuZGVyZXJzO1xuXHRcdHZhciB1c2VLZXkgPSAhcmVuZGVyZXJzIHx8IHJlbmRlcmVycy5pbmRleE9mKG93bmVyUmVuZGVyZXIpICE9PSAtMSB8fCByZW5kZXJlcnMuaW5kZXhPZihvd25lclJlbmRlcmVyLlJFTkRFUkVSX05BTUUpICE9PSAtMTtcblx0XHRpZiAodXNlS2V5ICYmIGNvbmZpZy5rZXkgJiYgIWNvbmZpZy5yZWYpIHtcblx0XHRcdHJldHVybiBjb25maWcua2V5O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY29uZmlnLnJlZjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdWIgY29tcG9uZW50IHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHRhZyBhbmQgY29uZmlnIGRhdGEsXG4gKiBjcmVhdGluZyBpdCBpZiBpdCBkb2Vzbid0IHlldCBleGlzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfCFGdW5jdGlvbn0gdGFnT3JDdG9yIFRoZSB0YWcgbmFtZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUgc3ViIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gb3duZXJcbiAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSBzdWIgY29tcG9uZW50LlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBnZXRTdWJDb21wb25lbnRfKHRhZ09yQ3RvciwgY29uZmlnLCBvd25lcikge1xuXHR2YXIgQ3RvciA9IHRhZ09yQ3Rvcjtcblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKEN0b3IpKSB7XG5cdFx0Q3RvciA9IF9tZXRhbENvbXBvbmVudC5Db21wb25lbnRSZWdpc3RyeS5nZXRDb25zdHJ1Y3Rvcih0YWdPckN0b3IpO1xuXHR9XG5cblx0dmFyIHJlZiA9IGdldFJlZl8ob3duZXIsIGNvbmZpZyk7XG5cdHZhciBjb21wID0gdm9pZCAwO1xuXHRpZiAoKDAsIF9tZXRhbC5pc0RlZikocmVmKSkge1xuXHRcdGNvbXAgPSBtYXRjaF8ob3duZXIuY29tcG9uZW50c1tyZWZdLCBDdG9yLCBjb25maWcsIG93bmVyKTtcblx0XHRvd25lci5jb21wb25lbnRzW3JlZl0gPSBjb21wO1xuXHRcdG93bmVyLnJlZnNbcmVmXSA9IGNvbXA7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGRhdGEgPSBnZXRDdXJyZW50RGF0YSgpO1xuXHRcdHZhciBrZXkgPSBjb25maWcua2V5O1xuXHRcdGlmICghKDAsIF9tZXRhbC5pc0RlZikoa2V5KSkge1xuXHRcdFx0dmFyIHR5cGUgPSAoMCwgX21ldGFsLmdldFVpZCkoQ3RvciwgdHJ1ZSk7XG5cdFx0XHRkYXRhLmN1cnJDb3VudCA9IGRhdGEuY3VyckNvdW50IHx8IHt9O1xuXHRcdFx0ZGF0YS5jdXJyQ291bnRbdHlwZV0gPSBkYXRhLmN1cnJDb3VudFt0eXBlXSB8fCAwO1xuXHRcdFx0a2V5ID0gJ19fTUVUQUxfSUNfXycgKyB0eXBlICsgJ18nICsgZGF0YS5jdXJyQ291bnRbdHlwZV0rKztcblx0XHR9XG5cdFx0Y29tcCA9IG1hdGNoXyhkYXRhLnByZXZDb21wcyA/IGRhdGEucHJldkNvbXBzW2tleV0gOiBudWxsLCBDdG9yLCBjb25maWcsIG93bmVyKTtcblx0XHRkYXRhLmN1cnJDb21wcyA9IGRhdGEuY3VyckNvbXBzIHx8IHt9O1xuXHRcdGRhdGEuY3VyckNvbXBzW2tleV0gPSBjb21wO1xuXHR9XG5cblx0cmV0dXJuIGNvbXA7XG59XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgZXZlbnQgb2YgY2hpbGRyZW4gaGF2aW5nIGZpbmlzaGVkIGJlaW5nIGNhcHR1cmVkLlxuICogQHBhcmFtIHshT2JqZWN0fSB0cmVlIFRoZSBjYXB0dXJlZCBjaGlsZHJlbiBpbiB0cmVlIGZvcm1hdC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUNoaWxkcmVuQ2FwdHVyZWRfKHRyZWUsIF9yZWYpIHtcblx0dmFyIHByb3BzID0gX3JlZi5wcm9wcyxcblx0ICAgIHRhZyA9IF9yZWYudGFnO1xuXG5cdHByb3BzLmNoaWxkcmVuID0gYnVpbGRDaGlsZHJlbl8odHJlZS5wcm9wcy5jaGlsZHJlbik7XG5cdHJldHVybiByZW5kZXJGcm9tVGFnXyh0YWcsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgY2hpbGQgYmVpbmcgcmVuZGVyZWQgdmlhIGBJbmNyZW1lbnRhbERvbUNoaWxkcmVuLnJlbmRlcmAuIFNraXBzXG4gKiBjb21wb25lbnQgbm9kZXMgc28gdGhhdCB0aGV5IGNhbiBiZSByZW5kZXJlZCB0aGUgY29ycmVjdCB3YXkgd2l0aG91dFxuICogaGF2aW5nIHRvIHJlY2FwdHVyZSBib3RoIHRoZW0gYW5kIHRoZWlyIGNoaWxkcmVuIHZpYSBpbmNyZW1lbnRhbCBkb20uXG4gKiBAcGFyYW0geyFPYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVDaGlsZFJlbmRlcl8obm9kZSkge1xuXHRpZiAobm9kZS50YWcgJiYgaXNDb21wb25lbnRUYWdfKG5vZGUudGFnKSkge1xuXHRcdG5vZGUucHJvcHMuY2hpbGRyZW4gPSBidWlsZENoaWxkcmVuXyhub2RlLnByb3BzLmNoaWxkcmVuKTtcblx0XHRyZW5kZXJGcm9tVGFnXyhub2RlLnRhZywgbm9kZS5wcm9wcywgKDAsIF9jaGlsZHJlbi5nZXRPd25lcikobm9kZSkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBhdHRyaWJ1dGVzIGRlZmF1bHQgaGFuZGxlciBmcm9tXG4gKiBpbmNyZW1lbnRhbCBkb20uXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRBdHRyaWJ1dGVzQ2FsbF8oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcblx0KDAsIF9hdHRyaWJ1dGVzLmFwcGx5QXR0cmlidXRlKShnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCksIGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbFxuICogZG9tLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF8odGFnKSB7XG5cdGlmIChpc0NvbXBvbmVudFRhZ18odGFnKSkge1xuXHRcdHJldHVybiBoYW5kbGVTdWJDb21wb25lbnRDYWxsXy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBoYW5kbGVSZWd1bGFyQ2FsbF8uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIEhhbmRsZXMgYW4gaW50ZXJjZXB0ZWQgY2FsbCB0byB0aGUgYGVsZW1lbnRPcGVuYCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsXG4gKiBkb20sIGRvbmUgZm9yIGEgcmVndWxhciBlbGVtZW50LiBBbW9uZyBvdGhlciB0aGluZ3MsIGFkZHMgYW55IGlubGluZVxuICogbGlzdGVuZXJzIGZvdW5kIG9uIHRoZSBmaXJzdCByZW5kZXIgYW5kIG1ha2VzIHN1cmUgdGhhdCBjb21wb25lbnQgcm9vdFxuICogZWxlbWVudHMgYXJlIGFsd2F5cyByZXVzZWQuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IG93bmVyXG4gKiBAcGFyYW0geyFBcnJheX0gYXJnc1xuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmVndWxhckNhbGxfKCkge1xuXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHRcdGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdH1cblxuXHR2YXIgY29uZmlnID0gKDAsIF9jYWxsQXJncy5idWlsZENvbmZpZ0Zyb21DYWxsKShhcmdzKTtcblx0dmFyIHRhZyA9IGFyZ3NbMF07XG5cblx0dmFyIGNvbXAgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCk7XG5cdHZhciBvd25lciA9IGNvbXA7XG5cdGlmICgoMCwgX2NoaWxkcmVuLmlzQ2hpbGRUYWcpKHRhZykpIHtcblx0XHRvd25lciA9IHRhZy5vd25lcjtcblx0XHR0YWcgPSB0YWcudGFnO1xuXHR9XG5cdGNvbmZpZy5rZXkgPSBnZW5lcmF0ZUtleV8oY29tcCwgY29uZmlnLmtleSk7XG5cblx0aWYgKCEoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCkucm9vdEVsZW1lbnRSZWFjaGVkKSB7XG5cdFx0dmFyIGVsZW1lbnRDbGFzc2VzID0gY29tcC5nZXREYXRhTWFuYWdlcigpLmdldChjb21wLCAnZWxlbWVudENsYXNzZXMnKTtcblx0XHRpZiAoZWxlbWVudENsYXNzZXMpIHtcblx0XHRcdGFkZEVsZW1lbnRDbGFzc2VzXyhlbGVtZW50Q2xhc3NlcywgY29uZmlnKTtcblx0XHR9XG5cdH1cblx0KDAsIF9hdHRyaWJ1dGVzLmNvbnZlcnRMaXN0ZW5lck5hbWVzVG9GbnMpKGNvbXAsIGNvbmZpZyk7XG5cblx0dmFyIGNhbGwgPSAoMCwgX2NhbGxBcmdzLmJ1aWxkQ2FsbEZyb21Db25maWcpKHRhZywgY29uZmlnKTtcblx0dmFyIG5vZGUgPSAoMCwgX2luY3JlbWVudGFsRG9tQW9wLmdldE9yaWdpbmFsRm4pKCdlbGVtZW50T3BlbicpLmFwcGx5KG51bGwsIGNhbGwpO1xuXHRyZXNldE5vZGVEYXRhXyhub2RlKTtcblx0dXBkYXRlRWxlbWVudElmTm90UmVhY2hlZF8oY29tcCwgbm9kZSk7XG5cblx0aWYgKCgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKShjb25maWcucmVmKSkge1xuXHRcdG93bmVyLnJlZnNbY29uZmlnLnJlZl0gPSBub2RlO1xuXHR9XG5cdG93bmVyLmdldFJlbmRlcmVyKCkuaGFuZGxlTm9kZVJlbmRlcmVkKG5vZGUpO1xuXG5cdHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgYW4gaW50ZXJjZXB0ZWQgY2FsbCB0byB0aGUgYGVsZW1lbnRPcGVuYCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsXG4gKiBkb20sIGRvbmUgZm9yIGEgc3ViIGNvbXBvbmVudCBlbGVtZW50LiBDcmVhdGVzIGFuZCB1cGRhdGVzIHRoZSBhcHByb3ByaWF0ZVxuICogc3ViIGNvbXBvbmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVN1YkNvbXBvbmVudENhbGxfKCkge1xuXHRmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHRcdGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0fVxuXG5cdCgwLCBfY2hpbGRyZW4uY2FwdHVyZUNoaWxkcmVuKShnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCksIGhhbmRsZUNoaWxkcmVuQ2FwdHVyZWRfLCB7XG5cdFx0cHJvcHM6ICgwLCBfY2FsbEFyZ3MuYnVpbGRDb25maWdGcm9tQ2FsbCkoYXJncyksXG5cdFx0dGFnOiBhcmdzWzBdXG5cdH0pO1xufVxuXG4vKipcbiAqIFBhc3NlcyBkb3duIGVsZW1lbnRDbGFzc2VzIHRvIGEgY2hpbGQgY29tcG9uZW50IGlmIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gKiByZXR1cm5zIGFub3RoZXIgY29tcG9uZW50IGF0IHRoZSB0b3AgbGV2ZWwgKEhPQykuXG4gKiBAcGFyYW0geyp9IHBhcmVudCBUaGUgcGFyZW50IGNvbXBvbmVudFxuICogQHBhcmFtIHsqfSBjb25maWcgVGhlIGNvbmZpZyBvZiB0aGUgc3ViY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXRFbGVtZW50Q2xhc3Nlc18ocGFyZW50LCBjb25maWcpIHtcblx0dmFyIHBhcmVudERhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkocGFyZW50KTtcblx0dmFyIHBhcmVudENvbmZpZyA9IHBhcmVudERhdGEuY29uZmlnO1xuXG5cdGlmICghcGFyZW50RGF0YS5yb290RWxlbWVudFJlYWNoZWQgJiYgcGFyZW50Q29uZmlnICYmICgwLCBfbWV0YWwuaXNTdHJpbmcpKHBhcmVudENvbmZpZy5lbGVtZW50Q2xhc3NlcykpIHtcblx0XHR2YXIgY3VycmVudENsYXNzZXMgPSAnJztcblx0XHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoY29uZmlnLmVsZW1lbnRDbGFzc2VzKSkge1xuXHRcdFx0Y3VycmVudENsYXNzZXMgPSBjb25maWcuZWxlbWVudENsYXNzZXMgKyAnICc7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLmVsZW1lbnRDbGFzc2VzID0gY3VycmVudENsYXNzZXMgKyBwYXJlbnRDb25maWcuZWxlbWVudENsYXNzZXM7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRhZyByZXByZXNlbnRzIGEgbWV0YWwgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnXyh0YWcpIHtcblx0cmV0dXJuICgwLCBfbWV0YWwuaXNGdW5jdGlvbikodGFnKSB8fCAoMCwgX21ldGFsLmlzU3RyaW5nKSh0YWcpICYmIHRhZ1swXSA9PT0gdGFnWzBdLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjb21wb25lbnQgY2FuIGJlIGEgbWF0Y2ggZm9yIGEgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IEN0b3JcbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gb3duZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc01hdGNoXyhjb21wLCBDdG9yLCBvd25lcikge1xuXHRpZiAoIWNvbXAgfHwgY29tcC5jb25zdHJ1Y3RvciAhPT0gQ3RvciB8fCBjb21wLmlzRGlzcG9zZWQoKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gKDAsIF9kYXRhLmdldERhdGEpKGNvbXApLm93bmVyID09PSBvd25lcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBjb21wb25lbnQgaWYgaXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnN0cnVjdG9yXG4gKiBmdW5jdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjb25zdHJ1Y3Rvci4gT25cbiAqIGJvdGggY2FzZXMgdGhlIGNvbXBvbmVudCdzIHN0YXRlIGFuZCBjb25maWcgd2lsbCBiZSB1cGRhdGVkLlxuICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IEN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IG93bmVyXG4gKiBAcmV0dXJuIHshQ29tcG9uZW50fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWF0Y2hfKGNvbXAsIEN0b3IsIGNvbmZpZywgb3duZXIpIHtcblx0aWYgKGlzTWF0Y2hfKGNvbXAsIEN0b3IsIG93bmVyKSkge1xuXHRcdGNvbXAuc3RhcnRTa2lwVXBkYXRlcygpO1xuXHRcdGNvbXAuZ2V0RGF0YU1hbmFnZXIoKS5yZXBsYWNlTm9uSW50ZXJuYWwoY29tcCwgY29uZmlnKTtcblx0XHRjb21wLnN0b3BTa2lwVXBkYXRlcygpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbXAgPSBuZXcgQ3Rvcihjb25maWcsIGZhbHNlKTtcblx0fVxuXHQoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCkuY29uZmlnID0gY29uZmlnO1xuXHRyZXR1cm4gY29tcDtcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgcmVuZGVyIG9wZXJhdGlvbiwgcmVzZXR0aW5nIHRoZSBjb21wb25lbnQncyBkYXRhIGFuZCBzdGFydGluZ1xuICogdGhlIGluY3JlbWVudGFsIGRvbSBpbnRlcmNlcHRpb24uXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVJlbmRlcl8oY29tcG9uZW50KSB7XG5cdHJlbmRlcmluZ0NvbXBvbmVudHNfLnB1c2goY29tcG9uZW50KTtcblxuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRyZXNldENvbXBvbmVudHNEYXRhXyhkYXRhLmljQ29tcG9uZW50c0RhdGEpO1xuXHQoMCwgX2NoYW5nZXMuY2xlYXJDaGFuZ2VzKShkYXRhKTtcblx0ZGF0YS5yb290RWxlbWVudFJlYWNoZWQgPSBmYWxzZTtcblx0Y29tcG9uZW50LnJlZnMgPSB7fTtcblxuXHRpZiAoZGF0YS5jaGlsZENvbXBvbmVudHMpIHtcblx0XHQoMCwgX3VudXNlZC5zY2hlZHVsZSkoZGF0YS5jaGlsZENvbXBvbmVudHMpO1xuXHRcdGRhdGEuY2hpbGRDb21wb25lbnRzID0gbnVsbDtcblx0fVxuXG5cdCgwLCBfaW5jcmVtZW50YWxEb21Bb3Auc3RhcnRJbnRlcmNlcHRpb24pKHtcblx0XHRhdHRyaWJ1dGVzOiBoYW5kbGVJbnRlcmNlcHRlZEF0dHJpYnV0ZXNDYWxsXyxcblx0XHRlbGVtZW50T3BlbjogaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF9cblx0fSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgY3NzIGNsYXNzZXMgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzU3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVDbGFzc2VzXyhjbGFzc1N0cmluZykge1xuXHR2YXIgY2xhc3NlcyA9IFtdO1xuXHR2YXIgYWxsID0gY2xhc3NTdHJpbmcuc3BsaXQoL1xccysvKTtcblx0dmFyIHVzZWQgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIXVzZWRbYWxsW2ldXSkge1xuXHRcdFx0dXNlZFthbGxbaV1dID0gdHJ1ZTtcblx0XHRcdGNsYXNzZXMucHVzaChhbGxbaV0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY29tcG9uZW50IHdpdGggaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGNhbGxzLiBUaGlzIGFzc3VtZXMgdGhhdFxuICogYW4gaW5jcmVtZW50YWwgZG9tIGBwYXRjaGAgaXMgYWxyZWFkeSBydW5uaW5nLCBhbmQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhc1xuICogYmVlbiBjYWxsZWQgaW5zaWRlIGl0LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gcmVuZGVyKGNvbXBvbmVudCkge1xuXHRwcmVwYXJlUmVuZGVyXyhjb21wb25lbnQpO1xuXHRjb21wb25lbnQuZ2V0UmVuZGVyZXIoKS5yZW5kZXJJbmNEb20oY29tcG9uZW50KTtcblx0Y2xlYW5VcFJlbmRlcl8oY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBnaXZlbiBjaGlsZCBub2RlLlxuICogQHBhcmFtIHshT2JqZWN0fSBjaGlsZFxuICovXG5mdW5jdGlvbiByZW5kZXJDaGlsZChjaGlsZCkge1xuXHQoMCwgX2NoaWxkcmVuLnJlbmRlckNoaWxkVHJlZSkoY2hpbGQsIGhhbmRsZUNoaWxkUmVuZGVyXyk7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY29udGVudHMgZm9yIHRoZSBnaXZlbiB0YWcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfHN0cmluZ30gdGFnXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtDb21wb25lbnQ9fSBvcHRfb3duZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckZyb21UYWdfKHRhZywgY29uZmlnLCBvcHRfb3duZXIpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKHRhZykgfHwgdGFnLnByb3RvdHlwZS5nZXRSZW5kZXJlcikge1xuXHRcdHZhciBjb21wID0gcmVuZGVyU3ViQ29tcG9uZW50Xyh0YWcsIGNvbmZpZywgb3B0X293bmVyKTtcblx0XHR1cGRhdGVFbGVtZW50SWZOb3RSZWFjaGVkXyhnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCksIGNvbXAuZWxlbWVudCk7XG5cdFx0cmV0dXJuIGNvbXAuZWxlbWVudDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGFnKGNvbmZpZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZW5kZXJzIHRoZSBnaXZlbiBmdW5jdGlvbiwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIHNpbXBsZVxuICogaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIG9yIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHshSW5jcmVtZW50YWxEb21SZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuT3JDdG9yIEVpdGhlciBhIHNpbXBsZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gb3IgYVxuICogICAgIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fEVsZW1lbnQ9fSBvcHRfZGF0YU9yRWxlbWVudCBPcHRpb25hbCBjb25maWcgZGF0YSBmb3IgdGhlXG4gKiAgICAgZnVuY3Rpb24gb3IgcGFyZW50IGZvciB0aGUgcmVuZGVyZWQgY29udGVudC5cbiAqIEBwYXJhbSB7RWxlbWVudD19IG9wdF9wYXJlbnQgT3B0aW9uYWwgcGFyZW50IGZvciB0aGUgcmVuZGVyZWQgY29udGVudC5cbiAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSByZW5kZXJlZCBjb21wb25lbnQncyBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyRnVuY3Rpb24ocmVuZGVyZXIsIGZuT3JDdG9yLCBvcHRfZGF0YU9yRWxlbWVudCwgb3B0X3BhcmVudCkge1xuXHRpZiAoIV9tZXRhbENvbXBvbmVudC5Db21wb25lbnQuaXNDb21wb25lbnRDdG9yKGZuT3JDdG9yKSkge1xuXHRcdHZhciBmbiA9IGZuT3JDdG9yO1xuXG5cdFx0dmFyIFRlbXBDb21wb25lbnQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuXHRcdFx0X2luaGVyaXRzKFRlbXBDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG5cdFx0XHRmdW5jdGlvbiBUZW1wQ29tcG9uZW50KCkge1xuXHRcdFx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVtcENvbXBvbmVudCk7XG5cblx0XHRcdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZW1wQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGVtcENvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHRcdFx0fVxuXG5cdFx0XHRfY3JlYXRlQ2xhc3MoVGVtcENvbXBvbmVudCwgW3tcblx0XHRcdFx0a2V5OiAnY3JlYXRlZCcsXG5cdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlQ29udGV4dF8odGhpcywgcGFyZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIHtcblx0XHRcdFx0a2V5OiAncmVuZGVyJyxcblx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHRcdFx0XHRmbih0aGlzLmdldEluaXRpYWxDb25maWcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1dKTtcblxuXHRcdFx0cmV0dXJuIFRlbXBDb21wb25lbnQ7XG5cdFx0fShfbWV0YWxDb21wb25lbnQuQ29tcG9uZW50KTtcblxuXHRcdFRlbXBDb21wb25lbnQuUkVOREVSRVIgPSByZW5kZXJlcjtcblx0XHRmbk9yQ3RvciA9IFRlbXBDb21wb25lbnQ7XG5cdH1cblx0cmV0dXJuIF9tZXRhbENvbXBvbmVudC5Db21wb25lbnQucmVuZGVyKGZuT3JDdG9yLCBvcHRfZGF0YU9yRWxlbWVudCwgb3B0X3BhcmVudCk7XG59XG5cbi8qKlxuICogVGhpcyB1cGRhdGVzIHRoZSBzdWIgY29tcG9uZW50IHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGRhdGEuXG4gKiBUaGUgc3ViIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBhZGRlZCB0byBpdHMgcGFyZW50IGFuZCByZW5kZXJlZC4gSWYgaXRcbiAqIGhhZCBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgYmVmb3JlIHRob3VnaCwgaXQgd2lsbCBvbmx5IGhhdmUgaXRzIHN0YXRlXG4gKiB1cGRhdGVkIGluc3RlYWQuXG4gKiBAcGFyYW0ge3N0cmluZ3whZnVuY3Rpb24oKX0gdGFnT3JDdG9yIFRoZSB0YWcgbmFtZSBvciBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUgc3ViIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7Q29tcG9uZW50UmVuZGVyZXI9fSBvcHRfb3duZXJcbiAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSB1cGRhdGVkIHN1YiBjb21wb25lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXJTdWJDb21wb25lbnRfKHRhZ09yQ3RvciwgY29uZmlnLCBvcHRfb3duZXIpIHtcblx0dmFyIHBhcmVudCA9IGdldENvbXBvbmVudEJlaW5nUmVuZGVyZWQoKTtcblx0dmFyIG93bmVyID0gb3B0X293bmVyIHx8IHBhcmVudDtcblxuXHRpbmhlcml0RWxlbWVudENsYXNzZXNfKHBhcmVudCwgY29uZmlnKTtcblxuXHR2YXIgY29tcCA9IGdldFN1YkNvbXBvbmVudF8odGFnT3JDdG9yLCBjb25maWcsIG93bmVyKTtcblx0dXBkYXRlQ29udGV4dF8oY29tcCwgcGFyZW50KTtcblxuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wKTtcblx0ZGF0YS5wYXJlbnQgPSBwYXJlbnQ7XG5cdGRhdGEub3duZXIgPSBvd25lcjtcblxuXHR2YXIgcGFyZW50RGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShwYXJlbnQpO1xuXHRnZXRDaGlsZENvbXBvbmVudHNfKHBhcmVudERhdGEpLnB1c2goY29tcCk7XG5cdGlmICghY29uZmlnLmtleSAmJiAhcGFyZW50RGF0YS5yb290RWxlbWVudFJlYWNoZWQpIHtcblx0XHRjb25maWcua2V5ID0gcGFyZW50RGF0YS5jb25maWcua2V5O1xuXHR9XG5cblx0Y29tcC5nZXRSZW5kZXJlcigpLnJlbmRlckluc2lkZVBhdGNoKGNvbXApO1xuXHRpZiAoIWNvbXAud2FzUmVuZGVyZWQpIHtcblx0XHRjb21wLnJlbmRlckNvbXBvbmVudCgpO1xuXHR9XG5cdHJldHVybiBjb21wO1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gaW5jcmVtZW50YWwgZG9tIGRhdGEgb2JqZWN0LCBwcmVwYXJpbmcgaXQgZm9yIHRoZSBuZXh0IHBhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb21wb25lbnRzRGF0YV8oZGF0YSkge1xuXHRpZiAoZGF0YSkge1xuXHRcdGRhdGEucHJldkNvbXBzID0gZGF0YS5jdXJyQ29tcHM7XG5cdFx0ZGF0YS5jdXJyQ29tcHMgPSBudWxsO1xuXHRcdGRhdGEuY3VyckNvdW50ID0gbnVsbDtcblx0fVxufVxuLyoqXG4gKiBSZXNldHMgYWxsIGRhdGEgc3RvcmVkIGluIHRoZSBnaXZlbiBub2RlLlxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXROb2RlRGF0YV8obm9kZSkge1xuXHRpZiAoX21ldGFsRG9tLmRvbURhdGEuaGFzKG5vZGUpKSB7XG5cdFx0cmVzZXRDb21wb25lbnRzRGF0YV8oX21ldGFsRG9tLmRvbURhdGEuZ2V0KG5vZGUpLmljQ29tcG9uZW50c0RhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZ2l2ZW4gY29tcG9uZW50J3MgY29udGV4dCBhY2NvcmRpbmcgdG8gdGhlIGRhdGEgZnJvbSB0aGVcbiAqIGNvbXBvbmVudCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcFxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Xyhjb21wLCBwYXJlbnQpIHtcblx0dmFyIGNvbnRleHQgPSBjb21wLmNvbnRleHQ7XG5cdHZhciBjaGlsZENvbnRleHQgPSBwYXJlbnQuZ2V0Q2hpbGRDb250ZXh0ID8gcGFyZW50LmdldENoaWxkQ29udGV4dCgpIDogbnVsbDtcblx0X21ldGFsLm9iamVjdC5taXhpbihjb250ZXh0LCBwYXJlbnQuY29udGV4dCwgY2hpbGRDb250ZXh0KTtcblx0Y29tcC5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgcmVuZGVyZXIncyBjb21wb25lbnQncyBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHZhbHVlcywgdW5sZXNzXG4gKiBpdCBoYXMgYWxyZWFkeSBiZWVuIHJlYWNoZWQgYnkgYW4gZWFybGllciBjYWxsLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRJZk5vdFJlYWNoZWRfKGNvbXBvbmVudCwgbm9kZSkge1xuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRpZiAoIWRhdGEucm9vdEVsZW1lbnRSZWFjaGVkKSB7XG5cdFx0ZGF0YS5yb290RWxlbWVudFJlYWNoZWQgPSB0cnVlO1xuXHRcdGlmIChjb21wb25lbnQuZWxlbWVudCAhPT0gbm9kZSkge1xuXHRcdFx0Y29tcG9uZW50LmVsZW1lbnQgPSBub2RlO1xuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL3JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgY29yZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gY29yZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgY29yZSk7XG5cdH1cblxuXHQvKipcbiAgKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICAqIEZvby5wcm90b3R5cGUuYmFyID0gY29yZS5hYnN0cmFjdE1ldGhvZFxuICAqXG4gICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAgKlxuICAqIEB0eXBlIHshRnVuY3Rpb259XG4gICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICAqL1xuXHRjb3JlLmFic3RyYWN0TWV0aG9kID0gZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH07XG5cblx0LyoqXG4gICogTG9vcHMgY29uc3RydWN0b3Igc3VwZXIgY2xhc3NlcyBjb2xsZWN0aW5nIGl0cyBwcm9wZXJ0aWVzIHZhbHVlcy4gSWZcbiAgKiBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzdXBlciBjbGFzcyBgdW5kZWZpbmVkYCB3aWxsIGJlXG4gICogY29sbGVjdGVkIGFzIHZhbHVlIGZvciB0aGUgY2xhc3MgaGllcmFyY2h5IHBvc2l0aW9uLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGNvbnN0cnVjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG4gICogQHJldHVybiB7QXJyYXkuPCo+fSBBcnJheSBvZiBjb2xsZWN0ZWQgdmFsdWVzLlxuICAqIFRPRE8oKik6IFJldGhpbmsgc3VwZXJjbGFzcyBsb29wLlxuICAqL1xuXG5cblx0Y29yZS5jb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkgPSBmdW5jdGlvbiBjb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuXHRcdHZhciBwcm9wZXJ0eVZhbHVlcyA9IFtjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdXTtcblx0XHR3aGlsZSAoY29uc3RydWN0b3IuX19wcm90b19fICYmICFjb25zdHJ1Y3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcblx0XHRcdGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3IuX19wcm90b19fO1xuXHRcdFx0cHJvcGVydHlWYWx1ZXMucHVzaChjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb3BlcnR5VmFsdWVzO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAgKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICAqIGNvbnRlbnQgc3RyaW5nLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gICogQHJldHVybiB7c3RyaW5nfVxuICAqL1xuXG5cblx0Y29yZS5nZXRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0XHRpZiAoIWZuLm5hbWUpIHtcblx0XHRcdHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuXHRcdFx0Zm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmbi5uYW1lO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAgKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICAqIHJldHVybnMuIFNlZSB7QGxpbmsgY29yZS5VSURfUFJPUEVSVFl9LlxuICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAgKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAgKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gICovXG5cblxuXHRjb3JlLmdldFVpZCA9IGZ1bmN0aW9uIGdldFVpZChvcHRfb2JqZWN0LCBvcHRfbm9Jbmhlcml0YW5jZSkge1xuXHRcdGlmIChvcHRfb2JqZWN0KSB7XG5cdFx0XHR2YXIgaWQgPSBvcHRfb2JqZWN0W2NvcmUuVUlEX1BST1BFUlRZXTtcblx0XHRcdGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShjb3JlLlVJRF9QUk9QRVJUWSkpIHtcblx0XHRcdFx0aWQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W2NvcmUuVUlEX1BST1BFUlRZXSA9IGNvcmUudW5pcXVlSWRDb3VudGVyXysrKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmUudW5pcXVlSWRDb3VudGVyXysrO1xuXHR9O1xuXG5cdC8qKlxuICAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAgKi9cblxuXG5cdGNvcmUuaWRlbnRpdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG5cdFx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gICovXG5cblxuXHRjb3JlLmlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gICovXG5cblxuXHRjb3JlLmlzRGVmID0gZnVuY3Rpb24gaXNEZWYodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gICogQHBhcmFtIHsqfSB2YWxcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuXG5cblx0Y29yZS5pc0RlZkFuZE5vdE51bGwgPSBmdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWYodmFsKSAmJiAhY29yZS5pc051bGwodmFsKTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzRG9jdW1lbnQgPSBmdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gICogQHBhcmFtIHsqfSB2YWxcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuXG5cblx0Y29yZS5pc0VsZW1lbnQgPSBmdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICAqL1xuXG5cblx0Y29yZS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcblx0XHRyZXR1cm4gdmFsID09PSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAgKi9cblxuXG5cdGNvcmUuaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICAqIEBwYXJhbSB7Kn0gdmFsXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cblxuXG5cdGNvcmUuaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gICogYW5kIGZ1bmN0aW9ucy5cbiAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICAqL1xuXG5cblx0Y29yZS5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcblx0XHRyZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xuXHR9O1xuXG5cdC8qKlxuICAqIE1lcmdlcyB0aGUgdmFsdWVzIG9mIGEgc3RhdGljIHByb3BlcnR5IGEgY2xhc3Mgd2l0aCB0aGUgdmFsdWVzIG9mIHRoYXRcbiAgKiBwcm9wZXJ0eSBmb3IgYWxsIGl0cyBzdXBlciBjbGFzc2VzLCBhbmQgc3RvcmVzIGl0IGFzIGEgbmV3IHN0YXRpY1xuICAqIHByb3BlcnR5IG9mIHRoYXQgY2xhc3MuIElmIHRoZSBzdGF0aWMgcHJvcGVydHkgYWxyZWFkeSBleGlzdGVkLCBpdCB3b24ndFxuICAqIGJlIHJlY2FsY3VsYXRlZC5cbiAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgY29sbGVjdGVkLlxuICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYW4gYXJyYXkgZmlsbGVkXG4gICogICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgY3VycmVudCBjbGFzcyBhbmQgYWxsIGl0cyBzdXBlciBjbGFzc2VzLlxuICAqICAgU2hvdWxkIHJldHVybiB0aGUgbWVyZ2VkIHZhbHVlIHRvIGJlIHN0b3JlZCBvbiB0aGUgY3VycmVudCBjbGFzcy5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgbWVyZ2UgaGFwcGVucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuXG5cblx0Y29yZS5tZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5ID0gZnVuY3Rpb24gbWVyZ2VTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuXHRcdHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuXHRcdGlmIChjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBtZXJnZWQgPSBjb3JlLmNvbGxlY3RTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKTtcblx0XHRpZiAob3B0X21lcmdlRm4pIHtcblx0XHRcdG1lcmdlZCA9IG9wdF9tZXJnZUZuKG1lcmdlZCk7XG5cdFx0fVxuXHRcdGNvbnN0cnVjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuICAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAgKi9cblxuXG5cdGNvcmUubnVsbEZ1bmN0aW9uID0gZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge307XG5cblx0cmV0dXJuIGNvcmU7XG59KCk7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5jb3JlLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvcmUudW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9zY3NzL2FwcC5zY3NzJztcbmltcG9ydCBNZXRhbEZvcm0gZnJvbSAnLi9jb21wb25lbnRzL01ldGFsRm9ybS9NZXRhbEZvcm0nO1xuaW1wb3J0IERyb3Bkb3duIGZyb20gJy4vY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93bic7XG5pbXBvcnQgQ2FsY3VsYXRvciBmcm9tICcuL2NvbXBvbmVudHMvQ2FsY3VsYXRvci9DYWxjdWxhdG9yJztcbmltcG9ydCBDYWxjdWxhdG9yQnV0dG9uIGZyb20gJy4vY29tcG9uZW50cy9DYWxjdWxhdG9yQnV0dG9uL0NhbGN1bGF0b3JCdXR0b24nO1xuXG5uZXcgTWV0YWxGb3JtKHtcblx0ZW5kcG9pbnQ6ICdodHRwOi8vbG9jYWxob3N0OjMxMDAvY2FsY3VsYXRvcidcbn0pO1xuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHAuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHAuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHAuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2Nzcy9hcHAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PU9wZW4rU2Fucyk7XCIsIFwiXCJdKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJodG1sLCBib2R5LCBkaXYsIHNwYW4sIGFwcGxldCwgb2JqZWN0LCBpZnJhbWUsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIGJsb2NrcXVvdGUsIHByZSwgYSwgYWJiciwgYWNyb255bSwgYWRkcmVzcywgYmlnLCBjaXRlLCBjb2RlLCBkZWwsIGRmbiwgZW0sIGltZywgaW5zLCBrYmQsIHEsIHMsIHNhbXAsIHNtYWxsLCBzdHJpa2UsIHN0cm9uZywgc3ViLCBzdXAsIHR0LCB2YXIsIGIsIHUsIGksIGNlbnRlciwgZGwsIGR0LCBkZCwgb2wsIHVsLCBsaSwgZmllbGRzZXQsIGZvcm0sIGxhYmVsLCBsZWdlbmQsIHRhYmxlLCBjYXB0aW9uLCB0Ym9keSwgdGZvb3QsIHRoZWFkLCB0ciwgdGgsIHRkLCBhcnRpY2xlLCBhc2lkZSwgY2FudmFzLCBkZXRhaWxzLCBlbWJlZCwgZmlndXJlLCBmaWdjYXB0aW9uLCBmb290ZXIsIGhlYWRlciwgaGdyb3VwLCBtZW51LCBuYXYsIG91dHB1dCwgcnVieSwgc2VjdGlvbiwgc3VtbWFyeSwgdGltZSwgbWFyaywgYXVkaW8sIHZpZGVvIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3JkZXI6IDA7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICBmb250OiBpbmhlcml0O1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuXFxuLyogSFRNTDUgZGlzcGxheS1yb2xlIHJlc2V0IGZvciBvbGRlciBicm93c2VycyAqL1xcbmFydGljbGUsIGFzaWRlLCBkZXRhaWxzLCBmaWdjYXB0aW9uLCBmaWd1cmUsIGZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiB7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbmJvZHkge1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cXG5vbCwgdWwge1xcbiAgbGlzdC1zdHlsZTogbm9uZTsgfVxcblxcbmJsb2NrcXVvdGUsIHEge1xcbiAgcXVvdGVzOiBub25lOyB9XFxuXFxuYmxvY2txdW90ZTpiZWZvcmUsIGJsb2NrcXVvdGU6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBjb250ZW50OiBub25lOyB9XFxuXFxucTpiZWZvcmUsIHE6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBjb250ZW50OiBub25lOyB9XFxuXFxudGFibGUge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwOyB9XFxuXFxuKiwgKjphZnRlciwgKjpiZWZvcmUge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcblxcbmJvZHkge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJPcGVuIFNhbnNcXFwiO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgYmFja2dyb3VuZDogI2ZhZmFmYTsgfVxcbiAgYm9keTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiA0MjFweDtcXG4gICAgYmFja2dyb3VuZDogIzNlOWNmYztcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwOyB9XFxuXFxuaHRtbCwgYm9keSB7XFxuICBoZWlnaHQ6IDEwMCU7IH1cXG5cXG5hIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcblxcbi53cmFwcGVyIHtcXG4gIHBhZGRpbmctdG9wOiA1NnB4O1xcbiAgbWluLWhlaWdodDogY2FsYygxMDAlIC0gMTY4cHgpO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLmNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiAwIDIwcHg7XFxuICBtYXgtd2lkdGg6IDEyODBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luOiAwIGF1dG87IH1cXG4gIC5jb250YWluZXI6YWZ0ZXIge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmb250LXNpemU6IDA7XFxuICAgIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG4gICAgY2xlYXI6IGJvdGg7XFxuICAgIGhlaWdodDogMDsgfVxcblxcbmZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvciB7XFxuICBjb2xvcjogI2QwMDIxYjtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjA4LCAxLCAyNywgMC4yKTsgfVxcbiAgZm9ybS5sb2FuLWZvcm0gZmllbGRzZXQgLmlucHV0LWVycm9yOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICNkMDAyMWI7IH1cXG4gIGZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvcjotbW96LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICNkMDAyMWI7IH1cXG4gIGZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvcjo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjZDAwMjFiOyB9XFxuICBmb3JtLmxvYW4tZm9ybSBmaWVsZHNldCAuaW5wdXQtZXJyb3I6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICNkMDAyMWI7IH1cXG4gIGZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvcjphY3RpdmUge1xcbiAgICBib3JkZXItY29sb3I6ICNkMDAyMWI7IH1cXG5cXG5idXR0b246aG92ZXIsIGJ1dHRvbjpmb2N1cywgYnV0dG9uOmFjdGl2ZSwgYTpob3ZlciwgYTpmb2N1cywgYTphY3RpdmUsIGlucHV0OmhvdmVyLCBpbnB1dDpmb2N1cywgaW5wdXQ6YWN0aXZlIHtcXG4gIG91dGxpbmU6IG5vbmU7IH1cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDM4cHg7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA0NnB4OyB9XFxuICBoMSBzbWFsbCB7XFxuICAgIG1hcmdpbi10b3A6IDM1cHg7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIGZvbnQtd2VpZ2h0OiAzMDA7IH1cXG5cXG4uc2l0ZS1mb290ZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEyOHB4O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1vei1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXg7XFxuICBkaXNwbGF5OiAtby1mbGV4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIGNvbG9yOiAjOWI5YjliO1xcbiAgYmFja2dyb3VuZDogI2ZmZmZmZjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYm90dG9tOiAtMTY4cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7IH1cXG5cXG4uZHJvcGRvd24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZm9udC1zaXplOiAxNHB4OyB9XFxuICAuZHJvcGRvd24gLmRyb3Bkb3duLWRpc3BsYXkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5kcm9wZG93biAuZHJvcGRvd24tbGlzdC13cmFwcGVyIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHRvcDogNDBweDtcXG4gICAgYm94LXNoYWRvdzogMCAycHggMTRweCAwIHJnYmEoOTcsIDE0OSwgMjM3LCAwLjEpO1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjZTRlOWVjO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDU7XFxuICAgIGJhY2tncm91bmQ6ICNmZmY7IH1cXG4gICAgLmRyb3Bkb3duIC5kcm9wZG93bi1saXN0LXdyYXBwZXIgaW5wdXQge1xcbiAgICAgIGJhY2tncm91bmQ6IG5vLXJlcGVhdCA1cHggY2VudGVyIHRyYW5zcGFyZW50IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lQejROQ2p3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krRFFvOGMzWm5JSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIWmxjbk5wYjI0OUlqRXVNU0lnSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajROQ2lBZ0lEeHdZWFJvSUdacGJHdzlJaU13TURBd01EQWlJR1E5SWswNUxqVXNNMEUyTGpVc05pNDFJREFnTUN3eElERTJMRGt1TlVNeE5pd3hNUzR4TVNBeE5TNDBNU3d4TWk0MU9TQXhOQzQwTkN3eE15NDNNMHd4TkM0M01Td3hORWd4TlM0MVRESXdMalVzTVRsTU1Ua3NNakF1TlV3eE5Dd3hOUzQxVmpFMExqY3hUREV6TGpjekxERTBMalEwUXpFeUxqVTVMREUxTGpReElERXhMakV4TERFMklEa3VOU3d4TmtFMkxqVXNOaTQxSURBZ01Dd3hJRE1zT1M0MVFUWXVOU3cyTGpVZ01DQXdMREVnT1M0MUxETk5PUzQxTERWRE55dzFJRFVzTnlBMUxEa3VOVU0xTERFeUlEY3NNVFFnT1M0MUxERTBRekV5TERFMElERTBMREV5SURFMExEa3VOVU14TkN3M0lERXlMRFVnT1M0MUxEVmFJaUF2UGcwS1BDOXpkbWMrXFxcIik7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAzOHB4O1xcbiAgICAgIHBhZGRpbmctdG9wOiA5cHg7XFxuICAgICAgcGFkZGluZy1ib3R0b206IDEycHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgICAgIC5kcm9wZG93biAuZHJvcGRvd24tbGlzdC13cmFwcGVyIGlucHV0LCAuZHJvcGRvd24gLmRyb3Bkb3duLWxpc3Qtd3JhcHBlciBpbnB1dDpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlNGU5ZWM7IH1cXG4gIC5kcm9wZG93biAuYXJyb3dfYm94IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBiYWNrZ3JvdW5kOiAjODY5Y2FlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiAxMnB4O1xcbiAgICB6LWluZGV4OiAyO1xcbiAgICBoZWlnaHQ6IDRweDtcXG4gICAgdG9wOiAxOXB4OyB9XFxuICAgIC5kcm9wZG93biAuYXJyb3dfYm94OmFmdGVyIHtcXG4gICAgICBib3R0b206IDEwMCU7XFxuICAgICAgbGVmdDogNTAlO1xcbiAgICAgIGJvcmRlcjogc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgICAgIGhlaWdodDogMDtcXG4gICAgICB3aWR0aDogMDtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogIzg2OWNhZTtcXG4gICAgICBib3JkZXItd2lkdGg6IDRweDtcXG4gICAgICBtYXJnaW4tbGVmdDogLTRweDsgfVxcbiAgICAuZHJvcGRvd24gLmFycm93X2JveDpiZWZvcmUge1xcbiAgICAgIHRvcDogMTAwJTtcXG4gICAgICBsZWZ0OiA1MCU7XFxuICAgICAgYm9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG4gICAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgIHdpZHRoOiAwO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgICBib3JkZXItdG9wLWNvbG9yOiAjODY5Y2FlO1xcbiAgICAgIGJvcmRlci13aWR0aDogNHB4O1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4OyB9XFxuXFxuLmJveC1jYWxjdWxhdG9yIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGZsZXg6IDEgMCAyMDJweDtcXG4gIG1hcmdpbjogMCA2NXB4IDAgMDsgfVxcbiAgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWRpc3BsYXkge1xcbiAgICB3aWR0aDogMjAycHg7XFxuICAgIGhlaWdodDogNTZweDtcXG4gICAgcGFkZGluZzogMjFweCAxNnB4IDA7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIGJhY2tncm91bmQ6ICNlYWYwZjM7IH1cXG4gIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b25zLXdyYXBwZXIge1xcbiAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICAgIGRpc3BsYXk6IC1tb3otZmxleDtcXG4gICAgZGlzcGxheTogLW1zLWZsZXg7XFxuICAgIGRpc3BsYXk6IC1vLWZsZXg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIHdpZHRoOiAyMDJweDtcXG4gICAgbWFyZ2luLXRvcDogMTBweDsgfVxcbiAgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWRpZ2l0cyB7XFxuICAgIHdpZHRoOiAxNDRweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4OyB9XFxuICAuYm94LWNhbGN1bGF0b3IgLmNhbGN1bGF0b3Itb3BlcmF0b3JzIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICB3aWR0aDogNDdweDsgfVxcbiAgICAuYm94LWNhbGN1bGF0b3IgLmNhbGN1bGF0b3Itb3BlcmF0b3JzIC5jYWxjdWxhdG9yLWJ1dHRvbiwgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLW9wZXJhdG9ycyAuY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b24sIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB3aWR0aDogNDdweDtcXG4gICAgaGVpZ2h0OiA0N3B4O1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgbWFyZ2luOiAwIDFweCAxcHggMDtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDYyLCAxNTYsIDI1MiwgMC4zKTtcXG4gICAgY29sb3I6ICMzZTljZmM7IH1cXG4gICAgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWJ1dHRvbjpob3ZlciwgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWJ1dHRvbi0tZG91YmxlLXNpemU6aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQ6IHJnYmEoNjIsIDE1NiwgMjUyLCAwLjQ1KTsgfVxcbiAgICAuYm94LWNhbGN1bGF0b3IgLmNhbGN1bGF0b3ItYnV0dG9uOmFjdGl2ZSwgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWJ1dHRvbi0tZG91YmxlLXNpemU6YWN0aXZlIHtcXG4gICAgICBiYWNrZ3JvdW5kOiByZ2JhKDYyLCAxNTYsIDI1MiwgMC41NSk7IH1cXG4gIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplIHtcXG4gICAgd2lkdGg6IDk1cHg7IH1cXG5cXG4ubG9hbi1mb3JtIHtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwYWRkaW5nOiA2MXB4IDY1cHg7XFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICBib3gtc2hhZG93OiAwIDAgMjBweCAwIHJnYmEoMCwgNSwgNjEsIDAuMSk7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbW96LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleDtcXG4gIGRpc3BsYXk6IC1vLWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBpbml0aWFsO1xcbiAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xcbiAgbWFyZ2luOiAwIGF1dG8gMTIycHg7XFxuICBtYXgtd2lkdGg6IDY4OHB4O1xcbiAgZmxleC13cmFwOiB3cmFwOyB9XFxuXFxuLmJveC1sb2FuLW9wdGlvbnMge1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1vei1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXg7XFxuICBkaXNwbGF5OiAtby1mbGV4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcXG4gIGZsZXg6IDEgMCAyOTBweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTsgfVxcbiAgLmJveC1sb2FuLW9wdGlvbnMgaW5wdXQsIC5ib3gtbG9hbi1vcHRpb25zIGxhYmVsLCAuYm94LWxvYW4tb3B0aW9ucyBidXR0b24ge1xcbiAgICB3aWR0aDogMTAwJTsgfVxcbiAgLmJveC1sb2FuLW9wdGlvbnMgLmNhbGN1bGF0ZS1pbnRlcmVzdCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgbWFyZ2luLXRvcDogLTNweDtcXG4gICAgdHJhbnNpdGlvbjogZWFzZS1vdXQgLjNzIGFsbDtcXG4gICAgYm94LXNoYWRvdzogaW5zZXQgMCAwIDAgIzNlOWNmYzsgfVxcbiAgICAuYm94LWxvYW4tb3B0aW9ucyAuY2FsY3VsYXRlLWludGVyZXN0OmhvdmVyIHtcXG4gICAgICBib3gtc2hhZG93OiBpbnNldCAwIDUwcHggMCAjM2U5Y2ZjO1xcbiAgICAgIGNvbG9yOiAjZmZmOyB9XFxuICAuYm94LWxvYW4tb3B0aW9ucyAuZ2V0LXF1b3Qge1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbWF4LXdpZHRoOiAyOTBweDtcXG4gICAgYm90dG9tOiAwOyB9XFxuICAuYm94LWxvYW4tb3B0aW9ucyAjaW5wdXQtdG90YWwge1xcbiAgICBtYXJnaW4tYm90dG9tOiAyNnB4OyB9XFxuXFxuaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJhY2tncm91bmQ6ICNlYWYwZjM7XFxuICBwYWRkaW5nOiAxMXB4IDEwcHg7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgY29sb3I6ICMzOTUzNmM7XFxuICBib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDsgfVxcbiAgaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6IHJnYmEoMTM0LCAxNTYsIDE3MywgMC41KTsgfVxcbiAgaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdOi1tb3otcGxhY2Vob2xkZXIge1xcbiAgICBjb2xvcjogcmdiYSgxMzQsIDE1NiwgMTczLCAwLjUpOyB9XFxuICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl06Oi1tb3otcGxhY2Vob2xkZXIge1xcbiAgICBjb2xvcjogcmdiYSgxMzQsIDE1NiwgMTczLCAwLjUpOyB9XFxuICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl06LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6IHJnYmEoMTM0LCAxNTYsIDE3MywgMC41KTsgfVxcbiAgaW5wdXRbdHlwZT1cXFwidGV4dFxcXCJdOmZvY3VzIHtcXG4gICAgYm9yZGVyLWNvbG9yOiAjNjViNGYwOyB9XFxuXFxuLndhcm5pbmctbGFiZWwge1xcbiAgZm9udC1zaXplOiAxMi41cHg7XFxuICBtYXJnaW4tdG9wOiA2cHg7XFxuICBsaW5lLWhlaWdodDogMTZweDtcXG4gIGNvbG9yOiAjZDAwMjFiO1xcbiAgZGlzcGxheTogbm9uZTsgfVxcbiAgLndhcm5pbmctbGFiZWwgaSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcblxcbi5kcm9wZG93biAuZHJvcGRvd24tbGlzdC13cmFwcGVyLnNob3csIC53YXJuaW5nLWxhYmVsLnNob3cge1xcbiAgZGlzcGxheTogYmxvY2s7IH1cXG5cXG5sYWJlbCB7XFxuICBtYXJnaW4tYm90dG9tOiAyN3B4OyB9XFxuICBsYWJlbDphZnRlciB7XFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICAgIGZvbnQtc2l6ZTogMDtcXG4gICAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgICBjbGVhcjogYm90aDtcXG4gICAgaGVpZ2h0OiAwOyB9XFxuICBsYWJlbCAuY2FwdGlvbiB7XFxuICAgIGNvbG9yOiAjNGE0YTRhO1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDZweDtcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXG4gIGxhYmVsIC5tYW5kYXRvcnktc2lnbiB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbiAgICBjb2xvcjogI2Y1OTg0YzsgfVxcblxcbi5idXR0b24sIC5idXR0b24tLWZpbGxlZCB7XFxuICBjb2xvcjogIzMwOGZmZjtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBiYWNrZ3JvdW5kOiAjZmZmZmZmO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICMzMDhmZmY7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7IH1cXG4gIC5idXR0b25bZGlzYWJsZWRdLCBbZGlzYWJsZWRdLmJ1dHRvbi0tZmlsbGVkIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzcyODY5NDtcXG4gICAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudDsgfVxcblxcbi5idXR0b24tLWZpbGxlZCB7XFxuICBiYWNrZ3JvdW5kOiAjMzA4ZmZmO1xcbiAgY29sb3I6ICNmZmZmZmY7IH1cXG5cXG4uZHJvcGRvd24tbGlzdC1pdGVtLCAuZHJvcGRvd24tbGlzdC1pdGVtOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHBhZGRpbmc6IDEwcHg7IH1cXG4gIC5kcm9wZG93bi1saXN0LWl0ZW06aG92ZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjZjhmYWZhOyB9XFxuICAuZHJvcGRvd24tbGlzdC1pdGVtW2RhdGEtc2VsZWN0ZWRdIHtcXG4gICAgY29sb3I6ICMzMjlkZTY7IH1cXG5cXG4uc3VibWl0LWxhYmVsIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIGJvdHRvbTogNDVweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgY29sb3I6ICNmZmY7XFxuICBiYWNrZ3JvdW5kOiAjM2U5Y2ZjO1xcbiAgcGFkZGluZzogMC41cmVtO1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgb3BhY2l0eTogMDtcXG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMHB4KTtcXG4gIHotaW5kZXg6IDI7XFxuICB0cmFuc2l0aW9uOiBhbGwgLjNzIGVhc2UtaW4tb3V0OyB9XFxuICAuc3VibWl0LWxhYmVsOmJlZm9yZSB7XFxuICAgIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgYm9yZGVyOiBzb2xpZCA3cHggdHJhbnNwYXJlbnQ7XFxuICAgIGJvcmRlci10b3AtY29sb3I6ICMzZTljZmM7XFxuICAgIHdpZHRoOiAwO1xcbiAgICBoZWlnaHQ6IDA7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgYm90dG9tOiAtMTFweDtcXG4gICAgbGVmdDogNTAlO1xcbiAgICBtYXJnaW4tbGVmdDogLTEwcHg7IH1cXG4gIC5zdWJtaXQtbGFiZWwuZGFuZ2VyIHtcXG4gICAgYmFja2dyb3VuZDogI2JlMDAwMDsgfVxcbiAgICAuc3VibWl0LWxhYmVsLmRhbmdlcjpiZWZvcmUge1xcbiAgICAgIGJvcmRlci10b3AtY29sb3I6ICNiZTAwMDA7IH1cXG4gIC5zdWJtaXQtbGFiZWwuc2hvdy1tZXNzYWdlIHtcXG4gICAgb3BhY2l0eTogMTtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9saWIvbG9hZGVyLmpzIS4vc3JjL3Njc3MvYXBwLnNjc3Ncbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvdXJscy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgdGVtcGxhdGVzIGZyb20gJy4vTWV0YWxGb3JtLnNveS5qcyc7XG5pbXBvcnQgY29yZSBmcm9tICdtZXRhbCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uLy4uL1V0aWxzL0V2ZW50RW1pdHRlcic7XG5cbmNsYXNzIE1ldGFsRm9ybSBleHRlbmRzIENvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBNZXRhbEZvcm0gY29tcG9uZW50XG5cdCAqL1xuXHRjcmVhdGVkKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGluc3RhbmNlLkFwcGxpY2F0aW9uRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0XHRpbnN0YW5jZS5BcHBsaWNhdGlvbkVtaXR0ZXIub24oJ0xJU1RFTl9EUk9QRE9XTl9FVkVOVCcsIGRhdGEgPT4gaW5zdGFuY2UuZHJvcGRvd25EYXRhID0gZGF0YSk7XG5cdFx0aW5zdGFuY2UuQXBwbGljYXRpb25FbWl0dGVyLm9uKCdMSVNURU5fQ0FMQ1VMQVRPUl9FVkVOVCcsIGRhdGEgPT4gaW5zdGFuY2UuY2FsY3VsYXRvckRhdGEgPSBkYXRhKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgZm9ybSBkZWZhdWx0IGJlaGF2aW9yXG5cdCAqIFNldCBib2R5IGV2ZW50IHRvIHZlcmlmeSB0aGUgYnV0dG9uIHNob3cgbWVzc2FnZVxuXHQgKi9cblx0YXR0YWNoZWQoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdFxuXHRcdGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignZm9ybScpLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKTtcblx0XHRcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSk9PiB7XG5cdFx0XHRpZihlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2dldC1xdW90JykpIHJldHVyblxuXHRcdFx0aW5zdGFuY2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuc3VibWl0LWxhYmVsJykuY2xhc3NMaXN0LnJlbW92ZSgnc2hvdy1tZXNzYWdlJyk7XG5cdFx0fSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBoYXMgb3BlcmF0b3JzIGluIHRoZSBjYWxjdWxhdG9yIGRpc3BsYXlcblx0ICogQHBhcmFtIHtTcmluZ30gdGV4dFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0NhbGN1bGF0b3JPcGVyYXRvcnModGV4dCl7XG5cdFx0cmV0dXJuIC9bKCkrXFwtLypdLy50ZXN0KHRleHQpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgaGFzIGVycm9yIGluIHRoZSBmb3JtXG5cdCAqIEByZXR1cm5zIHtib29sZWFuIHx8IG51bGx9XG5cdCAqL1xuXHRoYXNFcnJvckluVGhlRm9ybSgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXMsXG5cdFx0XHRcdGVycjtcblx0XHRcblx0XHRpZighaW5zdGFuY2UuY2hlY2tEcm9wZG93bkRhdGEoKSkgZXJyID0gdHJ1ZTtcblx0XHRpZighaW5zdGFuY2UuY2hlY2tDYWxjdWxhdG9yRGF0YSgpKSBlcnIgPSB0cnVlO1xuXHRcdFxuXHRcdHJldHVybiBpbnN0YW5jZS5lcnJvciA9IGVycjtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENhbGN1bGF0ZSB0aGUgZm9ybSB1c2luZyB0aGUgY29tcG91bmQgaW50ZXJlc3QgZm9ybXVsYVxuXHQgKiBhbmQgc2hvdyB0aGUgcmVzdWx0IGluIHRoZSB0b3RhbCBpbnB1dFxuXHQgKi9cblx0Y2FsY3VsYXRlRm9ybSgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cblx0XHRpZihpbnN0YW5jZS5oYXNFcnJvckluVGhlRm9ybSgpKSByZXR1cm47XG5cdFx0XG5cdFx0aW5zdGFuY2UuZGVidCA9IGluc3RhbmNlLmNhbGN1bGF0ZURlYnQoe1xuXHRcdFx0YW1vdW50OiBpbnN0YW5jZS5jYWxjdWxhdG9yRGF0YSxcblx0XHRcdGludGVyZXN0OiBpbnN0YW5jZS5kcm9wZG93bkRhdGEuaW50ZXJlc3QsXG5cdFx0XHRtb250aHM6IGluc3RhbmNlLmRyb3Bkb3duRGF0YS5tb250aHNcblx0XHR9KTtcblxuXHRcdGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignI2lucHV0LXRvdGFsJykucGxhY2Vob2xkZXIgPSBgUiQ6ICR7aW5zdGFuY2UuZGVidH1gO1xuXHRcdGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLmdldC1xdW90JykucmVtb3ZlQXR0cmlidXRlKCdkaXNhYmxlZCcpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSBkZWJpdCB1c2luZyB0aGUgY29tcG91bmQgaW50ZXJlc3QgZm9ybXVsYVxuXHQgKiBAcmV0dXJucyB7IHN0cmluZyB9XG5cdCAqL1xuXHRjYWxjdWxhdGVEZWJ0KHthbW91bnQsIGludGVyZXN0LCBtb250aHN9KXtcblx0XHRsZXQgcmVzdWx0O1xuXHRcdGludGVyZXN0ID0gaW50ZXJlc3QgLyAxMDA7XG5cdFx0cmVzdWx0ID0gKGFtb3VudCAqIE1hdGgucG93KDEgKyBpbnRlcmVzdCwgbW9udGhzKSkudG9Mb2NhbGVTdHJpbmcoJ3B0LUJSJyk7XG5cdFx0XG5cdFx0aWYocmVzdWx0LnNwbGl0KCcsJylbMV0ubGVuZ3RoID4gMikgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigwLCByZXN1bHQubGVuZ3RoLTEpO1xuXHRcdFxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgZHJvcGRvd24gaGFzIGl0ZW0gc2VsZWN0ZWRcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRjaGVja0Ryb3Bkb3duRGF0YSgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXMsXG5cdFx0XHRcdGlzVmFsaWQgPSB0cnVlO1xuXHRcdFxuXHRcdGlmKCFpbnN0YW5jZS5kcm9wZG93bkRhdGEpe1xuXHRcdFx0aW5zdGFuY2UuQXBwbGljYXRpb25FbWl0dGVyLmVtaXQoJ0xJU1RFTl9EUk9QRE9XTl9FUlJPUicsICdQbGVhc2UsIHNlbGVjdCBhbiBpdGVtIG9mIHRoZSBkcm9wZG93bicpO1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gaXNWYWxpZDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBjYWxjdWxhdG9yIGhhcyBqdXN0IG51bWJlcnMgKGludGVnZXJzIG9yIGZsb2F0cylcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRjaGVja0NhbGN1bGF0b3JEYXRhKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcyxcblx0XHRcdGRhdGEgPSBpbnN0YW5jZS5jYWxjdWxhdG9yRGF0YSxcblx0XHRcdGlzVmFsaWQgPSB0cnVlO1xuXHRcdFxuXHRcdGlmKGluc3RhbmNlLmhhc0NhbGN1bGF0b3JPcGVyYXRvcnMoZGF0YSkgfHwgIWRhdGEgfHwgIXBhcnNlRmxvYXQoZGF0YSkpe1xuXHRcdFx0aW5zdGFuY2UuQXBwbGljYXRpb25FbWl0dGVyLmVtaXQoJ0xJU1RFTl9DQUxDVUxBVE9SX0VSUk9SJywgXCJQbGVhc2UsIHR5cGUgYW4gZXhlcHJlc3Npb24gaW4geW91ciBjYWxjdWxhdG9yIGFuZCBjbGljayBpbiB0aGUgYnV0dG9uICc9J1wiKTtcblx0XHRcdGlzVmFsaWQgPSBmYWxzZTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIGlzVmFsaWQ7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZW5kIHRoZSBjb3VudCByZXN1bHRzIHRvIHRoZSBzZXJ2ZXJcblx0ICovXG5cdHN1Ym1pdEZvcm0oKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdGNvbnN0XHRkYXRhID0gSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0aW50ZXJlc3Q6IGluc3RhbmNlLmRyb3Bkb3duRGF0YS5pbnRlcmVzdCxcblx0XHRcdGxvYW46IGluc3RhbmNlLmNhbGN1bGF0b3JEYXRhLFxuXHRcdFx0bnVtYmVyT2ZNb250aHM6IGluc3RhbmNlLmRyb3Bkb3duRGF0YS5tb250aHMsXG5cdFx0XHR0b3RhbERlYnQ6IGluc3RhbmNlLmRlYnRcblx0XHR9KTtcblx0XHRcblx0XHRcblx0XHRmZXRjaChpbnN0YW5jZS5lbmRwb2ludCwge1xuXHRcdFx0bWV0aG9kOiBcIlBPU1RcIixcblx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0J0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonLFxuXHRcdFx0XHQnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG5cdFx0XHR9LFxuXHRcdFx0Ym9keTogZGF0YVxuXHRcdH0pLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcblx0XHRcdC50aGVuKCh7c3RhdHVzfSkgPT4gaW5zdGFuY2Uuc2hvd0Zvcm1NZXNzYWdlKHN0YXR1cykpXG5cdFx0XHQuY2F0Y2goZXJyID0+IGluc3RhbmNlLnNob3dGb3JtTWVzc2FnZShgc29tZXRoaW5nIHdyb25nLiBQbGVhc2UgY29udGFjdCB0aGUgYWRtaW5pc3RyYXRvci5gLCB0cnVlKSlcblx0fVxuXHRcblx0LyoqXG5cdCAqICBTaG93IGEgdml6dWFsIGZlZWRiYWNrIGluIHRoZSBmb3JtXG5cdCAqIEBwYXJhbSB7IFN0cmluZyB9IHRleHRcblx0ICogQHBhcmFtIHsgQm9vbGVhbiB9IGhhc0Vycm9yXG5cdCAqL1xuXHRzaG93Rm9ybU1lc3NhZ2UodGV4dCwgaGFzRXJyb3Ipe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0bGV0IGVsZW1lbnQgPSBpbnN0YW5jZS5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zdWJtaXQtbGFiZWwnKTtcblx0XHRcblx0XHRlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcblx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RhbmdlcicpO1xuXHRcdFxuXHRcdGlmKGhhc0Vycm9yKSBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2RhbmdlcicpO1xuXHRcdHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3ctbWVzc2FnZScpO1xuXHR9XG59XG5cblNveS5yZWdpc3RlcihNZXRhbEZvcm0sIHRlbXBsYXRlcyk7XG5cbi8qKlxuICogTWV0YWxGb3JtIFN0YXRlIERlZmluaXRpb25cbiAqL1xuTWV0YWxGb3JtLlNUQVRFID0ge1xuXHQvKipcblx0ICogVGhlIGVtaXR0ZXIgb2YgdGhlIGFwcGxpY2F0aW9uXG5cdCAqIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIG90aGVyIGNvbXBvbmVudHNcblx0ICovXG5cdEFwcGxpY2F0aW9uRW1pdHRlcjoge1xuXHRcdHZhbHVlOiBmYWxzZVxuXHR9LFxuXHQvKipcblx0ICogVGhlIHVzZXIgZGViaXQgY2FsY3VsYXRlZCBpbiB0aGlzIGNvbXBvbmVudFxuXHQgKi9cblx0ZGVidDoge1xuXHRcdHZhbHVlOiBudWxsXG5cdH0sXG5cdFxuXHQvKipcblx0ICogRXhwcmVzc2lvbiB0aGF0IGlzIGluIHRoZSBjYWxjdWxhdG9yIGRpc3BsYXlcblx0ICovXG5cdGNhbGN1bGF0b3JEYXRhOiB7XG5cdFx0dmFsdWU6IG51bGxcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBJdGVtIHNlbGVjdGVkIGluIHRoZSBkcm9wZG93biBjb21wb25lbnRcblx0ICovXG5cdGRyb3Bkb3duRGF0YToge1xuXHRcdHZhbHVlOiBudWxsXG5cdH0sXG5cdFxuXHQvKipcblx0ICogVXJsIG9mIHRoZSBzZXJ2ZXIsIHRoYXQgd2lsbCBzYXZlIHRoZSBmb3JtIGRhdGFcblx0ICovXG5cdGVuZHBvaW50OiB7XG5cdFx0dmFsdWU6ICdodHRwOi8vbG9jYWxob3N0OjMxMDAvY2FsY3VsYXRvcidcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTWV0YWxGb3JtO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9NZXRhbEZvcm0vTWV0YWxGb3JtLmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG52YXIgdGVtcGxhdGVzO1xuZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uKGV4cG9ydHMpIHtcblxuLy8gVGhpcyBmaWxlIHdhcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tIE1ldGFsRm9ybS5zb3kuXG4vLyBQbGVhc2UgZG9uJ3QgZWRpdCB0aGlzIGZpbGUgYnkgaGFuZC5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRlbXBsYXRlcyBpbiBuYW1lc3BhY2UgTWV0YWxGb3JtLlxuICogQHB1YmxpY1xuICovXG5cbmdvb2cubW9kdWxlKCdNZXRhbEZvcm0uaW5jcmVtZW50YWxkb20nKTtcblxuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xudmFyIHNveSA9IGdvb2cucmVxdWlyZSgnc295Jyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ZGF0YSA9IGdvb2cucmVxdWlyZSgnc295ZGF0YScpO1xuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xuZ29vZy5yZXF1aXJlKCdnb29nLmkxOG4uYmlkaScpO1xuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xuZ29vZy5yZXF1aXJlKCdnb29nLmFzc2VydHMnKTtcbnZhciBJbmNyZW1lbnRhbERvbSA9IGdvb2cucmVxdWlyZSgnaW5jcmVtZW50YWxkb20nKTtcbnZhciBpZV9vcGVuID0gSW5jcmVtZW50YWxEb20uZWxlbWVudE9wZW47XG52YXIgaWVfY2xvc2UgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50Q2xvc2U7XG52YXIgaWVfdm9pZCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRWb2lkO1xudmFyIGllX29wZW5fc3RhcnQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlblN0YXJ0O1xudmFyIGllX29wZW5fZW5kID0gSW5jcmVtZW50YWxEb20uZWxlbWVudE9wZW5FbmQ7XG52YXIgaXRleHQgPSBJbmNyZW1lbnRhbERvbS50ZXh0O1xudmFyIGlhdHRyID0gSW5jcmVtZW50YWxEb20uYXR0cjtcblxudmFyICR0ZW1wbGF0ZUFsaWFzMSA9IFNveS5nZXRUZW1wbGF0ZSgnQ2FsY3VsYXRvci5pbmNyZW1lbnRhbGRvbScsICdyZW5kZXInKTtcblxudmFyICR0ZW1wbGF0ZUFsaWFzMiA9IFNveS5nZXRUZW1wbGF0ZSgnRHJvcGRvd24uaW5jcmVtZW50YWxkb20nLCAncmVuZGVyJyk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2RhdGFcbiAqIEBwYXJhbSB7KG51bGx8dW5kZWZpbmVkKT19IG9wdF9pZ25vcmVkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2lqRGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZnVuY3Rpb24gJHJlbmRlcihvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpIHtcbiAgaWVfb3BlbignbWFpbicsIG51bGwsIG51bGwsXG4gICAgICAnY2xhc3MnLCAnd3JhcHBlcicpO1xuICAgIGllX29wZW4oJ2gxJyk7XG4gICAgICBpZV9vcGVuKCdzcGFuJyk7XG4gICAgICAgIGl0ZXh0KCdQZXJzb25hbCBMb2FuJyk7XG4gICAgICBpZV9jbG9zZSgnc3BhbicpO1xuICAgICAgaWVfb3Blbignc21hbGwnKTtcbiAgICAgICAgaXRleHQoJ1NhdmUgYW5kIG5vIHJlZCB0YXBlIGxvYW4uJyk7XG4gICAgICBpZV9jbG9zZSgnc21hbGwnKTtcbiAgICBpZV9jbG9zZSgnaDEnKTtcbiAgICBpZV9vcGVuKCdmb3JtJywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ21ldGhvZCcsICdwb3N0JyxcbiAgICAgICAgJ2NsYXNzJywgJ2xvYW4tZm9ybScpO1xuICAgICAgaWVfb3BlbignZmllbGRzZXQnLCBudWxsLCBudWxsLFxuICAgICAgICAgICdjbGFzcycsICdib3gtY2FsY3VsYXRvcicpO1xuICAgICAgICAkdGVtcGxhdGVBbGlhczEoe0xpc3RlbmVyOiBvcHRfZGF0YS5BcHBsaWNhdGlvbkVtaXR0ZXJ9LCBudWxsLCBvcHRfaWpEYXRhKTtcbiAgICAgIGllX2Nsb3NlKCdmaWVsZHNldCcpO1xuICAgICAgaWVfb3BlbignZmllbGRzZXQnLCBudWxsLCBudWxsLFxuICAgICAgICAgICdjbGFzcycsICdib3gtbG9hbi1vcHRpb25zJyk7XG4gICAgICAgIGllX29wZW4oJ2xhYmVsJywgbnVsbCwgbnVsbCxcbiAgICAgICAgICAgICdmb3InLCAnc2VsZWN0LW1vbnRocycpO1xuICAgICAgICAgIGllX29wZW4oJ3NwYW4nLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAnY2xhc3MnLCAnY2FwdGlvbicpO1xuICAgICAgICAgICAgaXRleHQoJ01vbnRocyAnKTtcbiAgICAgICAgICAgIGllX29wZW4oJ3NwYW4nLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAgICdjbGFzcycsICdtYW5kYXRvcnktc2lnbicpO1xuICAgICAgICAgICAgICBpdGV4dCgnKicpO1xuICAgICAgICAgICAgaWVfY2xvc2UoJ3NwYW4nKTtcbiAgICAgICAgICBpZV9jbG9zZSgnc3BhbicpO1xuICAgICAgICAgICR0ZW1wbGF0ZUFsaWFzMih7c2hvd246ICcnLCBMaXN0ZW5lcjogb3B0X2RhdGEuQXBwbGljYXRpb25FbWl0dGVyfSwgbnVsbCwgb3B0X2lqRGF0YSk7XG4gICAgICAgIGllX2Nsb3NlKCdsYWJlbCcpO1xuICAgICAgICBpZV9vcGVuKCdidXR0b24nLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJywgJ2J1dHRvbiBjYWxjdWxhdGUtaW50ZXJlc3QnLFxuICAgICAgICAgICAgJ2RhdGEtb25jbGljaycsICdjYWxjdWxhdGVGb3JtJyk7XG4gICAgICAgICAgaXRleHQoJ0NhbGN1bGF0ZScpO1xuICAgICAgICBpZV9jbG9zZSgnYnV0dG9uJyk7XG4gICAgICAgIGllX29wZW4oJ2xhYmVsJywgbnVsbCwgbnVsbCxcbiAgICAgICAgICAgICdmb3InLCAnaW5wdXQtdG90YWwnKTtcbiAgICAgICAgICBpZV9vcGVuKCdzcGFuJywgbnVsbCwgbnVsbCxcbiAgICAgICAgICAgICAgJ2NsYXNzJywgJ2NhcHRpb24nKTtcbiAgICAgICAgICAgIGl0ZXh0KCdUb3RhbCcpO1xuICAgICAgICAgIGllX2Nsb3NlKCdzcGFuJyk7XG4gICAgICAgICAgaWVfb3BlbignaW5wdXQnLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAndHlwZScsICd0ZXh0JyxcbiAgICAgICAgICAgICAgJ2lkJywgJ2lucHV0LXRvdGFsJyxcbiAgICAgICAgICAgICAgJ2Rpc2FibGVkJywgJycsXG4gICAgICAgICAgICAgICdwbGFjZWhvbGRlcicsICdSJDogMCwwMCcsXG4gICAgICAgICAgICAgICdyZWFkb25seScsICcnKTtcbiAgICAgICAgICBpZV9jbG9zZSgnaW5wdXQnKTtcbiAgICAgICAgaWVfY2xvc2UoJ2xhYmVsJyk7XG4gICAgICAgIGllX3ZvaWQoJ3NwYW4nLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJywgJ3N1Ym1pdC1sYWJlbCcpO1xuICAgICAgICBpZV9vcGVuKCdidXR0b24nLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgJ2NsYXNzJywgJ2dldC1xdW90IGJ1dHRvbi0tZmlsbGVkJyxcbiAgICAgICAgICAgICdkYXRhLW9uY2xpY2snLCAnc3VibWl0Rm9ybScsXG4gICAgICAgICAgICAnZGlzYWJsZWQnLCAnJyk7XG4gICAgICAgICAgaXRleHQoJ0dldCBRdW90Jyk7XG4gICAgICAgIGllX2Nsb3NlKCdidXR0b24nKTtcbiAgICAgIGllX2Nsb3NlKCdmaWVsZHNldCcpO1xuICAgIGllX2Nsb3NlKCdmb3JtJyk7XG4gICAgaWVfb3BlbignZm9vdGVyJywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ2NsYXNzJywgJ3NpdGUtZm9vdGVyJyk7XG4gICAgICBpZV9vcGVuKCdkaXYnLCBudWxsLCBudWxsLFxuICAgICAgICAgICdjbGFzcycsICdjb250YWluZXInKTtcbiAgICAgICAgaWVfb3BlbigncCcpO1xuICAgICAgICAgIGl0ZXh0KCcgTGlmZXJheSBJbmMuICcpO1xuICAgICAgICAgIGllX29wZW4oJ2JyJyk7XG4gICAgICAgICAgaWVfY2xvc2UoJ2JyJyk7XG4gICAgICAgICAgaXRleHQoJyBDb3B5cmlnaHQgXFx1MDBBOSAyMDE2IEFsbCBSaWdodHMgUmVzZXJ2ZWQuJyk7XG4gICAgICAgIGllX2Nsb3NlKCdwJyk7XG4gICAgICBpZV9jbG9zZSgnZGl2Jyk7XG4gICAgaWVfY2xvc2UoJ2Zvb3RlcicpO1xuICBpZV9jbG9zZSgnbWFpbicpO1xufVxuZXhwb3J0cy5yZW5kZXIgPSAkcmVuZGVyO1xuaWYgKGdvb2cuREVCVUcpIHtcbiAgJHJlbmRlci5zb3lUZW1wbGF0ZU5hbWUgPSAnTWV0YWxGb3JtLnJlbmRlcic7XG59XG5cbmV4cG9ydHMucmVuZGVyLnBhcmFtcyA9IFtcIkFwcGxpY2F0aW9uRW1pdHRlclwiXTtcbmV4cG9ydHMucmVuZGVyLnR5cGVzID0ge1wiQXBwbGljYXRpb25FbWl0dGVyXCI6XCJhbnlcIn07XG50ZW1wbGF0ZXMgPSBleHBvcnRzO1xucmV0dXJuIGV4cG9ydHM7XG5cbn0pO1xuXG5jbGFzcyBNZXRhbEZvcm0gZXh0ZW5kcyBDb21wb25lbnQge31cblNveS5yZWdpc3RlcihNZXRhbEZvcm0sIHRlbXBsYXRlcyk7XG5leHBvcnQgeyBNZXRhbEZvcm0sIHRlbXBsYXRlcyB9O1xuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVzO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvTWV0YWxGb3JtL01ldGFsRm9ybS5zb3kuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5hYnN0cmFjdE1ldGhvZCA9IGFic3RyYWN0TWV0aG9kO1xuZXhwb3J0cy5kaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmVuYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSA9IGdldENvbXBhdGliaWxpdHlNb2RlRGF0YTtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuZXhwb3J0cy5nZXRTdGF0aWNQcm9wZXJ0eSA9IGdldFN0YXRpY1Byb3BlcnR5O1xuZXhwb3J0cy5nZXRVaWQgPSBnZXRVaWQ7XG5leHBvcnRzLmlkZW50aXR5RnVuY3Rpb24gPSBpZGVudGl0eUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzRGVmID0gaXNEZWY7XG5leHBvcnRzLmlzRGVmQW5kTm90TnVsbCA9IGlzRGVmQW5kTm90TnVsbDtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzRG9jdW1lbnRGcmFnbWVudCA9IGlzRG9jdW1lbnRGcmFnbWVudDtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc1dpbmRvdyA9IGlzV2luZG93O1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzU2VydmVyU2lkZSA9IGlzU2VydmVyU2lkZTtcbmV4cG9ydHMubnVsbEZ1bmN0aW9uID0gbnVsbEZ1bmN0aW9uO1xudmFyIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB2b2lkIDA7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xudmFyIFVJRF9QUk9QRVJUWSA9IGV4cG9ydHMuVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBhYnN0cmFjdE1ldGhvZCgpIHtcbiAgdGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBFbmFibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlIHdpdGggdGhlIGZvbGxvd2luZyBmZWF0dXJlcyBmcm9tIHJjXG4gKiBhbmQgMS54IHZlcnNpb25zOlxuICogICAgIC0gVXNpbmcgXCJrZXlcIiB0byByZWZlcmVuY2UgY29tcG9uZW50IGluc3RhbmNlcy4gSW4gdGhlIGN1cnJlbnQgdmVyc2lvblxuICogICAgICAgdGhpcyBzaG91bGQgYmUgZG9uZSB2aWEgXCJyZWZcIiBpbnN0ZWFkLiBUaGlzIGFsbG93cyBvbGQgY29kZSBzdGlsbFxuICogICAgICAgdXNpbmcgXCJrZXlcIiB0byBrZWVwIHdvcmtpbmcgbGlrZSBiZWZvcmUuIE5PVEU6IHRoaXMgbWF5IGNhdXNlXG4gKiAgICAgICBwcm9ibGVtcywgc2luY2UgXCJrZXlcIiBpcyBtZWFudCB0byBiZSB1c2VkIGRpZmZlcmVudGx5LiBPbmx5IHVzZSB0aGlzXG4gKiAgICAgICBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byB1cGdyYWRlIHRoZSBjb2RlIHRvIHVzZSBcInJlZlwiIGluc3RlYWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9kYXRhIE9wdGlvbmFsIG9iamVjdCB3aXRoIGRhdGEgdG8gc3BlY2lmeSBtb3JlXG4gKiAgICAgZGV0YWlscywgc3VjaCBhczpcbiAqICAgICAgICAgLSByZW5kZXJlcnMge0FycmF5fSB0aGUgdGVtcGxhdGUgcmVuZGVyZXJzIHRoYXQgc2hvdWxkIGJlIGluXG4gKiAgICAgICAgICAgY29tcGF0aWJpbGl0eSBtb2RlLCBlaXRoZXIgdGhlaXIgY29uc3RydWN0b3JzIG9yIHN0cmluZ3NcbiAqICAgICAgICAgICByZXByZXNlbnRpbmcgdGhlbSAoZS5nLiAnc295JyBvciAnanN4JykuIEJ5IGRlZmF1bHQsIGFsbCB0aGUgb25lc1xuICogICAgICAgICAgIHRoYXQgZXh0ZW5kIGZyb20gSW5jcmVtZW50YWxEb21SZW5kZXJlci5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICB2YXIgb3B0X2RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBvcHRfZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHVzZWQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZSwgb3Igbm90aGluZyBpZiBpdCBoYXNuJ3QgYmVlblxuICogZW5hYmxlZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuICAvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG4gIGlmIChjb21wYXRpYmlsaXR5TW9kZURhdGFfID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKSB7XG4gICAgICBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSh3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcGF0aWJpbGl0eU1vZGVEYXRhXztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCdzIHRydXRoeSwgb3IgdGhlIHNlY29uZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RUcnV0aHlfKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkb2Vzbid0XG4gKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICogY29udGVudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKCFmbi5uYW1lKSB7XG4gICAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG4gIH1cbiAgcmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgcHJvcGVydHkgaW4gdGhlIGdpdmVuIGNsYXNzLiBUaGUgdmFsdWUgd2lsbCBiZVxuICogaW5oZXJpdGVkIGZyb20gYW5jZXN0b3JzIGFzIGV4cGVjdGVkLCB1bmxlc3MgYSBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gaXMgZ2l2ZW4sXG4gKiB3aGljaCBjYW4gY2hhbmdlIGhvdyB0aGUgc3VwZXIgY2xhc3NlcycgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkgd2lsbCBiZSBtZXJnZWRcbiAqIHRvZ2V0aGVyLlxuICogVGhlIGZpbmFsIG1lcmdlZCB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBpbiBhbm90aGVyIHByb3BlcnR5LCBzbyB0aGF0IGl0IHdvbid0XG4gKiBiZSByZWNhbGN1bGF0ZWQgZXZlbiBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbWVyZ2VkXG4gKiAgICAgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHNvIGZhciBhbmQgdGhlIG5leHQgdmFsdWUgdG8gYmUgbWVyZ2VkIHRvIGl0LlxuICogICAgIFNob3VsZCByZXR1cm4gdGhlc2UgdHdvIG1lcmdlZCB0b2dldGhlci4gSWYgbm90IHBhc3NlZCB0aGUgZmluYWwgcHJvcGVydHlcbiAqICAgICB3aWxsIGJlIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgYW1vbmcgYW5jZXN0b3JzLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG4gIHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuICBpZiAoIWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcbiAgICB2YXIgbWVyZ2VkID0gY3Rvci5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpID8gY3Rvcltwcm9wZXJ0eU5hbWVdIDogbnVsbDtcbiAgICBpZiAoY3Rvci5fX3Byb3RvX18gJiYgIWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG4gICAgICB2YXIgbWVyZ2VGbiA9IG9wdF9tZXJnZUZuIHx8IGdldEZpcnN0VHJ1dGh5XztcbiAgICAgIG1lcmdlZCA9IG1lcmdlRm4obWVyZ2VkLCBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLl9fcHJvdG9fXywgcHJvcGVydHlOYW1lLCBtZXJnZUZuKSk7XG4gICAgfVxuICAgIGN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG4gIH1cbiAgcmV0dXJuIGN0b3JbbWVyZ2VkTmFtZV07XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcbiAgaWYgKG9wdF9vYmplY3QpIHtcbiAgICB2YXIgaWQgPSBvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV07XG4gICAgaWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KFVJRF9QUk9QRVJUWSkpIHtcbiAgICAgIGlkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV0gPSB1bmlxdWVJZENvdW50ZXJfKyspO1xuICB9XG4gIHJldHVybiB1bmlxdWVJZENvdW50ZXJfKys7XG59XG5cbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF9yZXR1cm5WYWx1ZSBUaGUgc2luZ2xlIHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcbiAgcmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRGVmKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG4gIHJldHVybiBpc0RlZih2YWwpICYmICFpc051bGwodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LWZyYWdtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3codmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsID09PSB2YWwud2luZG93O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBhcnJheXNcbiAqIGFuZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogU2V0cyB0byB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aCBleHRyYSBjaGVjayBmb3JcbiAqIGBwcm9jZXNzLmJyb3dzZXJgIHRvIHNraXAgS2FybWEgcnVubmVyIGVudmlyb25tZW50LiBLYXJtYSBlbnZpcm9ubWVudCBoYXNcbiAqIGBwcm9jZXNzYCBkZWZpbmVkIGV2ZW4gdGhvdWdoIGl0IHJ1bnMgb24gdGhlIGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmICFwcm9jZXNzLmJyb3dzZXI7XG59XG5cbi8qKlxuICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBhcnJheSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgYXJyYXkpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGFycmF5LCBudWxsLCBbe1xuXHRcdGtleTogJ2VxdWFsJyxcblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIxXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBlcXVhbChhcnIxLCBhcnIyKSB7XG5cdFx0XHRpZiAoYXJyMSA9PT0gYXJyMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgaXNuJ3QgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0geyFBcnJheX0gYXJyXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmaXJzdERlZmluZWRWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKGFycikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFycltpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dCBuZXN0ZWQgYXJyYXkgdG8gYmVjb21lIGZsYXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPCp8QXJyYXkuPCo+Pn0gYXJyIE5lc3RlZCBhcnJheSB0byBmbGF0dGVuLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gb3B0X291dHB1dCBPcHRpb25hbCBvdXRwdXQgYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5LjwqPn0gRmxhdCBhcnJheS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZsYXR0ZW4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmbGF0dGVuKGFyciwgb3B0X291dHB1dCkge1xuXHRcdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG5cdFx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG5cdFx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0XHR2YXIgcnYgPSB2b2lkIDA7XG5cdFx0XHRpZiAocnYgPSBpID49IDApIHtcblx0XHRcdFx0YXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBydjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIEFycmF5IG9yIGFycmF5IGxpa2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVBdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcnIsIGksIDEpLmxlbmd0aCA9PT0gMTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcbiAgICogaXMgZmFzdGVyIGFuZCB3b3JraW5nIG9uIGFsbCBhcnJheS1saWtlIG9iamVjdHMgKGxpa2UgYXJndW1lbnRzKS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIGluZGV4IHdoZXJlIHRoZSBzbGljZSBzaG91bGQgZW5kLCBub3RcbiAgICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuICAgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NsaWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdFx0dmFyIGVuZCA9ICgwLCBfY29yZS5pc0RlZikob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRcdHNsaWNlZC5wdXNoKGFycltpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2xpY2VkO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBhcnJheTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXJyYXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xudmFyIGFzeW5jID0ge307XG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgZXhjZXB0aW9uO1xuXHR9KTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfHVuZGVmaW5lZH0gc2NvcGVcbiAqL1xuYXN5bmMucnVuLldvcmtJdGVtXyA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHR2YXIgY2IgPSBjYWxsYmFjaztcblx0aWYgKG9wdF9jb250ZXh0KSB7XG5cdFx0Y2IgPSBjYWxsYmFjay5iaW5kKG9wdF9jb250ZXh0KTtcblx0fVxuXHRjYiA9IGFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18oY2IpO1xuXHQvLyBJbnRyb2R1Y2VkIGFuZCBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSUUxMC5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IpO1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBMb29rIGZvciBhbmQgY2FjaGUgdGhlIGN1c3RvbSBmYWxsYmFjayB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZS5cblx0aWYgKCFhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKSB7XG5cdFx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IGFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXygpO1xuXHR9XG5cdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8oY2IpO1xufTtcblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gQ3JlYXRlIGEgcHJpdmF0ZSBtZXNzYWdlIGNoYW5uZWwgYW5kIHVzZSBpdCB0byBwb3N0TWVzc2FnZSBlbXB0eSBtZXNzYWdlc1xuXHQvLyB0byBvdXJzZWx2ZXMuXG5cdHZhciBDaGFubmVsID0gdm9pZCAwO1xuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRDaGFubmVsID0gTWVzc2FnZUNoYW5uZWw7XG5cdH1cblxuXHQvLyBJZiBNZXNzYWdlQ2hhbm5lbCBpcyBub3QgYXZhaWxhYmxlIGFuZCB3ZSBhcmUgaW4gYSBicm93c2VyLCBpbXBsZW1lbnRcblx0Ly8gYW4gaWZyYW1lIGJhc2VkIHBvbHlmaWxsIGluIGJyb3dzZXJzIHRoYXQgaGF2ZSBwb3N0TWVzc2FnZSBhbmRcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci4gVGhlIGxhdHRlciBleGNsdWRlcyBJRTggYmVjYXVzZSBpdCBoYXMgYVxuXHQvLyBzeW5jaHJvbm91cyBwb3N0TWVzc2FnZSBpbXBsZW1lbnRhdGlvbi5cblx0aWYgKHR5cGVvZiBDaGFubmVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uIENoYW5uZWwoKSB7XG5cdFx0XHQvLyBNYWtlIGFuIGVtcHR5LCBpbnZpc2libGUgaWZyYW1lLlxuXHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gJyc7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcblx0XHRcdHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cdFx0XHRkb2Mub3BlbigpO1xuXHRcdFx0ZG9jLndyaXRlKCcnKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSAnY2FsbEltbWVkaWF0ZScgKyBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dmFyIG9yaWdpbiA9IHdpbi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW4ubG9jYXRpb24uaG9zdDtcblx0XHRcdHZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSgpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHRhaWwubmV4dCA9IHtcblx0XHRcdFx0Y2I6IGNiXG5cdFx0XHR9O1xuXHRcdFx0dGFpbCA9IHRhaWwubmV4dDtcblx0XHRcdGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fVxuXHQvLyBJbXBsZW1lbnRhdGlvbiBmb3IgSUU2LTg6IFNjcmlwdCBlbGVtZW50cyBmaXJlIGFuIGFzeW5jaHJvbm91c1xuXHQvLyBvbnJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG5cdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXAgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxuXHRcdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0Y2IgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdH07XG5cdH1cblx0Ly8gRmFsbCBiYWNrIHRvIHNldFRpbWVvdXQgd2l0aCAwLiBJbiBicm93c2VycyB0aGlzIGNyZWF0ZXMgYSBkZWxheSBvZiA1bXNcblx0Ly8gb3IgbW9yZS5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbiAob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhc3luYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBEaXNwb3NhYmxlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuXHRcdC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG4gICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLiBDYWxscyBgZGlzcG9zZUludGVybmFsYC5cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEaXNwb3NhYmxlLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0aWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcbiAgICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG4gICAqIGRpc3Bvc2FibGVzKS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRGlzcG9zZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcG9zZWRfO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEaXNwb3NhYmxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwb3NhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBvYmplY3QoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIG9iamVjdCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Mob2JqZWN0LCBudWxsLCBbe1xuXHRcdGtleTogJ21peGluJyxcblxuXHRcdC8qKlxuICAgKiBDb3BpZXMgYWxsIHRoZSBtZW1iZXJzIG9mIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIFRoZSBvYmplY3RzIGZyb20gd2hpY2ggdmFsdWVzIHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG5cdFx0XHR2YXIga2V5ID0gdm9pZCAwLFxuXHRcdFx0ICAgIHNvdXJjZSA9IHZvaWQgMDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gICAqICAgICA8Y29kZT53aW5kb3c8L2NvZGU+LlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgdmFsdWUgKG9iamVjdCBvciBwcmltaXRpdmUpIG9yLCBpZiBub3QgZm91bmQsIHVuZGVmaW5lZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE9iamVjdEJ5TmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHRcdHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcblx0XHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnQsIGtleSkge1xuXHRcdFx0XHRyZXR1cm4gcGFydFtrZXldO1xuXHRcdFx0fSwgc2NvcGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcbiAgICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0XHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcHBlZE9iajtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG4gICAqIGNoZWNrLCBpbmNsdWRpbmcgb25seSB0aGUga2V5cyBkaXJlY3RseSBjb250YWluZWQgYnkgdGhlIDIgb2JqZWN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NoYWxsb3dFcXVhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmoxLCBvYmoyKSB7XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRcdGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIG9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gc3RyaW5nKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdHJpbmcpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKHN0cmluZywgbnVsbCwgW3tcblx0XHRrZXk6ICdjYXNlSW5zZW5zaXRpdmVDb21wYXJlJyxcblxuXHRcdC8qKlxuICAgKiBDb21wYXJlcyB0aGUgZ2l2ZW4gc3RyaW5ncyB3aXRob3V0IHRha2luZyB0aGUgY2FzZSBpbnRvIGFjY291bnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjJcbiAgICogQHJldHVybiB7bnVtYmVyfSBFaXRoZXIgLTEsIDAgb3IgMSwgYWNjb3JkaW5nIHRvIGlmIHRoZSBmaXJzdCBzdHJpbmcgaXNcbiAgICogICAgIFwic21hbGxlclwiLCBlcXVhbCBvciBcImJpZ2dlclwiIHRoYW4gdGhlIHNlY29uZCBnaXZlbiBzdHJpbmcuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYXNlSW5zZW5zaXRpdmVDb21wYXJlKHN0cjEsIHN0cjIpIHtcblx0XHRcdHZhciB0ZXN0MSA9IFN0cmluZyhzdHIxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIHRlc3QyID0gU3RyaW5nKHN0cjIpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICh0ZXN0MSA8IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0gZWxzZSBpZiAodGVzdDEgPT09IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuICAgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gICAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb2xsYXBzZUJyZWFraW5nU3BhY2VzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG4gICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcbiAgKiAgICAgdG8gb25lLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZXNjYXBlUmVnZXgnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy0oKVxcW1xcXXt9Kz8qLiRcXF58LDojPCFcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJhbmRvbVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcbiAgICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2VcbiAgICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG4gICAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cbiAgICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNoQ29kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc2hDb2RlKHZhbCkge1xuXHRcdFx0dmFyIGhhc2ggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG4gICAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VJbnRlcnZhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gc3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMvZXZlbnRzJyk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX3N5bmMgPSByZXF1aXJlKCcuL3N5bmMvc3luYycpO1xuXG52YXIgX21ldGFsRG9tID0gcmVxdWlyZSgnbWV0YWwtZG9tJyk7XG5cbnZhciBfQ29tcG9uZW50RGF0YU1hbmFnZXIgPSByZXF1aXJlKCcuL0NvbXBvbmVudERhdGFNYW5hZ2VyJyk7XG5cbnZhciBfQ29tcG9uZW50RGF0YU1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tcG9uZW50RGF0YU1hbmFnZXIpO1xuXG52YXIgX0NvbXBvbmVudFJlbmRlcmVyID0gcmVxdWlyZSgnLi9Db21wb25lbnRSZW5kZXJlcicpO1xuXG52YXIgX0NvbXBvbmVudFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbXBvbmVudFJlbmRlcmVyKTtcblxudmFyIF9tZXRhbEV2ZW50cyA9IHJlcXVpcmUoJ21ldGFsLWV2ZW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIENvbXBvbmVudCBjb2xsZWN0cyBjb21tb24gYmVoYXZpb3JzIHRvIGJlIGZvbGxvd2VkIGJ5IFVJIGNvbXBvbmVudHMsIHN1Y2hcbiAqIGFzIExpZmVjeWNsZSwgQ1NTIGNsYXNzZXMgbWFuYWdlbWVudCwgZXZlbnRzIGVuY2Fwc3VsYXRpb24gYW5kIHN1cHBvcnQgZm9yXG4gKiBkaWZmZXJlbnQgdHlwZXMgb2YgcmVuZGVyaW5nLlxuICogUmVuZGVyaW5nIGxvZ2ljIGNhbiBiZSBkb25lIGJ5IGVpdGhlcjpcbiAqICAgICAtIExpc3RlbmluZyB0byB0aGUgYHJlbmRlcmAgZXZlbnQgaW5zaWRlIHRoZSBgY3JlYXRlZGAgbGlmZWN5Y2xlIGZ1bmN0aW9uXG4gKiAgICAgICBhbmQgYWRkaW5nIHRoZSByZW5kZXJpbmcgbG9naWMgdG8gdGhlIGxpc3RlbmVyLlxuICogICAgIC0gVXNpbmcgYW4gZXhpc3RpbmcgaW1wbGVtZW50YXRpb24gb2YgYENvbXBvbmVudFJlbmRlcmVyYCBsaWtlIGBTb3lgLFxuICogICAgICAgYW5kIGZvbGxvd2luZyBpdHMgcGF0dGVybnMuXG4gKiAgICAgLSBCdWlsZGluZyB5b3VyIG93biBpbXBsZW1lbnRhdGlvbiBvZiBhIGBDb21wb25lbnRSZW5kZXJlcmAuXG4gKiBTcGVjaWZ5aW5nIHRoZSByZW5kZXJlciB0aGF0IHdpbGwgYmUgdXNlZCBjYW4gYmUgZG9uZSBieSBzZXR0aW5nIHRoZSBSRU5ERVJFUlxuICogc3RhdGljIHZhcmlhYmxlIHRvIHRoZSByZW5kZXJlcidzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogPGNvZGU+XG4gKiBjbGFzcyBDdXN0b21Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xuICogICBjcmVhdGVkKCkge1xuICogICB9XG4gKlxuICogICByZW5kZXJlZCgpIHtcbiAqICAgfVxuICpcbiAqICAgYXR0YWNoZWQoKSB7XG4gKiAgIH1cbiAqXG4gKiAgIGRldGFjaGVkKCkge1xuICogICB9XG4gKlxuICogICBkaXNwb3NlZCgpIHtcbiAqICAgfVxuICogfVxuICpcbiAqIEN1c3RvbUNvbXBvbmVudC5SRU5ERVJFUiA9IE15UmVuZGVyZXI7XG4gKlxuICogQ3VzdG9tQ29tcG9uZW50LlNUQVRFID0ge1xuICogICB0aXRsZTogeyB2YWx1ZTogJ1RpdGxlJyB9LFxuICogICBmb250U2l6ZTogeyB2YWx1ZTogJzEwcHgnIH1cbiAqIH07XG4gKiA8L2NvZGU+XG4gKlxuICogQGV4dGVuZHMge1N0YXRlfVxuICovXG52YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcblx0X2luaGVyaXRzKENvbXBvbmVudCwgX0V2ZW50RW1pdHRlcik7XG5cblx0LyoqXG4gICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGBDb21wb25lbnRgLlxuICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2NvbmZpZyBBbiBvYmplY3Qgd2l0aCB0aGUgaW5pdGlhbCB2YWx1ZXMgZm9yIHRoaXNcbiAgKiAgICAgY29tcG9uZW50J3Mgc3RhdGUuXG4gICogQHBhcmFtIHtib29sZWFufHN0cmluZ3xFbGVtZW50PX0gb3B0X3BhcmVudEVsZW1lbnQgVGhlIGVsZW1lbnQgd2hlcmUgdGhlXG4gICogICAgIGNvbXBvbmVudCBzaG91bGQgYmUgcmVuZGVyZWQuIENhbiBiZSBnaXZlbiBhcyBhIHNlbGVjdG9yIG9yIGFuIGVsZW1lbnQuXG4gICogICAgIElmIGBmYWxzZWAgaXMgcGFzc2VkLCB0aGUgY29tcG9uZW50IHdvbid0IGJlIHJlbmRlcmVkIGF1dG9tYXRpY2FsbHlcbiAgKiAgICAgYWZ0ZXIgY3JlYXRlZC5cbiAgKiBAY29uc3RydWN0b3JcbiAgKi9cblx0ZnVuY3Rpb24gQ29tcG9uZW50KG9wdF9jb25maWcsIG9wdF9wYXJlbnRFbGVtZW50KSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbXBvbmVudCk7XG5cblx0XHQvKipcbiAgICogSW5zdGFuY2Ugb2YgYERvbUV2ZW50RW1pdHRlclByb3h5YCB3aGljaCBwcm94aWVzIGV2ZW50cyBmcm9tIHRoZSBjb21wb25lbnQnc1xuICAgKiBlbGVtZW50IHRvIHRoZSBjb21wb25lbnQgaXRzZWxmLlxuICAgKiBAdHlwZSB7IURvbUV2ZW50RW1pdHRlclByb3h5fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDb21wb25lbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDb21wb25lbnQpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmVsZW1lbnRFdmVudFByb3h5XyA9IG5ldyBfbWV0YWxEb20uRG9tRXZlbnRFbWl0dGVyUHJveHkobnVsbCwgX3RoaXMsIHByb3h5QmxhY2tMaXN0Xyk7XG5cblx0XHQvKipcbiAgICogVGhlIGBFdmVudEhhbmRsZXJgIGluc3RhbmNlIGZvciBldmVudHMgYXR0YWNoZWQgZnJvbSB0aGUgYGV2ZW50c2Agc3RhdGUga2V5LlxuICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLmV2ZW50c1N0YXRlS2V5SGFuZGxlcl8gPSBudWxsO1xuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgaW4gZG9jdW1lbnQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblx0XHRfdGhpcy5pbkRvY3VtZW50ID0gZmFsc2U7XG5cblx0XHQvKipcbiAgICogVGhlIGluaXRpYWwgY29uZmlnIG9wdGlvbiBwYXNzZWQgdG8gdGhpcyBjb25zdHJ1Y3Rvci5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMuaW5pdGlhbENvbmZpZ18gPSBvcHRfY29uZmlnIHx8IHt9O1xuXG5cdFx0LyoqXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgd2FzIHJlbmRlcmVkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG5cdFx0X3RoaXMud2FzUmVuZGVyZWQgPSBmYWxzZTtcblxuXHRcdC8qKlxuICAgKiBUaGUgY29tcG9uZW50J3MgZWxlbWVudCB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBlbGVtZW50IHRoaXMgdmFyaWFibGUgaXNcbiAgICogc2V0IHRvLCB1bmxlc3MgdGhlIHVzZXIgc3BlY2lmaWVzIGFub3RoZXIgcGFyZW50IHdoZW4gY2FsbGluZyBgcmVuZGVyYCBvclxuICAgKiBgYXR0YWNoYC5cbiAgICogQHR5cGUgeyFFbGVtZW50fVxuICAgKi9cblx0XHRfdGhpcy5ERUZBVUxUX0VMRU1FTlRfUEFSRU5UID0gZG9jdW1lbnQuYm9keTtcblxuXHRcdF90aGlzLnNldFNob3VsZFVzZUZhY2FkZSh0cnVlKTtcblx0XHRfdGhpcy5lbGVtZW50ID0gX3RoaXMuaW5pdGlhbENvbmZpZ18uZWxlbWVudDtcblxuXHRcdF90aGlzLnNldFVwUmVuZGVyZXJfKCk7XG5cdFx0X3RoaXMuc2V0VXBEYXRhTWFuYWdlcl8oKTtcblx0XHRfdGhpcy5zZXRVcFN5bmNVcGRhdGVzXygpO1xuXG5cdFx0X3RoaXMub24oJ3N0YXRlQ2hhbmdlZCcsIF90aGlzLmhhbmRsZUNvbXBvbmVudFN0YXRlQ2hhbmdlZF8pO1xuXHRcdF90aGlzLm9uKCdldmVudHNDaGFuZ2VkJywgX3RoaXMub25FdmVudHNDaGFuZ2VkXyk7XG5cdFx0X3RoaXMuYWRkTGlzdGVuZXJzRnJvbU9ial8oX3RoaXMuZGF0YU1hbmFnZXJfLmdldChfdGhpcywgJ2V2ZW50cycpKTtcblxuXHRcdF90aGlzLmNyZWF0ZWQoKTtcblx0XHRfdGhpcy5jb21wb25lbnRDcmVhdGVkXyA9IHRydWU7XG5cdFx0aWYgKG9wdF9wYXJlbnRFbGVtZW50ICE9PSBmYWxzZSkge1xuXHRcdFx0X3RoaXMucmVuZGVyQ29tcG9uZW50KG9wdF9wYXJlbnRFbGVtZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogR2V0dGVyIGxvZ2ljIGZvciB0aGUgZWxlbWVudCBwcm9wZXJ0eS5cbiAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKENvbXBvbmVudCwgW3tcblx0XHRrZXk6ICdhZGRMaXN0ZW5lcnNGcm9tT2JqXycsXG5cblxuXHRcdC8qKlxuICAgKiBBZGRzIHRoZSBsaXN0ZW5lcnMgc3BlY2lmaWVkIGluIHRoZSBnaXZlbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVyc0Zyb21PYmpfKG9iaikge1xuXHRcdFx0dmFyIF9ldmVudHNTdGF0ZUtleUhhbmRsZTtcblxuXHRcdFx0aWYgKCF0aGlzLmV2ZW50c1N0YXRlS2V5SGFuZGxlcl8pIHtcblx0XHRcdFx0dGhpcy5ldmVudHNTdGF0ZUtleUhhbmRsZXJfID0gbmV3IF9tZXRhbEV2ZW50cy5FdmVudEhhbmRsZXIoKTtcblx0XHRcdH1cblx0XHRcdHZhciBoYW5kbGVzID0gKDAsIF9ldmVudHMuYWRkTGlzdGVuZXJzRnJvbU9iaikodGhpcywgb2JqKTtcblx0XHRcdChfZXZlbnRzU3RhdGVLZXlIYW5kbGUgPSB0aGlzLmV2ZW50c1N0YXRlS2V5SGFuZGxlcl8pLmFkZC5hcHBseShfZXZlbnRzU3RhdGVLZXlIYW5kbGUsIF90b0NvbnN1bWFibGVBcnJheShoYW5kbGVzKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEludm9rZXMgdGhlIGF0dGFjaGVkIExpZmVjeWNsZS4gV2hlbiBhdHRhY2hlZCwgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlzXG4gICAqIGFwcGVuZGVkIHRvIHRoZSBET00gYW5kIGFueSBvdGhlciBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIG11c3QgYmVcbiAgICogaW1wbGVtZW50ZWQgaW4gdGhpcyBtZXRob2QsIHN1Y2ggYXMsIGJpbmRpbmcgRE9NIGV2ZW50cy4gQSBjb21wb25lbnQgY2FuXG4gICAqIGJlIHJlLWF0dGFjaGVkIG11bHRpcGxlIHRpbWVzLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8RWxlbWVudCk9fSBvcHRfcGFyZW50RWxlbWVudCBPcHRpb25hbCBwYXJlbnQgZWxlbWVudFxuICAgKiAgICAgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xFbGVtZW50KT19IG9wdF9zaWJsaW5nRWxlbWVudCBPcHRpb25hbCBzaWJsaW5nIGVsZW1lbnRcbiAgICogICAgIHRvIHJlbmRlciB0aGUgY29tcG9uZW50IGJlZm9yZSBpdC4gUmVsZXZhbnQgd2hlbiB0aGUgY29tcG9uZW50IG5lZWRzXG4gICAqICAgICB0byBiZSByZW5kZXJlZCBiZWZvcmUgYW4gZXhpc3RpbmcgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBjaGFpbmFibGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2F0dGFjaCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGF0dGFjaChvcHRfcGFyZW50RWxlbWVudCwgb3B0X3NpYmxpbmdFbGVtZW50KSB7XG5cdFx0XHRpZiAoIXRoaXMuaW5Eb2N1bWVudCkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaEVsZW1lbnQob3B0X3BhcmVudEVsZW1lbnQsIG9wdF9zaWJsaW5nRWxlbWVudCk7XG5cdFx0XHRcdHRoaXMuaW5Eb2N1bWVudCA9IHRydWU7XG5cdFx0XHRcdHRoaXMuYXR0YWNoRGF0YV8gPSB7XG5cdFx0XHRcdFx0cGFyZW50OiBvcHRfcGFyZW50RWxlbWVudCxcblx0XHRcdFx0XHRzaWJsaW5nOiBvcHRfc2libGluZ0VsZW1lbnRcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5lbWl0KCdhdHRhY2hlZCcsIHRoaXMuYXR0YWNoRGF0YV8pO1xuXHRcdFx0XHR0aGlzLmF0dGFjaGVkKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogTGlmZWN5Y2xlLiBXaGVuIGF0dGFjaGVkLCB0aGUgY29tcG9uZW50IGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIERPTVxuICAgKiBhbmQgYW55IG90aGVyIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiB0aGlzIG1ldGhvZCxcbiAgICogc3VjaCBhcywgYmluZGluZyBET00gZXZlbnRzLiBBIGNvbXBvbmVudCBjYW4gYmUgcmUtYXR0YWNoZWQgbXVsdGlwbGVcbiAgICogdGltZXMsIHRoZXJlZm9yZSB0aGUgdW5kbyBiZWhhdmlvciBmb3IgYW55IGFjdGlvbiBwZXJmb3JtZWQgaW4gdGhpcyBwaGFzZVxuICAgKiBtdXN0IGJlIGltcGxlbWVudGVkIG9uIHRoZSBkZXRhY2ggcGhhc2UuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhdHRhY2hlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGF0dGFjaGVkKCkge31cblxuXHRcdC8qKlxuICAgKiBBdHRhY2hlcyB0aGUgY29tcG9uZW50IGVsZW1lbnQgaW50byB0aGUgRE9NLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8RWxlbWVudCk9fSBvcHRfcGFyZW50RWxlbWVudCBPcHRpb25hbCBwYXJlbnQgZWxlbWVudFxuICAgKiAgICAgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xFbGVtZW50KT19IG9wdF9zaWJsaW5nRWxlbWVudCBPcHRpb25hbCBzaWJsaW5nIGVsZW1lbnRcbiAgICogICAgIHRvIHJlbmRlciB0aGUgY29tcG9uZW50IGJlZm9yZSBpdC4gUmVsZXZhbnQgd2hlbiB0aGUgY29tcG9uZW50IG5lZWRzXG4gICAqICAgICB0byBiZSByZW5kZXJlZCBiZWZvcmUgYW4gZXhpc3RpbmcgZWxlbWVudCBpbiB0aGUgRE9NLCBlLmcuXG4gICAqICAgICBgY29tcG9uZW50LmF0dGFjaChudWxsLCBleGlzdGluZ0VsZW1lbnQpYC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2F0dGFjaEVsZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hFbGVtZW50KG9wdF9wYXJlbnRFbGVtZW50LCBvcHRfc2libGluZ0VsZW1lbnQpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0aWYgKGVsZW1lbnQgJiYgKG9wdF9zaWJsaW5nRWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnROb2RlKSkge1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gKDAsIF9tZXRhbERvbS50b0VsZW1lbnQpKG9wdF9wYXJlbnRFbGVtZW50KSB8fCB0aGlzLkRFRkFVTFRfRUxFTUVOVF9QQVJFTlQ7XG5cdFx0XHRcdHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgKDAsIF9tZXRhbERvbS50b0VsZW1lbnQpKG9wdF9zaWJsaW5nRWxlbWVudCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBMaWZlY3ljbGUuIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMganVzdCBiZWVuIGNyZWF0ZWQsIGJlZm9yZVxuICAgKiBpdCdzIHJlbmRlcmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY3JlYXRlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZWQoKSB7fVxuXG5cdFx0LyoqXG4gICAqIExpc3RlbnMgdG8gYSBkZWxlZ2F0ZSBldmVudCBvbiB0aGUgY29tcG9uZW50J3MgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHRoYXQgbWF0Y2hlcyB0aGUgY2hpbGQgZWxlbWVudHMgdGhhdFxuICAgKiAgIHRoZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZvci5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIU9iamVjdCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpc1xuICAgKiAgIHRyaWdnZXJlZC4gSXQgd2lsbCByZWNlaXZlIHRoZSBub3JtYWxpemVkIGV2ZW50IG9iamVjdC5cbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGVsZWdhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkZWxlZ2F0ZShldmVudE5hbWUsIHNlbGVjdG9yLCBjYWxsYmFjaykge1xuXHRcdFx0cmV0dXJuIHRoaXMub24oJ2RlbGVnYXRlOicgKyBldmVudE5hbWUgKyAnOicgKyBzZWxlY3RvciwgY2FsbGJhY2spO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBJbnZva2VzIHRoZSBkZXRhY2hlZCBMaWZlY3ljbGUuIFdoZW4gZGV0YWNoZWQsIHRoZSBjb21wb25lbnQgZWxlbWVudCBpc1xuICAgKiByZW1vdmVkIGZyb20gdGhlIERPTSBhbmQgYW55IG90aGVyIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgbXVzdCBiZVxuICAgKiBpbXBsZW1lbnRlZCBpbiB0aGlzIG1ldGhvZCwgc3VjaCBhcywgdW5iaW5kaW5nIERPTSBldmVudHMuIEEgY29tcG9uZW50XG4gICAqIGNhbiBiZSBkZXRhY2hlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICogQGNoYWluYWJsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGV0YWNoJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGV0YWNoKCkge1xuXHRcdFx0aWYgKHRoaXMuaW5Eb2N1bWVudCkge1xuXHRcdFx0XHRpZiAodGhpcy5lbGVtZW50ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmluRG9jdW1lbnQgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5kZXRhY2hlZCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbWl0KCdkZXRhY2hlZCcpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIExpZmVjeWNsZS4gV2hlbiBkZXRhY2hlZCwgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4gICAqIGFuZCBhbnkgb3RoZXIgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCBtdXN0IGJlIGltcGxlbWVudGVkIGluIHRoaXMgbWV0aG9kLFxuICAgKiBzdWNoIGFzLCB1bmJpbmRpbmcgRE9NIGV2ZW50cy4gQSBjb21wb25lbnQgY2FuIGJlIGRldGFjaGVkIG11bHRpcGxlXG4gICAqIHRpbWVzLCB0aGVyZWZvcmUgdGhlIHVuZG8gYmVoYXZpb3IgZm9yIGFueSBhY3Rpb24gcGVyZm9ybWVkIGluIHRoaXMgcGhhc2VcbiAgICogbXVzdCBiZSBpbXBsZW1lbnRlZCBvbiB0aGUgYXR0YWNoIHBoYXNlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGV0YWNoZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hlZCgpIHt9XG5cblx0XHQvKipcbiAgICogTGlmZWN5Y2xlLiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRpc3Bvc2VkLiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieVxuICAgKiBzdWIgY2xhc3NlcyB0byBkaXNwb3NlIG9mIGFueSBpbnRlcm5hbCBkYXRhIG9yIGV2ZW50cy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZWQoKSB7fVxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0XHR0aGlzLmRldGFjaCgpO1xuXHRcdFx0dGhpcy5kaXNwb3NlZCgpO1xuXG5cdFx0XHR0aGlzLmVsZW1lbnRFdmVudFByb3h5Xy5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLmVsZW1lbnRFdmVudFByb3h5XyA9IG51bGw7XG5cblx0XHRcdHRoaXMuZGF0YU1hbmFnZXJfLmRpc3Bvc2UodGhpcyk7XG5cdFx0XHR0aGlzLmRhdGFNYW5hZ2VyXyA9IG51bGw7XG5cblx0XHRcdHRoaXMucmVuZGVyZXJfLmRpc3Bvc2UodGhpcyk7XG5cdFx0XHR0aGlzLnJlbmRlcmVyXyA9IG51bGw7XG5cblx0XHRcdF9nZXQoQ29tcG9uZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbXBvbmVudC5wcm90b3R5cGUpLCAnZGlzcG9zZUludGVybmFsJywgdGhpcykuY2FsbCh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyBkYXRhIGFib3V0IHdoZXJlIHRoaXMgY29tcG9uZW50IHdhcyBhdHRhY2hlZCBhdC5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEF0dGFjaERhdGEnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRhY2hEYXRhKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0YWNoRGF0YV87XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGBDb21wb25lbnREYXRhTWFuYWdlcmAgYmVpbmcgdXNlZC5cbiAgICogQHJldHVybiB7IUNvbXBvbmVudERhdGFNYW5hZ2VyfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0RGF0YU1hbmFnZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhTWFuYWdlcigpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGFNYW5hZ2VyXztcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIHRvIHRoaXMgY29tcG9uZW50J3MgY29uc3RydWN0b3IuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRJbml0aWFsQ29uZmlnJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0SW5pdGlhbENvbmZpZygpIHtcblx0XHRcdHJldHVybiB0aGlzLmluaXRpYWxDb25maWdfO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHN0YXRlIGRhdGEgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRhdGFNYW5hZ2VyXy5nZXRTdGF0ZSh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUga2V5cyBmb3IgdGhlIHN0YXRlIGRhdGEuXG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGVLZXlzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGVLZXlzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YU1hbmFnZXJfLmdldFN0YXRlS2V5cyh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgYENvbXBvbmVudFJlbmRlcmVyYCBpbnN0YW5jZSBiZWluZyB1c2VkLlxuICAgKiBAcmV0dXJuIHshQ29tcG9uZW50UmVuZGVyZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRSZW5kZXJlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlcmVyKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMucmVuZGVyZXJfO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBIYW5kbGVzIGEgY2hhbmdlIGluIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHByZXZWYWxcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdWYWxcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlQ29tcG9uZW50RWxlbWVudENoYW5nZWRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ29tcG9uZW50RWxlbWVudENoYW5nZWRfKHByZXZWYWwsIG5ld1ZhbCkge1xuXHRcdFx0dGhpcy5lbGVtZW50RXZlbnRQcm94eV8uc2V0T3JpZ2luRW1pdHRlcihuZXdWYWwpO1xuXHRcdFx0aWYgKHRoaXMuY29tcG9uZW50Q3JlYXRlZF8pIHtcblx0XHRcdFx0dGhpcy5lbWl0KCdlbGVtZW50Q2hhbmdlZCcsIHtcblx0XHRcdFx0XHRwcmV2VmFsOiBwcmV2VmFsLFxuXHRcdFx0XHRcdG5ld1ZhbDogbmV3VmFsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAobmV3VmFsICYmIHRoaXMud2FzUmVuZGVyZWQpIHtcblx0XHRcdFx0XHR0aGlzLnN5bmNWaXNpYmxlKHRoaXMuZGF0YU1hbmFnZXJfLmdldCh0aGlzLCAndmlzaWJsZScpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBIYW5kbGVzIHN0YXRlIGJhdGNoIGNoYW5nZXMuIENhbGxzIGFueSBleGlzdGluZyBgc3luY2AgZnVuY3Rpb25zIHRoYXRcbiAgICogbWF0Y2ggdGhlIGNoYW5nZWQgc3RhdGUga2V5cy5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlQ29tcG9uZW50U3RhdGVDaGFuZ2VkXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNvbXBvbmVudFN0YXRlQ2hhbmdlZF8oZXZlbnQpIHtcblx0XHRcdGlmICghdGhpcy5oYXNTeW5jVXBkYXRlcygpKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlUmVuZGVyZXJfKGV2ZW50KTtcblx0XHRcdH1cblx0XHRcdCgwLCBfc3luYy5zeW5jU3RhdGUpKHRoaXMsIGV2ZW50LmNoYW5nZXMpO1xuXHRcdFx0dGhpcy5lbWl0KCdzdGF0ZVN5bmNlZCcsIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogSGFuZGxlcyBhIGBzdGF0ZUtleUNoYW5nZWRgIGV2ZW50LiBUaGlzIGlzIG9ubHkgY2FsbGVkIGZvciBjb21wb25lbnRzIHRoYXRcbiAgICogaGF2ZSByZXF1ZXN0ZWQgdXBkYXRlcyB0byBoYXBwZW4gc3luY2hyb25vdXNseS5cbiAgICogQHBhcmFtIHshe2tleTogc3RyaW5nLCBuZXdWYWw6ICosIHByZXZWYWw6ICp9fSBkYXRhXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhbmRsZUNvbXBvbmVudFN0YXRlS2V5Q2hhbmdlZF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDb21wb25lbnRTdGF0ZUtleUNoYW5nZWRfKGRhdGEpIHtcblx0XHRcdHRoaXMudXBkYXRlUmVuZGVyZXJfKHtcblx0XHRcdFx0Y2hhbmdlczogX2RlZmluZVByb3BlcnR5KHt9LCBkYXRhLmtleSwgZGF0YSlcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBjb21wb25lbnQgaGFzIHN5bmMgdXBkYXRlcyBlbmFibGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzU3luY1VwZGF0ZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNTeW5jVXBkYXRlcygpIHtcblx0XHRcdHJldHVybiB0aGlzLnN5bmNVcGRhdGVzXztcblx0XHR9XG5cblx0XHQvKipcbiAgICogSW5mb3JtcyB0aGF0IHRoZSBjb21wb25lbnQgdGhhdCB0aGUgcmVuZGVyZWQgaGFzIGZpbmlzaGVkIHJlbmRlcmluZyBpdC4gVGhlXG4gICAqIHJlbmRlcmVyIGlzIHRoZSBvbmUgcmVzcG9uc2libGUgZm9yIGNhbGxpbmcgdGhpcyB3aGVuIGFwcHJvcHJpYXRlLiBUaGlzXG4gICAqIHdpbGwgZW1pdCBldmVudHMgYW5kIHJ1biB0aGUgYXBwcm9wcmlhdGUgbGlmZWN5Y2xlIGZvciB0aGUgZmlyc3QgcmVuZGVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaW5mb3JtUmVuZGVyZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpbmZvcm1SZW5kZXJlZCgpIHtcblx0XHRcdHZhciBmaXJzdFJlbmRlciA9ICF0aGlzLmhhc1JlbmRlcmVyUmVuZGVyZWRfO1xuXHRcdFx0dGhpcy5oYXNSZW5kZXJlclJlbmRlcmVkXyA9IHRydWU7XG5cdFx0XHR0aGlzLnJlbmRlcmVkKGZpcnN0UmVuZGVyKTtcblx0XHRcdHRoaXMuZW1pdCgncmVuZGVyZWQnLCBmaXJzdFJlbmRlcik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZnVuY3Rpb24gaXMgYSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuIEFueSBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWVyZ2VFbGVtZW50Q2xhc3Nlc18nLFxuXG5cblx0XHQvKipcbiAgICogTWVyZ2VzIHR3byB2YWx1ZXMgZm9yIHRoZSBFTEVNRU5UX0NMQVNTRVMgcHJvcGVydHkgaW50byBhIHNpbmdsZSBvbmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzczFcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzMlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtZXJnZWQgdmFsdWUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1lcmdlRWxlbWVudENsYXNzZXNfKGNsYXNzMSwgY2xhc3MyKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3MxID8gY2xhc3MxICsgJyAnICsgKGNsYXNzMiB8fCAnJykgOiBjbGFzczI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEZpcmVkIHdoZW4gdGhlIGBldmVudHNgIHN0YXRlIHZhbHVlIGlzIGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnb25FdmVudHNDaGFuZ2VkXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG9uRXZlbnRzQ2hhbmdlZF8oZXZlbnQpIHtcblx0XHRcdHRoaXMuZXZlbnRzU3RhdGVLZXlIYW5kbGVyXy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblx0XHRcdHRoaXMuYWRkTGlzdGVuZXJzRnJvbU9ial8oZXZlbnQubmV3VmFsKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ3JlYXRlcyBhbmQgcmVuZGVycyBhIGNvbXBvbmVudCBmb3IgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLiBUaGlzXG4gICAqIHdpbGwgYWx3YXlzIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb25zdHJ1Y3RvciBydW5zIHdpdGhvdXQgcmVuZGVyaW5nIHRoZVxuICAgKiBjb21wb25lbnQsIGhhdmluZyB0aGUgYHJlbmRlcmAgc3RlcCBoYXBwZW4gb25seSBhZnRlciBpdCBoYXMgZmluaXNoZWQuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IEN0b3IgVGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdHxFbGVtZW50PX0gb3B0X2NvbmZpZ09yRWxlbWVudCBPcHRpb25hbCBjb25maWcgZGF0YSBvciBwYXJlbnRcbiAgICogICAgIGZvciB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBvcHRfZWxlbWVudCBPcHRpb25hbCBwYXJlbnQgZm9yIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSByZW5kZXJlZCBjb21wb25lbnQncyBpbnN0YW5jZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlckNvbXBvbmVudCcsXG5cblxuXHRcdC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb21wb25lbnQgaW50byB0aGUgRE9NIHZpYSBpdHMgYENvbXBvbmVudFJlbmRlcmVyYC4gU3RvcmVzIHRoZVxuICAgKiBnaXZlbiBwYXJlbnQgZWxlbWVudCB0byBiZSB1c2VkIHdoZW4gdGhlIHJlbmRlcmVyIGlzIGRvbmUgKGBpbmZvcm1SZW5kZXJlZGApLlxuICAgKiBAcGFyYW0geyhzdHJpbmd8RWxlbWVudHxib29sZWFuKT19IG9wdF9wYXJlbnRFbGVtZW50IE9wdGlvbmFsIHBhcmVudCBlbGVtZW50XG4gICAqICAgICB0byByZW5kZXIgdGhlIGNvbXBvbmVudC4gSWYgc2V0IHRvIGBmYWxzZWAsIHRoZSBlbGVtZW50IHdvbid0IGJlXG4gICAqICAgICBhdHRhY2hlZCB0byBhbnkgZWxlbWVudCBhZnRlciByZW5kZXJpbmcuIEluIHRoaXMgY2FzZSwgYGF0dGFjaGAgc2hvdWxkXG4gICAqICAgICBiZSBjYWxsZWQgbWFudWFsbHkgbGF0ZXIgdG8gYWN0dWFsbHkgYXR0YWNoIGl0IHRvIHRoZSBkb20uXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDb21wb25lbnQob3B0X3BhcmVudEVsZW1lbnQpIHtcblx0XHRcdGlmICghdGhpcy5oYXNSZW5kZXJlclJlbmRlcmVkXykge1xuXHRcdFx0XHRpZiAod2luZG93Ll9fTUVUQUxfREVWX1RPT0xTX0hPT0tfXykge1xuXHRcdFx0XHRcdHdpbmRvdy5fX01FVEFMX0RFVl9UT09MU19IT09LX18odGhpcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5nZXRSZW5kZXJlcigpLnJlbmRlcih0aGlzKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZW1pdCgncmVuZGVyJyk7XG5cdFx0XHQoMCwgX3N5bmMuc3luY1N0YXRlKSh0aGlzKTtcblx0XHRcdHRoaXMuYXR0YWNoKG9wdF9wYXJlbnRFbGVtZW50KTtcblx0XHRcdHRoaXMud2FzUmVuZGVyZWQgPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXR0ZXIgbG9naWMgZm9yIHRoZSBlbGVtZW50IHByb3BlcnR5LlxuICAgKiBAcGFyYW0gez9zdHJpbmd8RWxlbWVudH0gdmFsXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRTdGF0ZScsXG5cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbGwgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXlzLlxuICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gdmFsdWVzIEEgbWFwIG9mIHN0YXRlIGtleXMgdG8gdGhlIHZhbHVlcyB0aGV5XG4gICAqICAgc2hvdWxkIGJlIHNldCB0by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW5cbiAgICogICBhZnRlciB0aGUgbmV4dCBiYXRjaGVkIHVwZGF0ZSBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSwgb3B0X2NhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmRhdGFNYW5hZ2VyXy5zZXRTdGF0ZSh0aGlzLCBzdGF0ZSwgb3B0X2NhbGxiYWNrKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0dGVyIGZvciB0aGUgYGVsZW1lbnRDbGFzc2VzYCBkYXRhIHByb3BlcnR5LiBBcHBlbmRzIGdpdmVuIHZhbHVlIHdpdGhcbiAgICogdGhlIG9uZSBzcGVjaWZpZWQgaW4gYEVMRU1FTlRfQ0xBU1NFU2AuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXR0ZXJFbGVtZW50Q2xhc3Nlc0ZuXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldHRlckVsZW1lbnRDbGFzc2VzRm5fKHZhbCkge1xuXHRcdFx0dmFyIGVsZW1lbnRDbGFzc2VzID0gKDAsIF9tZXRhbC5nZXRTdGF0aWNQcm9wZXJ0eSkodGhpcy5jb25zdHJ1Y3RvciwgJ0VMRU1FTlRfQ0xBU1NFUycsIHRoaXMubWVyZ2VFbGVtZW50Q2xhc3Nlc18pO1xuXHRcdFx0aWYgKGVsZW1lbnRDbGFzc2VzKSB7XG5cdFx0XHRcdHZhbCArPSAnICcgKyBlbGVtZW50Q2xhc3Nlcztcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWwudHJpbSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjb21wb25lbnQncyBkYXRhIG1hbmFnZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFVwRGF0YU1hbmFnZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VXBEYXRhTWFuYWdlcl8oKSB7XG5cdFx0XHR0aGlzLmRhdGFNYW5hZ2VyXyA9ICgwLCBfbWV0YWwuZ2V0U3RhdGljUHJvcGVydHkpKHRoaXMuY29uc3RydWN0b3IsICdEQVRBX01BTkFHRVInKTtcblx0XHRcdHRoaXMuZGF0YU1hbmFnZXJfLnNldFVwKHRoaXMsIF9tZXRhbC5vYmplY3QubWl4aW4oe30sIHRoaXMucmVuZGVyZXJfLmdldEV4dHJhRGF0YUNvbmZpZyh0aGlzKSwgQ29tcG9uZW50LkRBVEEpKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB1cCB0aGUgY29tcG9uZW50J3MgcmVuZGVyZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFVwUmVuZGVyZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VXBSZW5kZXJlcl8oKSB7XG5cdFx0XHR0aGlzLnJlbmRlcmVyXyA9ICgwLCBfbWV0YWwuZ2V0U3RhdGljUHJvcGVydHkpKHRoaXMuY29uc3RydWN0b3IsICdSRU5ERVJFUicpO1xuXHRcdFx0dGhpcy5yZW5kZXJlcl8uc2V0VXAodGhpcyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdXAgdGhlIGNvbXBvbmVudCB0byB1c2Ugc3luYyB1cGRhdGVzIHdoZW4gYFNZTkNfVVBEQVRFU2AgaXMgYHRydWVgLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRVcFN5bmNVcGRhdGVzXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFVwU3luY1VwZGF0ZXNfKCkge1xuXHRcdFx0dGhpcy5zeW5jVXBkYXRlc18gPSAoMCwgX21ldGFsLmdldFN0YXRpY1Byb3BlcnR5KSh0aGlzLmNvbnN0cnVjdG9yLCAnU1lOQ19VUERBVEVTJyk7XG5cdFx0XHRpZiAodGhpcy5oYXNTeW5jVXBkYXRlcygpKSB7XG5cdFx0XHRcdHRoaXMub24oJ3N0YXRlS2V5Q2hhbmdlZCcsIHRoaXMuaGFuZGxlQ29tcG9uZW50U3RhdGVLZXlDaGFuZ2VkXy5iaW5kKHRoaXMpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU2tpcHMgcmVuZGVyZXIgdXBkYXRlcyB1bnRpbCBgc3RvcFNraXBVcGRhdGVzYCBpcyBjYWxsZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzdGFydFNraXBVcGRhdGVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc3RhcnRTa2lwVXBkYXRlcygpIHtcblx0XHRcdHRoaXMuc2tpcFVwZGF0ZXNfID0gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU3RvcHMgc2tpcHBpbmcgcmVuZGVyZXIgdXBkYXRlcy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3N0b3BTa2lwVXBkYXRlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHN0b3BTa2lwVXBkYXRlcygpIHtcblx0XHRcdHRoaXMuc2tpcFVwZGF0ZXNfID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN0YXRlIHN5bmNocm9uaXphdGlvbiBsb2dpYyBmb3IgYHZpc2libGVgIHN0YXRlIGtleS5cbiAgICogVXBkYXRlcyB0aGUgZWxlbWVudCdzIGRpc3BsYXkgdmFsdWUgYWNjb3JkaW5nIHRvIGl0cyB2aXNpYmlsaXR5LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5ld1ZhbFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc3luY1Zpc2libGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzeW5jVmlzaWJsZShuZXdWYWwpIHtcblx0XHRcdGlmICh0aGlzLmVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBuZXdWYWwgPyAnJyA6ICdub25lJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogTGlmZWN5Y2xlLiBDYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBoYXMganVzdCBiZWVuIHJlbmRlcmVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpcnN0UmVuZGVyIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIHdhcyB0aGUgY29tcG9uZW50J3NcbiAgICogICAgIGZpcnN0IHJlbmRlci5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlcmVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVuZGVyZWQoKSB7fVxuXG5cdFx0LyoqXG4gICAqIENhbGxzIFwidXBkYXRlXCIgb24gdGhlIHJlbmRlcmVyLCBwYXNzaW5nIGl0IHRoZSBjaGFuZ2VkIGRhdGEuXG4gICAqIEBwYXJhbSB7IXtjaGFuZ2VzOiAhT2JqZWN0fX0gZGF0YVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd1cGRhdGVSZW5kZXJlcl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVSZW5kZXJlcl8oZGF0YSkge1xuXHRcdFx0aWYgKCF0aGlzLnNraXBVcGRhdGVzXyAmJiB0aGlzLmhhc1JlbmRlcmVyUmVuZGVyZWRfKSB7XG5cdFx0XHRcdHRoaXMuZ2V0UmVuZGVyZXIoKS51cGRhdGUodGhpcywgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFZhbGlkYXRvciBsb2dpYyBmb3IgdGhlIGBldmVudHNgIHN0YXRlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd2YWxpZGF0b3JFdmVudHNGbl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0b3JFdmVudHNGbl8odmFsKSB7XG5cdFx0XHRyZXR1cm4gISgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKSh2YWwpIHx8ICgwLCBfbWV0YWwuaXNPYmplY3QpKHZhbCk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnZWxlbWVudCcsXG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50VmFsdWVfO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG5cdFx0XHRpZiAoISgwLCBfbWV0YWwuaXNFbGVtZW50KSh2YWwpICYmICEoMCwgX21ldGFsLmlzU3RyaW5nKSh2YWwpICYmICgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKSh2YWwpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbCkge1xuXHRcdFx0XHR2YWwgPSAoMCwgX21ldGFsRG9tLnRvRWxlbWVudCkodmFsKSB8fCB0aGlzLmVsZW1lbnRWYWx1ZV87XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmVsZW1lbnRWYWx1ZV8gIT09IHZhbCkge1xuXHRcdFx0XHR2YXIgcHJldiA9IHRoaXMuZWxlbWVudFZhbHVlXztcblx0XHRcdFx0dGhpcy5lbGVtZW50VmFsdWVfID0gdmFsO1xuXHRcdFx0XHR0aGlzLmhhbmRsZUNvbXBvbmVudEVsZW1lbnRDaGFuZ2VkXyhwcmV2LCB2YWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0sIFt7XG5cdFx0a2V5OiAnaXNDb21wb25lbnRDdG9yJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNDb21wb25lbnRDdG9yKGZuKSB7XG5cdFx0XHRyZXR1cm4gZm4ucHJvdG90eXBlICYmIGZuLnByb3RvdHlwZVtDb21wb25lbnQuQ09NUE9ORU5UX0ZMQUddO1xuXHRcdH1cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihDdG9yLCBvcHRfY29uZmlnT3JFbGVtZW50LCBvcHRfZWxlbWVudCkge1xuXHRcdFx0dmFyIGNvbmZpZyA9IG9wdF9jb25maWdPckVsZW1lbnQ7XG5cdFx0XHR2YXIgZWxlbWVudCA9IG9wdF9lbGVtZW50O1xuXHRcdFx0aWYgKCgwLCBfbWV0YWwuaXNFbGVtZW50KShvcHRfY29uZmlnT3JFbGVtZW50KSkge1xuXHRcdFx0XHRjb25maWcgPSBudWxsO1xuXHRcdFx0XHRlbGVtZW50ID0gb3B0X2NvbmZpZ09yRWxlbWVudDtcblx0XHRcdH1cblx0XHRcdHZhciBpbnN0YW5jZSA9IG5ldyBDdG9yKGNvbmZpZywgZmFsc2UpO1xuXHRcdFx0aW5zdGFuY2UucmVuZGVyQ29tcG9uZW50KGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIGluc3RhbmNlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZW5kZXJzIGEgY29tcG9uZW50IGZvciB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24gYXNcbiAgICogc3RyaW5nLiBUaGlzIHdpbGwgYWx3YXlzIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb25zdHJ1Y3RvciBydW5zIHdpdGhvdXRcbiAgICogcmVuZGVyaW5nIHRoZSBjb21wb25lbnQsIGhhdmluZyB0aGUgYHJlbmRlcmAgc3RlcCBoYXBwZW4gb25seSBhZnRlciBpdFxuICAgKiBoYXMgZmluaXNoZWQuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IEN0b3IgVGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdHxFbGVtZW50PX0gb3B0X2NvbmZpZ09yRWxlbWVudCBPcHRpb25hbCBjb25maWcgZGF0YSBvclxuICAgKiAgICAgcGFyZW50IGZvciB0aGUgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHshU3RyaW5nfSBUaGUgcmVuZGVyZWQgY29tcG9uZW50J3MgY29udGVudCBhcyBzdHJpbmcuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJUb1N0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKEN0b3IsIG9wdF9jb25maWcpIHtcblx0XHRcdHZhciByZW5kZXJlck5hbWUgPSBDdG9yLlJFTkRFUkVSICYmIEN0b3IuUkVOREVSRVIuUkVOREVSRVJfTkFNRTtcblx0XHRcdHN3aXRjaCAocmVuZGVyZXJOYW1lKSB7XG5cdFx0XHRcdGNhc2UgJ2pzeCc6XG5cdFx0XHRcdGNhc2UgJ3NveSc6XG5cdFx0XHRcdGNhc2UgJ2luY3JlbWVudGFsLWRvbSc6XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBJbmNyZW1lbnRhbERPTSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdFcnJvci4gVHJ5aW5nIHRvIHJlbmRlciBpbmNyZW1lbnRhbCBkb20gJyArICdiYXNlZCBjb21wb25lbnQgdG8gc3RyaW5nIHJlcXVpcmVzIEluY3JlbWVudGFsRE9NICcgKyAnaW1wbGVtZW50YXRpb24gdG8gYmUgbG9hZGVkLicpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gSW5jcmVtZW50YWwgZG9tIHBhdGNoZXMgZm9yIGNvbXBvbmVudHMgb3IgbmVzdGVkIGNvbXBvbmVudHMgYXJlXG5cdFx0XHRcdFx0XHQvLyBpc29sYXRlZCBpbnNpZGUgdGhlIGNvbXBvbmVudCBlbGVtZW50LiBUaGUgZm9sbG93aW5nIGNvZGUgaW50ZXJjZXB0c1xuXHRcdFx0XHRcdFx0Ly8gaW5jcmVtZW50YWwgZG9tIHBhdGNoZXMgYW5kIGNvbGxlY3QgcmVzdWx0cyBpbnRvIHRlbXBvcmFyeSBzdGFjayBpblxuXHRcdFx0XHRcdFx0Ly8gb3JkZXIgdG8gc3VjY2Vzc2Z1bGx5IGNvbGxlY3QgdGhlIGZpbmFsIHN0cmluZyBvZiB0aGUgb3V0ZXJtb3N0XG5cdFx0XHRcdFx0XHQvLyBjb21wb25lbnQgYWZ0ZXIgYWxsIG5lc3RlZCBjb21wb25lbnRzIHN0YWNrIHJlbmRlcmVkLlxuXHRcdFx0XHRcdFx0dmFyIGludGVyY2VwdGVkQ29tcG9uZW50U3RyaW5ncyA9IFtdO1xuXHRcdFx0XHRcdFx0dmFyIHBhdGNoID0gSW5jcmVtZW50YWxET00ucGF0Y2g7XG5cdFx0XHRcdFx0XHR2YXIgcGF0Y2hJbnRlcmNlcHRvciA9IGZ1bmN0aW9uIHBhdGNoSW50ZXJjZXB0b3IoKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50RWxlbWVudCA9IHBhdGNoLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdFx0XHRcdGludGVyY2VwdGVkQ29tcG9uZW50U3RyaW5ncy5wdXNoKGN1cnJlbnRFbGVtZW50LmlubmVySFRNTCk7XG5cdFx0XHRcdFx0XHRcdEluY3JlbWVudGFsRE9NLnBhdGNoID0gcGF0Y2g7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0SW5jcmVtZW50YWxET00ucGF0Y2ggPSBwYXRjaEludGVyY2VwdG9yO1xuXHRcdFx0XHRcdFx0Q29tcG9uZW50LnJlbmRlcihDdG9yLCBvcHRfY29uZmlnKS5kaXNwb3NlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW50ZXJjZXB0ZWRDb21wb25lbnRTdHJpbmdzWzBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yLiBUcnlpbmcgdG8gcmVuZGVyIG5vbiBpbmNyZW1lbnRhbCBkb20gJyArICdiYXNlZCBjb21wb25lbnQgdG8gc3RyaW5nLicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBDb21wb25lbnQ7XG59KF9tZXRhbEV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENvbXBvbmVudCBkYXRhIGRlZmluaXRpb24uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICovXG5cblxuQ29tcG9uZW50LkRBVEEgPSB7XG5cdC8qKlxuICAqIE9iamVjdHMgZGVzY3JpYmluZyBjaGlsZHJlbiBlbGVtZW50cyB0aGF0IHdlcmUgcGFzc2VkIHRvIGJlIHJlbmRlcmVkIGluc2lkZVxuICAqIHRoaXMgY29tcG9uZW50LlxuICAqIEB0eXBlIHshQXJyYXk8IU9iamVjdD59XG4gICovXG5cdGNoaWxkcmVuOiB7XG5cdFx0dmFsaWRhdG9yOiBBcnJheS5pc0FycmF5LFxuXHRcdHZhbHVlOiBbXVxuXHR9LFxuXG5cdC8qKlxuICAqIENTUyBjbGFzc2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gICogQHR5cGUge3N0cmluZ31cbiAgKi9cblx0ZWxlbWVudENsYXNzZXM6IHtcblx0XHRzZXR0ZXI6ICdzZXR0ZXJFbGVtZW50Q2xhc3Nlc0ZuXycsXG5cdFx0dmFsaWRhdG9yOiBfbWV0YWwuaXNTdHJpbmcsXG5cdFx0dmFsdWU6ICcnXG5cdH0sXG5cblx0LyoqXG4gICogTGlzdGVuZXJzIHRoYXQgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50LiBTaG91bGQgYmUgcHJvdmlkZWQgYXNcbiAgKiBhbiBvYmplY3QsIHdoZXJlIHRoZSBrZXlzIGFyZSBldmVudCBuYW1lcyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIGxpc3RlbmVyXG4gICogZnVuY3Rpb25zIChvciBmdW5jdGlvbiBuYW1lcykuXG4gICogQHR5cGUge09iamVjdDxzdHJpbmcsIChmdW5jdGlvbigpfHN0cmluZ3x7c2VsZWN0b3I6IHN0cmluZywgZm46IGZ1bmN0aW9uKCl8c3RyaW5nfSk+fVxuICAqL1xuXHRldmVudHM6IHtcblx0XHR2YWxpZGF0b3I6ICd2YWxpZGF0b3JFdmVudHNGbl8nLFxuXHRcdHZhbHVlOiBudWxsXG5cdH0sXG5cblx0LyoqXG4gICogSW5kaWNhdGVzIGlmIHRoZSBjb21wb25lbnQgaXMgdmlzaWJsZSBvciBub3QuXG4gICogQHR5cGUge2Jvb2xlYW59XG4gICovXG5cdHZpc2libGU6IHtcblx0XHR2YWxpZGF0b3I6IF9tZXRhbC5pc0Jvb2xlYW4sXG5cdFx0dmFsdWU6IHRydWVcblx0fVxufTtcblxuLyoqXG4gKiBOYW1lIG9mIHRoZSBmbGFnIHVzZWQgdG8gaWRlbnRpZnkgY29tcG9uZW50IGNvbnN0cnVjdG9ycyB2aWEgdGhlaXIgcHJvdG90eXBlLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuQ29tcG9uZW50LkNPTVBPTkVOVF9GTEFHID0gJ19fbWV0YWxfY29tcG9uZW50X18nO1xuXG4vKipcbiAqIFRoZSBgQ29tcG9uZW50RGF0YU1hbmFnZXJgIGNsYXNzIHRoYXQgc2hvdWxkIGJlIHVzZWQuIFRoaXMgY2xhc3Mgd2lsbCBiZVxuICogcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBjb21wb25lbnQncyBkYXRhLiBFYWNoIGNvbXBvbmVudCBtYXkgaGF2ZSBpdHNcbiAqIG93biBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHshQ29tcG9uZW50RGF0YU1hbmFnZXJ9XG4gKi9cbkNvbXBvbmVudC5EQVRBX01BTkFHRVIgPSBfQ29tcG9uZW50RGF0YU1hbmFnZXIyLmRlZmF1bHQ7XG5cbi8qKlxuICogQ1NTIGNsYXNzZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkNvbXBvbmVudC5FTEVNRU5UX0NMQVNTRVMgPSAnJztcblxuLyoqXG4gKiBUaGUgYENvbXBvbmVudFJlbmRlcmVyYCB0aGF0IHNob3VsZCBiZSB1c2VkLiBDb21wb25lbnRzIG5lZWQgdG8gc2V0IHRoaXNcbiAqIHRvIGEgc3ViY2xhc3Mgb2YgYENvbXBvbmVudFJlbmRlcmVyYCB0aGF0IGhhcyB0aGUgcmVuZGVyaW5nIGxvZ2ljLCBsaWtlXG4gKiBgU295UmVuZGVyZXJgLlxuICogQHR5cGUgeyFDb21wb25lbnRSZW5kZXJlcn1cbiAqL1xuQ29tcG9uZW50LlJFTkRFUkVSID0gX0NvbXBvbmVudFJlbmRlcmVyMi5kZWZhdWx0O1xuXG4vKipcbiAqIEZsYWcgaW5kaWNhdGluZyBpZiBjb21wb25lbnQgdXBkYXRlcyB3aWxsIGhhcHBlbiBzeW5jaHJvbm91c2x5LiBVcGRhdGVzIGFyZVxuICogZG9uZSBhc3luY2hyb25vdXNseSBieSBkZWZhdWx0LCB3aGljaCBhbGxvd3MgY2hhbmdlcyB0byBiZSBiYXRjaGVkIGFuZFxuICogYXBwbGllZCB0b2dldGhlci5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5Db21wb25lbnQuU1lOQ19VUERBVEVTID0gZmFsc2U7XG5cbi8qKlxuICogU2V0cyBhIHByb3RvdHlwZSBmbGFnIHRvIGVhc2lseSBkZXRlcm1pbmUgaWYgYSBnaXZlbiBjb25zdHJ1Y3RvciBpcyBmb3JcbiAqIGEgY29tcG9uZW50IG9yIG5vdC5cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZVtDb21wb25lbnQuQ09NUE9ORU5UX0ZMQUddID0gdHJ1ZTtcblxudmFyIHByb3h5QmxhY2tMaXN0XyA9IHtcblx0ZXZlbnRzQ2hhbmdlZDogdHJ1ZSxcblx0c3RhdGVDaGFuZ2VkOiB0cnVlLFxuXHRzdGF0ZUtleUNoYW5nZWQ6IHRydWVcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IENvbXBvbmVudDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL0NvbXBvbmVudC5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5zeW5jU3RhdGUgPSBzeW5jU3RhdGU7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgU1lOQ19GTlNfS0VZID0gJ19fTUVUQUxfU1lOQ19GTlNfXyc7XG5cbi8qKlxuICogR2V0cyB0aGUgYHN5bmNgIG1ldGhvZHMgZm9yIHRoaXMgY29tcG9uZW50J3Mgc3RhdGUuIENhY2hlcyB0aGUgcmVzdWx0cyBpblxuICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdoZW5ldmVyIHBvc3NpYmxlLCBzbyB0aGF0IHRoaXMgZG9lc24ndCBuZWVkIHRvXG4gKiBiZSBjYWxjdWxhdGVkIGFnYWluLiBJdCdzIG5vdCBwb3NzaWJsZSB0byBjYWNoZSB0aGUgcmVzdWx0cyB3aGVuIGF0IGxlYXN0XG4gKiBvbmUgc3luYyBtZXRob2QgaXMgZGVmaW5lZCBpbiB0aGUgaW5zdGFuY2UgaXRzZWxmIGluc3RlYWQgb2YgaW4gaXRzXG4gKiBwcm90b3R5cGUsIGFzIGl0IG1heSBiZSBib3VuZCB0byB0aGUgaW5zdGFuY2UgKG5vdCByZXVzYWJsZSBieSBvdGhlcnMpLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRTeW5jRm5zXyhjb21wb25lbnQpIHtcblx0dmFyIGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cdGlmIChjdG9yLmhhc093blByb3BlcnR5KFNZTkNfRk5TX0tFWSkpIHtcblx0XHRyZXR1cm4gY3RvcltTWU5DX0ZOU19LRVldO1xuXHR9XG5cblx0dmFyIGZucyA9IHt9O1xuXHR2YXIga2V5cyA9IGNvbXBvbmVudC5nZXREYXRhTWFuYWdlcigpLmdldFN5bmNLZXlzKGNvbXBvbmVudCk7XG5cdHZhciBjYW5DYWNoZSA9IHRydWU7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBuYW1lID0gJ3N5bmMnICsga2V5c1tpXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleXNbaV0uc2xpY2UoMSk7XG5cdFx0dmFyIGZuID0gY29tcG9uZW50W25hbWVdO1xuXHRcdGlmIChmbikge1xuXHRcdFx0Zm5zW2tleXNbaV1dID0gZm47XG5cdFx0XHRjYW5DYWNoZSA9IGNhbkNhY2hlICYmIGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5wcm90b3R5cGVbbmFtZV07XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNhbkNhY2hlKSB7XG5cdFx0Y3RvcltTWU5DX0ZOU19LRVldID0gZm5zO1xuXHR9XG5cdHJldHVybiBmbnM7XG59XG5cbi8qKlxuICogQ2FsbHMgXCJzeW5jXCIgZnVuY3Rpb25zIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50J3Mgc3RhdGUuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfY2hhbmdlcyBXaGVuIGdpdmVuLCBvbmx5IHRoZSBwcm9wZXJ0aWVzIGluc2lkZSBpdCB3aWxsXG4gKiAgICAgYmUgc3luY2VkLiBPdGhlcndpc2UgYWxsIHN0YXRlIHByb3BlcnRpZXMgd2lsbCBiZSBzeW5jZWQuXG4gKi9cbmZ1bmN0aW9uIHN5bmNTdGF0ZShjb21wb25lbnQsIG9wdF9jaGFuZ2VzKSB7XG5cdHZhciBzeW5jRm5zID0gZ2V0U3luY0Zuc18oY29tcG9uZW50KTtcblx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRfY2hhbmdlcyB8fCBzeW5jRm5zKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGZuID0gc3luY0Zuc1trZXlzW2ldXTtcblx0XHRpZiAoKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShmbikpIHtcblx0XHRcdHZhciBjaGFuZ2UgPSBvcHRfY2hhbmdlcyAmJiBvcHRfY2hhbmdlc1trZXlzW2ldXTtcblx0XHRcdHZhciBtYW5hZ2VyID0gY29tcG9uZW50LmdldERhdGFNYW5hZ2VyKCk7XG5cdFx0XHRmbi5jYWxsKGNvbXBvbmVudCwgY2hhbmdlID8gY2hhbmdlLm5ld1ZhbCA6IG1hbmFnZXIuZ2V0KGNvbXBvbmVudCwga2V5c1tpXSksIGNoYW5nZSA/IGNoYW5nZS5wcmV2VmFsIDogdW5kZWZpbmVkKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL3N5bmMvc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jdXN0b21FdmVudHMgPSB1bmRlZmluZWQ7XG5leHBvcnRzLmFkZENsYXNzZXMgPSBhZGRDbGFzc2VzO1xuZXhwb3J0cy5jbG9zZXN0ID0gY2xvc2VzdDtcbmV4cG9ydHMuYXBwZW5kID0gYXBwZW5kO1xuZXhwb3J0cy5idWlsZEZyYWdtZW50ID0gYnVpbGRGcmFnbWVudDtcbmV4cG9ydHMuY29udGFpbnMgPSBjb250YWlucztcbmV4cG9ydHMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbmV4cG9ydHMuZW50ZXJEb2N1bWVudCA9IGVudGVyRG9jdW1lbnQ7XG5leHBvcnRzLmV4aXREb2N1bWVudCA9IGV4aXREb2N1bWVudDtcbmV4cG9ydHMuaGFzQ2xhc3MgPSBoYXNDbGFzcztcbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5leHBvcnRzLm1hdGNoID0gbWF0Y2g7XG5leHBvcnRzLm5leHQgPSBuZXh0O1xuZXhwb3J0cy5vbiA9IG9uO1xuZXhwb3J0cy5vbmNlID0gb25jZTtcbmV4cG9ydHMucGFyZW50ID0gcGFyZW50O1xuZXhwb3J0cy5yZWdpc3RlckN1c3RvbUV2ZW50ID0gcmVnaXN0ZXJDdXN0b21FdmVudDtcbmV4cG9ydHMucmVtb3ZlQ2hpbGRyZW4gPSByZW1vdmVDaGlsZHJlbjtcbmV4cG9ydHMucmVtb3ZlQ2xhc3NlcyA9IHJlbW92ZUNsYXNzZXM7XG5leHBvcnRzLnJlcGxhY2UgPSByZXBsYWNlO1xuZXhwb3J0cy5zdXBwb3J0c0V2ZW50ID0gc3VwcG9ydHNFdmVudDtcbmV4cG9ydHMudG9FbGVtZW50ID0gdG9FbGVtZW50O1xuZXhwb3J0cy50b2dnbGVDbGFzc2VzID0gdG9nZ2xlQ2xhc3NlcztcbmV4cG9ydHMudHJpZ2dlckV2ZW50ID0gdHJpZ2dlckV2ZW50O1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9kb21EYXRhID0gcmVxdWlyZSgnLi9kb21EYXRhJyk7XG5cbnZhciBfZG9tRGF0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb21EYXRhKTtcblxudmFyIF9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4vRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUnKTtcblxudmFyIF9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZSk7XG5cbnZhciBfRG9tRXZlbnRIYW5kbGUgPSByZXF1aXJlKCcuL0RvbUV2ZW50SGFuZGxlJyk7XG5cbnZhciBfRG9tRXZlbnRIYW5kbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRG9tRXZlbnRIYW5kbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgZWxlbWVudHNCeVRhZ18gPSB7fTtcbnZhciBzdXBwb3J0Q2FjaGVfID0ge307XG52YXIgY3VzdG9tRXZlbnRzID0gZXhwb3J0cy5jdXN0b21FdmVudHMgPSB7fTtcblxudmFyIExBU1RfQ09OVEFJTkVSID0gJ19fbWV0YWxfbGFzdF9jb250YWluZXJfXyc7XG52YXIgVVNFX0NBUFRVUkUgPSB7XG5cdGJsdXI6IHRydWUsXG5cdGVycm9yOiB0cnVlLFxuXHRmb2N1czogdHJ1ZSxcblx0aW52YWxpZDogdHJ1ZSxcblx0bG9hZDogdHJ1ZSxcblx0c2Nyb2xsOiB0cnVlXG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyB0byBhbiBlbGVtZW50LlxuICogQHBhcmFtIHshRWxlbWVudHwhTm9kZWxpc3R9IGVsZW1lbnRzIFRoZSBlbGVtZW50IG9yIGVsZW1lbnRzIHRvIGFkZCBDU1MgY2xhc3NlcyB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIENTUyBjbGFzc2VzIHRvIGFkZC5cbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NlcyhlbGVtZW50cywgY2xhc3Nlcykge1xuXHRpZiAoISgwLCBfbWV0YWwuaXNPYmplY3QpKGVsZW1lbnRzKSB8fCAhKDAsIF9tZXRhbC5pc1N0cmluZykoY2xhc3NlcykpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoJ2NsYXNzTGlzdCcgaW4gZWxlbWVudHNbaV0pIHtcblx0XHRcdGFkZENsYXNzZXNXaXRoTmF0aXZlXyhlbGVtZW50c1tpXSwgY2xhc3Nlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFkZENsYXNzZXNXaXRob3V0TmF0aXZlXyhlbGVtZW50c1tpXSwgY2xhc3Nlcyk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgcmVxdWVzdGVkIENTUyBjbGFzc2VzIHRvIGFuIGVsZW1lbnQgdXNpbmcgY2xhc3NMaXN0LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgQ1NTIGNsYXNzZXMgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byBhZGQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHRjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0aWYgKGNsYXNzTmFtZSkge1xuXHRcdFx0ZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBBZGRzIHRoZSByZXF1ZXN0ZWQgQ1NTIGNsYXNzZXMgdG8gYW4gZWxlbWVudCB3aXRob3V0IHVzaW5nIGNsYXNzTGlzdC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYWRkIENTUyBjbGFzc2VzIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgQ1NTIGNsYXNzZXMgdG8gYWRkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0dmFyIGVsZW1lbnRDbGFzc05hbWUgPSAnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJztcblx0dmFyIGNsYXNzZXNUb0FwcGVuZCA9ICcnO1xuXG5cdGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJyk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNsYXNzTmFtZSA9IGNsYXNzZXNbaV07XG5cblx0XHRpZiAoZWxlbWVudENsYXNzTmFtZS5pbmRleE9mKCcgJyArIGNsYXNzTmFtZSArICcgJykgPT09IC0xKSB7XG5cdFx0XHRjbGFzc2VzVG9BcHBlbmQgKz0gJyAnICsgY2xhc3NOYW1lO1xuXHRcdH1cblx0fVxuXG5cdGlmIChjbGFzc2VzVG9BcHBlbmQpIHtcblx0XHRlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgY2xhc3Nlc1RvQXBwZW5kO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgZ2l2ZW4gZWxlbWVudCwgdG8gYmUgdHJpZ2dlcmVkIHZpYSBkZWxlZ2F0ZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGxpc3RlbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRFbGVtZW50TGlzdGVuZXJfKGVsZW1lbnQsIGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0YWRkVG9BcnJfKF9kb21EYXRhMi5kZWZhdWx0LmdldChlbGVtZW50LCAnbGlzdGVuZXJzJywge30pLCBldmVudE5hbWUsIGxpc3RlbmVyKTtcbn1cblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBnaXZlbiBlbGVtZW50LCB0byBiZSB0cmlnZ2VyZWQgdmlhIGRlbGVnYXRlXG4gKiBzZWxlY3RvcnMuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGxpc3RlbmVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRTZWxlY3Rvckxpc3RlbmVyXyhlbGVtZW50LCBldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcikge1xuXHR2YXIgZGVsZWdhdGluZ0RhdGEgPSBfZG9tRGF0YTIuZGVmYXVsdC5nZXQoZWxlbWVudCwgJ2RlbGVnYXRpbmcnLCB7fSk7XG5cdGFkZFRvQXJyXyhkZWxlZ2F0aW5nRGF0YVtldmVudE5hbWVdLnNlbGVjdG9ycywgc2VsZWN0b3IsIGxpc3RlbmVyKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgdmFsdWUgdG8gYW4gYXJyYXkgaW5zaWRlIGFuIG9iamVjdCwgY3JlYXRpbmcgaXQgZmlyc3QgaWYgaXQgZG9lc24ndFxuICogeWV0IGV4aXN0LlxuICogQHBhcmFtIHshQXJyYXl9IGFyclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkVG9BcnJfKGFyciwga2V5LCB2YWx1ZSkge1xuXHRpZiAoIWFycltrZXldKSB7XG5cdFx0YXJyW2tleV0gPSBbXTtcblx0fVxuXHRhcnJba2V5XS5wdXNoKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBdHRhY2hlcyBhIGRlbGVnYXRlIGxpc3RlbmVyLCB1bmxlc3MgdGhlcmUncyBhbHJlYWR5IG9uZSBhdHRhY2hlZC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaERlbGVnYXRlRXZlbnRfKGVsZW1lbnQsIGV2ZW50TmFtZSkge1xuXHR2YXIgZGVsZWdhdGluZ0RhdGEgPSBfZG9tRGF0YTIuZGVmYXVsdC5nZXQoZWxlbWVudCwgJ2RlbGVnYXRpbmcnLCB7fSk7XG5cdGlmICghZGVsZWdhdGluZ0RhdGFbZXZlbnROYW1lXSkge1xuXHRcdGRlbGVnYXRpbmdEYXRhW2V2ZW50TmFtZV0gPSB7XG5cdFx0XHRoYW5kbGU6IG9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgaGFuZGxlRGVsZWdhdGVFdmVudF8sICEhVVNFX0NBUFRVUkVbZXZlbnROYW1lXSksXG5cdFx0XHRzZWxlY3RvcnM6IHt9XG5cdFx0fTtcblx0fVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGNsb3Nlc3QgZWxlbWVudCB1cCB0aGUgdHJlZSBmcm9tIHRoZSBnaXZlbiBlbGVtZW50IChpbmNsdWRpbmdcbiAqIGl0c2VsZikgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgc2VsZWN0b3IsIG9yIG51bGwgaWYgbm9uZSBtYXRjaC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdHdoaWxlIChlbGVtZW50ICYmICFtYXRjaChlbGVtZW50LCBzZWxlY3RvcikpIHtcblx0XHRlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXHR9XG5cdHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgYSBjaGlsZCBub2RlIHdpdGggdGV4dCBvciBvdGhlciBub2RlcyB0byBhIHBhcmVudCBub2RlLiBJZlxuICogY2hpbGQgaXMgYSBIVE1MIHN0cmluZyBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGEgZG9jdW1lbnRcbiAqIGZyYWdtZW50IGJlZm9yZSBhcHBlbmRpbmcgaXQgdG8gdGhlIHBhcmVudC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IHBhcmVudCBUaGUgbm9kZSB0byBhcHBlbmQgbm9kZXMgdG8uXG4gKiBAcGFyYW0geyEoRWxlbWVudHxOb2RlTGlzdHxzdHJpbmcpfSBjaGlsZCBUaGUgdGhpbmcgdG8gYXBwZW5kIHRvIHRoZSBwYXJlbnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGFwcGVuZGVkIGNoaWxkLlxuICovXG5mdW5jdGlvbiBhcHBlbmQocGFyZW50LCBjaGlsZCkge1xuXHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoY2hpbGQpKSB7XG5cdFx0Y2hpbGQgPSBidWlsZEZyYWdtZW50KGNoaWxkKTtcblx0fVxuXHRpZiAoY2hpbGQgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuXHRcdHZhciBjaGlsZEFyciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNoaWxkKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkQXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGRBcnJbaV0pO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHR9XG5cdHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNvbnZlcnRpbmcgYSBIVE1MIHN0cmluZyBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFN0cmluZyBUaGUgSFRNTCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgcmVzdWx0aW5nIGRvY3VtZW50IGZyYWdtZW50LlxuICovXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KGh0bWxTdHJpbmcpIHtcblx0dmFyIHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0dGVtcERpdi5pbm5lckhUTUwgPSAnPGJyPicgKyBodG1sU3RyaW5nO1xuXHR0ZW1wRGl2LnJlbW92ZUNoaWxkKHRlbXBEaXYuZmlyc3RDaGlsZCk7XG5cblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHR3aGlsZSAodGVtcERpdi5maXJzdENoaWxkKSB7XG5cdFx0ZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGVtcERpdi5maXJzdENoaWxkKTtcblx0fVxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBmaXJzdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBzZWNvbmQgb25lLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudDFcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWlucyhlbGVtZW50MSwgZWxlbWVudDIpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNEb2N1bWVudCkoZWxlbWVudDEpKSB7XG5cdFx0Ly8gZG9jdW1lbnQuY29udGFpbnMgaXMgbm90IGRlZmluZWQgb24gSUU5LCBzbyBjYWxsIGl0IG9uIGRvY3VtZW50RWxlbWVudCBpbnN0ZWFkLlxuXHRcdHJldHVybiBlbGVtZW50MS5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZWxlbWVudDIpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBlbGVtZW50MS5jb250YWlucyhlbGVtZW50Mik7XG5cdH1cbn1cblxuLyoqXG4gKiBMaXN0ZW5zIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQgb24gdGhlIGdpdmVuIERPTSBlbGVtZW50LCBidXQgb25seSBjYWxscyB0aGVcbiAqIGdpdmVuIGNhbGxiYWNrIGxpc3RlbmVyIHdoZW4gaXQncyB0cmlnZ2VyZWQgYnkgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGVcbiAqIGdpdmVuIHNlbGVjdG9yIG9yIHRhcmdldCBlbGVtZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdGhlIGV2ZW50IHNob3VsZCBiZSBsaXN0ZW5lZCBvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAqIEBwYXJhbSB7IUVsZW1lbnR8c3RyaW5nfSBzZWxlY3Rvck9yVGFyZ2V0IEVpdGhlciBhbiBlbGVtZW50IG9yIGNzcyBzZWxlY3RvclxuICogICAgIHRoYXQgc2hvdWxkIG1hdGNoIHRoZSBldmVudCBmb3IgdGhlIGxpc3RlbmVyIHRvIGJlIHRyaWdnZXJlZC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFPYmplY3QpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnRcbiAqICAgICBpcyB0cmlnZ2VyZWQuIEl0IHdpbGwgcmVjZWl2ZSB0aGUgbm9ybWFsaXplZCBldmVudCBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfZGVmYXVsdCBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpcyBhIGRlZmF1bHRcbiAqICAgICBsaXN0ZW5lci4gVGhhdCBtZWFucyB0aGF0IGl0IHdvdWxkIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIG5vblxuICogICAgIGRlZmF1bHQgbGlzdGVuZXJzLCBhbmQgb25seSBpZiB0aGUgZXZlbnQgaXNuJ3QgcHJldmVudGVkIHZpYVxuICogICAgIGBwcmV2ZW50RGVmYXVsdGAuXG4gKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGRlbGVnYXRlKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3JPclRhcmdldCwgY2FsbGJhY2ssIG9wdF9kZWZhdWx0KSB7XG5cdHZhciBjdXN0b21Db25maWcgPSBjdXN0b21FdmVudHNbZXZlbnROYW1lXTtcblx0aWYgKGN1c3RvbUNvbmZpZyAmJiBjdXN0b21Db25maWcuZGVsZWdhdGUpIHtcblx0XHRldmVudE5hbWUgPSBjdXN0b21Db25maWcub3JpZ2luYWxFdmVudDtcblx0XHRjYWxsYmFjayA9IGN1c3RvbUNvbmZpZy5oYW5kbGVyLmJpbmQoY3VzdG9tQ29uZmlnLCBjYWxsYmFjayk7XG5cdH1cblxuXHRpZiAob3B0X2RlZmF1bHQpIHtcblx0XHQvLyBXcmFwIGNhbGxiYWNrIHNvIHdlIGRvbid0IHNldCBwcm9wZXJ0eSBkaXJlY3RseSBvbiBpdC5cblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrLmJpbmQoKTtcblx0XHRjYWxsYmFjay5kZWZhdWx0TGlzdGVuZXJfID0gdHJ1ZTtcblx0fVxuXG5cdGF0dGFjaERlbGVnYXRlRXZlbnRfKGVsZW1lbnQsIGV2ZW50TmFtZSk7XG5cdGlmICgoMCwgX21ldGFsLmlzU3RyaW5nKShzZWxlY3Rvck9yVGFyZ2V0KSkge1xuXHRcdGFkZFNlbGVjdG9yTGlzdGVuZXJfKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3JPclRhcmdldCwgY2FsbGJhY2spO1xuXHR9IGVsc2Uge1xuXHRcdGFkZEVsZW1lbnRMaXN0ZW5lcl8oc2VsZWN0b3JPclRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjayk7XG5cdH1cblxuXHRyZXR1cm4gbmV3IF9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZTIuZGVmYXVsdCgoMCwgX21ldGFsLmlzU3RyaW5nKShzZWxlY3Rvck9yVGFyZ2V0KSA/IGVsZW1lbnQgOiBzZWxlY3Rvck9yVGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrLCAoMCwgX21ldGFsLmlzU3RyaW5nKShzZWxlY3Rvck9yVGFyZ2V0KSA/IHNlbGVjdG9yT3JUYXJnZXQgOiBudWxsKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyBpZiB0aGUgZWxlbWVudCBpcyBhYmxlIHRvIHRyaWdnZXIgdGhlIENsaWNrIGV2ZW50LFxuICogc2ltdWxhdGluZyBicm93c2VycyBiZWhhdmlvdXIsIGF2b2lkaW5nIGV2ZW50IGxpc3RlbmVycyB0byBiZSBjYWxsZWQgYnkgdHJpZ2dlckV2ZW50IG1ldGhvZC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNBYmxlVG9JbnRlcmFjdFdpdGhfKG5vZGUsIGV2ZW50TmFtZSwgb3B0X2V2ZW50T2JqKSB7XG5cdGlmIChvcHRfZXZlbnRPYmogJiYgZXZlbnROYW1lID09PSAnY2xpY2snICYmIG9wdF9ldmVudE9iai5idXR0b24gPT09IDIpIHtcblx0XHQvLyBGaXJlZm94IHRyaWdnZXJzIFwiY2xpY2tcIiBldmVudHMgb24gdGhlIGRvY3VtZW50IGZvciByaWdodCBjbGlja3MuIFRoaXNcblx0XHQvLyBjYXVzZXMgb3VyIGRlbGVnYXRlIGxvZ2ljIHRvIHRyaWdnZXIgaXQgZm9yIHJlZ3VsYXIgZWxlbWVudHMgdG9vLCB3aGljaFxuXHRcdC8vIHNob3VsZG4ndCBoYXBwZW4uIElnbm9yaW5nIHRoZW0gaGVyZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgbWF0Y2hlc1NlbGVjdG9yID0gWydCVVRUT04nLCAnSU5QVVQnLCAnU0VMRUNUJywgJ1RFWFRBUkVBJywgJ0ZJRUxEU0VUJ107XG5cdGlmIChldmVudE5hbWUgPT09ICdjbGljaycgJiYgbWF0Y2hlc1NlbGVjdG9yLmluZGV4T2Yobm9kZS50YWdOYW1lKSA+IC0xKSB7XG5cdFx0cmV0dXJuICEobm9kZS5kaXNhYmxlZCB8fCBwYXJlbnQobm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXScpKTtcblx0fVxuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIG5vZGUgaW4gZG9jdW1lbnQgYXMgbGFzdCBlbGVtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGVudGVyRG9jdW1lbnQobm9kZSkge1xuXHRub2RlICYmIGFwcGVuZChkb2N1bWVudC5ib2R5LCBub2RlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIG5vZGUgZnJvbSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBjaGlsZHJlbiBmcm9tLlxuICovXG5mdW5jdGlvbiBleGl0RG9jdW1lbnQobm9kZSkge1xuXHRpZiAobm9kZSAmJiBub2RlLnBhcmVudE5vZGUpIHtcblx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGFuIGV2ZW50IGlzIHRyaWdnZXJlZCBieSBhIGRlbGVnYXRlIGxpc3RlbmVyLiBBbGxcbiAqIG1hdGNoaW5nIGxpc3RlbmVycyBvZiB0aGlzIGV2ZW50IHR5cGUgZnJvbSBgdGFyZ2V0YCB0byBgY3VycmVudFRhcmdldGAgd2lsbFxuICogYmUgdHJpZ2dlcmVkLlxuICogQHBhcmFtIHshRXZlbnR9IGV2ZW50IFRoZSBldmVudCBwYXlsb2FkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB0cmlnZ2VyZWQgY2FsbGJhY2tzIHJldHVybnNcbiAqICAgICBmYWxzZSwgb3IgdHJ1ZSBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVEZWxlZ2F0ZUV2ZW50XyhldmVudCkge1xuXHRub3JtYWxpemVEZWxlZ2F0ZUV2ZW50XyhldmVudCk7XG5cdHZhciByZXQgPSB0cnVlO1xuXHR2YXIgY29udGFpbmVyID0gZXZlbnQuY3VycmVudFRhcmdldDtcblx0dmFyIGRlZkZucyA9IFtdO1xuXG5cdHJldCAmPSB0cmlnZ2VyRGVsZWdhdGVkTGlzdGVuZXJzXyhjb250YWluZXIsIGV2ZW50LCBkZWZGbnMpO1xuXHRyZXQgJj0gdHJpZ2dlckRlZmF1bHREZWxlZ2F0ZWRMaXN0ZW5lcnNfKGRlZkZucywgZXZlbnQpO1xuXG5cdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gbnVsbDtcblx0ZXZlbnRbTEFTVF9DT05UQUlORVJdID0gY29udGFpbmVyO1xuXHRyZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBjc3MgY2xhc3MuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0aWYgKCdjbGFzc0xpc3QnIGluIGVsZW1lbnQpIHtcblx0XHRyZXR1cm4gaGFzQ2xhc3NXaXRoTmF0aXZlXyhlbGVtZW50LCBjbGFzc05hbWUpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBoYXNDbGFzc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgY3NzIGNsYXNzIHVzaW5nIGNsYXNzTGlzdC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYXNDbGFzc1dpdGhOYXRpdmVfKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRyZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgY3NzIGNsYXNzIHdpdGhvdXQgdXNpbmcgY2xhc3NMaXN0LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG5cdHJldHVybiAoJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA+PSAwO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBlbXB0eSBvciBub3QuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KGVsZW1lbnQpIHtcblx0cmV0dXJuIGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDA7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBtYXRjaGVzIGEgZ2l2ZW4gc2VsZWN0b3IuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbWF0Y2goZWxlbWVudCwgc2VsZWN0b3IpIHtcblx0aWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHR2YXIgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xuXHR2YXIgbSA9IHAubWF0Y2hlcyB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHAub01hdGNoZXNTZWxlY3Rvcjtcblx0aWYgKG0pIHtcblx0XHRyZXR1cm4gbS5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcblx0fVxuXG5cdHJldHVybiBtYXRjaEZhbGxiYWNrXyhlbGVtZW50LCBzZWxlY3Rvcik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYW4gZWxlbWVudCBtYXRjaGVzIGEgZ2l2ZW4gc2VsZWN0b3IsIHVzaW5nIGFuIGludGVybmFsIGltcGxlbWVudGF0aW9uXG4gKiBpbnN0ZWFkIG9mIGNhbGxpbmcgZXhpc3RpbmcgamF2YXNjcmlwdCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hdGNoRmFsbGJhY2tfKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGVsZW1lbnQucGFyZW50Tm9kZSk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcblx0XHRpZiAobm9kZXNbaV0gPT09IGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBnaXZlbiBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkXG4gKiBzZWxlY3Rvciwgb3IgbnVsbCBpZiB0aGVyZSBpcyBub25lLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHs/c3RyaW5nfSBzZWxlY3RvclxuICovXG5mdW5jdGlvbiBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdGRvIHtcblx0XHRlbGVtZW50ID0gZWxlbWVudC5uZXh0U2libGluZztcblx0XHRpZiAoZWxlbWVudCAmJiBtYXRjaChlbGVtZW50LCBzZWxlY3RvcikpIHtcblx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdH1cblx0fSB3aGlsZSAoZWxlbWVudCk7XG5cdHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgdGhlIGV2ZW50IHBheWxvYWQgZm9yIGRlbGVnYXRlIGxpc3RlbmVycy5cbiAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRGVsZWdhdGVFdmVudF8oZXZlbnQpIHtcblx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gc3RvcFByb3BhZ2F0aW9uXztcblx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uID0gc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uXztcbn1cblxuLyoqXG4gKiBMaXN0ZW5zIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQgb24gdGhlIGdpdmVuIERPTSBlbGVtZW50LiBUaGlzIGZ1bmN0aW9uIG5vcm1hbGl6ZXNcbiAqIERPTSBldmVudCBwYXlsb2FkcyBhbmQgZnVuY3Rpb25zIHNvIHRoZXknbGwgd29yayB0aGUgc2FtZSB3YXkgb24gYWxsIHN1cHBvcnRlZFxuICogYnJvd3NlcnMuXG4gKiBAcGFyYW0geyFFbGVtZW50fHN0cmluZ30gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gbGlzdGVuIHRvIHRoZSBldmVudCBvbiwgb3JcbiAqICAgYSBzZWxlY3RvciB0aGF0IHNob3VsZCBiZSBkZWxlZ2F0ZWQgb24gdGhlIGVudGlyZSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFPYmplY3QpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXNcbiAqICAgdHJpZ2dlcmVkLiBJdCB3aWxsIHJlY2VpdmUgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBvcHRfY2FwdHVyZSBGbGFnIGluZGljYXRpbmcgaWYgbGlzdGVuZXIgc2hvdWxkIGJlIHRyaWdnZXJlZFxuICogICBkdXJpbmcgY2FwdHVyZSBwaGFzZSwgaW5zdGVhZCBvZiBkdXJpbmcgdGhlIGJ1YmJsaW5nIHBoYXNlLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAqIEByZXR1cm4geyFEb21FdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gb24oZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0X2NhcHR1cmUpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKGVsZW1lbnQpKSB7XG5cdFx0cmV0dXJuIGRlbGVnYXRlKGRvY3VtZW50LCBldmVudE5hbWUsIGVsZW1lbnQsIGNhbGxiYWNrKTtcblx0fVxuXHR2YXIgY3VzdG9tQ29uZmlnID0gY3VzdG9tRXZlbnRzW2V2ZW50TmFtZV07XG5cdGlmIChjdXN0b21Db25maWcgJiYgY3VzdG9tQ29uZmlnLmV2ZW50KSB7XG5cdFx0ZXZlbnROYW1lID0gY3VzdG9tQ29uZmlnLm9yaWdpbmFsRXZlbnQ7XG5cdFx0Y2FsbGJhY2sgPSBjdXN0b21Db25maWcuaGFuZGxlci5iaW5kKGN1c3RvbUNvbmZpZywgY2FsbGJhY2spO1xuXHR9XG5cdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRfY2FwdHVyZSk7XG5cdHJldHVybiBuZXcgX0RvbUV2ZW50SGFuZGxlMi5kZWZhdWx0KGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdF9jYXB0dXJlKTtcbn1cblxuLyoqXG4gKiBMaXN0ZW5zIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQgb24gdGhlIGdpdmVuIERPTSBlbGVtZW50IG9uY2UuIFRoaXNcbiAqIGZ1bmN0aW9uIG5vcm1hbGl6ZXMgRE9NIGV2ZW50IHBheWxvYWRzIGFuZCBmdW5jdGlvbnMgc28gdGhleSdsbCB3b3JrIHRoZVxuICogc2FtZSB3YXkgb24gYWxsIHN1cHBvcnRlZCBicm93c2Vycy5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIERPTSBlbGVtZW50IHRvIGxpc3RlbiB0byB0aGUgZXZlbnQgb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG8uXG4gKiBAcGFyYW0geyFmdW5jdGlvbighT2JqZWN0KX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50XG4gKiAgIGlzIHRyaWdnZXJlZC4gSXQgd2lsbCByZWNlaXZlIHRoZSBub3JtYWxpemVkIGV2ZW50IG9iamVjdC5cbiAqIEByZXR1cm4geyFEb21FdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gb25jZShlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrKSB7XG5cdHZhciBkb21FdmVudEhhbmRsZSA9IG9uKGVsZW1lbnQsIGV2ZW50TmFtZSwgZnVuY3Rpb24gKCkge1xuXHRcdGRvbUV2ZW50SGFuZGxlLnJlbW92ZUxpc3RlbmVyKCk7XG5cdFx0cmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0pO1xuXHRyZXR1cm4gZG9tRXZlbnRIYW5kbGU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZmlyc3QgcGFyZW50IGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWRcbiAqIHNlbGVjdG9yLCBvciBudWxsIGlmIG5vbmUgbWF0Y2guXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIHBhcmVudChlbGVtZW50LCBzZWxlY3Rvcikge1xuXHRyZXR1cm4gY2xvc2VzdChlbGVtZW50LnBhcmVudE5vZGUsIHNlbGVjdG9yKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBjdXN0b20gZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZXZlbnQuXG4gKiBAcGFyYW0geyFPYmplY3R9IGN1c3RvbUNvbmZpZyBBbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBob3cgdGhlIGV2ZW50XG4gKiAgIHNob3VsZCBiZSBoYW5kbGVkLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgY3VzdG9tQ29uZmlnKSB7XG5cdGN1c3RvbUV2ZW50c1tldmVudE5hbWVdID0gY3VzdG9tQ29uZmlnO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIHRoZSBjaGlsZCBub2RlcyBvbiBhIERPTSBub2RlLlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKG5vZGUpIHtcblx0dmFyIGNoaWxkID0gdm9pZCAwO1xuXHR3aGlsZSAoY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQpIHtcblx0XHRub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0fVxufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyBmcm9tIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fCFOb2RlTGlzdH0gZWxlbWVudHMgVGhlIGVsZW1lbnQgb3IgZWxlbWVudHMgdG8gcmVtb3ZlIENTUyBjbGFzc2VzIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoZWxlbWVudHMsIGNsYXNzZXMpIHtcblx0aWYgKCEoMCwgX21ldGFsLmlzT2JqZWN0KShlbGVtZW50cykgfHwgISgwLCBfbWV0YWwuaXNTdHJpbmcpKGNsYXNzZXMpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCFlbGVtZW50cy5sZW5ndGgpIHtcblx0XHRlbGVtZW50cyA9IFtlbGVtZW50c107XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKCdjbGFzc0xpc3QnIGluIGVsZW1lbnRzW2ldKSB7XG5cdFx0XHRyZW1vdmVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudHNbaV0sIGNsYXNzZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmVDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudHNbaV0sIGNsYXNzZXMpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyBmcm9tIGFuIGVsZW1lbnQgdXNpbmcgY2xhc3NMaXN0LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byByZW1vdmUgQ1NTIGNsYXNzZXMgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIENTUyBjbGFzc2VzIHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzZXNXaXRoTmF0aXZlXyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRpZiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyBmcm9tIGFuIGVsZW1lbnQgd2l0aG91dCB1c2luZyBjbGFzc0xpc3QuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZSBDU1MgY2xhc3NlcyBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgQ1NTIGNsYXNzZXMgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0dmFyIGVsZW1lbnRDbGFzc05hbWUgPSAnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJztcblxuXHRjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgnICcpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuXHRcdGVsZW1lbnRDbGFzc05hbWUgPSBlbGVtZW50Q2xhc3NOYW1lLnJlcGxhY2UoJyAnICsgY2xhc3Nlc1tpXSArICcgJywgJyAnKTtcblx0fVxuXG5cdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudENsYXNzTmFtZS50cmltKCk7XG59XG5cbi8qKlxuICogUmVwbGFjZXMgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGUgc2Vjb25kLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50MVxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50MlxuICovXG5mdW5jdGlvbiByZXBsYWNlKGVsZW1lbnQxLCBlbGVtZW50Mikge1xuXHRpZiAoZWxlbWVudDEgJiYgZWxlbWVudDIgJiYgZWxlbWVudDEgIT09IGVsZW1lbnQyICYmIGVsZW1lbnQxLnBhcmVudE5vZGUpIHtcblx0XHRlbGVtZW50MS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50MiwgZWxlbWVudDEpO1xuXHRcdGVsZW1lbnQxLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudDEpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIGZ1bmN0aW9uIHRoYXQgcmVwbGFjZXMgYHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbl9gIGZvciBldmVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25fKCkge1xuXHR2YXIgZXZlbnQgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdGV2ZW50LnN0b3BwZWQgPSB0cnVlO1xuXHRldmVudC5zdG9wcGVkSW1tZWRpYXRlID0gdHJ1ZTtcblx0RXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbi5jYWxsKGV2ZW50KTtcbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gdGhhdCByZXBsYWNlcyBgc3RvcFByb3BhZ2F0aW9uYCBmb3IgZXZlbnRzLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uXygpIHtcblx0dmFyIGV2ZW50ID0gdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRldmVudC5zdG9wcGVkID0gdHJ1ZTtcblx0RXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5jYWxsKGV2ZW50KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgc3VwcG9ydHMgdGhlIGdpdmVuIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0geyFFbGVtZW50fHN0cmluZ30gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgb3IgZWxlbWVudCB0YWcgbmFtZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gc3VwcG9ydHNFdmVudChlbGVtZW50LCBldmVudE5hbWUpIHtcblx0aWYgKGN1c3RvbUV2ZW50c1tldmVudE5hbWVdKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoZWxlbWVudCkpIHtcblx0XHRpZiAoIWVsZW1lbnRzQnlUYWdfW2VsZW1lbnRdKSB7XG5cdFx0XHRlbGVtZW50c0J5VGFnX1tlbGVtZW50XSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxlbWVudCk7XG5cdFx0fVxuXHRcdGVsZW1lbnQgPSBlbGVtZW50c0J5VGFnX1tlbGVtZW50XTtcblx0fVxuXG5cdHZhciB0YWcgPSBlbGVtZW50LnRhZ05hbWU7XG5cdGlmICghc3VwcG9ydENhY2hlX1t0YWddIHx8ICFzdXBwb3J0Q2FjaGVfW3RhZ10uaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuXHRcdHN1cHBvcnRDYWNoZV9bdGFnXSA9IHN1cHBvcnRDYWNoZV9bdGFnXSB8fCB7fTtcblx0XHRzdXBwb3J0Q2FjaGVfW3RhZ11bZXZlbnROYW1lXSA9ICdvbicgKyBldmVudE5hbWUgaW4gZWxlbWVudDtcblx0fVxuXHRyZXR1cm4gc3VwcG9ydENhY2hlX1t0YWddW2V2ZW50TmFtZV07XG59XG5cbi8qKlxuICogVGhpcyB0cmlnZ2VycyBhbGwgZGVmYXVsdCBtYXRjaGVkIGRlbGVnYXRlZCBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudCB0eXBlLlxuICogQHBhcmFtIHshQXJyYXl9IGRlZmF1bHRGbnMgQXJyYXkgdG8gY29sbGVjdCBkZWZhdWx0IGxpc3RlbmVycyBpbiwgaW5zdGVhZFxuICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRyaWdnZXJlZCBjYWxsYmFja3MgcmV0dXJuc1xuICogICAgIGZhbHNlLCBvciB0cnVlIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEZWZhdWx0RGVsZWdhdGVkTGlzdGVuZXJzXyhkZWZGbnMsIGV2ZW50KSB7XG5cdHZhciByZXQgPSB0cnVlO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZGVmRm5zLmxlbmd0aCAmJiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDsgaSsrKSB7XG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBkZWZGbnNbaV0uZWxlbWVudDtcblx0XHRyZXQgJj0gZGVmRm5zW2ldLmZuKGV2ZW50KTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVGhpcyB0cmlnZ2VycyBhbGwgbWF0Y2hlZCBkZWxlZ2F0ZWQgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQgdHlwZSB3aGVuIGl0c1xuICogZGVsZWdhdGVkIHRhcmdldCBpcyBhYmxlIHRvIGludGVyYWN0LlxuICogQHBhcmFtIHshRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7IUFycmF5fSBkZWZhdWx0Rm5zIEFycmF5IHRvIGNvbGxlY3QgZGVmYXVsdCBsaXN0ZW5lcnMgaW4sIGluc3RlYWRcbiAqICAgICBvZiBydW5uaW5nIHRoZW0uXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRyaWdnZXJlZCBjYWxsYmFja3MgcmV0dXJuc1xuICogICAgIGZhbHNlLCBvciB0cnVlIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJEZWxlZ2F0ZWRMaXN0ZW5lcnNfKGNvbnRhaW5lciwgZXZlbnQsIGRlZmF1bHRGbnMpIHtcblx0dmFyIHJldCA9IHRydWU7XG5cdHZhciBjdXJyRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcblx0dmFyIGxpbWl0ID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG5cblx0d2hpbGUgKGN1cnJFbGVtZW50ICYmIGN1cnJFbGVtZW50ICE9PSBsaW1pdCAmJiAhZXZlbnQuc3RvcHBlZCkge1xuXHRcdGlmIChpc0FibGVUb0ludGVyYWN0V2l0aF8oY3VyckVsZW1lbnQsIGV2ZW50LnR5cGUsIGV2ZW50KSkge1xuXHRcdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBjdXJyRWxlbWVudDtcblx0XHRcdHJldCAmPSB0cmlnZ2VyRWxlbWVudExpc3RlbmVyc18oY3VyckVsZW1lbnQsIGV2ZW50LCBkZWZhdWx0Rm5zKTtcblx0XHRcdHJldCAmPSB0cmlnZ2VyU2VsZWN0b3JMaXN0ZW5lcnNfKGNvbnRhaW5lciwgY3VyckVsZW1lbnQsIGV2ZW50LCBkZWZhdWx0Rm5zKTtcblx0XHR9XG5cdFx0Y3VyckVsZW1lbnQgPSBjdXJyRWxlbWVudC5wYXJlbnROb2RlO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYSBET00gZWxlbWVudC4gU3RyaW5ncyBhcmUgYXNzdW1lZCB0b1xuICogYmUgc2VsZWN0b3JzLCBhbmQgc28gYSBtYXRjaGVkIGVsZW1lbnQgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlIGFyZ1xuICogaXMgYWxyZWFkeSBhIERPTSBlbGVtZW50IGl0IHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnR8RG9jdW1lbnR9IHNlbGVjdG9yT3JFbGVtZW50XG4gKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgY29udmVydGVkIGVsZW1lbnQsIG9yIG51bGwgaWYgbm9uZSB3YXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIHRvRWxlbWVudChzZWxlY3Rvck9yRWxlbWVudCkge1xuXHRpZiAoKDAsIF9tZXRhbC5pc0VsZW1lbnQpKHNlbGVjdG9yT3JFbGVtZW50KSB8fCAoMCwgX21ldGFsLmlzRG9jdW1lbnQpKHNlbGVjdG9yT3JFbGVtZW50KSB8fCAoMCwgX21ldGFsLmlzRG9jdW1lbnRGcmFnbWVudCkoc2VsZWN0b3JPckVsZW1lbnQpKSB7XG5cdFx0cmV0dXJuIHNlbGVjdG9yT3JFbGVtZW50O1xuXHR9IGVsc2UgaWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKHNlbGVjdG9yT3JFbGVtZW50KSkge1xuXHRcdGlmIChzZWxlY3Rvck9yRWxlbWVudFswXSA9PT0gJyMnICYmIHNlbGVjdG9yT3JFbGVtZW50LmluZGV4T2YoJyAnKSA9PT0gLTEpIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvck9yRWxlbWVudC5zdWJzdHIoMSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvck9yRWxlbWVudCk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIG9uZSBvciBtb3JlIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50LiBJZiBhbnkgb2YgdGhlIGNsYXNzZXNcbiAqIGlzIHByZXNlbnQsIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50LCBvciBhZGRlZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdoaWNoIGNsYXNzZXMgd2lsbCBiZSB0b2dnbGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgVGhlIGNsYXNzZXMgd2hpY2ggaGF2ZSB0byBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzZXMoZWxlbWVudCwgY2xhc3Nlcykge1xuXHRpZiAoISgwLCBfbWV0YWwuaXNPYmplY3QpKGVsZW1lbnQpIHx8ICEoMCwgX21ldGFsLmlzU3RyaW5nKShjbGFzc2VzKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICgnY2xhc3NMaXN0JyBpbiBlbGVtZW50KSB7XG5cdFx0dG9nZ2xlQ2xhc3Nlc1dpdGhOYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpO1xuXHR9IGVsc2Uge1xuXHRcdHRvZ2dsZUNsYXNzZXNXaXRob3V0TmF0aXZlXyhlbGVtZW50LCBjbGFzc2VzKTtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBvbmUgb3IgbW9yZSBjbGFzc2VzIGZyb20gYW4gZWxlbWVudCB1c2luZyBjbGFzc0xpc3QuXG4gKiBJZiBhbnkgb2YgdGhlIGNsYXNzZXMgaXMgcHJlc2VudCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQsXG4gKiBvciBhZGRlZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdoaWNoIGNsYXNzZXMgd2lsbCBiZSB0b2dnbGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgVGhlIGNsYXNzZXMgd2hpY2ggaGF2ZSB0byBhZGRlZCBvciByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0b2dnbGVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHRjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG5cdFx0ZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIEFkZHMgb3IgcmVtb3ZlcyBvbmUgb3IgbW9yZSBjbGFzc2VzIGZyb20gYW4gZWxlbWVudCB3aXRob3V0IHVzaW5nIGNsYXNzTGlzdC5cbiAqIElmIGFueSBvZiB0aGUgY2xhc3NlcyBpcyBwcmVzZW50LCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCxcbiAqIG9yIGFkZGVkIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd2hpY2ggY2xhc3NlcyB3aWxsIGJlIHRvZ2dsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBUaGUgY2xhc3NlcyB3aGljaCBoYXZlIHRvIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzZXNXaXRob3V0TmF0aXZlXyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdHZhciBlbGVtZW50Q2xhc3NOYW1lID0gJyAnICsgZWxlbWVudC5jbGFzc05hbWUgKyAnICc7XG5cblx0Y2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoJyAnKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gJyAnICsgY2xhc3Nlc1tpXSArICcgJztcblx0XHR2YXIgY2xhc3NJbmRleCA9IGVsZW1lbnRDbGFzc05hbWUuaW5kZXhPZihjbGFzc05hbWUpO1xuXG5cdFx0aWYgKGNsYXNzSW5kZXggPT09IC0xKSB7XG5cdFx0XHRlbGVtZW50Q2xhc3NOYW1lID0gJycgKyBlbGVtZW50Q2xhc3NOYW1lICsgY2xhc3Nlc1tpXSArICcgJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGJlZm9yZSA9IGVsZW1lbnRDbGFzc05hbWUuc3Vic3RyaW5nKDAsIGNsYXNzSW5kZXgpO1xuXHRcdFx0dmFyIGFmdGVyID0gZWxlbWVudENsYXNzTmFtZS5zdWJzdHJpbmcoY2xhc3NJbmRleCArIGNsYXNzTmFtZS5sZW5ndGgpO1xuXHRcdFx0ZWxlbWVudENsYXNzTmFtZSA9IGJlZm9yZSArICcgJyArIGFmdGVyO1xuXHRcdH1cblx0fVxuXG5cdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudENsYXNzTmFtZS50cmltKCk7XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgYWxsIGxpc3RlbmVycyBmb3IgdGhlIGdpdmVuIGV2ZW50IHR5cGUgdGhhdCBhcmUgc3RvcmVkIGluIHRoZVxuICogc3BlY2lmaWVkIGVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7IUFycmF5fSBkZWZhdWx0Rm5zIEFycmF5IHRvIGNvbGxlY3QgZGVmYXVsdCBsaXN0ZW5lcnMgaW4sIGluc3RlYWRcbiAqICAgICBvZiBydW5uaW5nIHRoZW0uXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRyaWdnZXJlZCBjYWxsYmFja3MgcmV0dXJuc1xuICogICAgIGZhbHNlLCBvciB0cnVlIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJFbGVtZW50TGlzdGVuZXJzXyhlbGVtZW50LCBldmVudCwgZGVmYXVsdEZucykge1xuXHR2YXIgbGFzdENvbnRhaW5lciA9IGV2ZW50W0xBU1RfQ09OVEFJTkVSXTtcblx0aWYgKCEoMCwgX21ldGFsLmlzRGVmKShsYXN0Q29udGFpbmVyKSB8fCAhY29udGFpbnMobGFzdENvbnRhaW5lciwgZWxlbWVudCkpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gX2RvbURhdGEyLmRlZmF1bHQuZ2V0KGVsZW1lbnQsICdsaXN0ZW5lcnMnLCB7fSlbZXZlbnQudHlwZV07XG5cdFx0cmV0dXJuIHRyaWdnZXJMaXN0ZW5lcnNfKGxpc3RlbmVycywgZXZlbnQsIGVsZW1lbnQsIGRlZmF1bHRGbnMpO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRyaWdnZXJzIHRoZSBzcGVjaWZpZWQgZXZlbnQgb24gdGhlIGdpdmVuIGVsZW1lbnQuXG4gKiBOT1RFOiBUaGlzIHNob3VsZCBtb3N0bHkgYmUgdXNlZCBmb3IgdGVzdGluZywgbm90IG9uIHJlYWwgY29kZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIG5vZGUgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiZSB0cmlnZ3JlZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2V2ZW50T2JqIEFuIG9iamVjdCB3aXRoIGRhdGEgdGhhdCBzaG91bGQgYmUgb24gdGhlXG4gKiAgIHRyaWdnZXJlZCBldmVudCdzIHBheWxvYWQuXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJFdmVudChlbGVtZW50LCBldmVudE5hbWUsIG9wdF9ldmVudE9iaikge1xuXHRpZiAoaXNBYmxlVG9JbnRlcmFjdFdpdGhfKGVsZW1lbnQsIGV2ZW50TmFtZSwgb3B0X2V2ZW50T2JqKSkge1xuXHRcdHZhciBldmVudE9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG5cdFx0ZXZlbnRPYmouaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0X21ldGFsLm9iamVjdC5taXhpbihldmVudE9iaiwgb3B0X2V2ZW50T2JqKTtcblx0XHRlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZlbnRPYmopO1xuXHR9XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlIGdpdmVuIGxpc3RlbmVycyBhcnJheS5cbiAqIEBwYXJhbSB7QXJyYXk8IWZ1bmN0aW9uKCk+fSBsaXN0ZW5lcnNcbiAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHshQXJyYXl9IGRlZmF1bHRGbnMgQXJyYXkgdG8gY29sbGVjdCBkZWZhdWx0IGxpc3RlbmVycyBpbiwgaW5zdGVhZFxuICogICAgIG9mIHJ1bm5pbmcgdGhlbS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdHJpZ2dlcmVkIGNhbGxiYWNrcyByZXR1cm5zXG4gKiAgICAgZmFsc2UsIG9yIHRydWUgb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckxpc3RlbmVyc18obGlzdGVuZXJzLCBldmVudCwgZWxlbWVudCwgZGVmYXVsdEZucykge1xuXHR2YXIgcmV0ID0gdHJ1ZTtcblx0bGlzdGVuZXJzID0gbGlzdGVuZXJzIHx8IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGggJiYgIWV2ZW50LnN0b3BwZWRJbW1lZGlhdGU7IGkrKykge1xuXHRcdGlmIChsaXN0ZW5lcnNbaV0uZGVmYXVsdExpc3RlbmVyXykge1xuXHRcdFx0ZGVmYXVsdEZucy5wdXNoKHtcblx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0Zm46IGxpc3RlbmVyc1tpXVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldCAmPSBsaXN0ZW5lcnNbaV0oZXZlbnQpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIFRyaWdnZXJzIGFsbCBzZWxlY3RvciBsaXN0ZW5lcnMgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGNvbnRhaW5lclxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0geyFBcnJheX0gZGVmYXVsdEZucyBBcnJheSB0byBjb2xsZWN0IGRlZmF1bHQgbGlzdGVuZXJzIGluLCBpbnN0ZWFkXG4gKiAgICAgb2YgcnVubmluZyB0aGVtLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB0cmlnZ2VyZWQgY2FsbGJhY2tzIHJldHVybnNcbiAqICAgICBmYWxzZSwgb3IgdHJ1ZSBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyU2VsZWN0b3JMaXN0ZW5lcnNfKGNvbnRhaW5lciwgZWxlbWVudCwgZXZlbnQsIGRlZmF1bHRGbnMpIHtcblx0dmFyIHJldCA9IHRydWU7XG5cdHZhciBkYXRhID0gX2RvbURhdGEyLmRlZmF1bHQuZ2V0KGNvbnRhaW5lciwgJ2RlbGVnYXRpbmcnLCB7fSk7XG5cdHZhciBtYXAgPSBkYXRhW2V2ZW50LnR5cGVdLnNlbGVjdG9ycztcblx0dmFyIHNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKG1hcCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0b3JzLmxlbmd0aCAmJiAhZXZlbnQuc3RvcHBlZEltbWVkaWF0ZTsgaSsrKSB7XG5cdFx0aWYgKG1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yc1tpXSkpIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSBtYXBbc2VsZWN0b3JzW2ldXTtcblx0XHRcdHJldCAmPSB0cmlnZ2VyTGlzdGVuZXJzXyhsaXN0ZW5lcnMsIGV2ZW50LCBlbGVtZW50LCBkZWZhdWx0Rm5zKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2RvbU5hbWVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuYWJzdHJhY3RNZXRob2QgPSBhYnN0cmFjdE1ldGhvZDtcbmV4cG9ydHMuZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5lbmFibGVDb21wYXRpYmlsaXR5TW9kZSA9IGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5nZXRDb21wYXRpYmlsaXR5TW9kZURhdGEgPSBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGE7XG5leHBvcnRzLmdldEZ1bmN0aW9uTmFtZSA9IGdldEZ1bmN0aW9uTmFtZTtcbmV4cG9ydHMuZ2V0U3RhdGljUHJvcGVydHkgPSBnZXRTdGF0aWNQcm9wZXJ0eTtcbmV4cG9ydHMuZ2V0VWlkID0gZ2V0VWlkO1xuZXhwb3J0cy5pZGVudGl0eUZ1bmN0aW9uID0gaWRlbnRpdHlGdW5jdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc0RlZiA9IGlzRGVmO1xuZXhwb3J0cy5pc0RlZkFuZE5vdE51bGwgPSBpc0RlZkFuZE5vdE51bGw7XG5leHBvcnRzLmlzRG9jdW1lbnQgPSBpc0RvY3VtZW50O1xuZXhwb3J0cy5pc0RvY3VtZW50RnJhZ21lbnQgPSBpc0RvY3VtZW50RnJhZ21lbnQ7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NlcnZlclNpZGUgPSBpc1NlcnZlclNpZGU7XG5leHBvcnRzLm51bGxGdW5jdGlvbiA9IG51bGxGdW5jdGlvbjtcbnZhciBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdm9pZCAwO1xuXG4vKipcbiAqIENvdW50ZXIgZm9yIHVuaXF1ZSBpZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBVSURfUFJPUEVSVFkgPSBleHBvcnRzLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAqIEZvby5wcm90b3R5cGUuYmFyID0gYWJzdHJhY3RNZXRob2RcbiAqXG4gKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiB3aGVuIGJhcigpIGlzIGludm9rZWQuXG4gKlxuICogQHR5cGUgeyFGdW5jdGlvbn1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG4gIHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIERpc2FibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRW5hYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZSB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgZnJvbSByY1xuICogYW5kIDEueCB2ZXJzaW9uczpcbiAqICAgICAtIFVzaW5nIFwia2V5XCIgdG8gcmVmZXJlbmNlIGNvbXBvbmVudCBpbnN0YW5jZXMuIEluIHRoZSBjdXJyZW50IHZlcnNpb25cbiAqICAgICAgIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFwicmVmXCIgaW5zdGVhZC4gVGhpcyBhbGxvd3Mgb2xkIGNvZGUgc3RpbGxcbiAqICAgICAgIHVzaW5nIFwia2V5XCIgdG8ga2VlcCB3b3JraW5nIGxpa2UgYmVmb3JlLiBOT1RFOiB0aGlzIG1heSBjYXVzZVxuICogICAgICAgcHJvYmxlbXMsIHNpbmNlIFwia2V5XCIgaXMgbWVhbnQgdG8gYmUgdXNlZCBkaWZmZXJlbnRseS4gT25seSB1c2UgdGhpc1xuICogICAgICAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gdXBncmFkZSB0aGUgY29kZSB0byB1c2UgXCJyZWZcIiBpbnN0ZWFkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBPcHRpb25hbCBvYmplY3Qgd2l0aCBkYXRhIHRvIHNwZWNpZnkgbW9yZVxuICogICAgIGRldGFpbHMsIHN1Y2ggYXM6XG4gKiAgICAgICAgIC0gcmVuZGVyZXJzIHtBcnJheX0gdGhlIHRlbXBsYXRlIHJlbmRlcmVycyB0aGF0IHNob3VsZCBiZSBpblxuICogICAgICAgICAgIGNvbXBhdGliaWxpdHkgbW9kZSwgZWl0aGVyIHRoZWlyIGNvbnN0cnVjdG9ycyBvciBzdHJpbmdzXG4gKiAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZW0gKGUuZy4gJ3NveScgb3IgJ2pzeCcpLiBCeSBkZWZhdWx0LCBhbGwgdGhlIG9uZXNcbiAqICAgICAgICAgICB0aGF0IGV4dGVuZCBmcm9tIEluY3JlbWVudGFsRG9tUmVuZGVyZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgdmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gb3B0X2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSB1c2VkIGZvciBjb21wYXRpYmlsaXR5IG1vZGUsIG9yIG5vdGhpbmcgaWYgaXQgaGFzbid0IGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhdGliaWxpdHlNb2RlRGF0YSgpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBtb2RlIGNhbiBiZSBzZXQgdmlhIHRoZSBfX01FVEFMX0NPTVBBVElCSUxJVFlfXyBnbG9iYWwgdmFyLlxuICBpZiAoY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXykge1xuICAgICAgZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUod2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyB0cnV0aHksIG9yIHRoZSBzZWNvbmQgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0VHJ1dGh5XyhhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24uIElmIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndFxuICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3NcbiAqIGNvbnRlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGZuLm5hbWUgPSBzdHIuc3Vic3RyaW5nKDksIHN0ci5pbmRleE9mKCcoJykpO1xuICB9XG4gIHJldHVybiBmbi5uYW1lO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIHByb3BlcnR5IGluIHRoZSBnaXZlbiBjbGFzcy4gVGhlIHZhbHVlIHdpbGwgYmVcbiAqIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyBhcyBleHBlY3RlZCwgdW5sZXNzIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICogd2hpY2ggY2FuIGNoYW5nZSBob3cgdGhlIHN1cGVyIGNsYXNzZXMnIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5IHdpbGwgYmUgbWVyZ2VkXG4gKiB0b2dldGhlci5cbiAqIFRoZSBmaW5hbCBtZXJnZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQgaW4gYW5vdGhlciBwcm9wZXJ0eSwgc28gdGhhdCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkIGV2ZW4gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG1lcmdlZFxuICogICAgIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBzbyBmYXIgYW5kIHRoZSBuZXh0IHZhbHVlIHRvIGJlIG1lcmdlZCB0byBpdC5cbiAqICAgICBTaG91bGQgcmV0dXJuIHRoZXNlIHR3byBtZXJnZWQgdG9nZXRoZXIuIElmIG5vdCBwYXNzZWQgdGhlIGZpbmFsIHByb3BlcnR5XG4gKiAgICAgd2lsbCBiZSB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIGFtb25nIGFuY2VzdG9ycy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljUHJvcGVydHkoY3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuICB2YXIgbWVyZ2VkTmFtZSA9IHByb3BlcnR5TmFtZSArICdfTUVSR0VEJztcbiAgaWYgKCFjdG9yLmhhc093blByb3BlcnR5KG1lcmdlZE5hbWUpKSB7XG4gICAgdmFyIG1lcmdlZCA9IGN0b3IuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSA/IGN0b3JbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgaWYgKGN0b3IuX19wcm90b19fICYmICFjdG9yLl9fcHJvdG9fXy5pc1Byb3RvdHlwZU9mKEZ1bmN0aW9uKSkge1xuICAgICAgdmFyIG1lcmdlRm4gPSBvcHRfbWVyZ2VGbiB8fCBnZXRGaXJzdFRydXRoeV87XG4gICAgICBtZXJnZWQgPSBtZXJnZUZuKG1lcmdlZCwgZ2V0U3RhdGljUHJvcGVydHkoY3Rvci5fX3Byb3RvX18sIHByb3BlcnR5TmFtZSwgbWVyZ2VGbikpO1xuICAgIH1cbiAgICBjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuICB9XG4gIHJldHVybiBjdG9yW21lcmdlZE5hbWVdO1xufVxuXG4vKipcbiAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gKiBtdXRhdGVkIHdpdGggYW4gdW5pcXVlIGlkLiBDb25zZWN1dGl2ZSBjYWxscyB3aXRoIHRoZSBzYW1lIG9iamVjdFxuICogcmVmZXJlbmNlIHdvbid0IG11dGF0ZSB0aGUgb2JqZWN0IGFnYWluLCBpbnN0ZWFkIHRoZSBjdXJyZW50IG9iamVjdCB1aWRcbiAqIHJldHVybnMuIFNlZSB7QGxpbmsgVUlEX1BST1BFUlRZfS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gKiAgICAgbm90IHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub0luaGVyaXRhbmNlIE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzXG4gKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG4gIGlmIChvcHRfb2JqZWN0KSB7XG4gICAgdmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuICAgIGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG4gICAgICBpZCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG4gIHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBpc0RlZih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEZWZBbmROb3ROdWxsKHZhbCkge1xuICByZXR1cm4gaXNEZWYodmFsKSAmJiAhaXNOdWxsKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC1mcmFnbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gKiBhbmQgZnVuY3Rpb25zLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICByZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIFNldHMgdG8gdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBOb2RlLmpzIGVudmlyb25tZW50IHdpdGggZXh0cmEgY2hlY2sgZm9yXG4gKiBgcHJvY2Vzcy5icm93c2VyYCB0byBza2lwIEthcm1hIHJ1bm5lciBlbnZpcm9ubWVudC4gS2FybWEgZW52aXJvbm1lbnQgaGFzXG4gKiBgcHJvY2Vzc2AgZGVmaW5lZCBldmVuIHRob3VnaCBpdCBydW5zIG9uIHRoZSBicm93c2VyLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJTaWRlKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLmVudiAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhcHJvY2Vzcy5icm93c2VyO1xufVxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBudWxsRnVuY3Rpb24oKSB7fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhhcnJheSwgbnVsbCwgW3tcblx0XHRrZXk6ICdlcXVhbCcsXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdFx0aWYgKGFycjEgPT09IGFycjIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHshQXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmlyc3REZWZpbmVkVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuICAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmbGF0dGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdFx0dmFyIHJ2ID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG4gICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzbGljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHRcdHZhciBlbmQgPSAoMCwgX2NvcmUuaXNEZWYpKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNsaWNlZDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFycmF5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbnZhciBhc3luYyA9IHt9O1xuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbCA9IHZvaWQgMDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbiBDaGFubmVsKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24gKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEaXNwb3NhYmxlIHV0aWxpdHkuIFdoZW4gaW5oZXJpdGVkIHByb3ZpZGVzIHRoZSBgZGlzcG9zZWAgZnVuY3Rpb24gdG8gaXRzXG4gKiBzdWJjbGFzcywgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyBvZiBhbnkgb2JqZWN0IHJlZmVyZW5jZXNcbiAqIHdoZW4gYW4gaW5zdGFuY2Ugd29uJ3QgYmUgdXNlZCBhbnltb3JlLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICogYGRpc3Bvc2VJbnRlcm5hbGAgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpYyBkaXNwb3NpbmcgbG9naWMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcG9zYWJsZSk7XG5cblx0XHQvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRGlzcG9zYWJsZSwgW3tcblx0XHRrZXk6ICdkaXNwb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdFx0dGhpcy5kaXNwb3NlSW50ZXJuYWwoKTtcblx0XHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG4gICAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuICAgKiBkaXNwb3NhYmxlcykuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0Rpc3Bvc2VkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRGlzcG9zYWJsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGlzcG9zYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKG9iamVjdCwgbnVsbCwgW3tcblx0XHRrZXk6ICdtaXhpbicsXG5cblx0XHQvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdFx0dmFyIGtleSA9IHZvaWQgMCxcblx0XHRcdCAgICBzb3VyY2UgPSB2b2lkIDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPYmplY3RCeU5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeU5hbWUobmFtZSwgb3B0X29iaikge1xuXHRcdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0XHRyZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChwYXJ0LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHRcdH0sIHNjb3BlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuICAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaGFsbG93RXF1YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuXHRcdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmoxW2tleXMxW2ldXSAhPT0gb2JqMltrZXlzMVtpXV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIHN0cmluZygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgc3RyaW5nKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhzdHJpbmcsIG51bGwsIFt7XG5cdFx0a2V5OiAnY2FzZUluc2Vuc2l0aXZlQ29tcGFyZScsXG5cblx0XHQvKipcbiAgICogQ29tcGFyZXMgdGhlIGdpdmVuIHN0cmluZ3Mgd2l0aG91dCB0YWtpbmcgdGhlIGNhc2UgaW50byBhY2NvdW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjFcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIyXG4gICAqIEByZXR1cm4ge251bWJlcn0gRWl0aGVyIC0xLCAwIG9yIDEsIGFjY29yZGluZyB0byBpZiB0aGUgZmlyc3Qgc3RyaW5nIGlzXG4gICAqICAgICBcInNtYWxsZXJcIiwgZXF1YWwgb3IgXCJiaWdnZXJcIiB0aGFuIHRoZSBzZWNvbmQgZ2l2ZW4gc3RyaW5nLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FzZUluc2Vuc2l0aXZlQ29tcGFyZShzdHIxLCBzdHIyKSB7XG5cdFx0XHR2YXIgdGVzdDEgPSBTdHJpbmcoc3RyMSkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB0ZXN0MiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAodGVzdDEgPCB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRlc3QxID09PSB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBicmVha2luZyBzcGFjZXMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHN0cmluZyBhbmRcbiAgICogY29sbGFwc2VzIHRoZSBzZXF1ZW5jZXMgb2YgYnJlYWtpbmcgc3BhY2VzIGluIHRoZSBtaWRkbGUgaW50byBzaW5nbGUgc3BhY2VzLlxuICAgKiBUaGUgb3JpZ2luYWwgYW5kIHRoZSByZXN1bHQgc3RyaW5ncyByZW5kZXIgdGhlIHNhbWUgd2F5IGluIEhUTUwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgaW4gd2hpY2ggdG8gY29sbGFwc2Ugc3BhY2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvcHkgb2YgdGhlIHN0cmluZyB3aXRoIG5vcm1hbGl6ZWQgYnJlYWtpbmcgc3BhY2VzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29sbGFwc2VCcmVha2luZ1NwYWNlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbGxhcHNlQnJlYWtpbmdTcGFjZXMoc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IHNhZmUgdG8gdXNlIGluIGEgUmVnRXhwLlxuICAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gZXNjYXBlLiBJZiBub3QgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY2FzdGVkXG4gICogICAgIHRvIG9uZS5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVnRXhwIHNhZmUsIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc30uXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2VzY2FwZVJlZ2V4Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRSYW5kb21TdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGhhc2hjb2RlIGZvciBhIHN0cmluZy4gVGhlIGhhc2hjb2RlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5XG4gICAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG4gICAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuICAgKiBhIHNoaWZ0IGFuZCBhIHN1YnRyYWN0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6IDMxKmkgPT0gKGk8PDUpLWkuXG4gICAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIGhhc2hjb2RlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzaENvZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNoQ29kZSh2YWwpIHtcblx0XHRcdHZhciBoYXNoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuICAgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlSW50ZXJ2YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIHN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfZG9tRGF0YSA9IHJlcXVpcmUoJy4vZG9tRGF0YScpO1xuXG52YXIgX2RvbURhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tRGF0YSk7XG5cbnZhciBfbWV0YWxFdmVudHMgPSByZXF1aXJlKCdtZXRhbC1ldmVudHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRoaXMgaXMgYSBzcGVjaWFsIEV2ZW50SGFuZGxlLCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkb20gZGVsZWdhdGVkIGV2ZW50c1xuICogKG9ubHkgdGhlIG9uZXMgdGhhdCByZWNlaXZlIGEgdGFyZ2V0IGVsZW1lbnQsIG5vdCBhIHNlbGVjdG9yIHN0cmluZykuXG4gKiBAZXh0ZW5kcyB7RXZlbnRIYW5kbGV9XG4gKi9cbnZhciBEb21EZWxlZ2F0ZWRFdmVudEhhbmRsZSA9IGZ1bmN0aW9uIChfRXZlbnRIYW5kbGUpIHtcblx0X2luaGVyaXRzKERvbURlbGVnYXRlZEV2ZW50SGFuZGxlLCBfRXZlbnRIYW5kbGUpO1xuXG5cdC8qKlxuICAqIFRoZSBjb25zdHJ1Y3RvciBmb3IgYERvbURlbGVnYXRlZEV2ZW50SGFuZGxlYC5cbiAgKiBAcGFyYW0geyFFdmVudH0gZW1pdHRlciBFbGVtZW50IHRoZSBldmVudCB3YXMgc3Vic2NyaWJlZCB0by5cbiAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRoYXQgd2FzIHN1YnNjcmliZWQgdG8uXG4gICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBzdWJzY3JpYmVkIHRvIHRoZSBldmVudC5cbiAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zZWxlY3RvciBBbiBvcHRpb25hbCBzZWxlY3RvciB1c2VkIHdoZW4gZGVsZWdhdGluZ1xuICAqICAgICB0aGUgZXZlbnQuXG4gICogQGNvbnN0cnVjdG9yXG4gICovXG5cdGZ1bmN0aW9uIERvbURlbGVnYXRlZEV2ZW50SGFuZGxlKGVtaXR0ZXIsIGV2ZW50LCBsaXN0ZW5lciwgb3B0X3NlbGVjdG9yKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvbURlbGVnYXRlZEV2ZW50SGFuZGxlKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEb21EZWxlZ2F0ZWRFdmVudEhhbmRsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvbURlbGVnYXRlZEV2ZW50SGFuZGxlKSkuY2FsbCh0aGlzLCBlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpKTtcblxuXHRcdF90aGlzLnNlbGVjdG9yXyA9IG9wdF9zZWxlY3Rvcjtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBAaW5oZXJpdERvY1xuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKERvbURlbGVnYXRlZEV2ZW50SGFuZGxlLCBbe1xuXHRcdGtleTogJ3JlbW92ZUxpc3RlbmVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG5cdFx0XHR2YXIgZGVsZWdhdGluZyA9IF9kb21EYXRhMi5kZWZhdWx0LmdldCh0aGlzLmVtaXR0ZXJfLCAnZGVsZWdhdGluZycsIHt9KTtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSBfZG9tRGF0YTIuZGVmYXVsdC5nZXQodGhpcy5lbWl0dGVyXywgJ2xpc3RlbmVycycsIHt9KTtcblx0XHRcdHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3JfO1xuXHRcdFx0dmFyIGFyciA9ICgwLCBfbWV0YWwuaXNTdHJpbmcpKHNlbGVjdG9yKSA/IGRlbGVnYXRpbmdbdGhpcy5ldmVudF9dLnNlbGVjdG9ycyA6IGxpc3RlbmVycztcblx0XHRcdHZhciBrZXkgPSAoMCwgX21ldGFsLmlzU3RyaW5nKShzZWxlY3RvcikgPyBzZWxlY3RvciA6IHRoaXMuZXZlbnRfO1xuXG5cdFx0XHRfbWV0YWwuYXJyYXkucmVtb3ZlKGFycltrZXldIHx8IFtdLCB0aGlzLmxpc3RlbmVyXyk7XG5cdFx0XHRpZiAoYXJyW2tleV0gJiYgYXJyW2tleV0ubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGRlbGV0ZSBhcnJba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGU7XG59KF9tZXRhbEV2ZW50cy5FdmVudEhhbmRsZSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERvbURlbGVnYXRlZEV2ZW50SGFuZGxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfRXZlbnRIYW5kbGUgPSByZXF1aXJlKCcuL0V2ZW50SGFuZGxlJyk7XG5cbnZhciBfRXZlbnRIYW5kbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnRIYW5kbGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBzaW5nbGVBcnJheV8gPSBbMF07XG5cbi8qKlxuICogRXZlbnRFbWl0dGVyIHV0aWxpdHkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbiAoX0Rpc3Bvc2FibGUpIHtcblx0X2luaGVyaXRzKEV2ZW50RW1pdHRlciwgX0Rpc3Bvc2FibGUpO1xuXG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuXHRcdC8qKlxuICAgKiBIb2xkcyBldmVudCBsaXN0ZW5lcnMgc2NvcGVkIGJ5IGV2ZW50IHR5cGUuXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAhQXJyYXk8IWZ1bmN0aW9uKCk+Pn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXZlbnRFbWl0dGVyLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXZlbnRFbWl0dGVyKSkuY2FsbCh0aGlzKSk7XG5cblx0XHRfdGhpcy5ldmVudHNfID0gbnVsbDtcblxuXHRcdC8qKlxuICAgKiBIYW5kbGVycyB0aGF0IGFyZSB0cmlnZ2VyZWQgd2hlbiBhbiBldmVudCBpcyBsaXN0ZW5lZCB0by5cbiAgICogQHR5cGUge0FycmF5fVxuICAgKi9cblx0XHRfdGhpcy5saXN0ZW5lckhhbmRsZXJzXyA9IG51bGw7XG5cblx0XHQvKipcbiAgICogQ29uZmlndXJhdGlvbiBvcHRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhbiBldmVudCBmYWNhZGUgc2hvdWxkIGJlIHNlbnRcbiAgICogYXMgYSBwYXJhbSBvZiBsaXN0ZW5lcnMgd2hlbiBlbWl0dGluZyBldmVudHMuIElmIHNldCB0byB0cnVlLCB0aGUgZmFjYWRlXG4gICAqIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLnNob3VsZFVzZUZhY2FkZV8gPSBmYWxzZTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBBZGRzIGEgaGFuZGxlciB0byBnaXZlbiBob2xkZXIgdmFyaWFibGUuIElmIHRoZSBob2xkZXIgZG9lc24ndCBoYXZlIGFcbiAgKiB2YWx1ZSB5ZXQsIGl0IHdpbGwgcmVjZWl2ZSB0aGUgaGFuZGxlciBkaXJlY3RseS4gSWYgdGhlIGhvbGRlciBpcyBhbiBhcnJheSxcbiAgKiB0aGUgdmFsdWUgd2lsbCBqdXN0IGJlIGFkZGVkIHRvIGl0LiBPdGhlcndpc2UsIHRoZSBob2xkZXIgd2lsbCBiZSBzZXQgdG8gYVxuICAqIG5ldyBhcnJheSBjb250YWluaW5nIGl0cyBwcmV2aW91cyB2YWx1ZSBwbHVzIHRoZSBuZXcgaGFuZGxlci5cbiAgKiBAcGFyYW0geyp9IGhvbGRlclxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl8T2JqZWN0fSBoYW5kbGVyXG4gICogQHJldHVybiB7Kn0gVGhlIGhvbGRlcidzIG5ldyB2YWx1ZS5cbiAgKiBAcHJvdGVjdGVkXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRXZlbnRFbWl0dGVyLCBbe1xuXHRcdGtleTogJ2FkZEhhbmRsZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkSGFuZGxlcl8oaG9sZGVyLCBoYW5kbGVyKSB7XG5cdFx0XHRpZiAoIWhvbGRlcikge1xuXHRcdFx0XHRob2xkZXIgPSBoYW5kbGVyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KGhvbGRlcikpIHtcblx0XHRcdFx0XHRob2xkZXIgPSBbaG9sZGVyXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob2xkZXIucHVzaChoYW5kbGVyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBob2xkZXI7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgZW5kIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRzLlxuICAgKiBAcGFyYW0geyEoQXJyYXl8c3RyaW5nKX0gZXZlbnRcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2RlZmF1bHQgRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgbGlzdGVuZXIgaXMgYSBkZWZhdWx0XG4gICAqICAgYWN0aW9uIGZvciB0aGlzIGV2ZW50LiBEZWZhdWx0IGFjdGlvbnMgYXJlIHJ1biBsYXN0LCBhbmQgb25seSBpZiBubyBwcmV2aW91c1xuICAgKiAgIGxpc3RlbmVyIGNhbGwgYHByZXZlbnREZWZhdWx0KClgIG9uIHRoZSByZWNlaXZlZCBldmVudCBmYWNhZGUuXG4gICAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZExpc3RlbmVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRfZGVmYXVsdCkge1xuXHRcdFx0dGhpcy52YWxpZGF0ZUxpc3RlbmVyXyhsaXN0ZW5lcik7XG5cblx0XHRcdHZhciBldmVudHMgPSB0aGlzLnRvRXZlbnRzQXJyYXlfKGV2ZW50KTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuYWRkU2luZ2xlTGlzdGVuZXJfKGV2ZW50c1tpXSwgbGlzdGVuZXIsIG9wdF9kZWZhdWx0KTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBfRXZlbnRIYW5kbGUyLmRlZmF1bHQodGhpcywgZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgYSBzaW5nbGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRfZGVmYXVsdCBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBsaXN0ZW5lciBpcyBhIGRlZmF1bHRcbiAgICogICBhY3Rpb24gZm9yIHRoaXMgZXZlbnQuIERlZmF1bHQgYWN0aW9ucyBhcmUgcnVuIGxhc3QsIGFuZCBvbmx5IGlmIG5vIHByZXZpb3VzXG4gICAqICAgbGlzdGVuZXIgY2FsbCBgcHJldmVudERlZmF1bHQoKWAgb24gdGhlIHJlY2VpdmVkIGV2ZW50IGZhY2FkZS5cbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0X29yaWdpbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gdGhhdCB3YXMgYWRkZWQgYXMgYVxuICAgKiAgIGxpc3RlbmVyLCBpZiB0aGVyZSBpcyBhbnkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2FkZFNpbmdsZUxpc3RlbmVyXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFNpbmdsZUxpc3RlbmVyXyhldmVudCwgbGlzdGVuZXIsIG9wdF9kZWZhdWx0LCBvcHRfb3JpZ2luKSB7XG5cdFx0XHR0aGlzLnJ1bkxpc3RlbmVySGFuZGxlcnNfKGV2ZW50KTtcblx0XHRcdGlmIChvcHRfZGVmYXVsdCB8fCBvcHRfb3JpZ2luKSB7XG5cdFx0XHRcdGxpc3RlbmVyID0ge1xuXHRcdFx0XHRcdGRlZmF1bHQ6IG9wdF9kZWZhdWx0LFxuXHRcdFx0XHRcdGZuOiBsaXN0ZW5lcixcblx0XHRcdFx0XHRvcmlnaW46IG9wdF9vcmlnaW5cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZXZlbnRzXyA9IHRoaXMuZXZlbnRzXyB8fCB7fTtcblx0XHRcdHRoaXMuZXZlbnRzX1tldmVudF0gPSB0aGlzLmFkZEhhbmRsZXJfKHRoaXMuZXZlbnRzX1tldmVudF0sIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQnVpbGRzIGZhY2FkZSBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdidWlsZEZhY2FkZV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBidWlsZEZhY2FkZV8oZXZlbnQpIHtcblx0XHRcdGlmICh0aGlzLmdldFNob3VsZFVzZUZhY2FkZSgpKSB7XG5cdFx0XHRcdHZhciBmYWNhZGUgPSB7XG5cdFx0XHRcdFx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KCkge1xuXHRcdFx0XHRcdFx0ZmFjYWRlLnByZXZlbnRlZERlZmF1bHQgPSB0cnVlO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dGFyZ2V0OiB0aGlzLFxuXHRcdFx0XHRcdHR5cGU6IGV2ZW50XG5cdFx0XHRcdH07XG5cdFx0XHRcdHJldHVybiBmYWNhZGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0XHR0aGlzLmV2ZW50c18gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFeGVjdXRlIGVhY2ggb2YgdGhlIGxpc3RlbmVycyBpbiBvcmRlciB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0geyp9IG9wdF9hcmdzIFthcmcxXSwgW2FyZzJdLCBbLi4uXVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgZXZlbnQgaGFkIGxpc3RlbmVycywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZW1pdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldFJhd0xpc3RlbmVyc18oZXZlbnQpO1xuXHRcdFx0aWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYXJncyA9IF9tZXRhbC5hcnJheS5zbGljZShhcmd1bWVudHMsIDEpO1xuXHRcdFx0dGhpcy5ydW5MaXN0ZW5lcnNfKGxpc3RlbmVycywgYXJncywgdGhpcy5idWlsZEZhY2FkZV8oZXZlbnQpKTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBsaXN0ZW5lciBvYmplY3RzIGZvciB0aGUgZ2l2ZW4gZXZlbnQsIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJhd0xpc3RlbmVyc18nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRSYXdMaXN0ZW5lcnNfKGV2ZW50KSB7XG5cdFx0XHR2YXIgZGlyZWN0TGlzdGVuZXJzID0gdG9BcnJheSh0aGlzLmV2ZW50c18gJiYgdGhpcy5ldmVudHNfW2V2ZW50XSk7XG5cdFx0XHRyZXR1cm4gZGlyZWN0TGlzdGVuZXJzLmNvbmNhdCh0b0FycmF5KHRoaXMuZXZlbnRzXyAmJiB0aGlzLmV2ZW50c19bJyonXSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmF0aW9uIG9wdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGFuIGV2ZW50IGZhY2FkZSBzaG91bGRcbiAgICogYmUgc2VudCBhcyBhIHBhcmFtIG9mIGxpc3RlbmVycyB3aGVuIGVtaXR0aW5nIGV2ZW50cy4gSWYgc2V0IHRvIHRydWUsIHRoZVxuICAgKiBmYWNhZGUgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFNob3VsZFVzZUZhY2FkZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFNob3VsZFVzZUZhY2FkZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLnNob3VsZFVzZUZhY2FkZV87XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGxpc3RlbmVycy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2xpc3RlbmVycycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0UmF3TGlzdGVuZXJzXyhldmVudCkubWFwKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuXHRcdFx0XHRyZXR1cm4gbGlzdGVuZXIuZm4gPyBsaXN0ZW5lci5mbiA6IGxpc3RlbmVyO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIGZpeGVkIG51bWJlciBvZiB0aW1lcyBmb3IgdGhlXG4gICAqIGV2ZW50cy4gQWZ0ZXIgZWFjaCBldmVudCBpcyB0cmlnZ2VyZWQgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZXMsIHRoZVxuICAgKiBsaXN0ZW5lciBpcyByZW1vdmVkIGZvciBpdC5cbiAgICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgVGhlIGFtb3VudCBvZiB0aW1lcyB0aGlzIGV2ZW50IHNob3VsZCBiZSBsaXN0ZW5lZFxuICAgKiB0by5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hbnknLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYW55KGV2ZW50LCBhbW91bnQsIGxpc3RlbmVyKSB7XG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy50b0V2ZW50c0FycmF5XyhldmVudCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLm1hbnlfKGV2ZW50c1tpXSwgYW1vdW50LCBsaXN0ZW5lcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBuZXcgX0V2ZW50SGFuZGxlMi5kZWZhdWx0KHRoaXMsIGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIGZpeGVkIG51bWJlciBvZiB0aW1lcyBmb3IgYSBzaW5nbGVcbiAgICogZXZlbnQuIEFmdGVyIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQgdGhlIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZXMsIHRoZVxuICAgKiBsaXN0ZW5lciBpcyByZW1vdmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIHRpbWVzIHRoaXMgZXZlbnQgc2hvdWxkIGJlIGxpc3RlbmVkXG4gICAqIHRvLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFueV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYW55XyhldmVudCwgYW1vdW50LCBsaXN0ZW5lcikge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRpZiAoYW1vdW50IDw9IDApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBoYW5kbGVySW50ZXJuYWwoKSB7XG5cdFx0XHRcdGlmICgtLWFtb3VudCA9PT0gMCkge1xuXHRcdFx0XHRcdHNlbGYucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGhhbmRsZXJJbnRlcm5hbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdGVuZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5hZGRTaW5nbGVMaXN0ZW5lcl8oZXZlbnQsIGhhbmRsZXJJbnRlcm5hbCwgZmFsc2UsIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIGEgbGlzdGVuZXIgb2JqZWN0IG1hdGNoZXMgdGhlIGdpdmVuIGxpc3RlbmVyIGZ1bmN0aW9uLiBUbyBtYXRjaCxcbiAgICogaXQgbmVlZHMgdG8gZWl0aGVyIHBvaW50IHRvIHRoYXQgbGlzdGVuZXIgb3IgaGF2ZSBpdCBhcyBpdHMgb3JpZ2luLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGxpc3RlbmVyT2JqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYXRjaGVzTGlzdGVuZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWF0Y2hlc0xpc3RlbmVyXyhsaXN0ZW5lck9iaiwgbGlzdGVuZXIpIHtcblx0XHRcdHZhciBmbiA9IGxpc3RlbmVyT2JqLmZuIHx8IGxpc3RlbmVyT2JqO1xuXHRcdFx0cmV0dXJuIGZuID09PSBsaXN0ZW5lciB8fCBsaXN0ZW5lck9iai5vcmlnaW4gJiYgbGlzdGVuZXJPYmoub3JpZ2luID09PSBsaXN0ZW5lcjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50cy5cbiAgICogQ2F1dGlvbjogY2hhbmdlcyBhcnJheSBpbmRpY2VzIGluIHRoZSBsaXN0ZW5lciBhcnJheSBiZWhpbmQgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0geyEoQXJyYXl8c3RyaW5nKX0gZXZlbnRzXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnb2ZmJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdFx0dGhpcy52YWxpZGF0ZUxpc3RlbmVyXyhsaXN0ZW5lcik7XG5cdFx0XHRpZiAoIXRoaXMuZXZlbnRzXykge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMudG9FdmVudHNBcnJheV8oZXZlbnQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5ldmVudHNfW2V2ZW50c1tpXV0gPSB0aGlzLnJlbW92ZU1hdGNoaW5nTGlzdGVuZXJPYmpzXyh0b0FycmF5KHRoaXMuZXZlbnRzX1tldmVudHNbaV1dKSwgbGlzdGVuZXIpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudHMuXG4gICAqIEBwYXJhbSB7IShBcnJheXxzdHJpbmcpfSBldmVudHNcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ29uJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIGhhbmRsZXIgdGhhdCBnZXRzIHRyaWdnZXJlZCB3aGVuIGFuIGV2ZW50IGlzIGxpc3RlbmVkIHRvIG9uIHRoaXNcbiAgICogaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdvbkxpc3RlbmVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gb25MaXN0ZW5lcihoYW5kbGVyKSB7XG5cdFx0XHR0aGlzLmxpc3RlbmVySGFuZGxlcnNfID0gdGhpcy5hZGRIYW5kbGVyXyh0aGlzLmxpc3RlbmVySGFuZGxlcnNfLCBoYW5kbGVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBhIG9uZSB0aW1lIGxpc3RlbmVyIGZvciB0aGUgZXZlbnRzLiBUaGlzIGxpc3RlbmVyIGlzIGludm9rZWQgb25seSB0aGVcbiAgICogbmV4dCB0aW1lIGVhY2ggZXZlbnQgaXMgZmlyZWQsIGFmdGVyIHdoaWNoIGl0IGlzIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7IShBcnJheXxzdHJpbmcpfSBldmVudHNcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ29uY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBvbmNlKGV2ZW50cywgbGlzdGVuZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLm1hbnkoZXZlbnRzLCAxLCBsaXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudHMuIEl0J3Mgbm90IGEgZ29vZFxuICAgKiBpZGVhIHRvIHJlbW92ZSBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkIGVsc2V3aGVyZSBpbiB0aGUgY29kZSxcbiAgICogZXNwZWNpYWxseSB3aGVuIGl0J3Mgb24gYW4gZW1pdHRlciB0aGF0IHlvdSBkaWRuJ3QgY3JlYXRlLlxuICAgKiBAcGFyYW0geyhBcnJheXxzdHJpbmcpPX0gb3B0X2V2ZW50c1xuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQWxsTGlzdGVuZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKG9wdF9ldmVudHMpIHtcblx0XHRcdGlmICh0aGlzLmV2ZW50c18pIHtcblx0XHRcdFx0aWYgKG9wdF9ldmVudHMpIHtcblx0XHRcdFx0XHR2YXIgZXZlbnRzID0gdGhpcy50b0V2ZW50c0FycmF5XyhvcHRfZXZlbnRzKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0dGhpcy5ldmVudHNfW2V2ZW50c1tpXV0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50c18gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXIgb2JqZWN0cyBmcm9tIHRoZSBnaXZlbiBhcnJheSB0aGF0IG1hdGNoIHRoZSBnaXZlblxuICAgKiBsaXN0ZW5lciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gbGlzdGVuZXJPYmpzXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAcmV0dXJuIHtBcnJheS48T2JqZWN0PnxPYmplY3R9IFRoZSBuZXcgbGlzdGVuZXJzIGFycmF5IGZvciB0aGlzIGV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVNYXRjaGluZ0xpc3RlbmVyT2Jqc18nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVNYXRjaGluZ0xpc3RlbmVyT2Jqc18obGlzdGVuZXJPYmpzLCBsaXN0ZW5lcikge1xuXHRcdFx0dmFyIGZpbmFsTGlzdGVuZXJzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVyT2Jqcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMubWF0Y2hlc0xpc3RlbmVyXyhsaXN0ZW5lck9ianNbaV0sIGxpc3RlbmVyKSkge1xuXHRcdFx0XHRcdGZpbmFsTGlzdGVuZXJzLnB1c2gobGlzdGVuZXJPYmpzW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZpbmFsTGlzdGVuZXJzLmxlbmd0aCA+IDAgPyBmaW5hbExpc3RlbmVycyA6IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudHMuXG4gICAqIENhdXRpb246IGNoYW5nZXMgYXJyYXkgaW5kaWNlcyBpbiB0aGUgbGlzdGVuZXIgYXJyYXkgYmVoaW5kIHRoZSBsaXN0ZW5lci5cbiAgICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHJldHVybiB7IU9iamVjdH0gUmV0dXJucyBlbWl0dGVyLCBzbyBjYWxscyBjYW4gYmUgY2hhaW5lZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUxpc3RlbmVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vZmYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUnVucyB0aGUgaGFuZGxlcnMgd2hlbiBhbiBldmVudCBpcyBsaXN0ZW5lZCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1bkxpc3RlbmVySGFuZGxlcnNfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuTGlzdGVuZXJIYW5kbGVyc18oZXZlbnQpIHtcblx0XHRcdHZhciBoYW5kbGVycyA9IHRoaXMubGlzdGVuZXJIYW5kbGVyc187XG5cdFx0XHRpZiAoaGFuZGxlcnMpIHtcblx0XHRcdFx0aGFuZGxlcnMgPSB0b0FycmF5KGhhbmRsZXJzKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGhhbmRsZXJzW2ldKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSdW5zIHRoZSBnaXZlbiBsaXN0ZW5lcnMuXG4gICAqIEBwYXJhbSB7IUFycmF5fSBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHshQXJyYXl9IGFyZ3NcbiAgICogQHBhcmFtIChPYmplY3QpIGZhY2FkZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdydW5MaXN0ZW5lcnNfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuTGlzdGVuZXJzXyhsaXN0ZW5lcnMsIGFyZ3MsIGZhY2FkZSkge1xuXHRcdFx0aWYgKGZhY2FkZSkge1xuXHRcdFx0XHRhcmdzLnB1c2goZmFjYWRlKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGRlZmF1bHRMaXN0ZW5lcnMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXS5mbiB8fCBsaXN0ZW5lcnNbaV07XG5cdFx0XHRcdGlmIChsaXN0ZW5lcnNbaV0uZGVmYXVsdCkge1xuXHRcdFx0XHRcdGRlZmF1bHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghZmFjYWRlIHx8ICFmYWNhZGUucHJldmVudGVkRGVmYXVsdCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRlZmF1bHRMaXN0ZW5lcnMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRkZWZhdWx0TGlzdGVuZXJzW2pdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYW4gZXZlbnQgZmFjYWRlIHNob3VsZFxuICAgKiBiZSBzZW50IGFzIGEgcGFyYW0gb2YgbGlzdGVuZXJzIHdoZW4gZW1pdHRpbmcgZXZlbnRzLiBJZiBzZXQgdG8gdHJ1ZSwgdGhlXG4gICAqIGZhY2FkZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFVzZUZhY2FkZVxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0U2hvdWxkVXNlRmFjYWRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0U2hvdWxkVXNlRmFjYWRlKHNob3VsZFVzZUZhY2FkZSkge1xuXHRcdFx0dGhpcy5zaG91bGRVc2VGYWNhZGVfID0gc2hvdWxkVXNlRmFjYWRlO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvbnZlcnRzIHRoZSBwYXJhbWV0ZXIgdG8gYW4gYXJyYXkgaWYgb25seSBvbmUgZXZlbnQgaXMgZ2l2ZW4uIFJldXNlcyB0aGVcbiAgICogc2FtZSBhcnJheSBlYWNoIHRpbWUgdGhpcyBjb252ZXJzaW9uIGlzIGRvbmUsIHRvIGF2b2lkIHVzaW5nIG1vcmUgbWVtb3J5XG4gICAqIHRoYW4gbmVjZXNzYXJ5LlxuICAgKiBAcGFyYW0gIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RvRXZlbnRzQXJyYXlfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9FdmVudHNBcnJheV8oZXZlbnRzKSB7XG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoZXZlbnRzKSkge1xuXHRcdFx0XHRzaW5nbGVBcnJheV9bMF0gPSBldmVudHM7XG5cdFx0XHRcdGV2ZW50cyA9IHNpbmdsZUFycmF5Xztcblx0XHRcdH1cblx0XHRcdHJldHVybiBldmVudHM7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gbGlzdGVuZXIgaXMgdmFsaWQsIHRocm93aW5nIGFuIGV4Y2VwdGlvbiB3aGVuIGl0J3Mgbm90LlxuICAgKiBAcGFyYW0gIHsqfSBsaXN0ZW5lclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd2YWxpZGF0ZUxpc3RlbmVyXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlTGlzdGVuZXJfKGxpc3RlbmVyKSB7XG5cdFx0XHRpZiAoISgwLCBfbWV0YWwuaXNGdW5jdGlvbikobGlzdGVuZXIpKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBFdmVudEVtaXR0ZXI7XG59KF9tZXRhbC5EaXNwb3NhYmxlKTtcblxuZnVuY3Rpb24gdG9BcnJheSh2YWwpIHtcblx0dmFsID0gdmFsIHx8IFtdO1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RW1pdHRlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50RW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb3JlIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmFic3RyYWN0TWV0aG9kID0gYWJzdHJhY3RNZXRob2Q7XG5leHBvcnRzLmRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSA9IGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBlbmFibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhID0gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhO1xuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbk5hbWU7XG5leHBvcnRzLmdldFN0YXRpY1Byb3BlcnR5ID0gZ2V0U3RhdGljUHJvcGVydHk7XG5leHBvcnRzLmdldFVpZCA9IGdldFVpZDtcbmV4cG9ydHMuaWRlbnRpdHlGdW5jdGlvbiA9IGlkZW50aXR5RnVuY3Rpb247XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbmV4cG9ydHMuaXNEZWYgPSBpc0RlZjtcbmV4cG9ydHMuaXNEZWZBbmROb3ROdWxsID0gaXNEZWZBbmROb3ROdWxsO1xuZXhwb3J0cy5pc0RvY3VtZW50ID0gaXNEb2N1bWVudDtcbmV4cG9ydHMuaXNEb2N1bWVudEZyYWdtZW50ID0gaXNEb2N1bWVudEZyYWdtZW50O1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5leHBvcnRzLmlzV2luZG93ID0gaXNXaW5kb3c7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNTZXJ2ZXJTaWRlID0gaXNTZXJ2ZXJTaWRlO1xuZXhwb3J0cy5udWxsRnVuY3Rpb24gPSBudWxsRnVuY3Rpb247XG52YXIgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHZvaWQgMDtcblxuLyoqXG4gKiBDb3VudGVyIGZvciB1bmlxdWUgaWQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVuaXF1ZUlkQ291bnRlcl8gPSAxO1xuXG4vKipcbiAqIFVuaXF1ZSBpZCBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG52YXIgVUlEX1BST1BFUlRZID0gZXhwb3J0cy5VSURfUFJPUEVSVFkgPSAnY29yZV8nICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApO1xuXG4vKipcbiAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG4gKiBGb28ucHJvdG90eXBlLmJhciA9IGFic3RyYWN0TWV0aG9kXG4gKlxuICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICpcbiAqIEB0eXBlIHshRnVuY3Rpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kKCkge1xuICB0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUgd2l0aCB0aGUgZm9sbG93aW5nIGZlYXR1cmVzIGZyb20gcmNcbiAqIGFuZCAxLnggdmVyc2lvbnM6XG4gKiAgICAgLSBVc2luZyBcImtleVwiIHRvIHJlZmVyZW5jZSBjb21wb25lbnQgaW5zdGFuY2VzLiBJbiB0aGUgY3VycmVudCB2ZXJzaW9uXG4gKiAgICAgICB0aGlzIHNob3VsZCBiZSBkb25lIHZpYSBcInJlZlwiIGluc3RlYWQuIFRoaXMgYWxsb3dzIG9sZCBjb2RlIHN0aWxsXG4gKiAgICAgICB1c2luZyBcImtleVwiIHRvIGtlZXAgd29ya2luZyBsaWtlIGJlZm9yZS4gTk9URTogdGhpcyBtYXkgY2F1c2VcbiAqICAgICAgIHByb2JsZW1zLCBzaW5jZSBcImtleVwiIGlzIG1lYW50IHRvIGJlIHVzZWQgZGlmZmVyZW50bHkuIE9ubHkgdXNlIHRoaXNcbiAqICAgICAgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVwZ3JhZGUgdGhlIGNvZGUgdG8gdXNlIFwicmVmXCIgaW5zdGVhZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGEgT3B0aW9uYWwgb2JqZWN0IHdpdGggZGF0YSB0byBzcGVjaWZ5IG1vcmVcbiAqICAgICBkZXRhaWxzLCBzdWNoIGFzOlxuICogICAgICAgICAtIHJlbmRlcmVycyB7QXJyYXl9IHRoZSB0ZW1wbGF0ZSByZW5kZXJlcnMgdGhhdCBzaG91bGQgYmUgaW5cbiAqICAgICAgICAgICBjb21wYXRpYmlsaXR5IG1vZGUsIGVpdGhlciB0aGVpciBjb25zdHJ1Y3RvcnMgb3Igc3RyaW5nc1xuICogICAgICAgICAgIHJlcHJlc2VudGluZyB0aGVtIChlLmcuICdzb3knIG9yICdqc3gnKS4gQnkgZGVmYXVsdCwgYWxsIHRoZSBvbmVzXG4gKiAgICAgICAgICAgdGhhdCBleHRlbmQgZnJvbSBJbmNyZW1lbnRhbERvbVJlbmRlcmVyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIHZhciBvcHRfZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG9wdF9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlLCBvciBub3RoaW5nIGlmIGl0IGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGEoKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgbW9kZSBjYW4gYmUgc2V0IHZpYSB0aGUgX19NRVRBTF9DT01QQVRJQklMSVRZX18gZ2xvYmFsIHZhci5cbiAgaWYgKGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pIHtcbiAgICAgIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wYXRpYmlsaXR5TW9kZURhdGFfO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgdHJ1dGh5LCBvciB0aGUgc2Vjb25kIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBnZXRGaXJzdFRydXRoeV8oYSwgYikge1xuICByZXR1cm4gYSB8fCBiO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiBjb250ZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAoIWZuLm5hbWUpIHtcbiAgICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICBmbi5uYW1lID0gc3RyLnN1YnN0cmluZyg5LCBzdHIuaW5kZXhPZignKCcpKTtcbiAgfVxuICByZXR1cm4gZm4ubmFtZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBwcm9wZXJ0eSBpbiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gKiBpbmhlcml0ZWQgZnJvbSBhbmNlc3RvcnMgYXMgZXhwZWN0ZWQsIHVubGVzcyBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiBpcyBnaXZlbixcbiAqIHdoaWNoIGNhbiBjaGFuZ2UgaG93IHRoZSBzdXBlciBjbGFzc2VzJyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eSB3aWxsIGJlIG1lcmdlZFxuICogdG9nZXRoZXIuXG4gKiBUaGUgZmluYWwgbWVyZ2VkIHZhbHVlIHdpbGwgYmUgc3RvcmVkIGluIGFub3RoZXIgcHJvcGVydHksIHNvIHRoYXQgaXQgd29uJ3RcbiAqIGJlIHJlY2FsY3VsYXRlZCBldmVuIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOio9fSBvcHRfbWVyZ2VGbiBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBtZXJnZWRcbiAqICAgICB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgc28gZmFyIGFuZCB0aGUgbmV4dCB2YWx1ZSB0byBiZSBtZXJnZWQgdG8gaXQuXG4gKiAgICAgU2hvdWxkIHJldHVybiB0aGVzZSB0d28gbWVyZ2VkIHRvZ2V0aGVyLiBJZiBub3QgcGFzc2VkIHRoZSBmaW5hbCBwcm9wZXJ0eVxuICogICAgIHdpbGwgYmUgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSBhbW9uZyBhbmNlc3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IsIHByb3BlcnR5TmFtZSwgb3B0X21lcmdlRm4pIHtcbiAgdmFyIG1lcmdlZE5hbWUgPSBwcm9wZXJ0eU5hbWUgKyAnX01FUkdFRCc7XG4gIGlmICghY3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuICAgIHZhciBtZXJnZWQgPSBjdG9yLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgPyBjdG9yW3Byb3BlcnR5TmFtZV0gOiBudWxsO1xuICAgIGlmIChjdG9yLl9fcHJvdG9fXyAmJiAhY3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcbiAgICAgIHZhciBtZXJnZUZuID0gb3B0X21lcmdlRm4gfHwgZ2V0Rmlyc3RUcnV0aHlfO1xuICAgICAgbWVyZ2VkID0gbWVyZ2VGbihtZXJnZWQsIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IuX19wcm90b19fLCBwcm9wZXJ0eU5hbWUsIG1lcmdlRm4pKTtcbiAgICB9XG4gICAgY3RvclttZXJnZWROYW1lXSA9IG1lcmdlZDtcbiAgfVxuICByZXR1cm4gY3RvclttZXJnZWROYW1lXTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIHVuaXF1ZSBpZC4gSWYgYG9wdF9vYmplY3RgIGFyZ3VtZW50IGlzIHBhc3NlZCwgdGhlIG9iamVjdCBpc1xuICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG4gKiByZXR1cm5zLiBTZWUge0BsaW5rIFVJRF9QUk9QRVJUWX0uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3QgT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZlxuICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9Jbmhlcml0YW5jZSBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhpc1xuICogICAgIG9iamVjdCdzIHVpZCBwcm9wZXJ0eSBjYW4gYmUgaW5oZXJpdGVkIGZyb20gcGFyZW50cyBvciBub3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGdldFVpZChvcHRfb2JqZWN0LCBvcHRfbm9Jbmhlcml0YW5jZSkge1xuICBpZiAob3B0X29iamVjdCkge1xuICAgIHZhciBpZCA9IG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXTtcbiAgICBpZiAob3B0X25vSW5oZXJpdGFuY2UgJiYgIW9wdF9vYmplY3QuaGFzT3duUHJvcGVydHkoVUlEX1BST1BFUlRZKSkge1xuICAgICAgaWQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaWQgfHwgKG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXSA9IHVuaXF1ZUlkQ291bnRlcl8rKyk7XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZUlkQ291bnRlcl8rKztcbn1cblxuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uIFJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7P30gVGhlIGZpcnN0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWYodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcbiAgcmV0dXJuIGlzRGVmKHZhbCkgJiYgIWlzTnVsbCh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQtZnJhZ21lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb20gZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHdpbmRvdy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuICogYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcbiAgcmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuLyoqXG4gKiBTZXRzIHRvIHRydWUgaWYgcnVubmluZyBpbnNpZGUgTm9kZS5qcyBlbnZpcm9ubWVudCB3aXRoIGV4dHJhIGNoZWNrIGZvclxuICogYHByb2Nlc3MuYnJvd3NlcmAgdG8gc2tpcCBLYXJtYSBydW5uZXIgZW52aXJvbm1lbnQuIEthcm1hIGVudmlyb25tZW50IGhhc1xuICogYHByb2Nlc3NgIGRlZmluZWQgZXZlbiB0aG91Z2ggaXQgcnVucyBvbiB0aGUgYnJvd3Nlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2VydmVyU2lkZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgIXByb2Nlc3MuYnJvd3Nlcjtcbn1cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge31cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlTmFtZWQuanNcbi8vIG1vZHVsZSBpZCA9IDY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGFycmF5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBhcnJheSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoYXJyYXksIG51bGwsIFt7XG5cdFx0a2V5OiAnZXF1YWwnLFxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudC5cbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjFcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRcdGlmIChhcnIxID09PSBhcnIyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7IUFycmF5fSBhcnJcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZpcnN0RGVmaW5lZFZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoYXJyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJyW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cbiAgICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhdHRlbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gb3B0X291dHB1dCB8fCBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0XHRhcnJheS5mbGF0dGVuKGFycltpXSwgb3V0cHV0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgcGFydGljdWxhciB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyIEFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1R9IG9iaiBPYmplY3QgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcblx0XHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHRcdHZhciBydiA9IHZvaWQgMDtcblx0XHRcdGlmIChydiA9IGkgPj0gMCkge1xuXHRcdFx0XHRhcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ2O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUF0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXQoYXJyLCBpKSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTbGljZXMgdGhlIGdpdmVuIGFycmF5LCBqdXN0IGxpa2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgdGhpc1xuICAgKiBpcyBmYXN0ZXIgYW5kIHdvcmtpbmcgb24gYWxsIGFycmF5LWxpa2Ugb2JqZWN0cyAobGlrZSBhcmd1bWVudHMpLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGFyciBBcnJheS1saWtlIG9iamVjdCB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0aGF0IHNob3VsZCBzdGFydCB0aGUgc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggd2hlcmUgdGhlIHNsaWNlIHNob3VsZCBlbmQsIG5vdFxuICAgKiAgIGluY2x1ZGVkIGluIHRoZSBmaW5hbCBhcnJheS4gSWYgbm90IGdpdmVuLCBhbGwgZWxlbWVudHMgYWZ0ZXIgdGhlXG4gICAqICAgc3RhcnQgaW5kZXggd2lsbCBiZSBpbmNsdWRlZC5cbiAgICogQHJldHVybiB7IUFycmF5fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2xpY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0XHR2YXIgc2xpY2VkID0gW107XG5cdFx0XHR2YXIgZW5kID0gKDAsIF9jb3JlLmlzRGVmKShvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzbGljZWQ7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGFycmF5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcnJheTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXN5bmMgPSB7fTtcblxuLyoqXG4gKiBUaHJvdyBhbiBpdGVtIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LiAgRm9yXG4gKiBleGFtcGxlLCBpZiBwcm9jZXNzaW5nIGEgZ3JvdXAgb2YgaXRlbXMgaW4gYSBsb29wLCBzb21ldGltZXMgaXQgaXMgdXNlZnVsXG4gKiB0byByZXBvcnQgYW4gZXJyb3Igd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIHRvIGJlXG4gKiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0geyp9IGV4Y2VwdGlvblxuICovXG5hc3luYy50aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgY2FsbHN0YWNrIHVud2luZHMsIG9yIGFzXG4gKiBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbiBjb250ZXh0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpfSBjYWxsYmFja1xuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgT2JqZWN0IHRvIHVzZSBhcyB0aGUgXCJ0aGlzIHZhbHVlXCIgd2hlbiBjYWxsaW5nXG4gKiAgICAgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuYXN5bmMucnVuID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2gobmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG4vKiogQHByaXZhdGUgeyFBcnJheS48IWFzeW5jLnJ1bi5Xb3JrSXRlbV8+fSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblxuLyoqXG4gKiBSdW4gYW55IHBlbmRpbmcgYXN5bmMucnVuIHdvcmsgaXRlbXMuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGludGVuZGVkXG4gKiBmb3IgZ2VuZXJhbCB1c2UsIGJ1dCBmb3IgdXNlIGJ5IGVudHJ5IHBvaW50IGhhbmRsZXJzIHRvIHJ1biBpdGVtcyBhaGVhZCBvZlxuICogYXN5bmMubmV4dFRpY2suXG4gKi9cbmFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuZm4gPSBmbjtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG4vKipcbiAqIENhY2hlIGZvciB0aGUgc2V0SW1tZWRpYXRlIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IG51bGw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24gKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWwgPSB2b2lkIDA7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8qKiBAY29uc3RydWN0b3IgKi9cblx0XHRDaGFubmVsID0gZnVuY3Rpb24gQ2hhbm5lbCgpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIFZhbGlkYXRlIG9yaWdpbiBhbmQgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG1lc3NhZ2Ugd2FzXG5cdFx0XHRcdC8vIGludGVuZGVkIGZvciB1cy5cblx0XHRcdFx0aWYgKGUub3JpZ2luICE9PSBvcmlnaW4gJiYgZS5kYXRhICE9PSBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucG9ydDEub25tZXNzYWdlKCk7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5wb3J0MSA9IHt9O1xuXHRcdFx0dGhpcy5wb3J0MiA9IHtcblx0XHRcdFx0cG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKCkge1xuXHRcdFx0XHRcdHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlLCBvcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGVvZiBDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBjaGFubmVsID0gbmV3IENoYW5uZWwoKTtcblx0XHQvLyBVc2UgYSBmaWZvIGxpbmtlZCBsaXN0IHRvIGNhbGwgY2FsbGJhY2tzIGluIHRoZSByaWdodCBvcmRlci5cblx0XHR2YXIgaGVhZCA9IHt9O1xuXHRcdHZhciB0YWlsID0gaGVhZDtcblx0XHRjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0c2V0VGltZW91dChjYiwgMCk7XG5cdH07XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uIChvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFzeW5jO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3Bvc2FibGUpO1xuXG5cdFx0LyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHRoaXMuZGlzcG9zZWRfID0gZmFsc2U7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKERpc3Bvc2FibGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpY1xuICAgKiBkaXNwb3NpbmcgbG9naWMgKGxpa2UgY2xlYXJpbmcgcmVmZXJlbmNlcyBhbmQgY2FsbGluZyBgZGlzcG9zZWAgb24gb3RoZXJcbiAgICogZGlzcG9zYWJsZXMpLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNEaXNwb3NlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERpc3Bvc2FibGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3Bvc2FibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIG9iamVjdCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgb2JqZWN0KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhvYmplY3QsIG51bGwsIFt7XG5cdFx0a2V5OiAnbWl4aW4nLFxuXG5cdFx0LyoqXG4gICAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBtaXhpbih0YXJnZXQpIHtcblx0XHRcdHZhciBrZXkgPSB2b2lkIDAsXG5cdFx0XHQgICAgc291cmNlID0gdm9pZCAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcbiAgICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG4gICAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0T2JqZWN0QnlOYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0T2JqZWN0QnlOYW1lKG5hbWUsIG9wdF9vYmopIHtcblx0XHRcdHZhciBzY29wZSA9IG9wdF9vYmogfHwgd2luZG93O1xuXHRcdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdFx0cmV0dXJuIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAocGFydCwga2V5KSB7XG5cdFx0XHRcdHJldHVybiBwYXJ0W2tleV07XG5cdFx0XHR9LCBzY29wZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgZ2l2ZW4gb25lLCBidXQgd2l0aFxuICAgKiB0aGVpciB2YWx1ZXMgc2V0IHRvIHRoZSByZXR1cm4gdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKHN0cmluZywgKil9IGZuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYXAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYXAob2JqLCBmbikge1xuXHRcdFx0dmFyIG1hcHBlZE9iaiA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG1hcHBlZE9ialtrZXlzW2ldXSA9IGZuKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwcGVkT2JqO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHR3byBnaXZlbiBvYmplY3RzIGFyZSBlcXVhbC4gVGhpcyBpcyBkb25lIHZpYSBhIHNoYWxsb3dcbiAgICogY2hlY2ssIGluY2x1ZGluZyBvbmx5IHRoZSBrZXlzIGRpcmVjdGx5IGNvbnRhaW5lZCBieSB0aGUgMiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hhbGxvd0VxdWFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRcdGlmIChvYmoxID09PSBvYmoyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcblx0XHRcdHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuXHRcdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAob2JqMVtrZXlzMVtpXV0gIT09IG9iajJba2V5czFbaV1dKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBvYmplY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBzdHJpbmcoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIHN0cmluZyk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Moc3RyaW5nLCBudWxsLCBbe1xuXHRcdGtleTogJ2Nhc2VJbnNlbnNpdGl2ZUNvbXBhcmUnLFxuXG5cdFx0LyoqXG4gICAqIENvbXBhcmVzIHRoZSBnaXZlbiBzdHJpbmdzIHdpdGhvdXQgdGFraW5nIHRoZSBjYXNlIGludG8gYWNjb3VudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIxXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEVpdGhlciAtMSwgMCBvciAxLCBhY2NvcmRpbmcgdG8gaWYgdGhlIGZpcnN0IHN0cmluZyBpc1xuICAgKiAgICAgXCJzbWFsbGVyXCIsIGVxdWFsIG9yIFwiYmlnZ2VyXCIgdGhhbiB0aGUgc2Vjb25kIGdpdmVuIHN0cmluZy5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmUoc3RyMSwgc3RyMikge1xuXHRcdFx0dmFyIHRlc3QxID0gU3RyaW5nKHN0cjEpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgdGVzdDIgPSBTdHJpbmcoc3RyMikudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKHRlc3QxIDwgdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSBlbHNlIGlmICh0ZXN0MSA9PT0gdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG4gICAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cbiAgICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NvbGxhcHNlQnJlYWtpbmdTcGFjZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx0XFxyXFxuIF0rL2csICcgJykucmVwbGFjZSgvXltcXHRcXHJcXG4gXSt8W1xcdFxcclxcbiBdKyQvZywgJycpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cbiAgKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuICAqICAgICB0byBvbmUuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIFJlZ0V4cCBzYWZlLCBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN9LlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlc2NhcGVSZWdleCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFx4MDgnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UmFuZG9tU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZG9tU3RyaW5nKCkge1xuXHRcdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArIE1hdGguYWJzKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpIF4gRGF0ZS5ub3coKSkudG9TdHJpbmcoMzYpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuICAgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuICAgKiBwcm9wZXJ0eSBvZiB1c2luZyAzMSBwcmltZSBpcyB0aGF0IHRoZSBtdWx0aXBsaWNhdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnlcbiAgICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuICAgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUYXJnZXQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc2hDb2RlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFzaENvZGUodmFsKSB7XG5cdFx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXBsYWNlcyBpbnRlcnZhbCBpbnRvIHRoZSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgdmFsdWUsIGUuZy5cbiAgICogYHJlcGxhY2VJbnRlcnZhbChcImFiY2RlXCIsIDEsIDQsIFwiXCIpYCByZXR1cm5zIFwiYWVcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgaW5wdXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcmVwbGFjZXMgdGhlIHNwZWNpZmllZCBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVwbGFjZUludGVydmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBzdHJpbmc7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogRXZlbnRFbWl0dGVyUHJveHkgdXRpbGl0eS4gSXQncyByZXNwb25zaWJsZSBmb3IgbGlua2luZyB0d28gRXZlbnRFbWl0dGVyXG4gKiBpbnN0YW5jZXMgdG9nZXRoZXIsIGVtaXR0aW5nIGV2ZW50cyBmcm9tIHRoZSBmaXJzdCBlbWl0dGVyIHRocm91Z2ggdGhlXG4gKiBzZWNvbmQgb25lLiBUaGF0IG1lYW5zIHRoYXQgbGlzdGVuaW5nIHRvIGEgc3VwcG9ydGVkIGV2ZW50IG9uIHRoZSB0YXJnZXRcbiAqIGVtaXR0ZXIgd2lsbCBtZWFuIGxpc3RlbmluZyB0byBpdCBvbiB0aGUgb3JpZ2luIGVtaXR0ZXIgYXMgd2VsbC5cbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBvcmlnaW5FbWl0dGVyIEV2ZW50cyBvcmlnaW5hdGVkIG9uIHRoaXMgZW1pdHRlclxuICogICB3aWxsIGJlIGZpcmVkIGZvciB0aGUgdGFyZ2V0IGVtaXR0ZXIncyBsaXN0ZW5lcnMgYXMgd2VsbC5cbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSB0YXJnZXRFbWl0dGVyIEV2ZW50IGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGlzIGVtaXR0ZXJcbiAqICAgd2lsbCBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBldmVudCBpcyBmaXJlZCBieSB0aGUgb3JpZ2luIGVtaXR0ZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0X2JsYWNrbGlzdCBPcHRpb25hbCBibGFja2xpc3Qgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIG5vdCBiZVxuICogICBwcm94aWVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xudmFyIEV2ZW50RW1pdHRlclByb3h5ID0gZnVuY3Rpb24gKF9EaXNwb3NhYmxlKSB7XG5cdF9pbmhlcml0cyhFdmVudEVtaXR0ZXJQcm94eSwgX0Rpc3Bvc2FibGUpO1xuXG5cdGZ1bmN0aW9uIEV2ZW50RW1pdHRlclByb3h5KG9yaWdpbkVtaXR0ZXIsIHRhcmdldEVtaXR0ZXIsIG9wdF9ibGFja2xpc3QsIG9wdF93aGl0ZWxpc3QpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRFbWl0dGVyUHJveHkpO1xuXG5cdFx0LyoqXG4gICAqIE1hcCBvZiBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlIHByb3hpZWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEV2ZW50RW1pdHRlclByb3h5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXZlbnRFbWl0dGVyUHJveHkpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmJsYWNrbGlzdF8gPSBvcHRfYmxhY2tsaXN0O1xuXG5cdFx0LyoqXG4gICAqIFRoZSBvcmlnaW4gZW1pdHRlci4gVGhpcyBlbWl0dGVyJ3MgZXZlbnRzIHdpbGwgYmUgcHJveGllZCB0aHJvdWdoIHRoZVxuICAgKiB0YXJnZXQgZW1pdHRlci5cbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5vcmlnaW5FbWl0dGVyXyA9IG9yaWdpbkVtaXR0ZXI7XG5cblx0XHQvKipcbiAgICogQSBsaXN0IG9mIGV2ZW50cyB0aGF0IGFyZSBwZW5kaW5nIHRvIGJlIGxpc3RlbmVkIGJ5IGFuIGFjdHVhbCBvcmlnaW5cbiAgICogZW1pdHRlci4gRXZlbnRzIGFyZSBzdG9yZWQgaGVyZSB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBleGlzdCwgc28gdGhleVxuICAgKiBjYW4gYmUgc2V0IG9uIGEgbmV3IG9yaWdpbiB3aGVuIG9uZSBpcyBzZXQuXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5wZW5kaW5nRXZlbnRzXyA9IG51bGw7XG5cblx0XHQvKipcbiAgICogSG9sZHMgYSBtYXAgb2YgZXZlbnRzIGZyb20gdGhlIG9yaWdpbiBlbWl0dGVyIHRoYXQgYXJlIGFscmVhZHkgYmVpbmcgcHJveGllZC5cbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICFFdmVudEhhbmRsZT59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMucHJveGllZEV2ZW50c18gPSBudWxsO1xuXG5cdFx0LyoqXG4gICAqIFRoZSB0YXJnZXQgZW1pdHRlci4gVGhpcyBlbWl0dGVyIHdpbGwgZW1pdCBhbGwgZXZlbnRzIHRoYXQgY29tZSBmcm9tXG4gICAqIHRoZSBvcmlnaW4gZW1pdHRlci5cbiAgICogQHR5cGUge0V2ZW50RW1pdHRlcn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy50YXJnZXRFbWl0dGVyXyA9IHRhcmdldEVtaXR0ZXI7XG5cblx0XHQvKipcbiAgICogTWFwIG9mIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBwcm94aWVkLiBJZiB3aGl0ZWxpc3QgaXMgc2V0IGJsYWNrbGlzdCBpcyBpZ25vcmVkLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLndoaXRlbGlzdF8gPSBvcHRfd2hpdGVsaXN0O1xuXG5cdFx0X3RoaXMuc3RhcnRQcm94eV8oKTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBBZGRzIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGxpc3RlbmVyXG4gICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBUaGUgbGlzdGVuZWQgZXZlbnQncyBoYW5kbGUuXG4gICogQHByb3RlY3RlZFxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKEV2ZW50RW1pdHRlclByb3h5LCBbe1xuXHRcdGtleTogJ2FkZExpc3RlbmVyXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVyXyhldmVudCwgbGlzdGVuZXIpIHtcblx0XHRcdHJldHVybiB0aGlzLm9yaWdpbkVtaXR0ZXJfLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0XHR0aGlzLnJlbW92ZUxpc3RlbmVyc18oKTtcblx0XHRcdHRoaXMucHJveGllZEV2ZW50c18gPSBudWxsO1xuXHRcdFx0dGhpcy5vcmlnaW5FbWl0dGVyXyA9IG51bGw7XG5cdFx0XHR0aGlzLnRhcmdldEVtaXR0ZXJfID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRW1pdHMgdGhlIHNwZWNpZmllZCBldmVudCB0eXBlIG9uIHRoZSB0YXJnZXQgZW1pdHRlci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZW1pdE9uVGFyZ2V0XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVtaXRPblRhcmdldF8oKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVtaXR0ZXJfLmVtaXQuYXBwbHkodGhpcy50YXJnZXRFbWl0dGVyXywgYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUHJveGllcyB0aGUgZ2l2ZW4gZXZlbnQgZnJvbSB0aGUgb3JpZ2luIHRvIHRoZSB0YXJnZXQgZW1pdHRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdwcm94eUV2ZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcHJveHlFdmVudChldmVudCkge1xuXHRcdFx0aWYgKHRoaXMuc2hvdWxkUHJveHlFdmVudF8oZXZlbnQpKSB7XG5cdFx0XHRcdHRoaXMudHJ5VG9BZGRMaXN0ZW5lcl8oZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBwcm94eSBsaXN0ZW5lciBmb3IgYWxsIGV2ZW50cy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlTGlzdGVuZXJzXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyc18oKSB7XG5cdFx0XHRpZiAodGhpcy5wcm94aWVkRXZlbnRzXykge1xuXHRcdFx0XHR2YXIgZXZlbnRzID0gT2JqZWN0LmtleXModGhpcy5wcm94aWVkRXZlbnRzXyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzX1tldmVudHNbaV1dLnJlbW92ZUxpc3RlbmVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzXyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBlbmRpbmdFdmVudHNfID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hhbmdlcyB0aGUgb3JpZ2luIGVtaXR0ZXIuIFRoaXMgYXV0b21hdGljYWxseSBkZXRhY2hlcyBhbnkgZXZlbnRzIHRoYXRcbiAgICogd2VyZSBhbHJlYWR5IGJlaW5nIHByb3hpZWQgZnJvbSB0aGUgcHJldmlvdXMgZW1pdHRlciwgYW5kIHN0YXJ0cyBwcm94eWluZ1xuICAgKiB0aGVtIG9uIHRoZSBuZXcgZW1pdHRlciBpbnN0ZWFkLlxuICAgKiBAcGFyYW0geyFFdmVudEVtaXR0ZXJ9IG9yaWdpbkVtaXR0ZXJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldE9yaWdpbkVtaXR0ZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRPcmlnaW5FbWl0dGVyKG9yaWdpbkVtaXR0ZXIpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy5vcmlnaW5FbWl0dGVyXyAmJiB0aGlzLnByb3hpZWRFdmVudHNfID8gT2JqZWN0LmtleXModGhpcy5wcm94aWVkRXZlbnRzXykgOiB0aGlzLnBlbmRpbmdFdmVudHNfO1xuXHRcdFx0dGhpcy5vcmlnaW5FbWl0dGVyXyA9IG9yaWdpbkVtaXR0ZXI7XG5cdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlTGlzdGVuZXJzXygpO1xuXHRcdFx0XHRldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdFx0XHRyZXR1cm4gX3RoaXMyLnByb3h5RXZlbnQoZXZlbnQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBldmVudCBzaG91bGQgYmUgcHJveGllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Nob3VsZFByb3h5RXZlbnRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hvdWxkUHJveHlFdmVudF8oZXZlbnQpIHtcblx0XHRcdGlmICh0aGlzLndoaXRlbGlzdF8gJiYgIXRoaXMud2hpdGVsaXN0X1tldmVudF0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuYmxhY2tsaXN0XyAmJiB0aGlzLmJsYWNrbGlzdF9bZXZlbnRdKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAhdGhpcy5wcm94aWVkRXZlbnRzXyB8fCAhdGhpcy5wcm94aWVkRXZlbnRzX1tldmVudF07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN0YXJ0cyBwcm94eWluZyBhbGwgZXZlbnRzIGZyb20gdGhlIG9yaWdpbiB0byB0aGUgdGFyZ2V0IGVtaXR0ZXIuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3N0YXJ0UHJveHlfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc3RhcnRQcm94eV8oKSB7XG5cdFx0XHR0aGlzLnRhcmdldEVtaXR0ZXJfLm9uTGlzdGVuZXIodGhpcy5wcm94eUV2ZW50LmJpbmQodGhpcykpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIG9yaWdpbiBlbWl0dGVyLCBpZiBpdCBleGlzdHMuIE90aGVyd2lzZSwgc3RvcmVzXG4gICAqIHRoZSBwZW5kaW5nIGxpc3RlbmVyIHNvIGl0IGNhbiBiZSB1c2VkIG9uIGEgZnV0dXJlIG9yaWdpbiBlbWl0dGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndHJ5VG9BZGRMaXN0ZW5lcl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB0cnlUb0FkZExpc3RlbmVyXyhldmVudCkge1xuXHRcdFx0aWYgKHRoaXMub3JpZ2luRW1pdHRlcl8pIHtcblx0XHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzXyA9IHRoaXMucHJveGllZEV2ZW50c18gfHwge307XG5cdFx0XHRcdHRoaXMucHJveGllZEV2ZW50c19bZXZlbnRdID0gdGhpcy5hZGRMaXN0ZW5lcl8oZXZlbnQsIHRoaXMuZW1pdE9uVGFyZ2V0Xy5iaW5kKHRoaXMsIGV2ZW50KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdFdmVudHNfID0gdGhpcy5wZW5kaW5nRXZlbnRzXyB8fCBbXTtcblx0XHRcdFx0dGhpcy5wZW5kaW5nRXZlbnRzXy5wdXNoKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRXZlbnRFbWl0dGVyUHJveHk7XG59KF9tZXRhbC5EaXNwb3NhYmxlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRFbWl0dGVyUHJveHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL2xpYi9FdmVudEVtaXR0ZXJQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEV2ZW50SGFuZGxlciB1dGlsaXR5LiBJdCdzIHVzZWZ1bCBmb3IgZWFzaWx5IHJlbW92aW5nIGEgZ3JvdXAgb2ZcbiAqIGxpc3RlbmVycyBmcm9tIGRpZmZlcmVudCBFdmVudEVtaXR0ZXIgaW5zdGFuY2VzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGlzcG9zYWJsZX1cbiAqL1xudmFyIEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChfRGlzcG9zYWJsZSkge1xuXHRfaW5oZXJpdHMoRXZlbnRIYW5kbGVyLCBfRGlzcG9zYWJsZSk7XG5cblx0ZnVuY3Rpb24gRXZlbnRIYW5kbGVyKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEhhbmRsZXIpO1xuXG5cdFx0LyoqXG4gICAqIEFuIGFycmF5IHRoYXQgaG9sZHMgdGhlIGFkZGVkIGV2ZW50IGhhbmRsZXMsIHNvIHRoZSBsaXN0ZW5lcnMgY2FuIGJlXG4gICAqIHJlbW92ZWQgbGF0ZXIuXG4gICAqIEB0eXBlIHtBcnJheS48RXZlbnRIYW5kbGU+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFdmVudEhhbmRsZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFdmVudEhhbmRsZXIpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmV2ZW50SGFuZGxlc18gPSBbXTtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBBZGRzIGV2ZW50IGhhbmRsZXMgdG8gYmUgcmVtb3ZlZCBsYXRlciB0aHJvdWdoIHRoZSBgcmVtb3ZlQWxsTGlzdGVuZXJzYFxuICAqIG1ldGhvZC5cbiAgKiBAcGFyYW0gey4uLighRXZlbnRIYW5kbGUpfSB2YXJfYXJnc1xuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKEV2ZW50SGFuZGxlciwgW3tcblx0XHRrZXk6ICdhZGQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGQoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlc18ucHVzaChhcmd1bWVudHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge1xuXHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRocm91Z2ggdGhlIGBhZGRgIG1ldGhvZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUFsbExpc3RlbmVycycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudEhhbmRsZXNfLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVzX1tpXS5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLmV2ZW50SGFuZGxlc18gPSBbXTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRXZlbnRIYW5kbGVyO1xufShfbWV0YWwuRGlzcG9zYWJsZSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50SGFuZGxlcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50SGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxudmFyIF9tZXRhbEV2ZW50cyA9IHJlcXVpcmUoJ21ldGFsLWV2ZW50cycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogRG9tRXZlbnRFbWl0dGVyUHJveHkgdXRpbGl0eS4gSXQgZXh0ZW5kcyBgRXZlbnRFbWl0dGVyUHJveHlgIHRvIGFsc28gYWNjZXB0XG4gKiBkb20gZWxlbWVudHMgYXMgb3JpZ2luIGVtaXR0ZXJzLlxuICogQGV4dGVuZHMge0V2ZW50RW1pdHRlclByb3h5fVxuICovXG52YXIgRG9tRXZlbnRFbWl0dGVyUHJveHkgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlclByb3h5KSB7XG5cdF9pbmhlcml0cyhEb21FdmVudEVtaXR0ZXJQcm94eSwgX0V2ZW50RW1pdHRlclByb3h5KTtcblxuXHRmdW5jdGlvbiBEb21FdmVudEVtaXR0ZXJQcm94eSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tRXZlbnRFbWl0dGVyUHJveHkpO1xuXG5cdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEb21FdmVudEVtaXR0ZXJQcm94eS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvbUV2ZW50RW1pdHRlclByb3h5KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoRG9tRXZlbnRFbWl0dGVyUHJveHksIFt7XG5cdFx0a2V5OiAnYWRkTGlzdGVuZXJfJyxcblxuXHRcdC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBsaXN0ZW5lciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gbGlzdGVuZXJcbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBUaGUgbGlzdGVuZWQgZXZlbnQncyBoYW5kbGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcl8oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0XHRpZiAodGhpcy5vcmlnaW5FbWl0dGVyXy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzRGVsZWdhdGVFdmVudF8oZXZlbnQpKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gZXZlbnQuaW5kZXhPZignOicsIDkpO1xuXHRcdFx0XHRcdHZhciBldmVudE5hbWUgPSBldmVudC5zdWJzdHJpbmcoOSwgaW5kZXgpO1xuXHRcdFx0XHRcdHZhciBzZWxlY3RvciA9IGV2ZW50LnN1YnN0cmluZyhpbmRleCArIDEpO1xuXHRcdFx0XHRcdHJldHVybiAoMCwgX2RvbS5kZWxlZ2F0ZSkodGhpcy5vcmlnaW5FbWl0dGVyXywgZXZlbnROYW1lLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiAoMCwgX2RvbS5vbikodGhpcy5vcmlnaW5FbWl0dGVyXywgZXZlbnQsIGxpc3RlbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIF9nZXQoRG9tRXZlbnRFbWl0dGVyUHJveHkucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRG9tRXZlbnRFbWl0dGVyUHJveHkucHJvdG90eXBlKSwgJ2FkZExpc3RlbmVyXycsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQsIGxpc3RlbmVyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBvZiB0aGUgZGVsZWdhdGUgdHlwZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRGVsZWdhdGVFdmVudF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0RlbGVnYXRlRXZlbnRfKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuc3Vic3RyKDAsIDkpID09PSAnZGVsZWdhdGU6Jztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBzdXBwb3J0ZWQgYnkgdGhlIG9yaWdpbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNTdXBwb3J0ZWREb21FdmVudF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZERvbUV2ZW50XyhldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLm9yaWdpbkVtaXR0ZXJfIHx8ICF0aGlzLm9yaWdpbkVtaXR0ZXJfLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5pc0RlbGVnYXRlRXZlbnRfKGV2ZW50KSAmJiBldmVudC5pbmRleE9mKCc6JywgOSkgIT09IC0xIHx8ICgwLCBfZG9tLnN1cHBvcnRzRXZlbnQpKHRoaXMub3JpZ2luRW1pdHRlcl8sIGV2ZW50KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBldmVudCBzaG91bGQgYmUgcHJveGllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaG91bGRQcm94eUV2ZW50XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNob3VsZFByb3h5RXZlbnRfKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gX2dldChEb21FdmVudEVtaXR0ZXJQcm94eS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEb21FdmVudEVtaXR0ZXJQcm94eS5wcm90b3R5cGUpLCAnc2hvdWxkUHJveHlFdmVudF8nLCB0aGlzKS5jYWxsKHRoaXMsIGV2ZW50KSAmJiB0aGlzLmlzU3VwcG9ydGVkRG9tRXZlbnRfKGV2ZW50KTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRG9tRXZlbnRFbWl0dGVyUHJveHk7XG59KF9tZXRhbEV2ZW50cy5FdmVudEVtaXR0ZXJQcm94eSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERvbUV2ZW50RW1pdHRlclByb3h5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvRG9tRXZlbnRFbWl0dGVyUHJveHkuanNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcnVubmluZyBqYXZhc2NyaXB0IGNvZGUgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAqL1xudmFyIGdsb2JhbEV2YWwgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGdsb2JhbEV2YWwoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGdsb2JhbEV2YWwpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGdsb2JhbEV2YWwsIG51bGwsIFt7XG5cdFx0a2V5OiAncnVuJyxcblxuXHRcdC8qKlxuICAgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIHN0cmluZyBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gc2NyaXB0XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW4odGV4dCwgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQudGV4dCA9IHRleHQ7XG5cdFx0XHRpZiAob3B0X2FwcGVuZEZuKSB7XG5cdFx0XHRcdG9wdF9hcHBlbmRGbihzY3JpcHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdFx0fVxuXHRcdFx0KDAsIF9kb20uZXhpdERvY3VtZW50KShzY3JpcHQpO1xuXHRcdFx0cmV0dXJuIHNjcmlwdDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRXZhbHVhdGVzIHRoZSBnaXZlbiBqYXZhc2NyaXB0IGZpbGUgaW4gdGhlIGdsb2JhbCBzY29wZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgZmlsZSdzIHBhdGguXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBzY3JpcHQgaGFzIGJlZW4gcnVuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gc2NyaXB0XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdydW5GaWxlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuRmlsZShzcmMsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQuc3JjID0gc3JjO1xuXG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcblx0XHRcdFx0KDAsIF9kb20uZXhpdERvY3VtZW50KShzY3JpcHQpO1xuXHRcdFx0XHRvcHRfY2FsbGJhY2sgJiYgb3B0X2NhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdFx0KDAsIF9kb20ub25jZSkoc2NyaXB0LCAnbG9hZCcsIGNhbGxiYWNrKTtcblx0XHRcdCgwLCBfZG9tLm9uY2UpKHNjcmlwdCwgJ2Vycm9yJywgY2FsbGJhY2spO1xuXG5cdFx0XHRpZiAob3B0X2FwcGVuZEZuKSB7XG5cdFx0XHRcdG9wdF9hcHBlbmRGbihzY3JpcHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2NyaXB0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFdmFsdWF0ZXMgdGhlIGNvZGUgcmVmZXJlbmNlZCBieSB0aGUgZ2l2ZW4gc2NyaXB0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHNjcmlwdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgT3B0aW9uYWwgZnVuY3Rpb24gdG8gYmUgY2FsbGVkXG4gICAqICAgd2hlbiB0aGUgc2NyaXB0IGhhcyBiZWVuIHJ1bi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuICAgKiAgIGludG8gZG9jdW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IHNjcmlwdFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuU2NyaXB0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuU2NyaXB0KHNjcmlwdCwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuXHRcdFx0XHRvcHRfY2FsbGJhY2sgJiYgb3B0X2NhbGxiYWNrKCk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKHNjcmlwdC50eXBlICYmIHNjcmlwdC50eXBlICE9PSAndGV4dC9qYXZhc2NyaXB0Jykge1xuXHRcdFx0XHRfbWV0YWwuYXN5bmMubmV4dFRpY2soY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQoMCwgX2RvbS5leGl0RG9jdW1lbnQpKHNjcmlwdCk7XG5cdFx0XHRpZiAoc2NyaXB0LnNyYykge1xuXHRcdFx0XHRyZXR1cm4gZ2xvYmFsRXZhbC5ydW5GaWxlKHNjcmlwdC5zcmMsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9tZXRhbC5hc3luYy5uZXh0VGljayhjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybiBnbG9iYWxFdmFsLnJ1bihzY3JpcHQudGV4dCwgb3B0X2FwcGVuZEZuKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogRXZhbHVhdGVzIGFueSBzY3JpcHQgdGFncyBwcmVzZW50IGluIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBzY3JpcHQgaGFzIGJlZW4gcnVuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1blNjcmlwdHNJbkVsZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5TY3JpcHRzSW5FbGVtZW50KGVsZW1lbnQsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgc2NyaXB0cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0Jyk7XG5cdFx0XHRpZiAoc2NyaXB0cy5sZW5ndGgpIHtcblx0XHRcdFx0Z2xvYmFsRXZhbC5ydW5TY3JpcHRzSW5PcmRlcihzY3JpcHRzLCAwLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0XHR9IGVsc2UgaWYgKG9wdF9jYWxsYmFjaykge1xuXHRcdFx0XHRfbWV0YWwuYXN5bmMubmV4dFRpY2sob3B0X2NhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUnVucyB0aGUgZ2l2ZW4gc2NyaXB0cyBlbGVtZW50cyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFwcGVhci5cbiAgICogQHBhcmFtIHshTm9kZUxpc3R9IHNjcmlwdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBzY3JpcHQgaGFzIGJlZW4gcnVuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1blNjcmlwdHNJbk9yZGVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuU2NyaXB0c0luT3JkZXIoc2NyaXB0cywgaW5kZXgsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHRnbG9iYWxFdmFsLnJ1blNjcmlwdChzY3JpcHRzLml0ZW0oaW5kZXgpLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmIChpbmRleCA8IHNjcmlwdHMubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdGdsb2JhbEV2YWwucnVuU2NyaXB0c0luT3JkZXIoc2NyaXB0cywgaW5kZXggKyAxLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0XHRcdH0gZWxzZSBpZiAob3B0X2NhbGxiYWNrKSB7XG5cdFx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKG9wdF9jYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIG9wdF9hcHBlbmRGbik7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGdsb2JhbEV2YWw7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbEV2YWw7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9nbG9iYWxFdmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHJ1bm5pbmcgc3R5bGVzLlxuICovXG52YXIgZ2xvYmFsRXZhbFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gZ2xvYmFsRXZhbFN0eWxlcygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgZ2xvYmFsRXZhbFN0eWxlcyk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoZ2xvYmFsRXZhbFN0eWxlcywgbnVsbCwgW3tcblx0XHRrZXk6ICdydW4nLFxuXG5cdFx0LyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gc3R5bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBzdHlsZVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuKHRleHQsIG9wdF9hcHBlbmRGbikge1xuXHRcdFx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcblx0XHRcdHN0eWxlLmlubmVySFRNTCA9IHRleHQ7XG5cdFx0XHRpZiAob3B0X2FwcGVuZEZuKSB7XG5cdFx0XHRcdG9wdF9hcHBlbmRGbihzdHlsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHlsZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRXZhbHVhdGVzIHRoZSBnaXZlbiBzdHlsZSBmaWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBUaGUgZmlsZSdzIHBhdGguXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBzdHlsZXMgaGFzIGJlZW4gcnVuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gc3R5bGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1bkZpbGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5GaWxlKGhyZWYsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcblx0XHRcdGxpbmsucmVsID0gJ3N0eWxlc2hlZXQnO1xuXHRcdFx0bGluay5ocmVmID0gaHJlZjtcblx0XHRcdGdsb2JhbEV2YWxTdHlsZXMucnVuU3R5bGUobGluaywgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pO1xuXHRcdFx0cmV0dXJuIGxpbms7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgY29kZSByZWZlcmVuY2VkIGJ5IHRoZSBnaXZlbiBzdHlsZS9saW5rIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHN0eWxlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBzY3JpcHQgaGFzIGJlZW4gcnVuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICogIEByZXR1cm4ge0VsZW1lbnR9IHN0eWxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdydW5TdHlsZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJ1blN0eWxlKHN0eWxlLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbikge1xuXHRcdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG5cdFx0XHRcdG9wdF9jYWxsYmFjayAmJiBvcHRfY2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoc3R5bGUucmVsICYmIHN0eWxlLnJlbCAhPT0gJ3N0eWxlc2hlZXQnKSB7XG5cdFx0XHRcdF9tZXRhbC5hc3luYy5uZXh0VGljayhjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHN0eWxlLnRhZ05hbWUgPT09ICdTVFlMRScpIHtcblx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKGNhbGxiYWNrKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCgwLCBfZG9tLm9uY2UpKHN0eWxlLCAnbG9hZCcsIGNhbGxiYWNrKTtcblx0XHRcdFx0KDAsIF9kb20ub25jZSkoc3R5bGUsICdlcnJvcicsIGNhbGxiYWNrKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdF9hcHBlbmRGbikge1xuXHRcdFx0XHRvcHRfYXBwZW5kRm4oc3R5bGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdHlsZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRXZhbHVhdGVzIGFueSBzdHlsZSBwcmVzZW50IGluIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGVcbiAgICogICBzdHlsZSBoYXMgYmVlbiBydW4uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuU3R5bGVzSW5FbGVtZW50Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuU3R5bGVzSW5FbGVtZW50KGVsZW1lbnQsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgc3R5bGVzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZSxsaW5rJyk7XG5cdFx0XHRpZiAoc3R5bGVzLmxlbmd0aCA9PT0gMCAmJiBvcHRfY2FsbGJhY2spIHtcblx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKG9wdF9jYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGxvYWRDb3VudCA9IDA7XG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcblx0XHRcdFx0aWYgKG9wdF9jYWxsYmFjayAmJiArK2xvYWRDb3VudCA9PT0gc3R5bGVzLmxlbmd0aCkge1xuXHRcdFx0XHRcdF9tZXRhbC5hc3luYy5uZXh0VGljayhvcHRfY2FsbGJhY2spO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Z2xvYmFsRXZhbFN0eWxlcy5ydW5TdHlsZShzdHlsZXNbaV0sIGNhbGxiYWNrLCBvcHRfYXBwZW5kRm4pO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBnbG9iYWxFdmFsU3R5bGVzO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBnbG9iYWxFdmFsU3R5bGVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZ2xvYmFsRXZhbFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoJy4vZG9tJyk7XG5cbnZhciBfZmVhdHVyZXMgPSByZXF1aXJlKCcuL2ZlYXR1cmVzJyk7XG5cbnZhciBfZmVhdHVyZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmVhdHVyZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgbW91c2VFdmVudE1hcCA9IHtcblx0bW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXG5cdG1vdXNlbGVhdmU6ICdtb3VzZW91dCcsXG5cdHBvaW50ZXJlbnRlcjogJ3BvaW50ZXJvdmVyJyxcblx0cG9pbnRlcmxlYXZlOiAncG9pbnRlcm91dCdcbn07XG5PYmplY3Qua2V5cyhtb3VzZUV2ZW50TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0KDAsIF9kb20ucmVnaXN0ZXJDdXN0b21FdmVudCkoZXZlbnROYW1lLCB7XG5cdFx0ZGVsZWdhdGU6IHRydWUsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcihjYWxsYmFjaywgZXZlbnQpIHtcblx0XHRcdHZhciByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblx0XHRcdHZhciB0YXJnZXQgPSBldmVudC5kZWxlZ2F0ZVRhcmdldDtcblx0XHRcdGlmICghcmVsYXRlZCB8fCByZWxhdGVkICE9PSB0YXJnZXQgJiYgISgwLCBfZG9tLmNvbnRhaW5zKSh0YXJnZXQsIHJlbGF0ZWQpKSB7XG5cdFx0XHRcdGV2ZW50LmN1c3RvbVR5cGUgPSBldmVudE5hbWU7XG5cdFx0XHRcdHJldHVybiBjYWxsYmFjayhldmVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRvcmlnaW5hbEV2ZW50OiBtb3VzZUV2ZW50TWFwW2V2ZW50TmFtZV1cblx0fSk7XG59KTtcblxudmFyIGFuaW1hdGlvbkV2ZW50TWFwID0ge1xuXHRhbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxuXHR0cmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCdcbn07XG5PYmplY3Qua2V5cyhhbmltYXRpb25FdmVudE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG5cdHZhciBldmVudE5hbWUgPSBhbmltYXRpb25FdmVudE1hcFtldmVudFR5cGVdO1xuXHQoMCwgX2RvbS5yZWdpc3RlckN1c3RvbUV2ZW50KShldmVudE5hbWUsIHtcblx0XHRldmVudDogdHJ1ZSxcblx0XHRkZWxlZ2F0ZTogdHJ1ZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNhbGxiYWNrLCBldmVudCkge1xuXHRcdFx0ZXZlbnQuY3VzdG9tVHlwZSA9IGV2ZW50TmFtZTtcblx0XHRcdHJldHVybiBjYWxsYmFjayhldmVudCk7XG5cdFx0fSxcblx0XHRvcmlnaW5hbEV2ZW50OiBfZmVhdHVyZXMyLmRlZmF1bHQuY2hlY2tBbmltYXRpb25FdmVudE5hbWUoKVtldmVudFR5cGVdXG5cdH0pO1xufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5hYnN0cmFjdE1ldGhvZCA9IGFic3RyYWN0TWV0aG9kO1xuZXhwb3J0cy5kaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmVuYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSA9IGdldENvbXBhdGliaWxpdHlNb2RlRGF0YTtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuZXhwb3J0cy5nZXRTdGF0aWNQcm9wZXJ0eSA9IGdldFN0YXRpY1Byb3BlcnR5O1xuZXhwb3J0cy5nZXRVaWQgPSBnZXRVaWQ7XG5leHBvcnRzLmlkZW50aXR5RnVuY3Rpb24gPSBpZGVudGl0eUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzRGVmID0gaXNEZWY7XG5leHBvcnRzLmlzRGVmQW5kTm90TnVsbCA9IGlzRGVmQW5kTm90TnVsbDtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzRG9jdW1lbnRGcmFnbWVudCA9IGlzRG9jdW1lbnRGcmFnbWVudDtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc1dpbmRvdyA9IGlzV2luZG93O1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzU2VydmVyU2lkZSA9IGlzU2VydmVyU2lkZTtcbmV4cG9ydHMubnVsbEZ1bmN0aW9uID0gbnVsbEZ1bmN0aW9uO1xudmFyIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB2b2lkIDA7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xudmFyIFVJRF9QUk9QRVJUWSA9IGV4cG9ydHMuVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBhYnN0cmFjdE1ldGhvZCgpIHtcbiAgdGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBFbmFibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlIHdpdGggdGhlIGZvbGxvd2luZyBmZWF0dXJlcyBmcm9tIHJjXG4gKiBhbmQgMS54IHZlcnNpb25zOlxuICogICAgIC0gVXNpbmcgXCJrZXlcIiB0byByZWZlcmVuY2UgY29tcG9uZW50IGluc3RhbmNlcy4gSW4gdGhlIGN1cnJlbnQgdmVyc2lvblxuICogICAgICAgdGhpcyBzaG91bGQgYmUgZG9uZSB2aWEgXCJyZWZcIiBpbnN0ZWFkLiBUaGlzIGFsbG93cyBvbGQgY29kZSBzdGlsbFxuICogICAgICAgdXNpbmcgXCJrZXlcIiB0byBrZWVwIHdvcmtpbmcgbGlrZSBiZWZvcmUuIE5PVEU6IHRoaXMgbWF5IGNhdXNlXG4gKiAgICAgICBwcm9ibGVtcywgc2luY2UgXCJrZXlcIiBpcyBtZWFudCB0byBiZSB1c2VkIGRpZmZlcmVudGx5LiBPbmx5IHVzZSB0aGlzXG4gKiAgICAgICBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byB1cGdyYWRlIHRoZSBjb2RlIHRvIHVzZSBcInJlZlwiIGluc3RlYWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9kYXRhIE9wdGlvbmFsIG9iamVjdCB3aXRoIGRhdGEgdG8gc3BlY2lmeSBtb3JlXG4gKiAgICAgZGV0YWlscywgc3VjaCBhczpcbiAqICAgICAgICAgLSByZW5kZXJlcnMge0FycmF5fSB0aGUgdGVtcGxhdGUgcmVuZGVyZXJzIHRoYXQgc2hvdWxkIGJlIGluXG4gKiAgICAgICAgICAgY29tcGF0aWJpbGl0eSBtb2RlLCBlaXRoZXIgdGhlaXIgY29uc3RydWN0b3JzIG9yIHN0cmluZ3NcbiAqICAgICAgICAgICByZXByZXNlbnRpbmcgdGhlbSAoZS5nLiAnc295JyBvciAnanN4JykuIEJ5IGRlZmF1bHQsIGFsbCB0aGUgb25lc1xuICogICAgICAgICAgIHRoYXQgZXh0ZW5kIGZyb20gSW5jcmVtZW50YWxEb21SZW5kZXJlci5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICB2YXIgb3B0X2RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBvcHRfZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHVzZWQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZSwgb3Igbm90aGluZyBpZiBpdCBoYXNuJ3QgYmVlblxuICogZW5hYmxlZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuICAvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG4gIGlmIChjb21wYXRpYmlsaXR5TW9kZURhdGFfID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKSB7XG4gICAgICBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSh3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcGF0aWJpbGl0eU1vZGVEYXRhXztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCdzIHRydXRoeSwgb3IgdGhlIHNlY29uZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RUcnV0aHlfKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkb2Vzbid0XG4gKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICogY29udGVudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKCFmbi5uYW1lKSB7XG4gICAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG4gIH1cbiAgcmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgcHJvcGVydHkgaW4gdGhlIGdpdmVuIGNsYXNzLiBUaGUgdmFsdWUgd2lsbCBiZVxuICogaW5oZXJpdGVkIGZyb20gYW5jZXN0b3JzIGFzIGV4cGVjdGVkLCB1bmxlc3MgYSBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gaXMgZ2l2ZW4sXG4gKiB3aGljaCBjYW4gY2hhbmdlIGhvdyB0aGUgc3VwZXIgY2xhc3NlcycgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkgd2lsbCBiZSBtZXJnZWRcbiAqIHRvZ2V0aGVyLlxuICogVGhlIGZpbmFsIG1lcmdlZCB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBpbiBhbm90aGVyIHByb3BlcnR5LCBzbyB0aGF0IGl0IHdvbid0XG4gKiBiZSByZWNhbGN1bGF0ZWQgZXZlbiBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbWVyZ2VkXG4gKiAgICAgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHNvIGZhciBhbmQgdGhlIG5leHQgdmFsdWUgdG8gYmUgbWVyZ2VkIHRvIGl0LlxuICogICAgIFNob3VsZCByZXR1cm4gdGhlc2UgdHdvIG1lcmdlZCB0b2dldGhlci4gSWYgbm90IHBhc3NlZCB0aGUgZmluYWwgcHJvcGVydHlcbiAqICAgICB3aWxsIGJlIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgYW1vbmcgYW5jZXN0b3JzLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG4gIHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuICBpZiAoIWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcbiAgICB2YXIgbWVyZ2VkID0gY3Rvci5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpID8gY3Rvcltwcm9wZXJ0eU5hbWVdIDogbnVsbDtcbiAgICBpZiAoY3Rvci5fX3Byb3RvX18gJiYgIWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG4gICAgICB2YXIgbWVyZ2VGbiA9IG9wdF9tZXJnZUZuIHx8IGdldEZpcnN0VHJ1dGh5XztcbiAgICAgIG1lcmdlZCA9IG1lcmdlRm4obWVyZ2VkLCBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLl9fcHJvdG9fXywgcHJvcGVydHlOYW1lLCBtZXJnZUZuKSk7XG4gICAgfVxuICAgIGN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG4gIH1cbiAgcmV0dXJuIGN0b3JbbWVyZ2VkTmFtZV07XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcbiAgaWYgKG9wdF9vYmplY3QpIHtcbiAgICB2YXIgaWQgPSBvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV07XG4gICAgaWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KFVJRF9QUk9QRVJUWSkpIHtcbiAgICAgIGlkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV0gPSB1bmlxdWVJZENvdW50ZXJfKyspO1xuICB9XG4gIHJldHVybiB1bmlxdWVJZENvdW50ZXJfKys7XG59XG5cbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF9yZXR1cm5WYWx1ZSBUaGUgc2luZ2xlIHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcbiAgcmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRGVmKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG4gIHJldHVybiBpc0RlZih2YWwpICYmICFpc051bGwodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LWZyYWdtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3codmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsID09PSB2YWwud2luZG93O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBhcnJheXNcbiAqIGFuZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogU2V0cyB0byB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aCBleHRyYSBjaGVjayBmb3JcbiAqIGBwcm9jZXNzLmJyb3dzZXJgIHRvIHNraXAgS2FybWEgcnVubmVyIGVudmlyb25tZW50LiBLYXJtYSBlbnZpcm9ubWVudCBoYXNcbiAqIGBwcm9jZXNzYCBkZWZpbmVkIGV2ZW4gdGhvdWdoIGl0IHJ1bnMgb24gdGhlIGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmICFwcm9jZXNzLmJyb3dzZXI7XG59XG5cbi8qKlxuICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlTmFtZWQuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGFycmF5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBhcnJheSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoYXJyYXksIG51bGwsIFt7XG5cdFx0a2V5OiAnZXF1YWwnLFxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudC5cbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjFcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRcdGlmIChhcnIxID09PSBhcnIyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7IUFycmF5fSBhcnJcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZpcnN0RGVmaW5lZFZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoYXJyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJyW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cbiAgICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhdHRlbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gb3B0X291dHB1dCB8fCBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0XHRhcnJheS5mbGF0dGVuKGFycltpXSwgb3V0cHV0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgcGFydGljdWxhciB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyIEFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1R9IG9iaiBPYmplY3QgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcblx0XHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHRcdHZhciBydiA9IHZvaWQgMDtcblx0XHRcdGlmIChydiA9IGkgPj0gMCkge1xuXHRcdFx0XHRhcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ2O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUF0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXQoYXJyLCBpKSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTbGljZXMgdGhlIGdpdmVuIGFycmF5LCBqdXN0IGxpa2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgdGhpc1xuICAgKiBpcyBmYXN0ZXIgYW5kIHdvcmtpbmcgb24gYWxsIGFycmF5LWxpa2Ugb2JqZWN0cyAobGlrZSBhcmd1bWVudHMpLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGFyciBBcnJheS1saWtlIG9iamVjdCB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0aGF0IHNob3VsZCBzdGFydCB0aGUgc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggd2hlcmUgdGhlIHNsaWNlIHNob3VsZCBlbmQsIG5vdFxuICAgKiAgIGluY2x1ZGVkIGluIHRoZSBmaW5hbCBhcnJheS4gSWYgbm90IGdpdmVuLCBhbGwgZWxlbWVudHMgYWZ0ZXIgdGhlXG4gICAqICAgc3RhcnQgaW5kZXggd2lsbCBiZSBpbmNsdWRlZC5cbiAgICogQHJldHVybiB7IUFycmF5fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2xpY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0XHR2YXIgc2xpY2VkID0gW107XG5cdFx0XHR2YXIgZW5kID0gKDAsIF9jb3JlLmlzRGVmKShvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzbGljZWQ7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGFycmF5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcnJheTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbnZhciBhc3luYyA9IHt9O1xuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbCA9IHZvaWQgMDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbiBDaGFubmVsKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24gKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBEaXNwb3NhYmxlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuXHRcdC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG4gICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLiBDYWxscyBgZGlzcG9zZUludGVybmFsYC5cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEaXNwb3NhYmxlLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0aWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcbiAgICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG4gICAqIGRpc3Bvc2FibGVzKS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRGlzcG9zZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcG9zZWRfO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEaXNwb3NhYmxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwb3NhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIG9iamVjdCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgb2JqZWN0KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhvYmplY3QsIG51bGwsIFt7XG5cdFx0a2V5OiAnbWl4aW4nLFxuXG5cdFx0LyoqXG4gICAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBtaXhpbih0YXJnZXQpIHtcblx0XHRcdHZhciBrZXkgPSB2b2lkIDAsXG5cdFx0XHQgICAgc291cmNlID0gdm9pZCAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcbiAgICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG4gICAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0T2JqZWN0QnlOYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0T2JqZWN0QnlOYW1lKG5hbWUsIG9wdF9vYmopIHtcblx0XHRcdHZhciBzY29wZSA9IG9wdF9vYmogfHwgd2luZG93O1xuXHRcdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdFx0cmV0dXJuIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAocGFydCwga2V5KSB7XG5cdFx0XHRcdHJldHVybiBwYXJ0W2tleV07XG5cdFx0XHR9LCBzY29wZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgZ2l2ZW4gb25lLCBidXQgd2l0aFxuICAgKiB0aGVpciB2YWx1ZXMgc2V0IHRvIHRoZSByZXR1cm4gdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKHN0cmluZywgKil9IGZuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYXAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYXAob2JqLCBmbikge1xuXHRcdFx0dmFyIG1hcHBlZE9iaiA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG1hcHBlZE9ialtrZXlzW2ldXSA9IGZuKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwcGVkT2JqO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHR3byBnaXZlbiBvYmplY3RzIGFyZSBlcXVhbC4gVGhpcyBpcyBkb25lIHZpYSBhIHNoYWxsb3dcbiAgICogY2hlY2ssIGluY2x1ZGluZyBvbmx5IHRoZSBrZXlzIGRpcmVjdGx5IGNvbnRhaW5lZCBieSB0aGUgMiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hhbGxvd0VxdWFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRcdGlmIChvYmoxID09PSBvYmoyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcblx0XHRcdHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuXHRcdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAob2JqMVtrZXlzMVtpXV0gIT09IG9iajJba2V5czFbaV1dKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBvYmplY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIHN0cmluZygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgc3RyaW5nKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhzdHJpbmcsIG51bGwsIFt7XG5cdFx0a2V5OiAnY2FzZUluc2Vuc2l0aXZlQ29tcGFyZScsXG5cblx0XHQvKipcbiAgICogQ29tcGFyZXMgdGhlIGdpdmVuIHN0cmluZ3Mgd2l0aG91dCB0YWtpbmcgdGhlIGNhc2UgaW50byBhY2NvdW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjFcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIyXG4gICAqIEByZXR1cm4ge251bWJlcn0gRWl0aGVyIC0xLCAwIG9yIDEsIGFjY29yZGluZyB0byBpZiB0aGUgZmlyc3Qgc3RyaW5nIGlzXG4gICAqICAgICBcInNtYWxsZXJcIiwgZXF1YWwgb3IgXCJiaWdnZXJcIiB0aGFuIHRoZSBzZWNvbmQgZ2l2ZW4gc3RyaW5nLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FzZUluc2Vuc2l0aXZlQ29tcGFyZShzdHIxLCBzdHIyKSB7XG5cdFx0XHR2YXIgdGVzdDEgPSBTdHJpbmcoc3RyMSkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB0ZXN0MiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAodGVzdDEgPCB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRlc3QxID09PSB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBicmVha2luZyBzcGFjZXMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHN0cmluZyBhbmRcbiAgICogY29sbGFwc2VzIHRoZSBzZXF1ZW5jZXMgb2YgYnJlYWtpbmcgc3BhY2VzIGluIHRoZSBtaWRkbGUgaW50byBzaW5nbGUgc3BhY2VzLlxuICAgKiBUaGUgb3JpZ2luYWwgYW5kIHRoZSByZXN1bHQgc3RyaW5ncyByZW5kZXIgdGhlIHNhbWUgd2F5IGluIEhUTUwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgaW4gd2hpY2ggdG8gY29sbGFwc2Ugc3BhY2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvcHkgb2YgdGhlIHN0cmluZyB3aXRoIG5vcm1hbGl6ZWQgYnJlYWtpbmcgc3BhY2VzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29sbGFwc2VCcmVha2luZ1NwYWNlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbGxhcHNlQnJlYWtpbmdTcGFjZXMoc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IHNhZmUgdG8gdXNlIGluIGEgUmVnRXhwLlxuICAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gZXNjYXBlLiBJZiBub3QgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY2FzdGVkXG4gICogICAgIHRvIG9uZS5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVnRXhwIHNhZmUsIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc30uXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2VzY2FwZVJlZ2V4Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRSYW5kb21TdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGhhc2hjb2RlIGZvciBhIHN0cmluZy4gVGhlIGhhc2hjb2RlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5XG4gICAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG4gICAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuICAgKiBhIHNoaWZ0IGFuZCBhIHN1YnRyYWN0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6IDMxKmkgPT0gKGk8PDUpLWkuXG4gICAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIGhhc2hjb2RlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzaENvZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNoQ29kZSh2YWwpIHtcblx0XHRcdHZhciBoYXNoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuICAgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlSW50ZXJ2YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIHN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF92YWxpZGF0b3JzID0gcmVxdWlyZSgnLi92YWxpZGF0b3JzJyk7XG5cbnZhciBfdmFsaWRhdG9yczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92YWxpZGF0b3JzKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBTdWdhciBhcGkgdGhhdCBjYW4gYmUgdXNlZCBhcyBhbiBhbHRlcm5hdGl2ZSBmb3IgbWFudWFsbHkgYnVpbGRpbmcgYFN0YXRlYFxuICogY29uZmlndXJhdGlvbiBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0LiBGb3IgZXhhbXBsZSwgaW5zdGVhZCBvZiBoYXZpbmdcbiAqIHNvbWV0aGluZyBsaWtlIHRoaXM6XG4gKlxuICogYGBganNcbiAqIE15Q2xhc3MuU1RBVEUgPSB7XG4gKiAgIGZvbzoge1xuICogICAgIHJlcXVpcmVkOiB0cnVlLFxuICogICAgIHZhbGlkYXRvcjogdmFsaWRhdG9ycy5udW1iZXIsXG4gKiAgICAgdmFsdWU6IDEzXG4gKiAgIH1cbiAqIH07XG4gKiBgYGBcbiAqXG4gKiBZb3UgY291bGQgaW5zdGVhZCBkbzpcbiAqXG4gKiBgYGBqc1xuICogTXlDbGFzcy5TVEFURSA9IHtcbiAqICAgZm9vOiBDb25maWcucmVxdWlyZWQoKS5udW1iZXIoKS52YWx1ZSgxMylcbiAqIH07XG4gKiBgYGBcbiAqL1xudmFyIENvbmZpZyA9IHtcblx0LyoqXG4gKiBBbiBvYmplY3QgdGhhdCBjb250YWlucyBhIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIEB0eXBlZGVmIHshT2JqZWN0fSBDb25maWdXaXRoVmFsaWRhdG9yXG4gKi9cblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgYW55YCB2YWxpZGF0b3IuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0YW55OiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdhbnknKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgYXJyYXlgIHZhbGlkYXRvci5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRhcnJheTogc2V0UHJpbWl0aXZlVmFsaWRhdG9ycygnYXJyYXknKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgYXJyYXlPZmAgdmFsaWRhdG9yLlxuICAqIEBwYXJhbSB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gc3RhdGVDb25maWcgYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdGFycmF5T2Y6IHNldE5lc3RlZFZhbGlkYXRvcnMoJ2FycmF5T2YnKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhIGBib29sYCB2YWxpZGF0b3IuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0Ym9vbDogc2V0UHJpbWl0aXZlVmFsaWRhdG9ycygnYm9vbCcpLFxuXG5cdC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBgU3RhdGVgIG9iamVjdCB3aXRoIGEgYGZ1bmNgIHZhbGlkYXRvci5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRmdW5jOiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdmdW5jJyksXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYW4gYGluc3RhbmNlT2ZgIHZhbGlkYXRvci5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRpbnN0YW5jZU9mOiBzZXRFeHBsaWNpdFZhbHVlVmFsaWRhdG9ycygnaW5zdGFuY2VPZicpLFxuXG5cdC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBgU3RhdGVgIG9iamVjdCB3aXRoIGEgYG51bWJlcmAgdmFsaWRhdG9yLlxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdG51bWJlcjogc2V0UHJpbWl0aXZlVmFsaWRhdG9ycygnbnVtYmVyJyksXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYW4gYG9iamVjdGAgdmFsaWRhdG9yLlxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdG9iamVjdDogc2V0UHJpbWl0aXZlVmFsaWRhdG9ycygnb2JqZWN0JyksXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYW4gYG9iamVjdE9mYCB2YWxpZGF0b3IuXG4gICogQHBhcmFtIHtDb25maWdXaXRoVmFsaWRhdG9yfSBzdGF0ZUNvbmZpZyBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0b2JqZWN0T2Y6IHNldE5lc3RlZFZhbGlkYXRvcnMoJ29iamVjdE9mJyksXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYW4gYG9uZU9mYCB2YWxpZGF0b3IuXG4gICogQHBhcmFtIHshQXJyYXl9IHZhbHVlcyBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0b25lT2Y6IHNldEV4cGxpY2l0VmFsdWVWYWxpZGF0b3JzKCdvbmVPZicpLFxuXG5cdC8qKlxuICAqIENyZWF0ZXMgYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIGFuIGBvbmVPZlR5cGVgIHZhbGlkYXRvci5cbiAgKiBAcGFyYW0ge0NvbmZpZ1dpdGhWYWxpZGF0b3JbXX0gdmFsaWRhdG9yQXJyYXkgQXJyYXkgb2YgYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0b25lT2ZUeXBlOiBmdW5jdGlvbiBvbmVPZlR5cGUodmFsaWRhdG9yQXJyYXkpIHtcblx0XHR2YWxpZGF0b3JBcnJheSA9IHZhbGlkYXRvckFycmF5Lm1hcChmdW5jdGlvbiAoY29uZmlnT2JqKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnT2JqLmNvbmZpZy52YWxpZGF0b3I7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcy52YWxpZGF0b3IoX3ZhbGlkYXRvcnMyLmRlZmF1bHQub25lT2ZUeXBlKHZhbGlkYXRvckFycmF5KSk7XG5cdH0sXG5cblxuXHQvKipcbiAgKiBDcmVhdGVzIGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aCBhIGBzaGFwZU9mYCB2YWxpZGF0b3IuXG4gICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsIENvbmZpZ1dpdGhWYWxpZGF0b3I+fSBzaGFwZU9iaiBWYWx1ZXMgYmVpbmcgYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0c2hhcGVPZjogZnVuY3Rpb24gc2hhcGVPZihzaGFwZU9iaikge1xuXHRcdHNoYXBlT2JqID0gZGVzdHJ1Y3RTaGFwZU9mQ29uZmlncyhzaGFwZU9iaik7XG5cblx0XHRyZXR1cm4gdGhpcy52YWxpZGF0b3IoX3ZhbGlkYXRvcnMyLmRlZmF1bHQuc2hhcGVPZihzaGFwZU9iaikpO1xuXHR9LFxuXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYW4gYHN0cmluZ2AgdmFsaWRhdG9yLlxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdHN0cmluZzogc2V0UHJpbWl0aXZlVmFsaWRhdG9ycygnc3RyaW5nJyksXG5cblx0LyoqXG4gICogQWRkcyB0aGUgYGludGVybmFsYCBmbGFnIHRvIHRoZSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24uXG4gICogQHBhcmFtIHtib29sZWFufSByZXF1aXJlZCBGbGFnIHRvIHNldCBcImludGVybmFsXCIgdG8uIFRydWUgYnkgZGVmYXVsdC5cbiAgKiBAcmV0dXJuIHshT2JqZWN0fSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRpbnRlcm5hbDogZnVuY3Rpb24gaW50ZXJuYWwoKSB7XG5cdFx0dmFyIF9pbnRlcm5hbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcblxuXHRcdHJldHVybiBtZXJnZUNvbmZpZyh0aGlzLCB7XG5cdFx0XHRpbnRlcm5hbDogX2ludGVybmFsXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvKipcbiAgKiBBZGRzIHRoZSBgcmVxdWlyZWRgIGZsYWcgdG8gdGhlIGBTdGF0ZWAgY29uZmlndXJhdGlvbi5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkIEZsYWcgdG8gc2V0IFwicmVxdWlyZWRcIiB0by4gVHJ1ZSBieSBkZWZhdWx0LlxuICAqIEByZXR1cm4geyFPYmplY3R9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdHJlcXVpcmVkOiBmdW5jdGlvbiByZXF1aXJlZCgpIHtcblx0XHR2YXIgX3JlcXVpcmVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG5cdFx0cmV0dXJuIG1lcmdlQ29uZmlnKHRoaXMsIHtcblx0XHRcdHJlcXVpcmVkOiBfcmVxdWlyZWRcblx0XHR9KTtcblx0fSxcblxuXG5cdC8qKlxuICAqIEFkZHMgYSBzZXR0ZXIgdG8gdGhlIGBTdGF0ZWAgY29uZmlndXJhdGlvbi5cbiAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBzZXR0ZXJcbiAgKiBAcmV0dXJuIHshT2JqZWN0fSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRzZXR0ZXI6IGZ1bmN0aW9uIHNldHRlcihfc2V0dGVyKSB7XG5cdFx0cmV0dXJuIG1lcmdlQ29uZmlnKHRoaXMsIHtcblx0XHRcdHNldHRlcjogX3NldHRlclxuXHRcdH0pO1xuXHR9LFxuXG5cblx0LyoqXG4gICogQWRkcyBhIHZhbGlkYXRvciB0byB0aGUgYFN0YXRlYCBjb25maWd1cmF0aW9uLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHZhbGlkYXRvclxuICAqIEByZXR1cm4geyFPYmplY3R9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdHZhbGlkYXRvcjogZnVuY3Rpb24gdmFsaWRhdG9yKF92YWxpZGF0b3IpIHtcblx0XHRyZXR1cm4gbWVyZ2VDb25maWcodGhpcywge1xuXHRcdFx0dmFsaWRhdG9yOiBfdmFsaWRhdG9yXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvKipcbiAgKiBBZGRzIGEgZGVmYXVsdCB2YWx1ZSB0byB0aGUgYFN0YXRlYCBjb25maWd1cmF0aW9uLlxuICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgKiBAcmV0dXJuIHshT2JqZWN0fSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHR2YWx1ZTogZnVuY3Rpb24gdmFsdWUoX3ZhbHVlKSB7XG5cdFx0cmV0dXJuIG1lcmdlQ29uZmlnKHRoaXMsIHtcblx0XHRcdHZhbHVlOiBfdmFsdWVcblx0XHR9KTtcblx0fSxcblxuXG5cdC8qKlxuICAqIEFkZHMgYSB2YWx1ZUZuIHRoYXQgd2lsbCByZXR1cm4gYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgYFN0YXRlYCBjb25maWd1cmF0aW9uLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHZhbHVlRm5cbiAgKiBAcmV0dXJuIHshT2JqZWN0fSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHR2YWx1ZUZuOiBmdW5jdGlvbiB2YWx1ZUZuKF92YWx1ZUZuKSB7XG5cdFx0cmV0dXJuIG1lcmdlQ29uZmlnKHRoaXMsIHtcblx0XHRcdHZhbHVlRm46IF92YWx1ZUZuXG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgc2V0cyB2YWxpZGF0b3JzIGZvciBzaGFwZU9mLlxuICogQHBhcmFtIHshT2JqZWN0fSBzaGFwZSBUaGUgc2hhcGUgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBTaGFwZSBvYmplY3Qgd2l0aCB2YWxpZGF0b3JzIGFzIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZGVzdHJ1Y3RTaGFwZU9mQ29uZmlncyhzaGFwZSkge1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNoYXBlKTtcblxuXHR2YXIgcmV0U2hhcGUgPSB7fTtcblxuXHRrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWx1ZSA9IHNoYXBlW2tleV07XG5cblx0XHRyZXRTaGFwZVtrZXldID0gdmFsdWUuY29uZmlnICYmIHZhbHVlLmNvbmZpZy52YWxpZGF0b3IgPyB2YWx1ZS5jb25maWcudmFsaWRhdG9yIDogZGVzdHJ1Y3RTaGFwZU9mQ29uZmlncyh2YWx1ZSk7XG5cdH0pO1xuXG5cdHJldHVybiByZXRTaGFwZTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgdGhlIGdpdmVuIGNvbmZpZyBvYmplY3QgaW50byB0aGUgb25lIHRoYXQgaGFzIGJlZW4gYnVpbHQgc28gZmFyLlxuICogQHBhcmFtIHshT2JqZWN0fSBjb250ZXh0IFRoZSBvYmplY3QgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshT2JqZWN0fSBjb25maWcgVGhlIG9iamVjdCB0byBtZXJnZSB0byB0aGUgYnVpbHQgY29uZmlnLlxuICogQHJldHVybiB7IU9iamVjdH0gVGhlIGZpbmFsIG9iamVjdCBjb250YWluaW5nIHRoZSBidWlsdCBjb25maWcuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbnRleHQsIGNvbmZpZykge1xuXHR2YXIgb2JqID0gY29udGV4dDtcblx0aWYgKG9iaiA9PT0gQ29uZmlnKSB7XG5cdFx0b2JqID0gT2JqZWN0LmNyZWF0ZShDb25maWcpO1xuXHRcdG9iai5jb25maWcgPSB7fTtcblx0fVxuXHRfbWV0YWwub2JqZWN0Lm1peGluKG9iai5jb25maWcsIGNvbmZpZyk7XG5cdHJldHVybiBvYmo7XG59XG5cbi8qKlxuKiBDYWxscyB2YWxpZGF0b3JzIHdpdGggcHJvdmlkZWQgYXJndW1lbnQuXG4qIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB2YWxpZGF0b3IuXG4qIEBwYXJhbSB7IWZ1bmN0aW9uKCl9XG4qL1xuZnVuY3Rpb24gc2V0RXhwbGljaXRWYWx1ZVZhbGlkYXRvcnMobmFtZSkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuXHRcdHJldHVybiB0aGlzLnZhbGlkYXRvcihfdmFsaWRhdG9yczIuZGVmYXVsdFtuYW1lXShhcmcpKTtcblx0fTtcbn1cblxuLyoqXG4qIENhbGxzIHZhbGlkYXRvcnMgd2l0aCBhIHNpbmdsZSBuZXN0ZWQgY29uZmlnLlxuKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFsaWRhdG9yLlxuKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiovXG5mdW5jdGlvbiBzZXROZXN0ZWRWYWxpZGF0b3JzKG5hbWUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZGF0b3IoX3ZhbGlkYXRvcnMyLmRlZmF1bHRbbmFtZV0oYXJnLmNvbmZpZy52YWxpZGF0b3IpKTtcblx0fTtcbn1cblxuLyoqXG4qIEFkZHMgcHJpbWl0aXZlIHR5cGUgdmFsaWRhdG9ycyB0byB0aGUgY29uZmlnIG9iamVjdC5cbiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhbGlkYXRvci5cbiogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4qL1xuZnVuY3Rpb24gc2V0UHJpbWl0aXZlVmFsaWRhdG9ycyhuYW1lKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWRhdG9yKF92YWxpZGF0b3JzMi5kZWZhdWx0W25hbWVdKTtcblx0fTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZmlnO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9tZXRhbEV2ZW50cyA9IHJlcXVpcmUoJ21ldGFsLWV2ZW50cycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogU3RhdGUgYWRkcyBzdXBwb3J0IGZvciBoYXZpbmcgb2JqZWN0IHByb3BlcnRpZXMgdGhhdCBjYW4gYmUgd2F0Y2hlZCBmb3JcbiAqIGNoYW5nZXMsIGFzIHdlbGwgYXMgY29uZmlndXJlZCB3aXRoIHZhbGlkYXRvcnMsIHNldHRlcnMgYW5kIG90aGVyIG9wdGlvbnMuXG4gKiBTZWUgdGhlIGBjb25maWdTdGF0ZWAgbWV0aG9kIGZvciBhIGNvbXBsZXRlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbmZpZ3VyYXRpb25cbiAqIG9wdGlvbnMgZm9yIGVhY2ggc3RhdGUga2V5LlxuICogQGV4dGVuZHMge0V2ZW50RW1pdHRlcn1cbiAqL1xudmFyIFN0YXRlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcblx0X2luaGVyaXRzKFN0YXRlLCBfRXZlbnRFbWl0dGVyKTtcblxuXHQvKipcbiAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgYFN0YXRlYC5cbiAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9jb25maWcgT3B0aW9uYWwgY29uZmlnIG9iamVjdCB3aXRoIGluaXRpYWwgdmFsdWVzIHRvXG4gICogICAgIHNldCBzdGF0ZSBwcm9wZXJ0aWVzIHRvLlxuICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iaiBPcHRpb25hbCBvYmplY3QgdGhhdCBzaG91bGQgaG9sZCB0aGUgc3RhdGVcbiAgKiAgICAgcHJvcGVydGllcy4gSWYgbm9uZSBpcyBnaXZlbiwgdGhleSB3aWxsIGJlIGFkZGVkIGRpcmVjdGx5IHRvIGB0aGlzYFxuICAqICAgICBpbnN0ZWFkLlxuICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2NvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBjYWxsIGZ1bmN0aW9ucyAobGlrZVxuICAqICAgICB2YWxpZGF0b3JzIGFuZCBzZXR0ZXJzKSBvbi4gRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAqL1xuXHRmdW5jdGlvbiBTdGF0ZShvcHRfY29uZmlnLCBvcHRfb2JqLCBvcHRfY29udGV4dCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGF0ZSk7XG5cblx0XHQvKipcbiAgICogQ29udGV4dCB0byBjYWxsIGZ1bmN0aW9ucyAobGlrZSB2YWxpZGF0b3JzIGFuZCBzZXR0ZXJzKSBvbi5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFN0YXRlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RhdGUpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmNvbnRleHRfID0gb3B0X2NvbnRleHQgfHwgX3RoaXM7XG5cblx0XHQvKipcbiAgICogTWFwIG9mIGtleXMgdGhhdCBjYW4gbm90IGJlIHVzZWQgYXMgc3RhdGUga2V5cy5cbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLmtleXNCbGFja2xpc3RfID0gbnVsbDtcblxuXHRcdC8qKlxuICAgKiBPYmplY3QgdGhhdCBzaG91bGQgaG9sZCB0aGUgc3RhdGUgcHJvcGVydGllcy5cbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMub2JqXyA9IG9wdF9vYmogfHwgX3RoaXM7XG5cblx0XHRfdGhpcy5ldmVudERhdGFfID0gbnVsbDtcblxuXHRcdC8qKlxuICAgKiBPYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYmF0Y2ggZXZlbnQgdGhhdCBpcyBjdXJyZW50bHlcbiAgICogc2NoZWR1bGVkLCBvciBudWxsIGlmIG5vbmUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMuc2NoZWR1bGVkQmF0Y2hEYXRhXyA9IG51bGw7XG5cblx0XHQvKipcbiAgICogT2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYWxsIHRoaXMgaW5zdGFuY2UncyBzdGF0ZSBrZXlzLlxuICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFPYmplY3Q+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLnN0YXRlSW5mb18gPSB7fTtcblxuXHRcdF90aGlzLnN0YXRlQ29uZmlnc18gPSB7fTtcblxuXHRcdF90aGlzLmluaXRpYWxWYWx1ZXNfID0gX21ldGFsLm9iamVjdC5taXhpbih7fSwgb3B0X2NvbmZpZyk7XG5cblx0XHRfdGhpcy5zZXRTaG91bGRVc2VGYWNhZGUodHJ1ZSk7XG5cdFx0X3RoaXMuY29uZmlnU3RhdGVGcm9tU3RhdGljSGludF8oKTtcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5vYmpfLCBTdGF0ZS5TVEFURV9SRUZfS0VZLCB7XG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0XHRcdHZhbHVlOiBfdGhpc1xuXHRcdH0pO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIExvZ3MgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHByb3BlcnR5IGlzIHJlcXVpcmVkIGJ1dCB3YXNuJ3QgZ2l2ZW4uXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgKiBAcHJvdGVjdGVkXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoU3RhdGUsIFt7XG5cdFx0a2V5OiAnYXNzZXJ0R2l2ZW5JZlJlcXVpcmVkXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzc2VydEdpdmVuSWZSZXF1aXJlZF8obmFtZSkge1xuXHRcdFx0dmFyIGNvbmZpZyA9IHRoaXMuc3RhdGVDb25maWdzX1tuYW1lXTtcblx0XHRcdGlmIChjb25maWcucmVxdWlyZWQpIHtcblx0XHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdFx0dmFyIHZhbHVlID0gaW5mby5zdGF0ZSA9PT0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWkVEID8gdGhpcy5nZXQobmFtZSkgOiB0aGlzLmluaXRpYWxWYWx1ZXNfW25hbWVdO1xuXHRcdFx0XHRpZiAoISgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKSh2YWx1ZSkpIHtcblx0XHRcdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gJ1RoZSBwcm9wZXJ0eSBjYWxsZWQgXCInICsgbmFtZSArICdcIiBpcyByZXF1aXJlZCBidXQgZGlkblxcJ3QgcmVjZWl2ZSBhIHZhbHVlLic7XG5cdFx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkVGhyb3dWYWxpZGF0aW9uRXJyb3IoKSkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogTG9ncyBhbiBlcnJvciBpZiB0aGUgYHZhbGlkYXRvclJldHVybmAgaXMgaW5zdGFuY2Ugb2YgYEVycm9yYC5cbiAgICogQHBhcmFtIHsqfSB2YWxpZGF0b3JSZXR1cm5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXNzZXJ0VmFsaWRhdG9yUmV0dXJuSW5zdGFuY2VPZkVycm9yXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzc2VydFZhbGlkYXRvclJldHVybkluc3RhbmNlT2ZFcnJvcl8odmFsaWRhdG9yUmV0dXJuKSB7XG5cdFx0XHRpZiAodmFsaWRhdG9yUmV0dXJuIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkVGhyb3dWYWxpZGF0aW9uRXJyb3IoKSkge1xuXHRcdFx0XHRcdHRocm93IHZhbGlkYXRvclJldHVybjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdXYXJuaW5nOiAnICsgdmFsaWRhdG9yUmV0dXJuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgdGhhdCB0aGUgZ2l2ZW4gbmFtZSBpcyBhIHZhbGlkIHN0YXRlIGtleSBuYW1lLiBJZiBpdCdzIG5vdCwgYW4gZXJyb3JcbiAgICogd2lsbCBiZSB0aHJvd24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Fzc2VydFZhbGlkU3RhdGVLZXlOYW1lXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFzc2VydFZhbGlkU3RhdGVLZXlOYW1lXyhuYW1lKSB7XG5cdFx0XHRpZiAodGhpcy5rZXlzQmxhY2tsaXN0XyAmJiB0aGlzLmtleXNCbGFja2xpc3RfW25hbWVdKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignSXRcXCdzIG5vdCBhbGxvd2VkIHRvIGNyZWF0ZSBhIHN0YXRlIGtleSB3aXRoIHRoZSBuYW1lIFwiJyArIG5hbWUgKyAnXCIuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEJ1aWxkcyB0aGUgcHJvcGVydHkgZGVmaW5pdGlvbiBvYmplY3QgZm9yIHRoZSBzcGVjaWZpZWQgc3RhdGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdidWlsZEtleVByb3BlcnR5RGVmXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJ1aWxkS2V5UHJvcGVydHlEZWZfKG5hbWUpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXNbU3RhdGUuU1RBVEVfUkVGX0tFWV0uZ2V0U3RhdGVLZXlWYWx1ZV8obmFtZSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHNldDogZnVuY3Rpb24gc2V0KHZhbCkge1xuXHRcdFx0XHRcdHRoaXNbU3RhdGUuU1RBVEVfUkVGX0tFWV0uc2V0U3RhdGVLZXlWYWx1ZV8obmFtZSwgdmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsbHMgdGhlIHJlcXVlc3RlZCBmdW5jdGlvbiwgcnVubmluZyB0aGUgYXBwcm9wcmlhdGUgY29kZSBmb3Igd2hlbiBpdCdzXG4gICAqIHBhc3NlZCBhcyBhbiBhY3R1YWwgZnVuY3Rpb24gb2JqZWN0IG9yIGp1c3QgdGhlIGZ1bmN0aW9uJ3MgbmFtZS5cbiAgICogQHBhcmFtIHshRnVuY3Rpb258c3RyaW5nfSBmbiBGdW5jdGlvbiwgb3IgbmFtZSBvZiB0aGUgZnVuY3Rpb24gdG8gcnVuLlxuICAgKiBAcGFyYW0geyFBcnJheX0gQW4gb3B0aW9uYWwgYXJyYXkgb2YgcGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlXG4gICAqICAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZC5cbiAgICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgY2FsbGVkIGZ1bmN0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjYWxsRnVuY3Rpb25fJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FsbEZ1bmN0aW9uXyhmbiwgYXJncykge1xuXHRcdFx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKGZuKSkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb250ZXh0X1tmbl0uYXBwbHkodGhpcy5jb250ZXh0XywgYXJncyk7XG5cdFx0XHR9IGVsc2UgaWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikoZm4pKSB7XG5cdFx0XHRcdHJldHVybiBmbi5hcHBseSh0aGlzLmNvbnRleHRfLCBhcmdzKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsbHMgdGhlIHN0YXRlIGtleSdzIHNldHRlciwgaWYgdGhlcmUgaXMgb25lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBzZXQuXG4gICAqIEBwYXJhbSB7Kn0gY3VycmVudFZhbHVlIFRoZSBjdXJyZW50IHZhbHVlLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwgdmFsdWUgdG8gYmUgc2V0LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjYWxsU2V0dGVyXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhbGxTZXR0ZXJfKG5hbWUsIHZhbHVlLCBjdXJyZW50VmFsdWUpIHtcblx0XHRcdHZhciBjb25maWcgPSB0aGlzLnN0YXRlQ29uZmlnc19bbmFtZV07XG5cdFx0XHRpZiAoY29uZmlnLnNldHRlcikge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuY2FsbEZ1bmN0aW9uXyhjb25maWcuc2V0dGVyLCBbdmFsdWUsIGN1cnJlbnRWYWx1ZV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxscyB0aGUgc3RhdGUga2V5J3MgdmFsaWRhdG9yLCBpZiB0aGVyZSBpcyBvbmUuIEVtaXRzIGNvbnNvbGVcbiAgICogd2FybmluZyBpZiB2YWxpZGF0b3IgcmV0dXJucyBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBGbGFnIGluZGljYXRpbmcgaWYgdmFsdWUgaXMgdmFsaWQgb3Igbm90LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjYWxsVmFsaWRhdG9yXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhbGxWYWxpZGF0b3JfKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHR2YXIgY29uZmlnID0gdGhpcy5zdGF0ZUNvbmZpZ3NfW25hbWVdO1xuXHRcdFx0aWYgKGNvbmZpZy52YWxpZGF0b3IpIHtcblx0XHRcdFx0dmFyIHZhbGlkYXRvclJldHVybiA9IHRoaXMuY2FsbEZ1bmN0aW9uXyhjb25maWcudmFsaWRhdG9yLCBbdmFsdWUsIG5hbWUsIHRoaXMuY29udGV4dF9dKTtcblx0XHRcdFx0dGhpcy5hc3NlcnRWYWxpZGF0b3JSZXR1cm5JbnN0YW5jZU9mRXJyb3JfKHZhbGlkYXRvclJldHVybik7XG5cdFx0XHRcdHJldHVybiB2YWxpZGF0b3JSZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBpdCdzIGFsbG93ZWQgdG8gd3JpdGUgb24gdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjYW5TZXRTdGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhblNldFN0YXRlKG5hbWUpIHtcblx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRTdGF0ZUluZm8obmFtZSk7XG5cdFx0XHRyZXR1cm4gIXRoaXMuc3RhdGVDb25maWdzX1tuYW1lXS53cml0ZU9uY2UgfHwgIWluZm8ud3JpdHRlbjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4ga2V5KHMpIHRvIHRoZSBzdGF0ZSwgdG9nZXRoZXIgd2l0aCBpdHModGhlaXIpIGNvbmZpZ3MuXG4gICAqIENvbmZpZyBvYmplY3RzIHN1cHBvcnQgdGhlIGdpdmVuIHNldHRpbmdzOlxuICAgKiAgICAgcmVxdWlyZWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGNhdXNlcyBlcnJvcnMgdG8gYmUgcHJpbnRlZCAodmlhXG4gICAqICAgICBgY29uc29sZS5lcnJvcmApIGlmIG5vIHZhbHVlIGlzIGdpdmVuIGZvciB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqICAgICBzZXR0ZXIgLSBGdW5jdGlvbiBmb3Igbm9ybWFsaXppbmcgc3RhdGUga2V5IHZhbHVlcy4gSXQgcmVjZWl2ZXMgdGhlIG5ld1xuICAgKiAgICAgdmFsdWUgdGhhdCB3YXMgc2V0LCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgc3RvcmVkLlxuICAgKlxuICAgKiAgICAgdmFsaWRhdG9yIC0gRnVuY3Rpb24gdGhhdCB2YWxpZGF0ZXMgc3RhdGUga2V5IHZhbHVlcy4gV2hlbiBpdCByZXR1cm5zXG4gICAqICAgICBmYWxzZSwgdGhlIG5ldyB2YWx1ZSBpcyBpZ25vcmVkLiBXaGVuIGl0IHJldHVybnMgYW4gaW5zdGFuY2Ugb2YgRXJyb3IsXG4gICAqICAgICBpdCB3aWxsIGVtaXQgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiAgICAgdmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHN0YXRlIGtleS4gTm90ZSB0aGF0IHNldHRpbmcgdGhpcyB0b1xuICAgKiAgICAgYW4gb2JqZWN0IHdpbGwgY2F1c2UgYWxsIGNsYXNzIGluc3RhbmNlcyB0byB1c2UgdGhlIHNhbWUgcmVmZXJlbmNlIHRvXG4gICAqICAgICB0aGUgb2JqZWN0LiBUbyBoYXZlIGVhY2ggaW5zdGFuY2UgdXNlIGEgZGlmZmVyZW50IHJlZmVyZW5jZSBmb3Igb2JqZWN0cyxcbiAgICogICAgIHVzZSB0aGUgYHZhbHVlRm5gIG9wdGlvbiBpbnN0ZWFkLlxuICAgKlxuICAgKiAgICAgdmFsdWVGbiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGZvciBhIHN0YXRlIGtleS5cbiAgICpcbiAgICogICAgIHdyaXRlT25jZSAtIElnbm9yZXMgd3JpdGVzIHRvIHRoZSBzdGF0ZSBrZXkgYWZ0ZXIgaXQncyBiZWVuIGZpcnN0XG4gICAqICAgICB3cml0dGVuIHRvLiBUaGF0IGlzLCBhbGxvd3Mgd3JpdGVzIG9ubHkgd2hlbiBzZXR0aW5nIHRoZSB2YWx1ZSBmb3IgdGhlXG4gICAqICAgICBmaXJzdCB0aW1lLlxuICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgIU9iamVjdD58c3RyaW5nfSBjb25maWdzIEFuIG9iamVjdCB0aGF0IG1hcHNcbiAgICogICAgIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3Iga2V5cyB0byBiZSBhZGRlZCB0byB0aGUgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3R8Kj19IG9wdF9jb250ZXh0IFRoZSBjb250ZXh0IHdoZXJlIHRoZSBhZGRlZCBzdGF0ZVxuICAgKiAgICAga2V5cyB3aWxsIGJlIGRlZmluZWQgKGRlZmF1bHRzIHRvIGB0aGlzYCksIG9yIGZhbHNlIGlmIHRoZXkgc2hvdWxkbid0XG4gICAqICAgICBiZSBkZWZpbmVkIGF0IGFsbC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NvbmZpZ1N0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29uZmlnU3RhdGUoY29uZmlncywgb3B0X2NvbnRleHQpIHtcblx0XHRcdHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGNvbmZpZ3MpO1xuXHRcdFx0aWYgKG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRfY29udGV4dCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0dmFyIHByb3BzID0ge307XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgbmFtZSA9IG5hbWVzW2ldO1xuXHRcdFx0XHRcdHRoaXMuYXNzZXJ0VmFsaWRTdGF0ZUtleU5hbWVfKG5hbWUpO1xuXHRcdFx0XHRcdHByb3BzW25hbWVdID0gdGhpcy5idWlsZEtleVByb3BlcnR5RGVmXyhuYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvcHRfY29udGV4dCB8fCB0aGlzLm9ial8sIHByb3BzKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5zdGF0ZUNvbmZpZ3NfID0gY29uZmlncztcblx0XHRcdGZvciAodmFyIF9pID0gMDsgX2kgPCBuYW1lcy5sZW5ndGg7IF9pKyspIHtcblx0XHRcdFx0dmFyIF9uYW1lID0gbmFtZXNbX2ldO1xuXHRcdFx0XHRjb25maWdzW19uYW1lXSA9IGNvbmZpZ3NbX25hbWVdLmNvbmZpZyA/IGNvbmZpZ3NbX25hbWVdLmNvbmZpZyA6IGNvbmZpZ3NbX25hbWVdO1xuXHRcdFx0XHR0aGlzLmFzc2VydEdpdmVuSWZSZXF1aXJlZF8obmFtZXNbX2ldKTtcblx0XHRcdFx0dGhpcy52YWxpZGF0ZUluaXRpYWxWYWx1ZV8obmFtZXNbX2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBzdGF0ZSBrZXlzIGZyb20gc3VwZXIgY2xhc3NlcyBzdGF0aWMgaGludCBgTXlDbGFzcy5TVEFURSA9IHt9O2AuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICFPYmplY3Q+PX0gb3B0X2NvbmZpZyBBbiBvYmplY3QgdGhhdCBtYXBzIGFsbCB0aGVcbiAgICogICAgIGNvbmZpZ3VyYXRpb25zIGZvciBzdGF0ZSBrZXlzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb25maWdTdGF0ZUZyb21TdGF0aWNIaW50XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbmZpZ1N0YXRlRnJvbVN0YXRpY0hpbnRfKCkge1xuXHRcdFx0dmFyIGN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHRcdFx0aWYgKGN0b3IgIT09IFN0YXRlKSB7XG5cdFx0XHRcdHZhciBkZWZpbmVDb250ZXh0ID0gdm9pZCAwO1xuXHRcdFx0XHRpZiAodGhpcy5vYmpfID09PSB0aGlzKSB7XG5cdFx0XHRcdFx0ZGVmaW5lQ29udGV4dCA9IGN0b3IuaGFzQ29uZmlndXJlZFN0YXRlXyA/IGZhbHNlIDogY3Rvci5wcm90b3R5cGU7XG5cdFx0XHRcdFx0Y3Rvci5oYXNDb25maWd1cmVkU3RhdGVfID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNvbmZpZ1N0YXRlKFN0YXRlLmdldFN0YXRlU3RhdGljKGN0b3IpLCBkZWZpbmVDb250ZXh0KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHRcdF9nZXQoU3RhdGUucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RhdGUucHJvdG90eXBlKSwgJ2Rpc3Bvc2VJbnRlcm5hbCcsIHRoaXMpLmNhbGwodGhpcyk7XG5cdFx0XHR0aGlzLmluaXRpYWxWYWx1ZXNfID0gbnVsbDtcblx0XHRcdHRoaXMuc3RhdGVJbmZvXyA9IG51bGw7XG5cdFx0XHR0aGlzLnN0YXRlQ29uZmlnc18gPSBudWxsO1xuXHRcdFx0dGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRW1pdHMgdGhlIHN0YXRlIGNoYW5nZSBiYXRjaCBldmVudC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZW1pdEJhdGNoRXZlbnRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW1pdEJhdGNoRXZlbnRfKCkge1xuXHRcdFx0aWYgKCF0aGlzLmlzRGlzcG9zZWQoKSkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IHRoaXMuc2NoZWR1bGVkQmF0Y2hEYXRhXztcblx0XHRcdFx0dGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfID0gbnVsbDtcblx0XHRcdFx0dGhpcy5jb250ZXh0Xy5lbWl0KCdzdGF0ZUNoYW5nZWQnLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG4gICAqIE5vdGU6IHRoaXMgY2FuIGFuZCBzaG91bGQgYmUgYWNjb21wbGlzaGVkIGJ5IGFjY2Vzc2luZyB0aGUgdmFsdWUgYXMgYVxuICAgKiByZWd1bGFyIHByb3BlcnR5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBmdW5jdGlvbiBpc1xuICAgKiBhY3R1YWxseSBuZWVkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMub2JqX1tuYW1lXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBtYXBzIHN0YXRlIGtleXMgdG8gdGhlaXIgdmFsdWVzLlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz49fSBvcHRfbmFtZXMgQSBsaXN0IG9mIG5hbWVzIG9mIHRoZSBrZXlzIHRoYXQgc2hvdWxkXG4gICAqICAgYmUgcmV0dXJuZWQuIElmIG5vbmUgaXMgZ2l2ZW4sIHRoZSB3aG9sZSBzdGF0ZSB3aWxsIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3QuPHN0cmluZywgKj59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKG9wdF9uYW1lcykge1xuXHRcdFx0dmFyIHN0YXRlID0ge307XG5cdFx0XHR2YXIgbmFtZXMgPSBvcHRfbmFtZXMgfHwgdGhpcy5nZXRTdGF0ZUtleXMoKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzdGF0ZVtuYW1lc1tpXV0gPSB0aGlzLmdldChuYW1lc1tpXSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc3BlY2lmaWVkIHN0YXRlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGVJbmZvJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGVJbmZvKG5hbWUpIHtcblx0XHRcdGlmICghdGhpcy5zdGF0ZUluZm9fW25hbWVdKSB7XG5cdFx0XHRcdHRoaXMuc3RhdGVJbmZvX1tuYW1lXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVJbmZvX1tuYW1lXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgY29uZmlnIG9iamVjdCBmb3IgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBrZXkncyBuYW1lLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFN0YXRlS2V5Q29uZmlnJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGVLZXlDb25maWcobmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVDb25maWdzXyA/IHRoaXMuc3RhdGVDb25maWdzX1tuYW1lXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCBhbGwgc3RhdGUga2V5cy5cbiAgICogQHJldHVybiB7IUFycmF5LjxzdHJpbmc+fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGVLZXlzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGVLZXlzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3RhdGVDb25maWdzXyA/IE9iamVjdC5rZXlzKHRoaXMuc3RhdGVDb25maWdzXykgOiBbXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXkuIFRoaXMgaXMgcGFzc2VkIGFzIHRoYXQga2V5J3NcbiAgICogZ2V0dGVyIHRvIHRoZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBjYWxsIGluc2lkZSB0aGUgYGFkZEtleVRvU3RhdGVgIG1ldGhvZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHJldHVybiB7Kn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGVLZXlWYWx1ZV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUtleVZhbHVlXyhuYW1lKSB7XG5cdFx0XHRpZiAoIXRoaXMud2FybklmRGlzcG9zZWRfKG5hbWUpKSB7XG5cdFx0XHRcdHRoaXMuaW5pdFN0YXRlS2V5XyhuYW1lKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0U3RhdGVJbmZvKG5hbWUpLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBNZXJnZXMgdGhlIFNUQVRFIHN0YXRpYyB2YXJpYWJsZSBmb3IgdGhlIGdpdmVuIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gIHshRnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBtZXJnZSBoYXBwZW5zLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBzdGF0aWNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc0JlZW5TZXQnLFxuXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBvZiB0aGUgc3RhdGUga2V5IHdpdGggdGhlIGdpdmVuIG5hbWUgaGFzIGFscmVhZHkgYmVlblxuICAgKiBzZXQuIE5vdGUgdGhhdCB0aGlzIGRvZXNuJ3QgcnVuIHRoZSBrZXkncyBnZXR0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNCZWVuU2V0KG5hbWUpIHtcblx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRTdGF0ZUluZm8obmFtZSk7XG5cdFx0XHRyZXR1cm4gaW5mby5zdGF0ZSA9PT0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWkVEIHx8IHRoaXMuaGFzSW5pdGlhbFZhbHVlXyhuYW1lKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIGFuIGluaXRpYWwgdmFsdWUgd2FzIGdpdmVuIHRvIHRoZSBzcGVjaWZpZWQgc3RhdGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc0luaXRpYWxWYWx1ZV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNJbml0aWFsVmFsdWVfKG5hbWUpIHtcblx0XHRcdHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZXNfLmhhc093blByb3BlcnR5KG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGtleSBpcyBwcmVzZW50IGluIHRoaXMgaW5zdGFuY2UncyBzdGF0ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzU3RhdGVLZXknLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNTdGF0ZUtleShrZXkpIHtcblx0XHRcdGlmICghdGhpcy53YXJuSWZEaXNwb3NlZF8oa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gISF0aGlzLnN0YXRlQ29uZmlnc19ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogSW5mb3JtcyBvZiBjaGFuZ2VzIHRvIGEgc3RhdGUga2V5J3MgdmFsdWUgdGhyb3VnaCBhbiBldmVudC4gV29uJ3QgdHJpZ2dlclxuICAgKiB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkIG9yIGlmIGl0J3MgYmVpbmcgaW5pdGlhbGl6ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7Kn0gcHJldlZhbCBUaGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaW5mb3JtQ2hhbmdlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluZm9ybUNoYW5nZV8obmFtZSwgcHJldlZhbCkge1xuXHRcdFx0aWYgKHRoaXMuc2hvdWxkSW5mb3JtQ2hhbmdlXyhuYW1lLCBwcmV2VmFsKSkge1xuXHRcdFx0XHR2YXIgZGF0YSA9IF9tZXRhbC5vYmplY3QubWl4aW4oe1xuXHRcdFx0XHRcdGtleTogbmFtZSxcblx0XHRcdFx0XHRuZXdWYWw6IHRoaXMuZ2V0KG5hbWUpLFxuXHRcdFx0XHRcdHByZXZWYWw6IHByZXZWYWxcblx0XHRcdFx0fSwgdGhpcy5ldmVudERhdGFfKTtcblx0XHRcdFx0dGhpcy5jb250ZXh0Xy5lbWl0KG5hbWUgKyAnQ2hhbmdlZCcsIGRhdGEpO1xuXHRcdFx0XHR0aGlzLmNvbnRleHRfLmVtaXQoJ3N0YXRlS2V5Q2hhbmdlZCcsIGRhdGEpO1xuXHRcdFx0XHR0aGlzLnNjaGVkdWxlQmF0Y2hFdmVudF8oZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBzcGVjaWZpZWQgc3RhdGUga2V5LCBnaXZpbmcgaXQgYSBmaXJzdCB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaW5pdFN0YXRlS2V5XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRTdGF0ZUtleV8obmFtZSkge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdGlmIChpbmZvLnN0YXRlICE9PSBTdGF0ZS5LZXlTdGF0ZXMuVU5JTklUSUFMSVpFRCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGluZm8uc3RhdGUgPSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaSU5HO1xuXHRcdFx0dGhpcy5zZXRJbml0aWFsVmFsdWVfKG5hbWUpO1xuXHRcdFx0aWYgKCFpbmZvLndyaXR0ZW4pIHtcblx0XHRcdFx0dGhpcy5zZXREZWZhdWx0VmFsdWUobmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRpbmZvLnN0YXRlID0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWkVEO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBNZXJnZXMgdHdvIHZhbHVlcyBmb3IgdGhlIFNUQVRFIHByb3BlcnR5IGludG8gYSBzaW5nbGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVyZ2VkVmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjdXJyVmFsXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBtZXJnZWQgdmFsdWUuXG4gICAqIEBzdGF0aWNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZVN0YXRlS2V5JyxcblxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVTdGF0ZUtleShuYW1lKSB7XG5cdFx0XHR0aGlzLnN0YXRlSW5mb19bbmFtZV0gPSBudWxsO1xuXHRcdFx0dGhpcy5zdGF0ZUNvbmZpZ3NfW25hbWVdID0gbnVsbDtcblx0XHRcdGRlbGV0ZSB0aGlzLm9ial9bbmFtZV07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNjaGVkdWxlcyBhIHN0YXRlIGNoYW5nZSBiYXRjaCBldmVudCB0byBiZSBlbWl0dGVkIGFzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZURhdGEgSW5mb3JtYXRpb24gYWJvdXQgYSBzdGF0ZSBrZXkncyB1cGRhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NjaGVkdWxlQmF0Y2hFdmVudF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZUJhdGNoRXZlbnRfKGNoYW5nZURhdGEpIHtcblx0XHRcdGlmICghdGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfKSB7XG5cdFx0XHRcdF9tZXRhbC5hc3luYy5uZXh0VGljayh0aGlzLmVtaXRCYXRjaEV2ZW50XywgdGhpcyk7XG5cdFx0XHRcdHRoaXMuc2NoZWR1bGVkQmF0Y2hEYXRhXyA9IF9tZXRhbC5vYmplY3QubWl4aW4oe1xuXHRcdFx0XHRcdGNoYW5nZXM6IHt9XG5cdFx0XHRcdH0sIHRoaXMuZXZlbnREYXRhXyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuYW1lID0gY2hhbmdlRGF0YS5rZXk7XG5cdFx0XHR2YXIgY2hhbmdlcyA9IHRoaXMuc2NoZWR1bGVkQmF0Y2hEYXRhXy5jaGFuZ2VzO1xuXHRcdFx0aWYgKGNoYW5nZXNbbmFtZV0pIHtcblx0XHRcdFx0Y2hhbmdlc1tuYW1lXS5uZXdWYWwgPSBjaGFuZ2VEYXRhLm5ld1ZhbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYW5nZXNbbmFtZV0gPSBjaGFuZ2VEYXRhO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cbiAgICogTm90ZTogdGhpcyBjYW4gYW5kIHNob3VsZCBiZSBhY2NvbXBsaXNoZWQgYnkgc2V0dGluZyB0aGUgc3RhdGUga2V5IGFzIGFcbiAgICogcmVndWxhciBwcm9wZXJ0eS4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIGEgZnVuY3Rpb24gaXNcbiAgICogYWN0dWFsbHkgbmVlZGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLmhhc1N0YXRlS2V5KG5hbWUpKSB7XG5cdFx0XHRcdHRoaXMub2JqX1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgc3RhdGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0RGVmYXVsdFZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5hbWUpIHtcblx0XHRcdHZhciBjb25maWcgPSB0aGlzLnN0YXRlQ29uZmlnc19bbmFtZV07XG5cblx0XHRcdGlmIChjb25maWcudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLnNldChuYW1lLCBjb25maWcudmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXQobmFtZSwgdGhpcy5jYWxsRnVuY3Rpb25fKGNvbmZpZy52YWx1ZUZuKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgZGF0YSB0byBiZSBzZW50IHdpdGggYWxsIGV2ZW50cyBlbWl0dGVkIGZyb20gdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRFdmVudERhdGEnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRFdmVudERhdGEoZGF0YSkge1xuXHRcdFx0dGhpcy5ldmVudERhdGFfID0gZGF0YTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHJldHVybiB7Kn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0SW5pdGlhbFZhbHVlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZV8obmFtZSkge1xuXHRcdFx0aWYgKHRoaXMuaGFzSW5pdGlhbFZhbHVlXyhuYW1lKSkge1xuXHRcdFx0XHR0aGlzLnNldChuYW1lLCB0aGlzLmluaXRpYWxWYWx1ZXNfW25hbWVdKTtcblx0XHRcdFx0dGhpcy5pbml0aWFsVmFsdWVzX1tuYW1lXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyBhIG1hcCBvZiBrZXlzIHRoYXQgYXJlIG5vdCB2YWxpZCBzdGF0ZSBrZXlzLlxuICAgKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEtleXNCbGFja2xpc3QnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRLZXlzQmxhY2tsaXN0KGJsYWNrbGlzdCkge1xuXHRcdFx0dGhpcy5rZXlzQmxhY2tsaXN0XyA9IGJsYWNrbGlzdDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgYWxsIHRoZSBzcGVjaWZpZWQgc3RhdGUga2V5cy5cbiAgICogQHBhcmFtIHshT2JqZWN0LjxzdHJpbmcsKj59IHZhbHVlcyBBIG1hcCBvZiBzdGF0ZSBrZXlzIHRvIHRoZSB2YWx1ZXMgdGhleVxuICAgKiAgIHNob3VsZCBiZSBzZXQgdG8uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgcnVuXG4gICAqICAgYWZ0ZXIgdGhlIG5leHQgYmF0Y2hlZCB1cGRhdGUgaXMgdHJpZ2dlcmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0U3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZSh2YWx1ZXMsIG9wdF9jYWxsYmFjaykge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdE9iamVjdC5rZXlzKHZhbHVlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gX3RoaXMyLnNldChuYW1lLCB2YWx1ZXNbbmFtZV0pO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3B0X2NhbGxiYWNrICYmIHRoaXMuc2NoZWR1bGVkQmF0Y2hEYXRhXykge1xuXHRcdFx0XHR0aGlzLmNvbnRleHRfLm9uY2UoJ3N0YXRlQ2hhbmdlZCcsIG9wdF9jYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgc3RhdGUga2V5LiBUaGlzIGlzIHBhc3NlZCBhcyB0aGF0IGtleSdzXG4gICAqIHNldHRlciB0byB0aGUgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eWAgY2FsbCBpbnNpZGUgdGhlIGBhZGRLZXlUb1N0YXRlYFxuICAgKiBtZXRob2QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBvZiB0aGUga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRTdGF0ZUtleVZhbHVlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlS2V5VmFsdWVfKG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodGhpcy53YXJuSWZEaXNwb3NlZF8obmFtZSkgfHwgIXRoaXMuY2FuU2V0U3RhdGUobmFtZSkgfHwgIXRoaXMudmFsaWRhdGVLZXlWYWx1ZV8obmFtZSwgdmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHByZXZWYWwgPSB0aGlzLmdldChuYW1lKTtcblx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRTdGF0ZUluZm8obmFtZSk7XG5cdFx0XHRpbmZvLnZhbHVlID0gdGhpcy5jYWxsU2V0dGVyXyhuYW1lLCB2YWx1ZSwgcHJldlZhbCk7XG5cdFx0XHR0aGlzLmFzc2VydEdpdmVuSWZSZXF1aXJlZF8obmFtZSk7XG5cdFx0XHRpbmZvLndyaXR0ZW4gPSB0cnVlO1xuXHRcdFx0dGhpcy5pbmZvcm1DaGFuZ2VfKG5hbWUsIHByZXZWYWwpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgd2Ugc2hvdWxkIGluZm9ybSBhYm91dCBhIHN0YXRlIHVwZGF0ZS4gVXBkYXRlcyBhcmUgaWdub3JlZCBkdXJpbmdcbiAgICogc3RhdGUgaW5pdGlhbGl6YXRpb24uIE90aGVyd2lzZSwgdXBkYXRlcyB0byBwcmltaXRpdmUgdmFsdWVzIGFyZSBvbmx5XG4gICAqIGluZm9ybWVkIHdoZW4gdGhlIG5ldyB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXMgb25lLiBVcGRhdGVzIHRvXG4gICAqIG9iamVjdHMgKHdoaWNoIGluY2x1ZGVzIGZ1bmN0aW9ucyBhbmQgYXJyYXlzKSBhcmUgYWx3YXlzIGluZm9ybWVkIG91dHNpZGVcbiAgICogaW5pdGlhbGl6YXRpb24gdGhvdWdoLCBzaW5jZSB3ZSBjYW4ndCBiZSBzdXJlIGlmIGFsbCBvZiB0aGUgaW50ZXJuYWwgZGF0YVxuICAgKiBoYXMgc3RheWVkIHRoZSBzYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcGFyYW0geyp9IHByZXZWYWwgVGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Nob3VsZEluZm9ybUNoYW5nZV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaG91bGRJbmZvcm1DaGFuZ2VfKG5hbWUsIHByZXZWYWwpIHtcblx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRTdGF0ZUluZm8obmFtZSk7XG5cdFx0XHRyZXR1cm4gaW5mby5zdGF0ZSA9PT0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWkVEICYmICgoMCwgX21ldGFsLmlzT2JqZWN0KShwcmV2VmFsKSB8fCBwcmV2VmFsICE9PSB0aGlzLmdldChuYW1lKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBzaG91bGQgdGhyb3cgZXJyb3Igd2hlblxuICAgKiB2YWlsZGF0b3IgZnVuY3Rpb25zIHJldHVybnMgYW4gYEVycm9yYCBpbnN0YW5jZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gQnkgZGVmYXVsdCByZXR1cm5zIGZhbHNlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hvdWxkVGhyb3dWYWxpZGF0aW9uRXJyb3InLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaG91bGRUaHJvd1ZhbGlkYXRpb25FcnJvcigpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVmFsaWRhdGVzIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgc3RhdGUgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndmFsaWRhdGVJbml0aWFsVmFsdWVfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVJbml0aWFsVmFsdWVfKG5hbWUpIHtcblx0XHRcdGlmICh0aGlzLmhhc0luaXRpYWxWYWx1ZV8obmFtZSkgJiYgIXRoaXMuY2FsbFZhbGlkYXRvcl8obmFtZSwgdGhpcy5pbml0aWFsVmFsdWVzX1tuYW1lXSkpIHtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuaW5pdGlhbFZhbHVlc19bbmFtZV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgc3RhdGUga2V5J3MgdmFsdWUsIHdoaWNoIGluY2x1ZGVzIGNhbGxpbmcgdGhlIHZhbGlkYXRvclxuICAgKiBkZWZpbmVkIGluIHRoZSBrZXkncyBjb25maWd1cmF0aW9uIG9iamVjdCwgaWYgdGhlcmUgaXMgb25lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEZsYWcgaW5kaWNhdGluZyBpZiB2YWx1ZSBpcyB2YWxpZCBvciBub3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZhbGlkYXRlS2V5VmFsdWVfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVLZXlWYWx1ZV8obmFtZSwgdmFsdWUpIHtcblx0XHRcdHZhciBpbmZvID0gdGhpcy5nZXRTdGF0ZUluZm8obmFtZSk7XG5cdFx0XHRyZXR1cm4gaW5mby5zdGF0ZSA9PT0gU3RhdGUuS2V5U3RhdGVzLklOSVRJQUxJWklORyB8fCB0aGlzLmNhbGxWYWxpZGF0b3JfKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogV2FybnMgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBiZSBhY2Nlc3NlZCBpZiBub3QgZGlzcG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZGlzcG9zZWQsIG9yIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnd2FybklmRGlzcG9zZWRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gd2FybklmRGlzcG9zZWRfKG5hbWUpIHtcblx0XHRcdHZhciBkaXNwb3NlZCA9IHRoaXMuaXNEaXNwb3NlZCgpO1xuXHRcdFx0aWYgKGRpc3Bvc2VkKSB7XG5cdFx0XHRcdGNvbnNvbGUud2FybignRXJyb3IuIFRyeWluZyB0byBhY2Nlc3MgcHJvcGVydHkgXCInICsgbmFtZSArICdcIiBvbiBkaXNwb3NlZCBpbnN0YW5jZScpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRpc3Bvc2VkO1xuXHRcdH1cblx0fV0sIFt7XG5cdFx0a2V5OiAnZ2V0U3RhdGVTdGF0aWMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZVN0YXRpYyhjdG9yKSB7XG5cdFx0XHRyZXR1cm4gKDAsIF9tZXRhbC5nZXRTdGF0aWNQcm9wZXJ0eSkoY3RvciwgJ1NUQVRFJywgU3RhdGUubWVyZ2VTdGF0ZSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnbWVyZ2VTdGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1lcmdlU3RhdGUobWVyZ2VkVmFsLCBjdXJyVmFsKSB7XG5cdFx0XHRyZXR1cm4gX21ldGFsLm9iamVjdC5taXhpbih7fSwgY3VyclZhbCwgbWVyZ2VkVmFsKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gU3RhdGU7XG59KF9tZXRhbEV2ZW50cy5FdmVudEVtaXR0ZXIpO1xuXG5TdGF0ZS5TVEFURV9SRUZfS0VZID0gJ19fTUVUQUxfU1RBVEVfUkVGX0tFWV9fJztcblxuLyoqXG4gKiBDb25zdGFudHMgdGhhdCByZXByZXNlbnQgdGhlIHN0YXRlcyB0aGF0IGEgc3RhdGUga2V5IGNhbiBiZSBpbi5cbiAqIEB0eXBlIHshT2JqZWN0fVxuICovXG5TdGF0ZS5LZXlTdGF0ZXMgPSB7XG5cdFVOSU5JVElBTElaRUQ6IHVuZGVmaW5lZCxcblx0SU5JVElBTElaSU5HOiAxLFxuXHRJTklUSUFMSVpFRDogMlxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhdGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbGliL1N0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFRoZSBjb21wb25lbnQgcmVnaXN0cnkgaXMgdXNlZCB0byByZWdpc3RlciBjb21wb25lbnRzLCBzbyB0aGV5IGNhblxuICogYmUgYWNjZXNzaWJsZSBieSBuYW1lLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIENvbXBvbmVudFJlZ2lzdHJ5ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBDb21wb25lbnRSZWdpc3RyeSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50UmVnaXN0cnkpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKENvbXBvbmVudFJlZ2lzdHJ5LCBudWxsLCBbe1xuXHRcdGtleTogJ2dldENvbnN0cnVjdG9yJyxcblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBuYW1lLCBvclxuICAgKiB1bmRlZmluZWQgaWYgaXQgaGFzbid0IGJlZW4gcmVnaXN0ZXJlZCB5ZXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBjb21wb25lbnQncyBuYW1lLlxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb24oKX1cbiAgICogQHN0YXRpY1xuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3IobmFtZSkge1xuXHRcdFx0dmFyIGNvbnN0cnVjdG9yRm4gPSBDb21wb25lbnRSZWdpc3RyeS5jb21wb25lbnRzX1tuYW1lXTtcblx0XHRcdGlmICghY29uc3RydWN0b3JGbikge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKCdUaGVyZVxcJ3Mgbm8gY29uc3RydWN0b3IgcmVnaXN0ZXJlZCBmb3IgdGhlIGNvbXBvbmVudCBuYW1lZCAnICsgbmFtZSArICcuXFxuXFx0XFx0XFx0XFx0Q29tcG9uZW50cyBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdmlhIENvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyLicpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbnN0cnVjdG9yRm47XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlZ2lzdGVycyBhIGNvbXBvbmVudCwgc28gaXQgY2FuIGJlIGZvdW5kIGJ5IGl0cyBuYW1lLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29uc3RydWN0b3JGbiBUaGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X25hbWUgTmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBjb21wb25lbnQuIElmIG5vbmUgaXMgZ2l2ZW5cbiAgICogICB0aGUgbmFtZSBkZWZpbmVkIGJ5IHRoZSBOQU1FIHN0YXRpYyB2YXJpYWJsZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gSWYgdGhhdFxuICAgKiAgIGlzbid0IHNldCBhcyB3ZWxsLCB0aGUgbmFtZSBvZiB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24gd2lsbCBiZSB1c2VkLlxuICAgKiBAc3RhdGljXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZWdpc3RlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvbnN0cnVjdG9yRm4sIG9wdF9uYW1lKSB7XG5cdFx0XHR2YXIgbmFtZSA9IG9wdF9uYW1lO1xuXHRcdFx0aWYgKCFuYW1lKSB7XG5cdFx0XHRcdGlmIChjb25zdHJ1Y3RvckZuLmhhc093blByb3BlcnR5KCdOQU1FJykpIHtcblx0XHRcdFx0XHRuYW1lID0gY29uc3RydWN0b3JGbi5OQU1FO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5hbWUgPSAoMCwgX21ldGFsLmdldEZ1bmN0aW9uTmFtZSkoY29uc3RydWN0b3JGbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNvbnN0cnVjdG9yRm4uTkFNRSA9IG5hbWU7XG5cdFx0XHRDb21wb25lbnRSZWdpc3RyeS5jb21wb25lbnRzX1tuYW1lXSA9IGNvbnN0cnVjdG9yRm47XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIENvbXBvbmVudFJlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIEhvbGRzIGFsbCByZWdpc3RlcmVkIGNvbXBvbmVudHMsIGluZGV4ZWQgYnkgdGhlaXIgbmFtZXMuXG4gKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIGZ1bmN0aW9uKCk+fVxuICogQHByb3RlY3RlZFxuICogQHN0YXRpY1xuICovXG5cblxuQ29tcG9uZW50UmVnaXN0cnkuY29tcG9uZW50c18gPSB7fTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9uZW50UmVnaXN0cnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9Db21wb25lbnRSZWdpc3RyeS5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnJlcXVpcmUoJ21ldGFsLWluY3JlbWVudGFsLWRvbScpO1xuXG4oZnVuY3Rpb24gKCkge1xuICB0aGlzLkNMT1NVUkVfTk9fREVQUyA9IHRydWU7XG4gIHRoaXMuZ29vZyA9IHRoaXMuZ29vZyB8fCB7fTtcblxuICAvLyBDb3B5cmlnaHQgMjAwNiBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gIC8vXG4gIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIC8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gIC8vXG4gIC8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gIC8vXG4gIC8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICAvLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAvLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAvKipcbiAgICogQGZpbGVvdmVydmlldyBCb290c3RyYXAgZm9yIHRoZSBHb29nbGUgSlMgTGlicmFyeSAoQ2xvc3VyZSkuXG4gICAqXG4gICAqIEluIHVuY29tcGlsZWQgbW9kZSBiYXNlLmpzIHdpbGwgd3JpdGUgb3V0IENsb3N1cmUncyBkZXBzIGZpbGUsIHVubGVzcyB0aGVcbiAgICogZ2xvYmFsIDxjb2RlPkNMT1NVUkVfTk9fREVQUzwvY29kZT4gaXMgc2V0IHRvIHRydWUuICBUaGlzIGFsbG93cyBwcm9qZWN0cyB0b1xuICAgKiBpbmNsdWRlIHRoZWlyIG93biBkZXBzIGZpbGUocykgZnJvbSBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICAgKlxuICAgKiBAYXV0aG9yIGFydkBnb29nbGUuY29tIChFcmlrIEFydmlkc3NvbilcbiAgICpcbiAgICogQHByb3ZpZGVHb29nXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBPdmVycmlkZGVuIHRvIHRydWUgYnkgdGhlIGNvbXBpbGVyIHdoZW5cbiAgICogICAgIC0tcHJvY2Vzc19jbG9zdXJlX3ByaW1pdGl2ZXMgaXMgc3BlY2lmaWVkLlxuICAgKi9cbiAgdmFyIENPTVBJTEVEID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIEJhc2UgbmFtZXNwYWNlIGZvciB0aGUgQ2xvc3VyZSBsaWJyYXJ5LiAgQ2hlY2tzIHRvIHNlZSBnb29nIGlzIGFscmVhZHlcbiAgICogZGVmaW5lZCBpbiB0aGUgY3VycmVudCBzY29wZSBiZWZvcmUgYXNzaWduaW5nIHRvIHByZXZlbnQgY2xvYmJlcmluZyBpZlxuICAgKiBiYXNlLmpzIGlzIGxvYWRlZCBtb3JlIHRoYW4gb25jZS5cbiAgICpcbiAgICogQGNvbnN0XG4gICAqL1xuICB2YXIgZ29vZyA9IHRoaXMuZ29vZyB8fCB7fTtcblxuICAvKipcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgY29udGV4dC4gIEluIG1vc3QgY2FzZXMgdGhpcyB3aWxsIGJlICd3aW5kb3cnLlxuICAgKi9cbiAgZ29vZy5nbG9iYWwgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBBIGhvb2sgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmluZSB2YWx1ZXMgaW4gdW5jb21waWxlZCBtb2RlLlxuICAgKlxuICAgKiBJbiB1bmNvbXBpbGVkIG1vZGUsIHtAY29kZSBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FU30gbWF5IGJlIGRlZmluZWQgYmVmb3JlXG4gICAqIGxvYWRpbmcgYmFzZS5qcy4gIElmIGEga2V5IGlzIGRlZmluZWQgaW4ge0Bjb2RlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTfSxcbiAgICoge0Bjb2RlIGdvb2cuZGVmaW5lfSB3aWxsIHVzZSB0aGUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCB2YWx1ZS4gIFRoaXNcbiAgICogYWxsb3dzIGZsYWdzIHRvIGJlIG92ZXJ3cml0dGVuIHdpdGhvdXQgY29tcGlsYXRpb24gKHRoaXMgaXMgbm9ybWFsbHlcbiAgICogYWNjb21wbGlzaGVkIHdpdGggdGhlIGNvbXBpbGVyJ3MgXCJkZWZpbmVcIiBmbGFnKS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogICB2YXIgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgPSB7J2dvb2cuREVCVUcnOiBmYWxzZX07XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbik+fHVuZGVmaW5lZH1cbiAgICovXG4gIGdvb2cuZ2xvYmFsLkNMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTO1xuXG4gIC8qKlxuICAgKiBBIGhvb2sgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmluZSB2YWx1ZXMgaW4gdW5jb21waWxlZCBvciBjb21waWxlZCBtb2RlLFxuICAgKiBsaWtlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTIGJ1dCBlZmZlY3RpdmUgaW4gY29tcGlsZWQgY29kZS4gIEluXG4gICAqIHVuY29tcGlsZWQgY29kZSBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyB0YWtlcyBwcmVjZWRlbmNlLlxuICAgKlxuICAgKiBBbHNvIHVubGlrZSBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyB0aGUgdmFsdWVzIG11c3QgYmUgbnVtYmVyLCBib29sZWFuIG9yXG4gICAqIHN0cmluZyBsaXRlcmFscyBvciB0aGUgY29tcGlsZXIgd2lsbCBlbWl0IGFuIGVycm9yLlxuICAgKlxuICAgKiBXaGlsZSBhbnkgQGRlZmluZSB2YWx1ZSBtYXkgYmUgc2V0LCBvbmx5IHRob3NlIHNldCB3aXRoIGdvb2cuZGVmaW5lIHdpbGwgYmVcbiAgICogZWZmZWN0aXZlIGZvciB1bmNvbXBpbGVkIGNvZGUuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIDxwcmU+XG4gICAqICAgdmFyIENMT1NVUkVfREVGSU5FUyA9IHsnZ29vZy5ERUJVRyc6IGZhbHNlfSA7XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbik+fHVuZGVmaW5lZH1cbiAgICovXG4gIGdvb2cuZ2xvYmFsLkNMT1NVUkVfREVGSU5FUztcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAgICogV0FSTklORzogRG8gbm90IHVzZSB0aGlzIHRvIHRlc3QgaWYgYW4gb2JqZWN0IGhhcyBhIHByb3BlcnR5LiBVc2UgdGhlIGluXG4gICAqIG9wZXJhdG9yIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cbiAgICovXG4gIGdvb2cuaXNEZWYgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gdm9pZCAwIGFsd2F5cyBldmFsdWF0ZXMgdG8gdW5kZWZpbmVkIGFuZCBoZW5jZSB3ZSBkbyBub3QgbmVlZCB0byBkZXBlbmQgb25cbiAgICAvLyB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgZ2xvYmFsIHZhcmlhYmxlIG5hbWVkICd1bmRlZmluZWQnLlxuICAgIHJldHVybiB2YWwgIT09IHZvaWQgMDtcbiAgfTtcblxuICAvKipcbiAgICogQnVpbGRzIGFuIG9iamVjdCBzdHJ1Y3R1cmUgZm9yIHRoZSBwcm92aWRlZCBuYW1lc3BhY2UgcGF0aCwgZW5zdXJpbmcgdGhhdFxuICAgKiBuYW1lcyB0aGF0IGFscmVhZHkgZXhpc3QgYXJlIG5vdCBvdmVyd3JpdHRlbi4gRm9yIGV4YW1wbGU6XG4gICAqIFwiYS5iLmNcIiAtPiBhID0ge307YS5iPXt9O2EuYi5jPXt9O1xuICAgKiBVc2VkIGJ5IGdvb2cucHJvdmlkZSBhbmQgZ29vZy5leHBvcnRTeW1ib2wuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG9iamVjdCB0aGF0IHRoaXMgZmlsZSBkZWZpbmVzLlxuICAgKiBAcGFyYW0geyo9fSBvcHRfb2JqZWN0IHRoZSBvYmplY3QgdG8gZXhwb3NlIGF0IHRoZSBlbmQgb2YgdGhlIHBhdGguXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdFRvRXhwb3J0VG8gVGhlIG9iamVjdCB0byBhZGQgdGhlIHBhdGggdG87IGRlZmF1bHRcbiAgICogICAgIGlzIHxnb29nLmdsb2JhbHwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmV4cG9ydFBhdGhfID0gZnVuY3Rpb24gKG5hbWUsIG9wdF9vYmplY3QsIG9wdF9vYmplY3RUb0V4cG9ydFRvKSB7XG4gICAgdmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciBjdXIgPSBvcHRfb2JqZWN0VG9FeHBvcnRUbyB8fCBnb29nLmdsb2JhbDtcblxuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIGV4aGliaXRzIHN0cmFuZ2UgYmVoYXZpb3Igd2hlbiB0aHJvd2luZyBlcnJvcnMgZnJvbVxuICAgIC8vIG1ldGhvZHMgZXh0ZXJuZWQgaW4gdGhpcyBtYW5uZXIuICBTZWUgdGhlIHRlc3RFeHBvcnRTeW1ib2xFeGNlcHRpb25zIGluXG4gICAgLy8gYmFzZV90ZXN0Lmh0bWwgZm9yIGFuIGV4YW1wbGUuXG4gICAgaWYgKCEocGFydHNbMF0gaW4gY3VyKSAmJiBjdXIuZXhlY1NjcmlwdCkge1xuICAgICAgY3VyLmV4ZWNTY3JpcHQoJ3ZhciAnICsgcGFydHNbMF0pO1xuICAgIH1cblxuICAgIC8vIENlcnRhaW4gYnJvd3NlcnMgY2Fubm90IHBhcnNlIGNvZGUgaW4gdGhlIGZvcm0gZm9yKChhIGluIGIpOyBjOyk7XG4gICAgLy8gVGhpcyBwYXR0ZXJuIGlzIHByb2R1Y2VkIGJ5IHRoZSBKU0NvbXBpbGVyIHdoZW4gaXQgY29sbGFwc2VzIHRoZVxuICAgIC8vIHN0YXRlbWVudCBhYm92ZSBpbnRvIHRoZSBjb25kaXRpb25hbCBsb29wIGJlbG93LiBUbyBwcmV2ZW50IHRoaXMgZnJvbVxuICAgIC8vIGhhcHBlbmluZywgdXNlIGEgZm9yLWxvb3AgYW5kIHJlc2VydmUgdGhlIGluaXQgbG9naWMgYXMgYmVsb3cuXG5cbiAgICAvLyBQYXJlbnRoZXNlcyBhZGRlZCB0byBlbGltaW5hdGUgc3RyaWN0IEpTIHdhcm5pbmcgaW4gRmlyZWZveC5cbiAgICBmb3IgKHZhciBwYXJ0OyBwYXJ0cy5sZW5ndGggJiYgKHBhcnQgPSBwYXJ0cy5zaGlmdCgpKTspIHtcbiAgICAgIGlmICghcGFydHMubGVuZ3RoICYmIGdvb2cuaXNEZWYob3B0X29iamVjdCkpIHtcbiAgICAgICAgLy8gbGFzdCBwYXJ0IGFuZCB3ZSBoYXZlIGFuIG9iamVjdDsgdXNlIGl0XG4gICAgICAgIGN1cltwYXJ0XSA9IG9wdF9vYmplY3Q7XG4gICAgICB9IGVsc2UgaWYgKGN1cltwYXJ0XSkge1xuICAgICAgICBjdXIgPSBjdXJbcGFydF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXIgPSBjdXJbcGFydF0gPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBuYW1lZCB2YWx1ZS4gSW4gdW5jb21waWxlZCBtb2RlLCB0aGUgdmFsdWUgaXMgcmV0cmlldmVkIGZyb21cbiAgICogQ0xPU1VSRV9ERUZJTkVTIG9yIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTIGlmIHRoZSBvYmplY3QgaXMgZGVmaW5lZCBhbmRcbiAgICogaGFzIHRoZSBwcm9wZXJ0eSBzcGVjaWZpZWQsIGFuZCBvdGhlcndpc2UgdXNlZCB0aGUgZGVmaW5lZCBkZWZhdWx0VmFsdWUuXG4gICAqIFdoZW4gY29tcGlsZWQgdGhlIGRlZmF1bHQgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGNvbXBpbGVyXG4gICAqIG9wdGlvbnMgb3IgdGhlIHZhbHVlIHNldCBpbiB0aGUgQ0xPU1VSRV9ERUZJTkVTIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGRpc3Rpbmd1aXNoZWQgbmFtZSB0byBwcm92aWRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gZGVmYXVsdFZhbHVlXG4gICAqL1xuICBnb29nLmRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgaWYgKCFDT01QSUxFRCkge1xuICAgICAgaWYgKGdvb2cuZ2xvYmFsLkNMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnb29nLmdsb2JhbC5DTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUywgbmFtZSkpIHtcbiAgICAgICAgdmFsdWUgPSBnb29nLmdsb2JhbC5DTE9TVVJFX1VOQ09NUElMRURfREVGSU5FU1tuYW1lXTtcbiAgICAgIH0gZWxzZSBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChnb29nLmdsb2JhbC5DTE9TVVJFX0RFRklORVMsIG5hbWUpKSB7XG4gICAgICAgIHZhbHVlID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBnb29nLmV4cG9ydFBhdGhfKG5hbWUsIHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gREVCVUcgaXMgcHJvdmlkZWQgYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGRlYnVnZ2luZyBjb2RlXG4gICAqIHRoYXQgc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBhIHByb2R1Y3Rpb24ganNfYmluYXJ5IGNhbiBiZSBlYXNpbHkgc3RyaXBwZWRcbiAgICogYnkgc3BlY2lmeWluZyAtLWRlZmluZSBnb29nLkRFQlVHPWZhbHNlIHRvIHRoZSBKU0NvbXBpbGVyLiBGb3IgZXhhbXBsZSwgbW9zdFxuICAgKiB0b1N0cmluZygpIG1ldGhvZHMgc2hvdWxkIGJlIGRlY2xhcmVkIGluc2lkZSBhbiBcImlmIChnb29nLkRFQlVHKVwiIGNvbmRpdGlvbmFsXG4gICAqIGJlY2F1c2UgdGhleSBhcmUgZ2VuZXJhbGx5IHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3NlcyBhbmQgaXQgaXMgZGlmZmljdWx0XG4gICAqIGZvciB0aGUgSlNDb21waWxlciB0byBzdGF0aWNhbGx5IGRldGVybWluZSB3aGV0aGVyIHRoZXkgYXJlIHVzZWQuXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5ERUJVRycsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtzdHJpbmd9IExPQ0FMRSBkZWZpbmVzIHRoZSBsb2NhbGUgYmVpbmcgdXNlZCBmb3IgY29tcGlsYXRpb24uIEl0IGlzXG4gICAqIHVzZWQgdG8gc2VsZWN0IGxvY2FsZSBzcGVjaWZpYyBkYXRhIHRvIGJlIGNvbXBpbGVkIGluIGpzIGJpbmFyeS4gQlVJTEQgcnVsZVxuICAgKiBjYW4gc3BlY2lmeSB0aGlzIHZhbHVlIGJ5IFwiLS1kZWZpbmUgZ29vZy5MT0NBTEU9PGxvY2FsZV9uYW1lPlwiIGFzIEpTQ29tcGlsZXJcbiAgICogb3B0aW9uLlxuICAgKlxuICAgKiBUYWtlIGludG8gYWNjb3VudCB0aGF0IHRoZSBsb2NhbGUgY29kZSBmb3JtYXQgaXMgaW1wb3J0YW50LiBZb3Ugc2hvdWxkIHVzZVxuICAgKiB0aGUgY2Fub25pY2FsIFVuaWNvZGUgZm9ybWF0IHdpdGggaHlwaGVuIGFzIGEgZGVsaW1pdGVyLiBMYW5ndWFnZSBtdXN0IGJlXG4gICAqIGxvd2VyY2FzZSwgTGFuZ3VhZ2UgU2NyaXB0IC0gQ2FwaXRhbGl6ZWQsIFJlZ2lvbiAtIFVQUEVSQ0FTRS5cbiAgICogVGhlcmUgYXJlIGZldyBleGFtcGxlczogcHQtQlIsIGVuLCBlbi1VUywgc3ItTGF0aW4tQk8sIHpoLUhhbnMtQ04uXG4gICAqXG4gICAqIFNlZSBtb3JlIGluZm8gYWJvdXQgbG9jYWxlIGNvZGVzIGhlcmU6XG4gICAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNVbmljb2RlX0xhbmd1YWdlX2FuZF9Mb2NhbGVfSWRlbnRpZmllcnNcbiAgICpcbiAgICogRm9yIGxhbmd1YWdlIGNvZGVzIHlvdSBzaG91bGQgdXNlIHZhbHVlcyBkZWZpbmVkIGJ5IElTTyA2OTMtMS4gU2VlIGl0IGhlcmVcbiAgICogaHR0cDovL3d3dy53My5vcmcvV0FJL0VSL0lHL2VydC9pc282MzkuaHRtLiBUaGVyZSBpcyBvbmx5IG9uZSBleGNlcHRpb24gZnJvbVxuICAgKiB0aGlzIHJ1bGU6IHRoZSBIZWJyZXcgbGFuZ3VhZ2UuIEZvciBsZWdhY3kgcmVhc29ucyB0aGUgb2xkIGNvZGUgKGl3KSBzaG91bGRcbiAgICogYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBuZXcgY29kZSAoaGUpLCBzZWUgaHR0cDovL3dpa2kvTWFpbi9JSUlTeW5vbnltcy5cbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLkxPQ0FMRScsICdlbicpOyAvLyBkZWZhdWx0IHRvIGVuXG5cblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIGNvZGUgaXMgcnVubmluZyBvbiB0cnVzdGVkIHNpdGVzLlxuICAgKlxuICAgKiBPbiB1bnRydXN0ZWQgc2l0ZXMsIHNldmVyYWwgbmF0aXZlIGZ1bmN0aW9ucyBjYW4gYmUgZGVmaW5lZCBvciBvdmVycmlkZGVuIGJ5XG4gICAqIGV4dGVybmFsIGxpYnJhcmllcyBsaWtlIFByb3RvdHlwZSwgRGF0ZWpzLCBhbmQgSlF1ZXJ5IGFuZCBzZXR0aW5nIHRoaXMgZmxhZ1xuICAgKiB0byBmYWxzZSBmb3JjZXMgY2xvc3VyZSB0byB1c2UgaXRzIG93biBpbXBsZW1lbnRhdGlvbnMgd2hlbiBwb3NzaWJsZS5cbiAgICpcbiAgICogSWYgeW91ciBKYXZhU2NyaXB0IGNhbiBiZSBsb2FkZWQgYnkgYSB0aGlyZCBwYXJ0eSBzaXRlIGFuZCB5b3UgYXJlIHdhcnkgYWJvdXRcbiAgICogcmVseWluZyBvbiBub24tc3RhbmRhcmQgaW1wbGVtZW50YXRpb25zLCBzcGVjaWZ5XG4gICAqIFwiLS1kZWZpbmUgZ29vZy5UUlVTVEVEX1NJVEU9ZmFsc2VcIiB0byB0aGUgSlNDb21waWxlci5cbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLlRSVVNURURfU0lURScsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIGEgcHJvamVjdCBpcyBleHBlY3RlZCB0byBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLlxuICAgKlxuICAgKiBUaGlzIGRlZmluZSBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGFsdGVybmF0ZSBpbXBsZW1lbnRhdGlvbnMgY29tcGF0aWJsZSB3aXRoXG4gICAqIHJ1bm5pbmcgaW4gRWNtYVNjcmlwdCBTdHJpY3QgbW9kZSBvciB3YXJuIGFib3V0IHVuYXZhaWxhYmxlIGZ1bmN0aW9uYWxpdHkuXG4gICAqIEBzZWUgaHR0cHM6Ly9nb28uZ2wvZzVFb0hJXG4gICAqXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5TVFJJQ1RfTU9ERV9DT01QQVRJQkxFJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIGNvZGUgdGhhdCBjYWxscyB7QGxpbmsgZ29vZy5zZXRUZXN0T25seX0gc2hvdWxkXG4gICAqICAgICBiZSBkaXNhbGxvd2VkIGluIHRoZSBjb21waWxhdGlvbiB1bml0LlxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuRElTQUxMT1dfVEVTVF9PTkxZX0NPREUnLCBDT01QSUxFRCAmJiAhZ29vZy5ERUJVRyk7XG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdG8gdXNlIGEgQ2hyb21lIGFwcCBDU1AtY29tcGxpYW50IG1ldGhvZCBmb3JcbiAgICogICAgIGxvYWRpbmcgc2NyaXB0cyB2aWEgZ29vZy5yZXF1aXJlLiBAc2VlIGFwcGVuZFNjcmlwdFNyY05vZGVfLlxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuRU5BQkxFX0NIUk9NRV9BUFBfU0FGRV9TQ1JJUFRfTE9BRElORycsIGZhbHNlKTtcblxuICAvKipcbiAgICogRGVmaW5lcyBhIG5hbWVzcGFjZSBpbiBDbG9zdXJlLlxuICAgKlxuICAgKiBBIG5hbWVzcGFjZSBtYXkgb25seSBiZSBkZWZpbmVkIG9uY2UgaW4gYSBjb2RlYmFzZS4gSXQgbWF5IGJlIGRlZmluZWQgdXNpbmdcbiAgICogZ29vZy5wcm92aWRlKCkgb3IgZ29vZy5tb2R1bGUoKS5cbiAgICpcbiAgICogVGhlIHByZXNlbmNlIG9mIG9uZSBvciBtb3JlIGdvb2cucHJvdmlkZSgpIGNhbGxzIGluIGEgZmlsZSBpbmRpY2F0ZXNcbiAgICogdGhhdCB0aGUgZmlsZSBkZWZpbmVzIHRoZSBnaXZlbiBvYmplY3RzL25hbWVzcGFjZXMuXG4gICAqIFByb3ZpZGVkIHN5bWJvbHMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuXG4gICAqXG4gICAqIEluIGFkZGl0aW9uLCBnb29nLnByb3ZpZGUoKSBjcmVhdGVzIHRoZSBvYmplY3Qgc3R1YnMgZm9yIGEgbmFtZXNwYWNlXG4gICAqIChmb3IgZXhhbXBsZSwgZ29vZy5wcm92aWRlKFwiZ29vZy5mb28uYmFyXCIpIHdpbGwgY3JlYXRlIHRoZSBvYmplY3RcbiAgICogZ29vZy5mb28uYmFyIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QpLlxuICAgKlxuICAgKiBCdWlsZCB0b29scyBhbHNvIHNjYW4gZm9yIHByb3ZpZGUvcmVxdWlyZS9tb2R1bGUgc3RhdGVtZW50c1xuICAgKiB0byBkaXNjZXJuIGRlcGVuZGVuY2llcywgYnVpbGQgZGVwZW5kZW5jeSBmaWxlcyAoc2VlIGRlcHMuanMpLCBldGMuXG4gICAqXG4gICAqIEBzZWUgZ29vZy5yZXF1aXJlXG4gICAqIEBzZWUgZ29vZy5tb2R1bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIHByb3ZpZGVkIGJ5IHRoaXMgZmlsZSBpbiB0aGUgZm9ybVxuICAgKiAgICAgXCJnb29nLnBhY2thZ2UucGFydFwiLlxuICAgKi9cbiAgZ29vZy5wcm92aWRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2FtZSBuYW1lc3BhY2UgaXNuJ3QgcHJvdmlkZWQgdHdpY2UuXG4gICAgICAvLyBBIGdvb2cubW9kdWxlL2dvb2cucHJvdmlkZSBtYXBzIGEgZ29vZy5yZXF1aXJlIHRvIGEgc3BlY2lmaWMgZmlsZVxuICAgICAgaWYgKGdvb2cuaXNQcm92aWRlZF8obmFtZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05hbWVzcGFjZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZGVjbGFyZWQuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfKG5hbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgcHJvdmlkZWQgYnkgdGhpcyBmaWxlIGluIHRoZSBmb3JtXG4gICAqICAgICBcImdvb2cucGFja2FnZS5wYXJ0XCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHRvIGVtYmVkIGluIHRoZSBuYW1lc3BhY2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmNvbnN0cnVjdE5hbWVzcGFjZV8gPSBmdW5jdGlvbiAobmFtZSwgb3B0X29iaikge1xuICAgIGlmICghQ09NUElMRUQpIHtcbiAgICAgIGRlbGV0ZSBnb29nLmltcGxpY2l0TmFtZXNwYWNlc19bbmFtZV07XG5cbiAgICAgIHZhciBuYW1lc3BhY2UgPSBuYW1lO1xuICAgICAgd2hpbGUgKG5hbWVzcGFjZSA9IG5hbWVzcGFjZS5zdWJzdHJpbmcoMCwgbmFtZXNwYWNlLmxhc3RJbmRleE9mKCcuJykpKSB7XG4gICAgICAgIGlmIChnb29nLmdldE9iamVjdEJ5TmFtZShuYW1lc3BhY2UpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZ29vZy5pbXBsaWNpdE5hbWVzcGFjZXNfW25hbWVzcGFjZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdvb2cuZXhwb3J0UGF0aF8obmFtZSwgb3B0X29iaik7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1vZHVsZSBpZGVudGlmaWVyIHZhbGlkYXRpb24gcmVnZXhwLlxuICAgKiBOb3RlOiBUaGlzIGlzIGEgY29uc2VydmF0aXZlIGNoZWNrLCBpdCBpcyB2ZXJ5IHBvc3NpYmxlIHRvIGJlIG1vcmUgbGVuaWVudCxcbiAgICogICB0aGUgcHJpbWFyeSBleGNsdXNpb24gaGVyZSBpcyBcIi9cIiBhbmQgXCJcXFwiIGFuZCBhIGxlYWRpbmcgXCIuXCIsIHRoZXNlXG4gICAqICAgcmVzdHJpY3Rpb25zIGFyZSBpbnRlbmRlZCB0byBsZWF2ZSB0aGUgZG9vciBvcGVuIGZvciB1c2luZyBnb29nLnJlcXVpcmVcbiAgICogICB3aXRoIHJlbGF0aXZlIGZpbGUgcGF0aHMgcmF0aGVyIHRoYW4gbW9kdWxlIGlkZW50aWZpZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5WQUxJRF9NT0RVTEVfUkVfID0gL15bYS16QS1aXyRdW2EtekEtWjAtOS5fJF0qJC87XG5cbiAgLyoqXG4gICAqIERlZmluZXMgYSBtb2R1bGUgaW4gQ2xvc3VyZS5cbiAgICpcbiAgICogTWFya3MgdGhhdCB0aGlzIGZpbGUgbXVzdCBiZSBsb2FkZWQgYXMgYSBtb2R1bGUgYW5kIGNsYWltcyB0aGUgbmFtZXNwYWNlLlxuICAgKlxuICAgKiBBIG5hbWVzcGFjZSBtYXkgb25seSBiZSBkZWZpbmVkIG9uY2UgaW4gYSBjb2RlYmFzZS4gSXQgbWF5IGJlIGRlZmluZWQgdXNpbmdcbiAgICogZ29vZy5wcm92aWRlKCkgb3IgZ29vZy5tb2R1bGUoKS5cbiAgICpcbiAgICogZ29vZy5tb2R1bGUoKSBoYXMgdGhyZWUgcmVxdWlyZW1lbnRzOlxuICAgKiAtIGdvb2cubW9kdWxlIG1heSBub3QgYmUgdXNlZCBpbiB0aGUgc2FtZSBmaWxlIGFzIGdvb2cucHJvdmlkZS5cbiAgICogLSBnb29nLm1vZHVsZSBtdXN0IGJlIHRoZSBmaXJzdCBzdGF0ZW1lbnQgaW4gdGhlIGZpbGUuXG4gICAqIC0gb25seSBvbmUgZ29vZy5tb2R1bGUgaXMgYWxsb3dlZCBwZXIgZmlsZS5cbiAgICpcbiAgICogV2hlbiBhIGdvb2cubW9kdWxlIGFubm90YXRlZCBmaWxlIGlzIGxvYWRlZCwgaXQgaXMgZW5jbG9zZWQgaW5cbiAgICogYSBzdHJpY3QgZnVuY3Rpb24gY2xvc3VyZS4gVGhpcyBtZWFucyB0aGF0OlxuICAgKiAtIGFueSB2YXJpYWJsZXMgZGVjbGFyZWQgaW4gYSBnb29nLm1vZHVsZSBmaWxlIGFyZSBwcml2YXRlIHRvIHRoZSBmaWxlXG4gICAqIChub3QgZ2xvYmFsKSwgdGhvdWdoIHRoZSBjb21waWxlciBpcyBleHBlY3RlZCB0byBpbmxpbmUgdGhlIG1vZHVsZS5cbiAgICogLSBUaGUgY29kZSBtdXN0IG9iZXkgYWxsIHRoZSBydWxlcyBvZiBcInN0cmljdFwiIEphdmFTY3JpcHQuXG4gICAqIC0gdGhlIGZpbGUgd2lsbCBiZSBtYXJrZWQgYXMgXCJ1c2Ugc3RyaWN0XCJcbiAgICpcbiAgICogTk9URTogdW5saWtlIGdvb2cucHJvdmlkZSwgZ29vZy5tb2R1bGUgZG9lcyBub3QgZGVjbGFyZSBhbnkgc3ltYm9scyBieVxuICAgKiBpdHNlbGYuIElmIGRlY2xhcmVkIHN5bWJvbHMgYXJlIGRlc2lyZWQsIHVzZVxuICAgKiBnb29nLm1vZHVsZS5kZWNsYXJlTGVnYWN5TmFtZXNwYWNlKCkuXG4gICAqXG4gICAqXG4gICAqIFNlZSB0aGUgcHVibGljIGdvb2cubW9kdWxlIHByb3Bvc2FsOiBodHRwOi8vZ29vLmdsL1ZhMWhpblxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgcHJvdmlkZWQgYnkgdGhpcyBmaWxlIGluIHRoZSBmb3JtXG4gICAqICAgICBcImdvb2cucGFja2FnZS5wYXJ0XCIsIGlzIGV4cGVjdGVkIGJ1dCBub3QgcmVxdWlyZWQuXG4gICAqL1xuICBnb29nLm1vZHVsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCFnb29nLmlzU3RyaW5nKG5hbWUpIHx8ICFuYW1lIHx8IG5hbWUuc2VhcmNoKGdvb2cuVkFMSURfTU9EVUxFX1JFXykgPT0gLTEpIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG1vZHVsZSBpZGVudGlmaWVyJyk7XG4gICAgfVxuICAgIGlmICghZ29vZy5pc0luTW9kdWxlTG9hZGVyXygpKSB7XG4gICAgICB0aHJvdyBFcnJvcignTW9kdWxlICcgKyBuYW1lICsgJyBoYXMgYmVlbiBsb2FkZWQgaW5jb3JyZWN0bHkuJyk7XG4gICAgfVxuICAgIGlmIChnb29nLm1vZHVsZUxvYWRlclN0YXRlXy5tb2R1bGVOYW1lKSB7XG4gICAgICB0aHJvdyBFcnJvcignZ29vZy5tb2R1bGUgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIG1vZHVsZS4nKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgbW9kdWxlIG5hbWUgZm9yIHRoZSBsb2FkZXIuXG4gICAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8ubW9kdWxlTmFtZSA9IG5hbWU7XG4gICAgaWYgKCFDT01QSUxFRCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNhbWUgbmFtZXNwYWNlIGlzbid0IHByb3ZpZGVkIHR3aWNlLlxuICAgICAgLy8gQSBnb29nLm1vZHVsZS9nb29nLnByb3ZpZGUgbWFwcyBhIGdvb2cucmVxdWlyZSB0byBhIHNwZWNpZmljIGZpbGVcbiAgICAgIGlmIChnb29nLmlzUHJvdmlkZWRfKG5hbWUpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOYW1lc3BhY2UgXCInICsgbmFtZSArICdcIiBhbHJlYWR5IGRlY2xhcmVkLicpO1xuICAgICAgfVxuICAgICAgZGVsZXRlIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBtb2R1bGUgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7P30gVGhlIG1vZHVsZSBleHBvcnRzIGZvciBhbiBhbHJlYWR5IGxvYWRlZCBtb2R1bGUgb3IgbnVsbC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBpcyBub3QgYW4gYWx0ZXJuYXRpdmUgdG8gZ29vZy5yZXF1aXJlLCBpdCBkb2VzIG5vdFxuICAgKiBpbmRpY2F0ZSBhIGhhcmQgZGVwZW5kZW5jeSwgaW5zdGVhZCBpdCBpcyB1c2VkIHRvIGluZGljYXRlXG4gICAqIGFuIG9wdGlvbmFsIGRlcGVuZGVuY3kgb3IgdG8gYWNjZXNzIHRoZSBleHBvcnRzIG9mIGEgbW9kdWxlXG4gICAqIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBsb2FkZWQuXG4gICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3ZpZGV9XG4gICAqL1xuICBnb29nLm1vZHVsZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBnb29nLm1vZHVsZS5nZXRJbnRlcm5hbF8obmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBtb2R1bGUgaWRlbnRpZmllci5cbiAgICogQHJldHVybiB7P30gVGhlIG1vZHVsZSBleHBvcnRzIGZvciBhbiBhbHJlYWR5IGxvYWRlZCBtb2R1bGUgb3IgbnVsbC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubW9kdWxlLmdldEludGVybmFsXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCFDT01QSUxFRCkge1xuICAgICAgaWYgKGdvb2cuaXNQcm92aWRlZF8obmFtZSkpIHtcbiAgICAgICAgLy8gZ29vZy5yZXF1aXJlIG9ubHkgcmV0dXJuIGEgdmFsdWUgd2l0aC1pbiBnb29nLm1vZHVsZSBmaWxlcy5cbiAgICAgICAgcmV0dXJuIG5hbWUgaW4gZ29vZy5sb2FkZWRNb2R1bGVzXyA/IGdvb2cubG9hZGVkTW9kdWxlc19bbmFtZV0gOiBnb29nLmdldE9iamVjdEJ5TmFtZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHByaXZhdGUgez97bW9kdWxlTmFtZTogKHN0cmluZ3x1bmRlZmluZWQpLCBkZWNsYXJlTGVnYWN5TmFtZXNwYWNlOmJvb2xlYW59fVxuICAgKi9cbiAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgZ29vZy5tb2R1bGUgaXMgY3VycmVudGx5IGJlaW5nIGluaXRpYWxpemVkLlxuICAgKi9cbiAgZ29vZy5pc0luTW9kdWxlTG9hZGVyXyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8gIT0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSB0aGUgbW9kdWxlJ3MgZXhwb3J0cyBhcyBhIGdsb2JhbGx5IGFjY2Vzc2libGUgb2JqZWN0IHVuZGVyIHRoZVxuICAgKiBtb2R1bGUncyBkZWNsYXJlZCBuYW1lLiAgVGhpcyBpcyBpbnRlbmRlZCB0byBlYXNlIG1pZ3JhdGlvbiB0byBnb29nLm1vZHVsZVxuICAgKiBmb3IgZmlsZXMgdGhhdCBoYXZlIGV4aXN0aW5nIHVzYWdlcy5cbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvdmlkZX1cbiAgICovXG4gIGdvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFDT01QSUxFRCAmJiAhZ29vZy5pc0luTW9kdWxlTG9hZGVyXygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UgbXVzdCBiZSBjYWxsZWQgZnJvbSAnICsgJ3dpdGhpbiBhIGdvb2cubW9kdWxlJyk7XG4gICAgfVxuICAgIGlmICghQ09NUElMRUQgJiYgIWdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLm1vZHVsZU5hbWUpIHtcbiAgICAgIHRocm93IEVycm9yKCdnb29nLm1vZHVsZSBtdXN0IGJlIGNhbGxlZCBwcmlvciB0byAnICsgJ2dvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UuJyk7XG4gICAgfVxuICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UgPSB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYXJrcyB0aGF0IHRoZSBjdXJyZW50IGZpbGUgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZywgYW5kIG5ldmVyIGZvclxuICAgKiBsaXZlIGNvZGUgaW4gcHJvZHVjdGlvbi5cbiAgICpcbiAgICogSW4gdGhlIGNhc2Ugb2YgdW5pdCB0ZXN0cywgdGhlIG1lc3NhZ2UgbWF5IG9wdGlvbmFsbHkgYmUgYW4gZXhhY3QgbmFtZXNwYWNlXG4gICAqIGZvciB0aGUgdGVzdCAoZS5nLiAnZ29vZy5zdHJpbmdUZXN0JykuIFRoZSBsaW50ZXIgd2lsbCB0aGVuIGlnbm9yZSB0aGUgZXh0cmFcbiAgICogcHJvdmlkZSAoaWYgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpbiB0aGUgY29kZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZSB0byBhZGQgdG8gdGhlIGVycm9yIHRoYXQnc1xuICAgKiAgICAgcmFpc2VkIHdoZW4gdXNlZCBpbiBwcm9kdWN0aW9uIGNvZGUuXG4gICAqL1xuICBnb29nLnNldFRlc3RPbmx5ID0gZnVuY3Rpb24gKG9wdF9tZXNzYWdlKSB7XG4gICAgaWYgKGdvb2cuRElTQUxMT1dfVEVTVF9PTkxZX0NPREUpIHtcbiAgICAgIG9wdF9tZXNzYWdlID0gb3B0X21lc3NhZ2UgfHwgJyc7XG4gICAgICB0aHJvdyBFcnJvcignSW1wb3J0aW5nIHRlc3Qtb25seSBjb2RlIGludG8gbm9uLWRlYnVnIGVudmlyb25tZW50JyArIChvcHRfbWVzc2FnZSA/ICc6ICcgKyBvcHRfbWVzc2FnZSA6ICcuJykpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIG5hbWUgaGFzIGJlZW4gZ29vZy5wcm92aWRlZC4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBmb3JcbiAgICAgKiBuYW1lcyB0aGF0IGFyZSBhdmFpbGFibGUgb25seSBhcyBpbXBsaWNpdCBuYW1lc3BhY2VzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG9iamVjdCB0byBsb29rIGZvci5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBuYW1lIGhhcyBiZWVuIHByb3ZpZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5pc1Byb3ZpZGVkXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZSBpbiBnb29nLmxvYWRlZE1vZHVsZXNfIHx8ICFnb29nLmltcGxpY2l0TmFtZXNwYWNlc19bbmFtZV0gJiYgZ29vZy5pc0RlZkFuZE5vdE51bGwoZ29vZy5nZXRPYmplY3RCeU5hbWUobmFtZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2VzIGltcGxpY2l0bHkgZGVmaW5lZCBieSBnb29nLnByb3ZpZGUuIEZvciBleGFtcGxlLFxuICAgICAqIGdvb2cucHJvdmlkZSgnZ29vZy5ldmVudHMuRXZlbnQnKSBpbXBsaWNpdGx5IGRlY2xhcmVzIHRoYXQgJ2dvb2cnIGFuZFxuICAgICAqICdnb29nLmV2ZW50cycgbXVzdCBiZSBuYW1lc3BhY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAoYm9vbGVhbnx1bmRlZmluZWQpPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzXyA9IHsgJ2dvb2cubW9kdWxlJzogdHJ1ZSB9O1xuXG4gICAgLy8gTk9URTogV2UgYWRkIGdvb2cubW9kdWxlIGFzIGFuIGltcGxpY2l0IG5hbWVzcGFjZSBhcyBnb29nLm1vZHVsZSBpcyBkZWZpbmVkXG4gICAgLy8gaGVyZSBhbmQgYmVjYXVzZSB0aGUgZXhpc3RpbmcgbW9kdWxlIHBhY2thZ2UgaGFzIG5vdCBiZWVuIG1vdmVkIHlldCBvdXQgb2ZcbiAgICAvLyB0aGUgZ29vZy5tb2R1bGUgbmFtZXNwYWNlLiBUaGlzIHNhdGlzaWZpZXMgYm90aCB0aGUgZGVidWcgbG9hZGVyIGFuZFxuICAgIC8vIGFoZWFkLW9mLXRpbWUgZGVwZW5kZW5jeSBtYW5hZ2VtZW50LlxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS4gIFRoZSBvYmplY3RcbiAgICogaXMgbm90IGZvdW5kIGlmIG51bGwgb3IgdW5kZWZpbmVkLiAgSWYgeW91IGFyZSB1c2luZyBhIGNvbXBpbGF0aW9uIHBhc3MgdGhhdFxuICAgKiByZW5hbWVzIHByb3BlcnR5IG5hbWVzIGJld2FyZSB0aGF0IHVzaW5nIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgZmluZCByZW5hbWVkXG4gICAqIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcbiAgICogICAgIHxnb29nLmdsb2JhbHwuXG4gICAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgbnVsbC5cbiAgICovXG4gIGdvb2cuZ2V0T2JqZWN0QnlOYW1lID0gZnVuY3Rpb24gKG5hbWUsIG9wdF9vYmopIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIGN1ciA9IG9wdF9vYmogfHwgZ29vZy5nbG9iYWw7XG4gICAgZm9yICh2YXIgcGFydDsgcGFydCA9IHBhcnRzLnNoaWZ0KCk7KSB7XG4gICAgICBpZiAoZ29vZy5pc0RlZkFuZE5vdE51bGwoY3VyW3BhcnRdKSkge1xuICAgICAgICBjdXIgPSBjdXJbcGFydF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cjtcbiAgfTtcblxuICAvKipcbiAgICogR2xvYmFsaXplcyBhIHdob2xlIG5hbWVzcGFjZSwgc3VjaCBhcyBnb29nIG9yIGdvb2cubGFuZy5cbiAgICpcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmogVGhlIG5hbWVzcGFjZSB0byBnbG9iYWxpemUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2dsb2JhbCBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgcHJvcGVydGllcyB0by5cbiAgICogQGRlcHJlY2F0ZWQgUHJvcGVydGllcyBtYXkgYmUgZXhwbGljaXRseSBleHBvcnRlZCB0byB0aGUgZ2xvYmFsIHNjb3BlLCBidXRcbiAgICogICAgIHRoaXMgc2hvdWxkIG5vIGxvbmdlciBiZSBkb25lIGluIGJ1bGsuXG4gICAqL1xuICBnb29nLmdsb2JhbGl6ZSA9IGZ1bmN0aW9uIChvYmosIG9wdF9nbG9iYWwpIHtcbiAgICB2YXIgZ2xvYmFsID0gb3B0X2dsb2JhbCB8fCBnb29nLmdsb2JhbDtcbiAgICBmb3IgKHZhciB4IGluIG9iaikge1xuICAgICAgZ2xvYmFsW3hdID0gb2JqW3hdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIGRlcGVuZGVuY3kgZnJvbSBhIGZpbGUgdG8gdGhlIGZpbGVzIGl0IHJlcXVpcmVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVsUGF0aCBUaGUgcGF0aCB0byB0aGUganMgZmlsZS5cbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gcHJvdmlkZXMgQW4gYXJyYXkgb2Ygc3RyaW5ncyB3aXRoXG4gICAqICAgICB0aGUgbmFtZXMgb2YgdGhlIG9iamVjdHMgdGhpcyBmaWxlIHByb3ZpZGVzLlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSByZXF1aXJlcyBBbiBhcnJheSBvZiBzdHJpbmdzIHdpdGhcbiAgICogICAgIHRoZSBuYW1lcyBvZiB0aGUgb2JqZWN0cyB0aGlzIGZpbGUgcmVxdWlyZXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbnwhT2JqZWN0PHN0cmluZz49fSBvcHRfbG9hZEZsYWdzIFBhcmFtZXRlcnMgaW5kaWNhdGluZ1xuICAgKiAgICAgaG93IHRoZSBmaWxlIG11c3QgYmUgbG9hZGVkLiAgVGhlIGJvb2xlYW4gJ3RydWUnIGlzIGVxdWl2YWxlbnRcbiAgICogICAgIHRvIHsnbW9kdWxlJzogJ2dvb2cnfSBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuICBWYWxpZCBwcm9wZXJ0aWVzXG4gICAqICAgICBhbmQgdmFsdWVzIGluY2x1ZGUgeydtb2R1bGUnOiAnZ29vZyd9IGFuZCB7J2xhbmcnOiAnZXM2J30uXG4gICAqL1xuICBnb29nLmFkZERlcGVuZGVuY3kgPSBmdW5jdGlvbiAocmVsUGF0aCwgcHJvdmlkZXMsIHJlcXVpcmVzLCBvcHRfbG9hZEZsYWdzKSB7XG4gICAgaWYgKGdvb2cuREVQRU5ERU5DSUVTX0VOQUJMRUQpIHtcbiAgICAgIHZhciBwcm92aWRlLCByZXF1aXJlO1xuICAgICAgdmFyIHBhdGggPSByZWxQYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgIHZhciBkZXBzID0gZ29vZy5kZXBlbmRlbmNpZXNfO1xuICAgICAgaWYgKCFvcHRfbG9hZEZsYWdzIHx8IHR5cGVvZiBvcHRfbG9hZEZsYWdzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0X2xvYWRGbGFncyA9IG9wdF9sb2FkRmxhZ3MgPyB7ICdtb2R1bGUnOiAnZ29vZycgfSA6IHt9O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb3ZpZGUgPSBwcm92aWRlc1tpXTsgaSsrKSB7XG4gICAgICAgIGRlcHMubmFtZVRvUGF0aFtwcm92aWRlXSA9IHBhdGg7XG4gICAgICAgIGRlcHMucGF0aElzTW9kdWxlW3BhdGhdID0gb3B0X2xvYWRGbGFnc1snbW9kdWxlJ10gPT0gJ2dvb2cnO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IHJlcXVpcmUgPSByZXF1aXJlc1tqXTsgaisrKSB7XG4gICAgICAgIGlmICghKHBhdGggaW4gZGVwcy5yZXF1aXJlcykpIHtcbiAgICAgICAgICBkZXBzLnJlcXVpcmVzW3BhdGhdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZGVwcy5yZXF1aXJlc1twYXRoXVtyZXF1aXJlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIE5PVEUobm5hemUpOiBUaGUgZGVidWcgRE9NIGxvYWRlciB3YXMgaW5jbHVkZWQgaW4gYmFzZS5qcyBhcyBhbiBvcmlnaW5hbCB3YXlcbiAgLy8gdG8gZG8gXCJkZWJ1Zy1tb2RlXCIgZGV2ZWxvcG1lbnQuICBUaGUgZGVwZW5kZW5jeSBzeXN0ZW0gY2FuIHNvbWV0aW1lcyBiZVxuICAvLyBjb25mdXNpbmcsIGFzIGNhbiB0aGUgZGVidWcgRE9NIGxvYWRlcidzIGFzeW5jaHJvbm91cyBuYXR1cmUuXG4gIC8vXG4gIC8vIFdpdGggdGhlIERPTSBsb2FkZXIsIGEgY2FsbCB0byBnb29nLnJlcXVpcmUoKSBpcyBub3QgYmxvY2tpbmcgLS0gdGhlIHNjcmlwdFxuICAvLyB3aWxsIG5vdCBsb2FkIHVudGlsIHNvbWUgcG9pbnQgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0LiAgSWYgYSBuYW1lc3BhY2UgaXNcbiAgLy8gbmVlZGVkIGF0IHJ1bnRpbWUsIGl0IG5lZWRzIHRvIGJlIGRlZmluZWQgaW4gYSBwcmV2aW91cyBzY3JpcHQsIG9yIGxvYWRlZCB2aWFcbiAgLy8gcmVxdWlyZSgpIHdpdGggaXRzIHJlZ2lzdGVyZWQgZGVwZW5kZW5jaWVzLlxuICAvL1xuICAvLyBVc2VyLWRlZmluZWQgbmFtZXNwYWNlcyBtYXkgbmVlZCB0aGVpciBvd24gZGVwcyBmaWxlLiBGb3IgYSByZWZlcmVuY2Ugb25cbiAgLy8gY3JlYXRpbmcgYSBkZXBzIGZpbGUsIHNlZTpcbiAgLy8gRXh0ZXJuYWxseTogaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vY2xvc3VyZS9saWJyYXJ5L2RvY3MvZGVwc3dyaXRlclxuICAvL1xuICAvLyBCZWNhdXNlIG9mIGxlZ2FjeSBjbGllbnRzLCB0aGUgRE9NIGxvYWRlciBjYW4ndCBiZSBlYXNpbHkgcmVtb3ZlZCBmcm9tXG4gIC8vIGJhc2UuanMuICBXb3JrIGlzIGJlaW5nIGRvbmUgdG8gbWFrZSBpdCBkaXNhYmxlYWJsZSBvciByZXBsYWNlYWJsZSBmb3JcbiAgLy8gZGlmZmVyZW50IGVudmlyb25tZW50cyAoRE9NLWxlc3MgSmF2YVNjcmlwdCBpbnRlcnByZXRlcnMgbGlrZSBSaGlubyBvciBWOCxcbiAgLy8gZm9yIGV4YW1wbGUpLiBTZWUgYm9vdHN0cmFwLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIGVuYWJsZSB0aGUgZGVidWcgbG9hZGVyLlxuICAgKlxuICAgKiBJZiBlbmFibGVkLCBhIGNhbGwgdG8gZ29vZy5yZXF1aXJlKCkgd2lsbCBhdHRlbXB0IHRvIGxvYWQgdGhlIG5hbWVzcGFjZSBieVxuICAgKiBhcHBlbmRpbmcgYSBzY3JpcHQgdGFnIHRvIHRoZSBET00gKGlmIHRoZSBuYW1lc3BhY2UgaGFzIGJlZW4gcmVnaXN0ZXJlZCkuXG4gICAqXG4gICAqIElmIGRpc2FibGVkLCBnb29nLnJlcXVpcmUoKSB3aWxsIHNpbXBseSBhc3NlcnQgdGhhdCB0aGUgbmFtZXNwYWNlIGhhcyBiZWVuXG4gICAqIHByb3ZpZGVkIChhbmQgZGVwZW5kIG9uIHRoZSBmYWN0IHRoYXQgc29tZSBvdXRzaWRlIHRvb2wgY29ycmVjdGx5IG9yZGVyZWRcbiAgICogdGhlIHNjcmlwdCkuXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5FTkFCTEVfREVCVUdfTE9BREVSJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubG9nVG9Db25zb2xlXyA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBpZiAoZ29vZy5nbG9iYWwuY29uc29sZSkge1xuICAgICAgZ29vZy5nbG9iYWwuY29uc29sZVsnZXJyb3InXShtc2cpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW1wbGVtZW50cyBhIHN5c3RlbSBmb3IgdGhlIGR5bmFtaWMgcmVzb2x1dGlvbiBvZiBkZXBlbmRlbmNpZXMgdGhhdCB3b3JrcyBpblxuICAgKiBwYXJhbGxlbCB3aXRoIHRoZSBCVUlMRCBzeXN0ZW0uIE5vdGUgdGhhdCBhbGwgY2FsbHMgdG8gZ29vZy5yZXF1aXJlIHdpbGwgYmVcbiAgICogc3RyaXBwZWQgYnkgdGhlIEpTQ29tcGlsZXIgd2hlbiB0aGUgLS1wcm9jZXNzX2Nsb3N1cmVfcHJpbWl0aXZlcyBvcHRpb24gaXNcbiAgICogdXNlZC5cbiAgICogQHNlZSBnb29nLnByb3ZpZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZXNwYWNlIHRvIGluY2x1ZGUgKGFzIHdhcyBnaXZlbiBpbiBnb29nLnByb3ZpZGUoKSkgaW5cbiAgICogICAgIHRoZSBmb3JtIFwiZ29vZy5wYWNrYWdlLnBhcnRcIi5cbiAgICogQHJldHVybiB7P30gSWYgY2FsbGVkIHdpdGhpbiBhIGdvb2cubW9kdWxlIGZpbGUsIHRoZSBhc3NvY2lhdGVkIG5hbWVzcGFjZSBvclxuICAgKiAgICAgbW9kdWxlIG90aGVyd2lzZSBudWxsLlxuICAgKi9cbiAgZ29vZy5yZXF1aXJlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAvLyBJZiB0aGUgb2JqZWN0IGFscmVhZHkgZXhpc3RzIHdlIGRvIG5vdCBuZWVkIGRvIGRvIGFueXRoaW5nLlxuICAgIGlmICghQ09NUElMRUQpIHtcbiAgICAgIGlmIChnb29nLkVOQUJMRV9ERUJVR19MT0FERVIgJiYgZ29vZy5JU19PTERfSUVfKSB7XG4gICAgICAgIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWREZXBfKG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgICBpZiAoZ29vZy5pc0luTW9kdWxlTG9hZGVyXygpKSB7XG4gICAgICAgICAgcmV0dXJuIGdvb2cubW9kdWxlLmdldEludGVybmFsXyhuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ29vZy5FTkFCTEVfREVCVUdfTE9BREVSKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ29vZy5nZXRQYXRoRnJvbURlcHNfKG5hbWUpO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIGdvb2cud3JpdGVTY3JpcHRzXyhwYXRoKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ2dvb2cucmVxdWlyZSBjb3VsZCBub3QgZmluZDogJyArIG5hbWU7XG4gICAgICBnb29nLmxvZ1RvQ29uc29sZV8oZXJyb3JNZXNzYWdlKTtcblxuICAgICAgdGhyb3cgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhdGggZm9yIGluY2x1ZGVkIHNjcmlwdHMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLmJhc2VQYXRoID0gJyc7XG5cbiAgLyoqXG4gICAqIEEgaG9vayBmb3Igb3ZlcnJpZGluZyB0aGUgYmFzZSBwYXRoLlxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICovXG4gIGdvb2cuZ2xvYmFsLkNMT1NVUkVfQkFTRV9QQVRIO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHdyaXRlIG91dCBDbG9zdXJlJ3MgZGVwcyBmaWxlLiBCeSBkZWZhdWx0LCB0aGUgZGVwcyBhcmUgd3JpdHRlbi5cbiAgICogQHR5cGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICAgKi9cbiAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9OT19ERVBTO1xuXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRvIGltcG9ydCBhIHNpbmdsZSBzY3JpcHQuIFRoaXMgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiB3aGVuXG4gICAqIENsb3N1cmUgaXMgYmVpbmcgcnVuIGluIG5vbi1IVE1MIGNvbnRleHRzLCBzdWNoIGFzIHdlYiB3b3JrZXJzLiBJdCdzIGRlZmluZWRcbiAgICogaW4gdGhlIGdsb2JhbCBzY29wZSBzbyB0aGF0IGl0IGNhbiBiZSBzZXQgYmVmb3JlIGJhc2UuanMgaXMgbG9hZGVkLCB3aGljaFxuICAgKiBhbGxvd3MgZGVwcy5qcyB0byBiZSBpbXBvcnRlZCBwcm9wZXJseS5cbiAgICpcbiAgICogVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aGUgc2NyaXB0IHNvdXJjZSwgd2hpY2ggaXMgYSByZWxhdGl2ZSBVUkkuIEl0IHNob3VsZFxuICAgKiByZXR1cm4gdHJ1ZSBpZiB0aGUgc2NyaXB0IHdhcyBpbXBvcnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdHlwZSB7KGZ1bmN0aW9uKHN0cmluZyk6IGJvb2xlYW4pfHVuZGVmaW5lZH1cbiAgICovXG4gIGdvb2cuZ2xvYmFsLkNMT1NVUkVfSU1QT1JUX1NDUklQVDtcblxuICAvKipcbiAgICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cbiAgICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAgICovXG4gIGdvb2cubnVsbEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge307XG5cbiAgLyoqXG4gICAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG4gICAqIEZvby5wcm90b3R5cGUuYmFyID0gZ29vZy5hYnN0cmFjdE1ldGhvZFxuICAgKlxuICAgKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAgICpcbiAgICogTm90ZTogVGhpcyBkb2VzIG5vdCB0YWtlIHRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBvdmVycmlkZSBhcyBhbiBhcmd1bWVudFxuICAgKiBiZWNhdXNlIHRoYXQgd291bGQgbWFrZSBpdCBtb3JlIGRpZmZpY3VsdCB0byBvYmZ1c2NhdGUgb3VyIEphdmFTY3JpcHQgY29kZS5cbiAgICpcbiAgICogQHR5cGUgeyFGdW5jdGlvbn1cbiAgICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICAgKi9cbiAgZ29vZy5hYnN0cmFjdE1ldGhvZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBFcnJvcigndW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcbiAgfTtcblxuICAvKipcbiAgICogQWRkcyBhIHtAY29kZSBnZXRJbnN0YW5jZX0gc3RhdGljIG1ldGhvZCB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBzYW1lXG4gICAqIGluc3RhbmNlIG9iamVjdC5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGN0b3IgVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgY2xhc3MgdG8gYWRkIHRoZSBzdGF0aWNcbiAgICogICAgIG1ldGhvZCB0by5cbiAgICovXG4gIGdvb2cuYWRkU2luZ2xldG9uR2V0dGVyID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICBjdG9yLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGN0b3IuaW5zdGFuY2VfKSB7XG4gICAgICAgIHJldHVybiBjdG9yLmluc3RhbmNlXztcbiAgICAgIH1cbiAgICAgIGlmIChnb29nLkRFQlVHKSB7XG4gICAgICAgIC8vIE5PVEU6IEpTQ29tcGlsZXIgY2FuJ3Qgb3B0aW1pemUgYXdheSBBcnJheSNwdXNoLlxuICAgICAgICBnb29nLmluc3RhbnRpYXRlZFNpbmdsZXRvbnNfW2dvb2cuaW5zdGFudGlhdGVkU2luZ2xldG9uc18ubGVuZ3RoXSA9IGN0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3Rvci5pbnN0YW5jZV8gPSBuZXcgY3RvcigpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEFsbCBzaW5nbGV0b24gY2xhc3NlcyB0aGF0IGhhdmUgYmVlbiBpbnN0YW50aWF0ZWQsIGZvciB0ZXN0aW5nLiBEb24ndCByZWFkXG4gICAqIGl0IGRpcmVjdGx5LCB1c2UgdGhlIHtAY29kZSBnb29nLnRlc3Rpbmcuc2luZ2xldG9ufSBtb2R1bGUuIFRoZSBjb21waWxlclxuICAgKiByZW1vdmVzIHRoaXMgdmFyaWFibGUgaWYgdW51c2VkLlxuICAgKiBAdHlwZSB7IUFycmF5PCFGdW5jdGlvbj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmluc3RhbnRpYXRlZFNpbmdsZXRvbnNfID0gW107XG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdG8gbG9hZCBnb29nLm1vZHVsZXMgdXNpbmcge0Bjb2RlIGV2YWx9IHdoZW4gdXNpbmdcbiAgICogdGhlIGRlYnVnIGxvYWRlci4gIFRoaXMgcHJvdmlkZXMgYSBiZXR0ZXIgZGVidWdnaW5nIGV4cGVyaWVuY2UgYXMgdGhlXG4gICAqIHNvdXJjZSBpcyB1bm1vZGlmaWVkIGFuZCBjYW4gYmUgZWRpdGVkIHVzaW5nIENocm9tZSBXb3Jrc3BhY2VzIG9yIHNpbWlsYXIuXG4gICAqIEhvd2V2ZXIgaW4gc29tZSBlbnZpcm9ubWVudHMgdGhlIHVzZSBvZiB7QGNvZGUgZXZhbH0gaXMgYmFubmVkXG4gICAqIHNvIHdlIHByb3ZpZGUgYW4gYWx0ZXJuYXRpdmUuXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5MT0FEX01PRFVMRV9VU0lOR19FVkFMJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV4cG9ydHMgb2YgZ29vZy5tb2R1bGVzIHNob3VsZCBiZSBzZWFsZWQgd2hlblxuICAgKiBwb3NzaWJsZS5cbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLlNFQUxfTU9EVUxFX0VYUE9SVFMnLCBnb29nLkRFQlVHKTtcblxuICAvKipcbiAgICogVGhlIHJlZ2lzdHJ5IG9mIGluaXRpYWxpemVkIG1vZHVsZXM6XG4gICAqIHRoZSBtb2R1bGUgaWRlbnRpZmllciB0byBtb2R1bGUgZXhwb3J0cyBtYXAuXG4gICAqIEBwcml2YXRlIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsID8+fVxuICAgKi9cbiAgZ29vZy5sb2FkZWRNb2R1bGVzXyA9IHt9O1xuXG4gIC8qKlxuICAgKiBUcnVlIGlmIGdvb2cuZGVwZW5kZW5jaWVzXyBpcyBhdmFpbGFibGUuXG4gICAqIEBjb25zdCB7Ym9vbGVhbn1cbiAgICovXG4gIGdvb2cuREVQRU5ERU5DSUVTX0VOQUJMRUQgPSAhQ09NUElMRUQgJiYgZ29vZy5FTkFCTEVfREVCVUdfTE9BREVSO1xuXG4gIGlmIChnb29nLkRFUEVOREVOQ0lFU19FTkFCTEVEKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGRlcGVuZGVuY2llcyBhbmQgb3RoZXIgZGF0YSB0aGF0IGlzXG4gICAgICogdXNlZCBmb3IgbG9hZGluZyBzY3JpcHRzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3tcbiAgICAgKiAgIHBhdGhJc01vZHVsZTogIU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+LFxuICAgICAqICAgbmFtZVRvUGF0aDogIU9iamVjdDxzdHJpbmcsIHN0cmluZz4sXG4gICAgICogICByZXF1aXJlczogIU9iamVjdDxzdHJpbmcsICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPj4sXG4gICAgICogICB2aXNpdGVkOiAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4sXG4gICAgICogICB3cml0dGVuOiAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4sXG4gICAgICogICBkZWZlcnJlZDogIU9iamVjdDxzdHJpbmcsIHN0cmluZz5cbiAgICAgKiB9fVxuICAgICAqL1xuICAgIGdvb2cuZGVwZW5kZW5jaWVzXyA9IHtcbiAgICAgIHBhdGhJc01vZHVsZToge30sIC8vIDEgdG8gMVxuXG4gICAgICBuYW1lVG9QYXRoOiB7fSwgLy8gMSB0byAxXG5cbiAgICAgIHJlcXVpcmVzOiB7fSwgLy8gMSB0byBtYW55XG5cbiAgICAgIC8vIFVzZWQgd2hlbiByZXNvbHZpbmcgZGVwZW5kZW5jaWVzIHRvIHByZXZlbnQgdXMgZnJvbSB2aXNpdGluZyBmaWxlIHR3aWNlLlxuICAgICAgdmlzaXRlZDoge30sXG5cbiAgICAgIHdyaXR0ZW46IHt9LCAvLyBVc2VkIHRvIGtlZXAgdHJhY2sgb2Ygc2NyaXB0IGZpbGVzIHdlIGhhdmUgd3JpdHRlbi5cblxuICAgICAgZGVmZXJyZWQ6IHt9IC8vIFVzZWQgdG8gdHJhY2sgZGVmZXJyZWQgbW9kdWxlIGV2YWx1YXRpb25zIGluIG9sZCBJRXNcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJpZXMgdG8gZGV0ZWN0IHdoZXRoZXIgaXMgaW4gdGhlIGNvbnRleHQgb2YgYW4gSFRNTCBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGl0IGxvb2tzIGxpa2UgSFRNTCBkb2N1bWVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuaW5IdG1sRG9jdW1lbnRfID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcbiAgICAgIHJldHVybiBkb2MgIT0gbnVsbCAmJiAnd3JpdGUnIGluIGRvYzsgLy8gWFVMRG9jdW1lbnQgbWlzc2VzIHdyaXRlLlxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byBkZXRlY3QgdGhlIGJhc2UgcGF0aCBvZiBiYXNlLmpzIHNjcmlwdCB0aGF0IGJvb3RzdHJhcHMgQ2xvc3VyZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuZmluZEJhc2VQYXRoXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnb29nLmlzRGVmKGdvb2cuZ2xvYmFsLkNMT1NVUkVfQkFTRV9QQVRIKSkge1xuICAgICAgICBnb29nLmJhc2VQYXRoID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9CQVNFX1BBVEg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWdvb2cuaW5IdG1sRG9jdW1lbnRfKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcbiAgICAgIHZhciBzY3JpcHRzID0gZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdTQ1JJUFQnKTtcbiAgICAgIC8vIFNlYXJjaCBiYWNrd2FyZHMgc2luY2UgdGhlIGN1cnJlbnQgc2NyaXB0IGlzIGluIGFsbW9zdCBhbGwgY2FzZXMgdGhlIG9uZVxuICAgICAgLy8gdGhhdCBoYXMgYmFzZS5qcy5cbiAgICAgIGZvciAodmFyIGkgPSBzY3JpcHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSAvKiogQHR5cGUgeyFIVE1MU2NyaXB0RWxlbWVudH0gKi9zY3JpcHRzW2ldO1xuICAgICAgICB2YXIgc3JjID0gc2NyaXB0LnNyYztcbiAgICAgICAgdmFyIHFtYXJrID0gc3JjLmxhc3RJbmRleE9mKCc/Jyk7XG4gICAgICAgIHZhciBsID0gcW1hcmsgPT0gLTEgPyBzcmMubGVuZ3RoIDogcW1hcms7XG4gICAgICAgIGlmIChzcmMuc3Vic3RyKGwgLSA3LCA3KSA9PSAnYmFzZS5qcycpIHtcbiAgICAgICAgICBnb29nLmJhc2VQYXRoID0gc3JjLnN1YnN0cigwLCBsIC0gNyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYSBzY3JpcHQgaWYsIGFuZCBvbmx5IGlmLCB0aGF0IHNjcmlwdCBoYXNuJ3QgYWxyZWFkeSBiZWVuIGltcG9ydGVkLlxuICAgICAqIChNdXN0IGJlIGNhbGxlZCBhdCBleGVjdXRpb24gdGltZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNjcmlwdCBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc291cmNlVGV4dCBUaGUgb3B0aW9uYWxseSBzb3VyY2UgdGV4dCB0byBldmFsdWF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5pbXBvcnRTY3JpcHRfID0gZnVuY3Rpb24gKHNyYywgb3B0X3NvdXJjZVRleHQpIHtcbiAgICAgIHZhciBpbXBvcnRTY3JpcHQgPSBnb29nLmdsb2JhbC5DTE9TVVJFX0lNUE9SVF9TQ1JJUFQgfHwgZ29vZy53cml0ZVNjcmlwdFRhZ187XG4gICAgICBpZiAoaW1wb3J0U2NyaXB0KHNyYywgb3B0X3NvdXJjZVRleHQpKSB7XG4gICAgICAgIGdvb2cuZGVwZW5kZW5jaWVzXy53cml0dGVuW3NyY10gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKiogQGNvbnN0IEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIGdvb2cuSVNfT0xEX0lFXyA9ICEhKCFnb29nLmdsb2JhbC5hdG9iICYmIGdvb2cuZ2xvYmFsLmRvY3VtZW50ICYmIGdvb2cuZ2xvYmFsLmRvY3VtZW50LmFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIFVSTCBpbml0aWF0ZSByZXRyaWV2YWwgYW5kIGV4ZWN1dGlvbiBvZiB0aGUgbW9kdWxlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU2NyaXB0IHNvdXJjZSBVUkwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLmltcG9ydE1vZHVsZV8gPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAvLyBJbiBhbiBhdHRlbXB0IHRvIGtlZXAgYnJvd3NlcnMgZnJvbSB0aW1pbmcgb3V0IGxvYWRpbmcgc2NyaXB0cyB1c2luZ1xuICAgICAgLy8gc3luY2hyb25vdXMgWEhScywgcHV0IGVhY2ggbG9hZCBpbiBpdHMgb3duIHNjcmlwdCBibG9jay5cbiAgICAgIHZhciBib290c3RyYXAgPSAnZ29vZy5yZXRyaWV2ZUFuZEV4ZWNNb2R1bGVfKFwiJyArIHNyYyArICdcIik7JztcblxuICAgICAgaWYgKGdvb2cuaW1wb3J0U2NyaXB0XygnJywgYm9vdHN0cmFwKSkge1xuICAgICAgICBnb29nLmRlcGVuZGVuY2llc18ud3JpdHRlbltzcmNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICBnb29nLnF1ZXVlZE1vZHVsZXNfID0gW107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXBwcm9wcmlhdGUgbW9kdWxlIHRleHQuIFN1aXRhYmxlIHRvIGluc2VydCBpbnRvXG4gICAgICogYSBzY3JpcHQgdGFnICh0aGF0IGlzIHVuZXNjYXBlZCkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyY1VybFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHRUZXh0XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy53cmFwTW9kdWxlXyA9IGZ1bmN0aW9uIChzcmNVcmwsIHNjcmlwdFRleHQpIHtcbiAgICAgIGlmICghZ29vZy5MT0FEX01PRFVMRV9VU0lOR19FVkFMIHx8ICFnb29nLmlzRGVmKGdvb2cuZ2xvYmFsLkpTT04pKSB7XG4gICAgICAgIHJldHVybiAnJyArICdnb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykgeycgKyAnXCJ1c2Ugc3RyaWN0XCI7JyArIHNjcmlwdFRleHQgKyAnXFxuJyArIC8vIHRlcm1pbmF0ZSBhbnkgdHJhaWxpbmcgc2luZ2xlIGxpbmUgY29tbWVudC5cbiAgICAgICAgJztyZXR1cm4gZXhwb3J0cycgKyAnfSk7JyArICdcXG4vLyMgc291cmNlVVJMPScgKyBzcmNVcmwgKyAnXFxuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnJyArICdnb29nLmxvYWRNb2R1bGUoJyArIGdvb2cuZ2xvYmFsLkpTT04uc3RyaW5naWZ5KHNjcmlwdFRleHQgKyAnXFxuLy8jIHNvdXJjZVVSTD0nICsgc3JjVXJsICsgJ1xcbicpICsgJyk7JztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gT24gSUU5IGFuZCBlYXJsaWVyLCBpdCBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlXG4gICAgLy8gZGVmZXJyZWQgbW9kdWxlIGxvYWRzLiBJbiBsYXRlciBicm93c2VycywgdGhlXG4gICAgLy8gY29kZSB0byBiZSBldmFsdWF0ZWQgaXMgc2ltcGx5IGluc2VydGVkIGFzIGEgc2NyaXB0XG4gICAgLy8gYmxvY2sgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIFRvIGV2YWwgZGVmZXJyZWRcbiAgICAvLyBjb2RlIGF0IHRoZSByaWdodCB0aW1lLCB3ZSBwaWdneSBiYWNrIG9uIGdvb2cucmVxdWlyZSB0byBjYWxsXG4gICAgLy8gZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZERlcF8uXG4gICAgLy9cbiAgICAvLyBUaGUgZ29vZy5yZXF1aXJlcyBhcmUgdXNlZCBib3RoIHRvIGJvb3RzdHJhcFxuICAgIC8vIHRoZSBsb2FkaW5nIHByb2Nlc3MgKHdoZW4gbm8gZGVwcyBhcmUgYXZhaWxhYmxlKSBhbmRcbiAgICAvLyBkZWNsYXJlIHRoYXQgdGhleSBzaG91bGQgYmUgYXZhaWxhYmxlLlxuICAgIC8vXG4gICAgLy8gSGVyZSB3ZSBldmFsIHRoZSBzb3VyY2VzLCBpZiBhbGwgdGhlIGRlcHMgYXJlIGF2YWlsYWJsZVxuICAgIC8vIGVpdGhlciBhbHJlYWR5IGV2YWwnZCBvciBnb29nLnJlcXVpcmUnZC4gIFRoaXMgd2lsbFxuICAgIC8vIGJlIHRoZSBjYXNlIHdoZW4gYWxsIHRoZSBkZXBlbmRlbmNpZXMgaGF2ZSBhbHJlYWR5XG4gICAgLy8gYmVlbiBsb2FkZWQsIGFuZCB0aGUgZGVwZW5kZW50IG1vZHVsZSBpcyBsb2FkZWQuXG4gICAgLy9cbiAgICAvLyBCdXQgdGhpcyBhbG9uZSBpc24ndCBzdWZmaWNpZW50IGJlY2F1c2UgaXQgaXMgYWxzb1xuICAgIC8vIG5lY2Vzc2FyeSB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlcmUgaXMgbm8gcm9vdFxuICAgIC8vIHRoYXQgaXMgbm90IGRlZmVycmVkLiAgRm9yIHRoYXQgdGhlcmUgd2UgcmVnaXN0ZXIgZm9yIGFuIGV2ZW50XG4gICAgLy8gYW5kIHRyaWdnZXIgZ29vZy5sb2FkUXVldWVkTW9kdWxlc18gaGFuZGxlIGFueSByZW1haW5pbmcgZGVmZXJyZWRcbiAgICAvLyBldmFsdWF0aW9ucy5cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbnkgcmVtYWluaW5nIGRlZmVycmVkIGdvb2cubW9kdWxlIGV2YWxzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5sb2FkUXVldWVkTW9kdWxlc18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY291bnQgPSBnb29nLnF1ZXVlZE1vZHVsZXNfLmxlbmd0aDtcbiAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gZ29vZy5xdWV1ZWRNb2R1bGVzXztcbiAgICAgICAgZ29vZy5xdWV1ZWRNb2R1bGVzXyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICB2YXIgcGF0aCA9IHF1ZXVlW2ldO1xuICAgICAgICAgIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWRQYXRoXyhwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFdmFsIHRoZSBuYW1lZCBtb2R1bGUgaWYgaXRzIGRlcGVuZGVuY2llcyBhcmVcbiAgICAgKiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG1vZHVsZSB0byBsb2FkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZERlcF8gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgaWYgKGdvb2cuaXNEZWZlcnJlZE1vZHVsZV8obmFtZSkgJiYgZ29vZy5hbGxEZXBzQXJlQXZhaWxhYmxlXyhuYW1lKSkge1xuICAgICAgICB2YXIgcGF0aCA9IGdvb2cuZ2V0UGF0aEZyb21EZXBzXyhuYW1lKTtcbiAgICAgICAgZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZFBhdGhfKGdvb2cuYmFzZVBhdGggKyBwYXRoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG1vZHVsZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBuYW1lIHJlcHJlc2VudHMgYVxuICAgICAqICAgICBtb2R1bGUgd2hvc2UgZXZhbHVhdGlvbiBoYXMgYmVlbiBkZWZlcnJlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuaXNEZWZlcnJlZE1vZHVsZV8gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHBhdGggPSBnb29nLmdldFBhdGhGcm9tRGVwc18obmFtZSk7XG4gICAgICBpZiAocGF0aCAmJiBnb29nLmRlcGVuZGVuY2llc18ucGF0aElzTW9kdWxlW3BhdGhdKSB7XG4gICAgICAgIHZhciBhYnNwYXRoID0gZ29vZy5iYXNlUGF0aCArIHBhdGg7XG4gICAgICAgIHJldHVybiBhYnNwYXRoIGluIGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG1vZHVsZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBuYW1lIHJlcHJlc2VudHMgYVxuICAgICAqICAgICBtb2R1bGUgd2hvc2UgZGVjbGFyZWQgZGVwZW5kZW5jaWVzIGhhdmUgYWxsIGJlZW4gbG9hZGVkXG4gICAgICogICAgIChldmFsJ2Qgb3IgYSBkZWZlcnJlZCBtb2R1bGUgbG9hZClcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuYWxsRGVwc0FyZUF2YWlsYWJsZV8gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHBhdGggPSBnb29nLmdldFBhdGhGcm9tRGVwc18obmFtZSk7XG4gICAgICBpZiAocGF0aCAmJiBwYXRoIGluIGdvb2cuZGVwZW5kZW5jaWVzXy5yZXF1aXJlcykge1xuICAgICAgICBmb3IgKHZhciByZXF1aXJlTmFtZSBpbiBnb29nLmRlcGVuZGVuY2llc18ucmVxdWlyZXNbcGF0aF0pIHtcbiAgICAgICAgICBpZiAoIWdvb2cuaXNQcm92aWRlZF8ocmVxdWlyZU5hbWUpICYmICFnb29nLmlzRGVmZXJyZWRNb2R1bGVfKHJlcXVpcmVOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhYnNwYXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkUGF0aF8gPSBmdW5jdGlvbiAoYWJzcGF0aCkge1xuICAgICAgaWYgKGFic3BhdGggaW4gZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkKSB7XG4gICAgICAgIHZhciBzcmMgPSBnb29nLmRlcGVuZGVuY2llc18uZGVmZXJyZWRbYWJzcGF0aF07XG4gICAgICAgIGRlbGV0ZSBnb29nLmRlcGVuZGVuY2llc18uZGVmZXJyZWRbYWJzcGF0aF07XG4gICAgICAgIGdvb2cuZ2xvYmFsRXZhbChzcmMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIGEgZ29vZy5tb2R1bGUgZnJvbSB0aGUgcHJvdmlkZWQgVVJMLiAgVGhpcyBpcyBub3QgYSBnZW5lcmFsIHB1cnBvc2VcbiAgICAgKiBjb2RlIGxvYWRlciBhbmQgZG9lcyBub3Qgc3VwcG9ydCBsYXRlIGxvYWRpbmcgY29kZSwgdGhhdCBpcyBpdCBzaG91bGQgb25seVxuICAgICAqIGJlIHVzZWQgZHVyaW5nIHBhZ2UgbG9hZC4gVGhpcyBtZXRob2QgZXhpc3RzIHRvIHN1cHBvcnQgdW5pdCB0ZXN0cyBhbmRcbiAgICAgKiBcImRlYnVnXCIgbG9hZGVycyB0aGF0IHdvdWxkIG90aGVyd2lzZSBoYXZlIGluc2VydGVkIHNjcmlwdCB0YWdzLiBVbmRlciB0aGVcbiAgICAgKiBob29kIHRoaXMgbmVlZHMgdG8gdXNlIGEgc3luY2hyb25vdXMgWEhSIGFuZCBpcyBub3QgcmVjb21tZW5lZGVkIGZvclxuICAgICAqIHByb2R1Y3Rpb24gY29kZS5cbiAgICAgKlxuICAgICAqIFRoZSBtb2R1bGUncyBnb29nLnJlcXVpcmVzIG11c3QgaGF2ZSBhbHJlYWR5IGJlZW4gc2F0aXNpZmllZDsgYW4gZXhjZXB0aW9uXG4gICAgICogd2lsbCBiZSB0aHJvd24gaWYgdGhpcyBpcyBub3QgdGhlIGNhc2UuIFRoaXMgYXNzdW1wdGlvbiBpcyB0aGF0IG5vXG4gICAgICogXCJkZXBzLmpzXCIgZmlsZSBleGlzdHMsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBkaXNjb3ZlciBhbmQgbG9jYXRlIHRoZVxuICAgICAqIG1vZHVsZS10by1iZS1sb2FkZWQncyBkZXBlbmRlbmNpZXMgYW5kIG5vIGF0dGVtcHQgaXMgbWFkZSB0byBkbyBzby5cbiAgICAgKlxuICAgICAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIG9uZSBhdHRlbXB0IHRvIGxvYWQgYSBtb2R1bGUuICBJZlxuICAgICAqIFwiZ29vZy5sb2FkTW9kdWxlRnJvbVVybFwiIGlzIGNhbGxlZCBmb3IgYW4gYWxyZWFkeSBsb2FkZWQgbW9kdWxlLCBhblxuICAgICAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIGZyb20gd2hpY2ggdG8gYXR0ZW1wdCB0byBsb2FkIHRoZSBnb29nLm1vZHVsZS5cbiAgICAgKi9cbiAgICBnb29nLmxvYWRNb2R1bGVGcm9tVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgLy8gQmVjYXVzZSB0aGlzIGV4ZWN1dGVzIHN5bmNocm9ub3VzbHksIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IGFkZGl0aW9uYWxcbiAgICAgIC8vIGJvb2trZWVwaW5nLiBXaGVuIFwiZ29vZy5sb2FkTW9kdWxlXCIgdGhlIG5hbWVzcGFjZSB3aWxsIGJlIG1hcmtlZCBhc1xuICAgICAgLy8gaGF2aW5nIGJlZW4gcHJvdmlkZWQgd2hpY2ggaXMgc3VmZmljaWVudC5cbiAgICAgIGdvb2cucmV0cmlldmVBbmRFeGVjTW9kdWxlXyh1cmwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKD8pOj98c3RyaW5nfSBtb2R1bGVEZWYgVGhlIG1vZHVsZSBkZWZpbml0aW9uLlxuICAgICAqL1xuICAgIGdvb2cubG9hZE1vZHVsZSA9IGZ1bmN0aW9uIChtb2R1bGVEZWYpIHtcbiAgICAgIC8vIE5PVEU6IHdlIGFsbG93IGZ1bmN0aW9uIGRlZmluaXRpb25zIHRvIGJlIGVpdGhlciBpbiB0aGUgZnJvbVxuICAgICAgLy8gb2YgYSBzdHJpbmcgdG8gZXZhbCAod2hpY2gga2VlcHMgdGhlIG9yaWdpbmFsIHNvdXJjZSBpbnRhY3QpIG9yXG4gICAgICAvLyBpbiBhIGV2YWwgZm9yYmlkZGVuIGVudmlyb25tZW50IChDU1ApIHdlIGFsbG93IGEgZnVuY3Rpb24gZGVmaW5pdGlvblxuICAgICAgLy8gd2hpY2ggaW4gaXRzIGJvZHkgbXVzdCBjYWxsIHtAY29kZSBnb29nLm1vZHVsZX0sIGFuZCByZXR1cm4gdGhlIGV4cG9ydHNcbiAgICAgIC8vIG9mIHRoZSBtb2R1bGUuXG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8gPSB7XG4gICAgICAgICAgbW9kdWxlTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRlY2xhcmVMZWdhY3lOYW1lc3BhY2U6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHZhciBleHBvcnRzO1xuICAgICAgICBpZiAoZ29vZy5pc0Z1bmN0aW9uKG1vZHVsZURlZikpIHtcbiAgICAgICAgICBleHBvcnRzID0gbW9kdWxlRGVmLmNhbGwoZ29vZy5nbG9iYWwsIHt9KTtcbiAgICAgICAgfSBlbHNlIGlmIChnb29nLmlzU3RyaW5nKG1vZHVsZURlZikpIHtcbiAgICAgICAgICBleHBvcnRzID0gZ29vZy5sb2FkTW9kdWxlRnJvbVNvdXJjZV8uY2FsbChnb29nLmdsb2JhbCwgbW9kdWxlRGVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBtb2R1bGUgZGVmaW5pdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZHVsZU5hbWUgPSBnb29nLm1vZHVsZUxvYWRlclN0YXRlXy5tb2R1bGVOYW1lO1xuICAgICAgICBpZiAoIWdvb2cuaXNTdHJpbmcobW9kdWxlTmFtZSkgfHwgIW1vZHVsZU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBtb2R1bGUgbmFtZSBcXFwiJyArIG1vZHVsZU5hbWUgKyAnXFxcIicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3Qgc2VhbCBsZWdhY3kgbmFtZXNwYWNlcyBhcyB0aGV5IG1heSBiZSB1c2VzIGFzIGEgcGFyZW50IG9mXG4gICAgICAgIC8vIGFub3RoZXIgbmFtZXNwYWNlXG4gICAgICAgIGlmIChnb29nLm1vZHVsZUxvYWRlclN0YXRlXy5kZWNsYXJlTGVnYWN5TmFtZXNwYWNlKSB7XG4gICAgICAgICAgZ29vZy5jb25zdHJ1Y3ROYW1lc3BhY2VfKG1vZHVsZU5hbWUsIGV4cG9ydHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGdvb2cuU0VBTF9NT0RVTEVfRVhQT1JUUyAmJiBPYmplY3Quc2VhbCkge1xuICAgICAgICAgIE9iamVjdC5zZWFsKGV4cG9ydHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ29vZy5sb2FkZWRNb2R1bGVzX1ttb2R1bGVOYW1lXSA9IGV4cG9ydHM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IHByZXZpb3VzU3RhdGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlIEBjb25zdCB7ZnVuY3Rpb24oc3RyaW5nKTo/fVxuICAgICAqXG4gICAgICogVGhlIG5ldyB0eXBlIGluZmVyZW5jZSB3YXJucyBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaGFzIG5vIGZvcm1hbFxuICAgICAqIHBhcmFtZXRlcnMsIGJ1dCBpdHMganNkb2Mgc2F5cyB0aGF0IGl0IHRha2VzIG9uZSBhcmd1bWVudC5cbiAgICAgKiAoVGhlIGFyZ3VtZW50IGlzIHVzZWQgdmlhIGFyZ3VtZW50c1swXSwgYnV0IE5USSBkb2VzIG5vdCBkZXRlY3QgdGhpcy4pXG4gICAgICogQHN1cHByZXNzIHtuZXdDaGVja1R5cGVzfVxuICAgICAqL1xuICAgIGdvb2cubG9hZE1vZHVsZUZyb21Tb3VyY2VfID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTk9URTogd2UgYXZvaWQgZGVjbGFyaW5nIHBhcmFtZXRlcnMgb3IgbG9jYWwgdmFyaWFibGVzIGhlcmUgdG8gYXZvaWRcbiAgICAgIC8vIG1hc2tpbmcgZ2xvYmFscyBvciBsZWFraW5nIHZhbHVlcyBpbnRvIHRoZSBtb2R1bGUgZGVmaW5pdGlvbi5cbiAgICAgICd1c2Ugc3RyaWN0JztcblxuICAgICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAgIGV2YWwoYXJndW1lbnRzWzBdKTtcbiAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBuZXcgc2NyaXB0IHBvaW50aW5nIHRvIHtAY29kZSBzcmN9IGRpcmVjdGx5IGludG8gdGhlIERPTS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBDU1AtY29tcGxpYW50LiBAc2VlIGdvb2cuYXBwZW5kU2NyaXB0U3JjTm9kZV8gZm9yXG4gICAgICogdGhlIGZhbGxiYWNrIG1lY2hhbmlzbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIHNjcmlwdCBVUkwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLndyaXRlU2NyaXB0U3JjTm9kZV8gPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICBnb29nLmdsb2JhbC5kb2N1bWVudC53cml0ZSgnPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwiJyArIHNyYyArICdcIj48LycgKyAnc2NyaXB0PicpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgbmV3IHNjcmlwdCBub2RlIHRvIHRoZSBET00gdXNpbmcgYSBDU1AtY29tcGxpYW50IG1lY2hhbmlzbS4gVGhpc1xuICAgICAqIG1ldGhvZCBleGlzdHMgYXMgYSBmYWxsYmFjayBmb3IgZG9jdW1lbnQud3JpdGUgKHdoaWNoIGlzIG5vdCBhbGxvd2VkIGluIGFcbiAgICAgKiBzdHJpY3QgQ1NQIGNvbnRleHQsIGUuZy4sIENocm9tZSBhcHBzKS5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBhbmFsb2dvdXMgdG8gdXNpbmcgZG9jdW1lbnQud3JpdGUgdG8gaW5zZXJ0IGFcbiAgICAgKiA8c2NyaXB0PiB0YWc7IHNwZWNpZmljYWxseSwgdGhlIHVzZXIgYWdlbnQgd2lsbCBleGVjdXRlIGEgc2NyaXB0IGFkZGVkIGJ5XG4gICAgICogZG9jdW1lbnQud3JpdGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGN1cnJlbnQgc2NyaXB0IGJsb2NrIGZpbmlzaGVzXG4gICAgICogZXhlY3V0aW5nLCB3aGVyZWFzIHRoZSBET00tYXBwZW5kZWQgc2NyaXB0IG5vZGUgd2lsbCBub3QgYmUgZXhlY3V0ZWQgdW50aWxcbiAgICAgKiB0aGUgZW50aXJlIGRvY3VtZW50IGlzIHBhcnNlZCBhbmQgZXhlY3V0ZWQuIFRoYXQgaXMgdG8gc2F5LCB0aGlzIHNjcmlwdCBpc1xuICAgICAqIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIHNjcmlwdCBleGVjdXRpb24gcXVldWUuXG4gICAgICpcbiAgICAgKiBUaGUgcGFnZSBtdXN0IG5vdCBhdHRlbXB0IHRvIGNhbGwgZ29vZy5yZXF1aXJlZCBlbnRpdGllcyB1bnRpbCBhZnRlciB0aGVcbiAgICAgKiBkb2N1bWVudCBoYXMgbG9hZGVkLCBlLmcuLCBpbiBvciBhZnRlciB0aGUgd2luZG93Lm9ubG9hZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIHNjcmlwdCBVUkwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLmFwcGVuZFNjcmlwdFNyY05vZGVfID0gZnVuY3Rpb24gKHNyYykge1xuICAgICAgLyoqIEB0eXBlIHtEb2N1bWVudH0gKi9cbiAgICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcbiAgICAgIHZhciBzY3JpcHRFbCA9XG4gICAgICAvKiogQHR5cGUge0hUTUxTY3JpcHRFbGVtZW50fSAqL2RvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdEVsLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgIHNjcmlwdEVsLnNyYyA9IHNyYztcbiAgICAgIHNjcmlwdEVsLmRlZmVyID0gZmFsc2U7XG4gICAgICBzY3JpcHRFbC5hc3luYyA9IGZhbHNlO1xuICAgICAgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0RWwpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgaW1wb3J0IGZ1bmN0aW9uLiBXcml0ZXMgYSBzY3JpcHQgdGFnIHRvXG4gICAgICogaW1wb3J0IHRoZSBzY3JpcHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBzY3JpcHQgdXJsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3NvdXJjZVRleHQgVGhlIG9wdGlvbmFsbHkgc291cmNlIHRleHQgdG8gZXZhbHVhdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzY3JpcHQgd2FzIGltcG9ydGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLndyaXRlU2NyaXB0VGFnXyA9IGZ1bmN0aW9uIChzcmMsIG9wdF9zb3VyY2VUZXh0KSB7XG4gICAgICBpZiAoZ29vZy5pbkh0bWxEb2N1bWVudF8oKSkge1xuICAgICAgICAvKiogQHR5cGUgeyFIVE1MRG9jdW1lbnR9ICovXG4gICAgICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciB0cmllcyB0byByZXF1aXJlIGEgbmV3IHN5bWJvbCBhZnRlciBkb2N1bWVudCBsb2FkLFxuICAgICAgICAvLyBzb21ldGhpbmcgaGFzIGdvbmUgdGVycmlibHkgd3JvbmcuIERvaW5nIGEgZG9jdW1lbnQud3JpdGUgd291bGRcbiAgICAgICAgLy8gd2lwZSBvdXQgdGhlIHBhZ2UuIFRoaXMgZG9lcyBub3QgYXBwbHkgdG8gdGhlIENTUC1jb21wbGlhbnQgbWV0aG9kXG4gICAgICAgIC8vIG9mIHdyaXRpbmcgc2NyaXB0IHRhZ3MuXG4gICAgICAgIGlmICghZ29vZy5FTkFCTEVfQ0hST01FX0FQUF9TQUZFX1NDUklQVF9MT0FESU5HICYmIGRvYy5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAvLyBDZXJ0YWluIHRlc3QgZnJhbWV3b3JrcyBsb2FkIGJhc2UuanMgbXVsdGlwbGUgdGltZXMsIHdoaWNoIHRyaWVzXG4gICAgICAgICAgLy8gdG8gd3JpdGUgZGVwcy5qcyBlYWNoIHRpbWUuIElmIHRoYXQgaGFwcGVucywganVzdCBmYWlsIHNpbGVudGx5LlxuICAgICAgICAgIC8vIFRoZXNlIGZyYW1ld29ya3Mgd2lwZSB0aGUgcGFnZSBiZXR3ZWVuIGVhY2ggbG9hZCBvZiBiYXNlLmpzLCBzbyB0aGlzXG4gICAgICAgICAgLy8gaXMgT0suXG4gICAgICAgICAgdmFyIGlzRGVwcyA9IC9cXGJkZXBzLmpzJC8udGVzdChzcmMpO1xuICAgICAgICAgIGlmIChpc0RlcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBcIicgKyBzcmMgKyAnXCIgYWZ0ZXIgZG9jdW1lbnQgbG9hZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc09sZElFID0gZ29vZy5JU19PTERfSUVfO1xuXG4gICAgICAgIGlmIChvcHRfc291cmNlVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCFpc09sZElFKSB7XG4gICAgICAgICAgICBpZiAoZ29vZy5FTkFCTEVfQ0hST01FX0FQUF9TQUZFX1NDUklQVF9MT0FESU5HKSB7XG4gICAgICAgICAgICAgIGdvb2cuYXBwZW5kU2NyaXB0U3JjTm9kZV8oc3JjKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdvb2cud3JpdGVTY3JpcHRTcmNOb2RlXyhzcmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBcIiBvbnJlYWR5c3RhdGVjaGFuZ2U9J2dvb2cub25TY3JpcHRMb2FkXyh0aGlzLCBcIiArICsrZ29vZy5sYXN0Tm9uTW9kdWxlU2NyaXB0SW5kZXhfICsgXCIpJyBcIjtcbiAgICAgICAgICAgIGRvYy53cml0ZSgnPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwiJyArIHNyYyArICdcIicgKyBzdGF0ZSArICc+PC8nICsgJ3NjcmlwdD4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jLndyaXRlKCc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIj4nICsgb3B0X3NvdXJjZVRleHQgKyAnPC8nICsgJ3NjcmlwdD4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgZ29vZy5sYXN0Tm9uTW9kdWxlU2NyaXB0SW5kZXhfID0gMDtcblxuICAgIC8qKlxuICAgICAqIEEgcmVhZHlzdGF0ZWNoYW5nZSBoYW5kbGVyIGZvciBsZWdhY3kgSUVcbiAgICAgKiBAcGFyYW0geyFIVE1MU2NyaXB0RWxlbWVudH0gc2NyaXB0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjcmlwdEluZGV4XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cub25TY3JpcHRMb2FkXyA9IGZ1bmN0aW9uIChzY3JpcHQsIHNjcmlwdEluZGV4KSB7XG4gICAgICAvLyBmb3Igbm93IGxvYWQgdGhlIG1vZHVsZXMgd2hlbiB3ZSByZWFjaCB0aGUgbGFzdCBzY3JpcHQsXG4gICAgICAvLyBsYXRlciBhbGxvdyBtb3JlIGludGVyLW1pbmdsaW5nLlxuICAgICAgaWYgKHNjcmlwdC5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScgJiYgZ29vZy5sYXN0Tm9uTW9kdWxlU2NyaXB0SW5kZXhfID09IHNjcmlwdEluZGV4KSB7XG4gICAgICAgIGdvb2cubG9hZFF1ZXVlZE1vZHVsZXNfKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgZGVwZW5kZW5jaWVzIGJhc2VkIG9uIHRoZSBkZXBlbmRlbmNpZXMgYWRkZWQgdXNpbmcgYWRkRGVwZW5kZW5jeVxuICAgICAqIGFuZCBjYWxscyBpbXBvcnRTY3JpcHRfIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoVG9Mb2FkIFRoZSBwYXRoIGZyb20gd2hpY2ggdG8gc3RhcnQgZGlzY292ZXJpbmdcbiAgICAgKiAgICAgZGVwZW5kZW5jaWVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy53cml0ZVNjcmlwdHNfID0gZnVuY3Rpb24gKHBhdGhUb0xvYWQpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59IFRoZSBzY3JpcHRzIHdlIG5lZWQgdG8gd3JpdGUgdGhpcyB0aW1lLiAqL1xuICAgICAgdmFyIHNjcmlwdHMgPSBbXTtcbiAgICAgIHZhciBzZWVuU2NyaXB0ID0ge307XG4gICAgICB2YXIgZGVwcyA9IGdvb2cuZGVwZW5kZW5jaWVzXztcblxuICAgICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICovXG4gICAgICBmdW5jdGlvbiB2aXNpdE5vZGUocGF0aCkge1xuICAgICAgICBpZiAocGF0aCBpbiBkZXBzLndyaXR0ZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBoYXZlIGFscmVhZHkgdmlzaXRlZCB0aGlzIG9uZS4gV2UgY2FuIGdldCBoZXJlIGlmIHdlIGhhdmUgY3ljbGljXG4gICAgICAgIC8vIGRlcGVuZGVuY2llcy5cbiAgICAgICAgaWYgKHBhdGggaW4gZGVwcy52aXNpdGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVwcy52aXNpdGVkW3BhdGhdID0gdHJ1ZTtcblxuICAgICAgICBpZiAocGF0aCBpbiBkZXBzLnJlcXVpcmVzKSB7XG4gICAgICAgICAgZm9yICh2YXIgcmVxdWlyZU5hbWUgaW4gZGVwcy5yZXF1aXJlc1twYXRoXSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVpcmVkIG5hbWUgaXMgZGVmaW5lZCwgd2UgYXNzdW1lIHRoYXQgaXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAgIC8vIGJvb3RzdHJhcHBlZCBieSBvdGhlciBtZWFucy5cbiAgICAgICAgICAgIGlmICghZ29vZy5pc1Byb3ZpZGVkXyhyZXF1aXJlTmFtZSkpIHtcbiAgICAgICAgICAgICAgaWYgKHJlcXVpcmVOYW1lIGluIGRlcHMubmFtZVRvUGF0aCkge1xuICAgICAgICAgICAgICAgIHZpc2l0Tm9kZShkZXBzLm5hbWVUb1BhdGhbcmVxdWlyZU5hbWVdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5kZWZpbmVkIG5hbWVUb1BhdGggZm9yICcgKyByZXF1aXJlTmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShwYXRoIGluIHNlZW5TY3JpcHQpKSB7XG4gICAgICAgICAgc2VlblNjcmlwdFtwYXRoXSA9IHRydWU7XG4gICAgICAgICAgc2NyaXB0cy5wdXNoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZpc2l0Tm9kZShwYXRoVG9Mb2FkKTtcblxuICAgICAgLy8gcmVjb3JkIHRoYXQgd2UgYXJlIGdvaW5nIHRvIGxvYWQgYWxsIHRoZXNlIHNjcmlwdHMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBhdGggPSBzY3JpcHRzW2ldO1xuICAgICAgICBnb29nLmRlcGVuZGVuY2llc18ud3JpdHRlbltwYXRoXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGEgbW9kdWxlIGlzIGxvYWRlZCBzeW5jaHJvbm91c2x5IHRoZW4gd2UgbmVlZCB0b1xuICAgICAgLy8gY2xlYXIgdGhlIGN1cnJlbnQgaW5Nb2R1bGVMb2FkZXIgdmFsdWUsIGFuZCByZXN0b3JlIGl0IHdoZW4gd2UgYXJlXG4gICAgICAvLyBkb25lIGxvYWRpbmcgdGhlIGN1cnJlbnQgXCJyZXF1aXJlc1wiLlxuICAgICAgdmFyIG1vZHVsZVN0YXRlID0gZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV87XG4gICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHNjcmlwdHNbaV07XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgaWYgKCFkZXBzLnBhdGhJc01vZHVsZVtwYXRoXSkge1xuICAgICAgICAgICAgZ29vZy5pbXBvcnRTY3JpcHRfKGdvb2cuYmFzZVBhdGggKyBwYXRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ29vZy5pbXBvcnRNb2R1bGVfKGdvb2cuYmFzZVBhdGggKyBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8gPSBtb2R1bGVTdGF0ZTtcbiAgICAgICAgICB0aHJvdyBFcnJvcignVW5kZWZpbmVkIHNjcmlwdCBpbnB1dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIGN1cnJlbnQgXCJtb2R1bGUgbG9hZGluZyBzdGF0ZVwiXG4gICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG1vZHVsZVN0YXRlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBMb29rcyBhdCB0aGUgZGVwZW5kZW5jeSBydWxlcyBhbmQgdHJpZXMgdG8gZGV0ZXJtaW5lIHRoZSBzY3JpcHQgZmlsZSB0aGF0XG4gICAgICogZnVsZmlsbHMgYSBwYXJ0aWN1bGFyIHJ1bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJ1bGUgSW4gdGhlIGZvcm0gZ29vZy5uYW1lc3BhY2UuQ2xhc3Mgb3IgcHJvamVjdC5zY3JpcHQuXG4gICAgICogQHJldHVybiB7P3N0cmluZ30gVXJsIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJ1bGUsIG9yIG51bGwuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLmdldFBhdGhGcm9tRGVwc18gPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKHJ1bGUgaW4gZ29vZy5kZXBlbmRlbmNpZXNfLm5hbWVUb1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIGdvb2cuZGVwZW5kZW5jaWVzXy5uYW1lVG9QYXRoW3J1bGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGdvb2cuZmluZEJhc2VQYXRoXygpO1xuXG4gICAgLy8gQWxsb3cgcHJvamVjdHMgdG8gbWFuYWdlIHRoZSBkZXBzIGZpbGVzIHRoZW1zZWx2ZXMuXG4gICAgaWYgKCFnb29nLmdsb2JhbC5DTE9TVVJFX05PX0RFUFMpIHtcbiAgICAgIGdvb2cuaW1wb3J0U2NyaXB0Xyhnb29nLmJhc2VQYXRoICsgJ2RlcHMuanMnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgZmlsZSBwYXRoIGJ5IHJlbW92aW5nIHJlZHVuZGFudCBcIi4uXCIgYW5kIGV4dHJhbmVvdXMgXCIuXCIgZmlsZVxuICAgKiBwYXRoIGNvbXBvbmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubm9ybWFsaXplUGF0aF8gPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBjb21wb25lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcG9uZW50c1tpXSA9PSAnLicpIHtcbiAgICAgICAgY29tcG9uZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2UgaWYgKGkgJiYgY29tcG9uZW50c1tpXSA9PSAnLi4nICYmIGNvbXBvbmVudHNbaSAtIDFdICYmIGNvbXBvbmVudHNbaSAtIDFdICE9ICcuLicpIHtcbiAgICAgICAgY29tcG9uZW50cy5zcGxpY2UoLS1pLCAyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudHMuam9pbignLycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2FkcyBmaWxlIGJ5IHN5bmNocm9ub3VzIFhIUi4gU2hvdWxkIG5vdCBiZSB1c2VkIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNvdXJjZSBVUkwuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gRmlsZSBjb250ZW50cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cubG9hZEZpbGVTeW5jXyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9MT0FEX0ZJTEVfU1lOQykge1xuICAgICAgcmV0dXJuIGdvb2cuZ2xvYmFsLkNMT1NVUkVfTE9BRF9GSUxFX1NZTkMoc3JjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtYTUxIdHRwUmVxdWVzdH0gKi9cbiAgICAgIHZhciB4aHIgPSBuZXcgZ29vZy5nbG9iYWxbJ1hNTEh0dHBSZXF1ZXN0J10oKTtcbiAgICAgIHhoci5vcGVuKCdnZXQnLCBzcmMsIGZhbHNlKTtcbiAgICAgIHhoci5zZW5kKCk7XG4gICAgICByZXR1cm4geGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIGFuZCBleGVjdXRlIGEgbW9kdWxlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFNjcmlwdCBzb3VyY2UgVVJMLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5yZXRyaWV2ZUFuZEV4ZWNNb2R1bGVfID0gZnVuY3Rpb24gKHNyYykge1xuICAgIGlmICghQ09NUElMRUQpIHtcbiAgICAgIC8vIFRoZSBmdWxsIGJ1dCBub24tY2Fub25pY2FsaXplZCBVUkwgZm9yIGxhdGVyIHVzZS5cbiAgICAgIHZhciBvcmlnaW5hbFBhdGggPSBzcmM7XG4gICAgICAvLyBDYW5vbmljYWxpemUgdGhlIHBhdGgsIHJlbW92aW5nIGFueSAvLi8gb3IgLy4uLyBzaW5jZSBDaHJvbWUncyBkZWJ1Z2dpbmdcbiAgICAgIC8vIGNvbnNvbGUgZG9lc24ndCBhdXRvLWNhbm9uaWNhbGl6ZSBYSFIgbG9hZHMgYXMgaXQgZG9lcyA8c2NyaXB0PiBzcmNzLlxuICAgICAgc3JjID0gZ29vZy5ub3JtYWxpemVQYXRoXyhzcmMpO1xuXG4gICAgICB2YXIgaW1wb3J0U2NyaXB0ID0gZ29vZy5nbG9iYWwuQ0xPU1VSRV9JTVBPUlRfU0NSSVBUIHx8IGdvb2cud3JpdGVTY3JpcHRUYWdfO1xuXG4gICAgICB2YXIgc2NyaXB0VGV4dCA9IGdvb2cubG9hZEZpbGVTeW5jXyhzcmMpO1xuXG4gICAgICBpZiAoc2NyaXB0VGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciBleGVjTW9kdWxlU2NyaXB0ID0gZ29vZy53cmFwTW9kdWxlXyhzcmMsIHNjcmlwdFRleHQpO1xuICAgICAgICB2YXIgaXNPbGRJRSA9IGdvb2cuSVNfT0xEX0lFXztcbiAgICAgICAgaWYgKGlzT2xkSUUpIHtcbiAgICAgICAgICBnb29nLmRlcGVuZGVuY2llc18uZGVmZXJyZWRbb3JpZ2luYWxQYXRoXSA9IGV4ZWNNb2R1bGVTY3JpcHQ7XG4gICAgICAgICAgZ29vZy5xdWV1ZWRNb2R1bGVzXy5wdXNoKG9yaWdpbmFsUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wb3J0U2NyaXB0KHNyYywgZXhlY01vZHVsZVNjcmlwdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9hZCBvZiAnICsgc3JjICsgJ2ZhaWxlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBMYW5ndWFnZSBFbmhhbmNlbWVudHNcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgXCJmaXhlZFwiIHZlcnNpb24gb2YgdGhlIHR5cGVvZiBvcGVyYXRvci4gIEl0IGRpZmZlcnMgZnJvbSB0aGUgdHlwZW9mXG4gICAqIG9wZXJhdG9yIGluIHN1Y2ggYSB3YXkgdGhhdCBudWxsIHJldHVybnMgJ251bGwnIGFuZCBhcnJheXMgcmV0dXJuICdhcnJheScuXG4gICAqIEBwYXJhbSB7P30gdmFsdWUgVGhlIHZhbHVlIHRvIGdldCB0aGUgdHlwZSBvZi5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgdHlwZS5cbiAgICovXG4gIGdvb2cudHlwZU9mID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbiAgICBpZiAocyA9PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZXNlIGZpcnN0LCBzbyB3ZSBjYW4gYXZvaWQgY2FsbGluZyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nIGlmXG4gICAgICAgIC8vIHBvc3NpYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBJRSBpbXByb3Blcmx5IG1hcnNoYWxzIHR5cGVvZiBhY3Jvc3MgZXhlY3V0aW9uIGNvbnRleHRzLCBidXQgYVxuICAgICAgICAvLyBjcm9zcy1jb250ZXh0IG9iamVjdCB3aWxsIHN0aWxsIHJldHVybiBmYWxzZSBmb3IgXCJpbnN0YW5jZW9mIE9iamVjdFwiLlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIQUNLOiBJbiBvcmRlciB0byB1c2UgYW4gT2JqZWN0IHByb3RvdHlwZSBtZXRob2Qgb24gdGhlIGFyYml0cmFyeVxuICAgICAgICAvLyAgIHZhbHVlLCB0aGUgY29tcGlsZXIgcmVxdWlyZXMgdGhlIHZhbHVlIGJlIGNhc3QgdG8gdHlwZSBPYmplY3QsXG4gICAgICAgIC8vICAgZXZlbiB0aG91Z2ggdGhlIEVDTUEgc3BlYyBleHBsaWNpdGx5IGFsbG93cyBpdC5cbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChcbiAgICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL3ZhbHVlKTtcbiAgICAgICAgLy8gSW4gRmlyZWZveCAzLjYsIGF0dGVtcHRpbmcgdG8gYWNjZXNzIGlmcmFtZSB3aW5kb3cgb2JqZWN0cycgbGVuZ3RoXG4gICAgICAgIC8vIHByb3BlcnR5IHRocm93cyBhbiBOU19FUlJPUl9GQUlMVVJFLCBzbyB3ZSBuZWVkIHRvIHNwZWNpYWwtY2FzZSBpdFxuICAgICAgICAvLyBoZXJlLlxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgY2Fubm90IGFsd2F5cyB1c2UgY29uc3RydWN0b3IgPT0gQXJyYXkgb3IgaW5zdGFuY2VvZiBBcnJheSBiZWNhdXNlXG4gICAgICAgIC8vIGRpZmZlcmVudCBmcmFtZXMgaGF2ZSBkaWZmZXJlbnQgQXJyYXkgb2JqZWN0cy4gSW4gSUU2LCBpZiB0aGUgaWZyYW1lXG4gICAgICAgIC8vIHdoZXJlIHRoZSBhcnJheSB3YXMgY3JlYXRlZCBpcyBkZXN0cm95ZWQsIHRoZSBhcnJheSBsb3NlcyBpdHNcbiAgICAgICAgLy8gcHJvdG90eXBlLiBUaGVuIGRlcmVmZXJlbmNpbmcgdmFsLnNwbGljZSBoZXJlIHRocm93cyBhbiBleGNlcHRpb24sIHNvXG4gICAgICAgIC8vIHdlIGNhbid0IHVzZSBnb29nLmlzRnVuY3Rpb24uIENhbGxpbmcgdHlwZW9mIGRpcmVjdGx5IHJldHVybnMgJ3Vua25vd24nXG4gICAgICAgIC8vIHNvIHRoYXQgd2lsbCB3b3JrLiBJbiB0aGlzIGNhc2UsIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UgYW5kXG4gICAgICAgIC8vIG1vc3QgYXJyYXkgZnVuY3Rpb25zIHdpbGwgc3RpbGwgd29yayBiZWNhdXNlIHRoZSBhcnJheSBpcyBzdGlsbFxuICAgICAgICAvLyBhcnJheS1saWtlIChzdXBwb3J0cyBsZW5ndGggYW5kIFtdKSBldmVuIHRob3VnaCBpdCBoYXMgbG9zdCBpdHNcbiAgICAgICAgLy8gcHJvdG90eXBlLlxuICAgICAgICAvLyBNYXJrIE1pbGxlciBub3RpY2VkIHRoYXQgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuICAgICAgICAvLyBhbGxvd3MgYWNjZXNzIHRvIHRoZSB1bmZvcmdlYWJsZSBbW0NsYXNzXV0gcHJvcGVydHkuXG4gICAgICAgIC8vICAxNS4yLjQuMiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICggKVxuICAgICAgICAvLyAgV2hlbiB0aGUgdG9TdHJpbmcgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgIC8vICAgICAgMS4gR2V0IHRoZSBbW0NsYXNzXV0gcHJvcGVydHkgb2YgdGhpcyBvYmplY3QuXG4gICAgICAgIC8vICAgICAgMi4gQ29tcHV0ZSBhIHN0cmluZyB2YWx1ZSBieSBjb25jYXRlbmF0aW5nIHRoZSB0aHJlZSBzdHJpbmdzXG4gICAgICAgIC8vICAgICAgICAgXCJbb2JqZWN0IFwiLCBSZXN1bHQoMSksIGFuZCBcIl1cIi5cbiAgICAgICAgLy8gICAgICAzLiBSZXR1cm4gUmVzdWx0KDIpLlxuICAgICAgICAvLyBhbmQgdGhpcyBiZWhhdmlvciBzdXJ2aXZlcyB0aGUgZGVzdHJ1Y3Rpb24gb2YgdGhlIGV4ZWN1dGlvbiBjb250ZXh0LlxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEFycmF5XScgfHxcbiAgICAgICAgLy8gSW4gSUUgYWxsIG5vbiB2YWx1ZSB0eXBlcyBhcmUgd3JhcHBlZCBhcyBvYmplY3RzIGFjcm9zcyB3aW5kb3dcbiAgICAgICAgLy8gYm91bmRhcmllcyAobm90IGlmcmFtZSB0aG91Z2gpIHNvIHdlIGhhdmUgdG8gZG8gb2JqZWN0IGRldGVjdGlvblxuICAgICAgICAvLyBmb3IgdGhpcyBlZGdlIGNhc2UuXG4gICAgICAgIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLnNwbGljZSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUgIT0gJ3VuZGVmaW5lZCcgJiYgIXZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdzcGxpY2UnKSkge1xuICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhBQ0s6IFRoZXJlIGlzIHN0aWxsIGFuIGFycmF5IGNhc2UgdGhhdCBmYWlscy5cbiAgICAgICAgLy8gICAgIGZ1bmN0aW9uIEFycmF5SW1wb3N0b3IoKSB7fVxuICAgICAgICAvLyAgICAgQXJyYXlJbXBvc3Rvci5wcm90b3R5cGUgPSBbXTtcbiAgICAgICAgLy8gICAgIHZhciBpbXBvc3RvciA9IG5ldyBBcnJheUltcG9zdG9yO1xuICAgICAgICAvLyB0aGlzIGNhbiBiZSBmaXhlZCBieSBnZXR0aW5nIHJpZCBvZiB0aGUgZmFzdCBwYXRoXG4gICAgICAgIC8vICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSBhbmQgc29sZWx5IHJlbHlpbmcgb25cbiAgICAgICAgLy8gKHZhbHVlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcudmFsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIC8vIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgbWFueSBtb3JlIGZ1bmN0aW9uIGNhbGxzIGFuZCBpcyBub3Qgd2FycmFudGVkXG4gICAgICAgIC8vIHVubGVzcyBjbG9zdXJlIGNvZGUgaXMgcmVjZWl2aW5nIG9iamVjdHMgZnJvbSB1bnRydXN0ZWQgc291cmNlcy5cblxuICAgICAgICAvLyBJRSBpbiBjcm9zcy13aW5kb3cgY2FsbHMgZG9lcyBub3QgY29ycmVjdGx5IG1hcnNoYWwgdGhlIGZ1bmN0aW9uIHR5cGVcbiAgICAgICAgLy8gKGl0IGFwcGVhcnMganVzdCBhcyBhbiBvYmplY3QpIHNvIHdlIGNhbm5vdCB1c2UganVzdCB0eXBlb2YgdmFsID09XG4gICAgICAgIC8vICdmdW5jdGlvbicuIEhvd2V2ZXIsIGlmIHRoZSBvYmplY3QgaGFzIGEgY2FsbCBwcm9wZXJ0eSwgaXQgaXMgYVxuICAgICAgICAvLyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8IHR5cGVvZiB2YWx1ZS5jYWxsICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWx1ZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPSAndW5kZWZpbmVkJyAmJiAhdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUoJ2NhbGwnKSkge1xuICAgICAgICAgIHJldHVybiAnZnVuY3Rpb24nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocyA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5jYWxsID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBJbiBTYWZhcmkgdHlwZW9mIG5vZGVMaXN0IHJldHVybnMgJ2Z1bmN0aW9uJywgYW5kIG9uIEZpcmVmb3ggdHlwZW9mXG4gICAgICAvLyBiZWhhdmVzIHNpbWlsYXJseSBmb3IgSFRNTHtBcHBsZXQsRW1iZWQsT2JqZWN0fSwgRWxlbWVudHMgYW5kIFJlZ0V4cHMuIFdlXG4gICAgICAvLyB3b3VsZCBsaWtlIHRvIHJldHVybiBvYmplY3QgZm9yIHRob3NlIGFuZCB3ZSBjYW4gZGV0ZWN0IGFuIGludmFsaWRcbiAgICAgIC8vIGZ1bmN0aW9uIGJ5IG1ha2luZyBzdXJlIHRoYXQgdGhlIGZ1bmN0aW9uIG9iamVjdCBoYXMgYSBjYWxsIG1ldGhvZC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG51bGwuXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgbnVsbC5cbiAgICovXG4gIGdvb2cuaXNOdWxsID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT09IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQgYW5kIG5vdCBudWxsLlxuICAgKi9cbiAgZ29vZy5pc0RlZkFuZE5vdE51bGwgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgLy8gTm90ZSB0aGF0IHVuZGVmaW5lZCA9PSBudWxsLlxuICAgIHJldHVybiB2YWwgIT0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gYXJyYXkuXG4gICAqL1xuICBnb29nLmlzQXJyYXkgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGdvb2cudHlwZU9mKHZhbCkgPT0gJ2FycmF5JztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhbiBhcnJheS4gVG8gcXVhbGlmeSBhcyBhcnJheSBsaWtlXG4gICAqIHRoZSB2YWx1ZSBuZWVkcyB0byBiZSBlaXRoZXIgYSBOb2RlTGlzdCBvciBhbiBvYmplY3Qgd2l0aCBhIE51bWJlciBsZW5ndGhcbiAgICogcHJvcGVydHkuIEFzIGEgc3BlY2lhbCBjYXNlLCBhIGZ1bmN0aW9uIHZhbHVlIGlzIG5vdCBhcnJheSBsaWtlLCBiZWNhdXNlIGl0c1xuICAgKiBsZW5ndGggcHJvcGVydHkgaXMgZml4ZWQgdG8gY29ycmVzcG9uZCB0byB0aGUgbnVtYmVyIG9mIGV4cGVjdGVkIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBhcnJheS5cbiAgICovXG4gIGdvb2cuaXNBcnJheUxpa2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHR5cGUgPSBnb29nLnR5cGVPZih2YWwpO1xuICAgIC8vIFdlIGRvIG5vdCB1c2UgZ29vZy5pc09iamVjdCBoZXJlIGluIG9yZGVyIHRvIGV4Y2x1ZGUgZnVuY3Rpb24gdmFsdWVzLlxuICAgIHJldHVybiB0eXBlID09ICdhcnJheScgfHwgdHlwZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLmxlbmd0aCA9PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgbG9va3MgbGlrZSBhIERhdGUuIFRvIHF1YWxpZnkgYXMgRGF0ZS1saWtlIHRoZVxuICAgKiB2YWx1ZSBuZWVkcyB0byBiZSBhbiBvYmplY3QgYW5kIGhhdmUgYSBnZXRGdWxsWWVhcigpIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbGlrZSBhIERhdGUuXG4gICAqL1xuICBnb29nLmlzRGF0ZUxpa2UgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGdvb2cuaXNPYmplY3QodmFsKSAmJiB0eXBlb2YgdmFsLmdldEZ1bGxZZWFyID09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgc3RyaW5nLlxuICAgKi9cbiAgZ29vZy5pc1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnc3RyaW5nJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gICAqL1xuICBnb29nLmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnYm9vbGVhbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICAgKi9cbiAgZ29vZy5pc051bWJlciA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSAnbnVtYmVyJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgZ29vZy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBnb29nLnR5cGVPZih2YWwpID09ICdmdW5jdGlvbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gIFRoaXMgaW5jbHVkZXMgYXJyYXlzIGFuZFxuICAgKiBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgZ29vZy5pc09iamVjdCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gICAgcmV0dXJuIHR5cGUgPT0gJ29iamVjdCcgJiYgdmFsICE9IG51bGwgfHwgdHlwZSA9PSAnZnVuY3Rpb24nO1xuICAgIC8vIHJldHVybiBPYmplY3QodmFsKSA9PT0gdmFsIGFsc28gd29ya3MsIGJ1dCBpcyBzbG93ZXIsIGVzcGVjaWFsbHkgaWYgdmFsIGlzXG4gICAgLy8gbm90IGFuIG9iamVjdC5cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyBhIHVuaXF1ZSBJRCBmb3IgYW4gb2JqZWN0LiBUaGlzIG11dGF0ZXMgdGhlIG9iamVjdCBzbyB0aGF0IGZ1cnRoZXIgY2FsbHNcbiAgICogd2l0aCB0aGUgc2FtZSBvYmplY3QgYXMgYSBwYXJhbWV0ZXIgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS4gVGhlIHVuaXF1ZSBJRCBpc1xuICAgKiBndWFyYW50ZWVkIHRvIGJlIHVuaXF1ZSBhY3Jvc3MgdGhlIGN1cnJlbnQgc2Vzc2lvbiBhbW9uZ3N0IG9iamVjdHMgdGhhdCBhcmVcbiAgICogcGFzc2VkIGludG8ge0Bjb2RlIGdldFVpZH0uIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBJRCBpcyB1bmlxdWUgb3JcbiAgICogY29uc2lzdGVudCBhY3Jvc3Mgc2Vzc2lvbnMuIEl0IGlzIHVuc2FmZSB0byBnZW5lcmF0ZSB1bmlxdWUgSUQgZm9yIGZ1bmN0aW9uXG4gICAqIHByb3RvdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBnZXQgdGhlIHVuaXF1ZSBJRCBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHVuaXF1ZSBJRCBmb3IgdGhlIG9iamVjdC5cbiAgICovXG4gIGdvb2cuZ2V0VWlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgIC8vIFRPRE8oYXJ2KTogTWFrZSB0aGUgdHlwZSBzdHJpY3RlciwgZG8gbm90IGFjY2VwdCBudWxsLlxuXG4gICAgLy8gSW4gT3BlcmEgd2luZG93Lmhhc093blByb3BlcnR5IGV4aXN0cyBidXQgYWx3YXlzIHJldHVybnMgZmFsc2Ugc28gd2UgYXZvaWRcbiAgICAvLyB1c2luZyBpdC4gQXMgYSBjb25zZXF1ZW5jZSB0aGUgdW5pcXVlIElEIGdlbmVyYXRlZCBmb3IgQmFzZUNsYXNzLnByb3RvdHlwZVxuICAgIC8vIGFuZCBTdWJDbGFzcy5wcm90b3R5cGUgd2lsbCBiZSB0aGUgc2FtZS5cbiAgICByZXR1cm4gb2JqW2dvb2cuVUlEX1BST1BFUlRZX10gfHwgKG9ialtnb29nLlVJRF9QUk9QRVJUWV9dID0gKytnb29nLnVpZENvdW50ZXJfKTtcbiAgfTtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFscmVhZHkgYXNzaWduZWQgYSB1bmlxdWUgSUQuXG4gICAqXG4gICAqIFRoaXMgZG9lcyBub3QgbW9kaWZ5IHRoZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlcmUgaXMgYW4gYXNzaWduZWQgdW5pcXVlIGlkIGZvciB0aGUgb2JqZWN0LlxuICAgKi9cbiAgZ29vZy5oYXNVaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqW2dvb2cuVUlEX1BST1BFUlRZX107XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHVuaXF1ZSBJRCBmcm9tIGFuIG9iamVjdC4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIG9iamVjdCB3YXNcbiAgICogcHJldmlvdXNseSBtdXRhdGVkIHVzaW5nIHtAY29kZSBnb29nLmdldFVpZH0gaW4gd2hpY2ggY2FzZSB0aGUgbXV0YXRpb24gaXNcbiAgICogdW5kb25lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmVtb3ZlIHRoZSB1bmlxdWUgSUQgZmllbGQgZnJvbS5cbiAgICovXG4gIGdvb2cucmVtb3ZlVWlkID0gZnVuY3Rpb24gKG9iaikge1xuICAgIC8vIFRPRE8oYXJ2KTogTWFrZSB0aGUgdHlwZSBzdHJpY3RlciwgZG8gbm90IGFjY2VwdCBudWxsLlxuXG4gICAgLy8gSW4gSUUsIERPTSBub2RlcyBhcmUgbm90IGluc3RhbmNlcyBvZiBPYmplY3QgYW5kIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB3ZVxuICAgIC8vIHRyeSB0byBkZWxldGUuICBJbnN0ZWFkIHdlIHRyeSB0byB1c2UgcmVtb3ZlQXR0cmlidXRlLlxuICAgIGlmIChvYmogIT09IG51bGwgJiYgJ3JlbW92ZUF0dHJpYnV0ZScgaW4gb2JqKSB7XG4gICAgICBvYmoucmVtb3ZlQXR0cmlidXRlKGdvb2cuVUlEX1BST1BFUlRZXyk7XG4gICAgfVxuICAgIC8qKiBAcHJlc2VydmVUcnkgKi9cbiAgICB0cnkge1xuICAgICAgZGVsZXRlIG9ialtnb29nLlVJRF9QUk9QRVJUWV9dO1xuICAgIH0gY2F0Y2ggKGV4KSB7fVxuICB9O1xuXG4gIC8qKlxuICAgKiBOYW1lIGZvciB1bmlxdWUgSUQgcHJvcGVydHkuIEluaXRpYWxpemVkIGluIGEgd2F5IHRvIGhlbHAgYXZvaWQgY29sbGlzaW9uc1xuICAgKiB3aXRoIG90aGVyIGNsb3N1cmUgSmF2YVNjcmlwdCBvbiB0aGUgc2FtZSBwYWdlLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5VSURfUFJPUEVSVFlfID0gJ2Nsb3N1cmVfdWlkXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbiAgLyoqXG4gICAqIENvdW50ZXIgZm9yIFVJRC5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cudWlkQ291bnRlcl8gPSAwO1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgaGFzaCBjb2RlIGZpZWxkIHRvIGFuIG9iamVjdC4gVGhlIGhhc2ggY29kZSBpcyB1bmlxdWUgZm9yIHRoZVxuICAgKiBnaXZlbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBnZXQgdGhlIGhhc2ggY29kZSBmb3IuXG4gICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhhc2ggY29kZSBmb3IgdGhlIG9iamVjdC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdvb2cuZ2V0VWlkIGluc3RlYWQuXG4gICAqL1xuICBnb29nLmdldEhhc2hDb2RlID0gZ29vZy5nZXRVaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGhhc2ggY29kZSBmaWVsZCBmcm9tIGFuIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJlbW92ZSB0aGUgZmllbGQgZnJvbS5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGdvb2cucmVtb3ZlVWlkIGluc3RlYWQuXG4gICAqL1xuICBnb29nLnJlbW92ZUhhc2hDb2RlID0gZ29vZy5yZW1vdmVVaWQ7XG5cbiAgLyoqXG4gICAqIENsb25lcyBhIHZhbHVlLiBUaGUgaW5wdXQgbWF5IGJlIGFuIE9iamVjdCwgQXJyYXksIG9yIGJhc2ljIHR5cGUuIE9iamVjdHMgYW5kXG4gICAqIGFycmF5cyB3aWxsIGJlIGNsb25lZCByZWN1cnNpdmVseS5cbiAgICpcbiAgICogV0FSTklOR1M6XG4gICAqIDxjb2RlPmdvb2cuY2xvbmVPYmplY3Q8L2NvZGU+IGRvZXMgbm90IGRldGVjdCByZWZlcmVuY2UgbG9vcHMuIE9iamVjdHMgdGhhdFxuICAgKiByZWZlciB0byB0aGVtc2VsdmVzIHdpbGwgY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgKlxuICAgKiA8Y29kZT5nb29nLmNsb25lT2JqZWN0PC9jb2RlPiBpcyB1bmF3YXJlIG9mIHVuaXF1ZSBpZGVudGlmaWVycywgYW5kIGNvcGllc1xuICAgKiBVSURzIGNyZWF0ZWQgYnkgPGNvZGU+Z2V0VWlkPC9jb2RlPiBpbnRvIGNsb25lZCByZXN1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG9iaiBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAqIEByZXR1cm4geyp9IEEgY2xvbmUgb2YgdGhlIGlucHV0IHZhbHVlLlxuICAgKiBAZGVwcmVjYXRlZCBnb29nLmNsb25lT2JqZWN0IGlzIHVuc2FmZS4gUHJlZmVyIHRoZSBnb29nLm9iamVjdCBtZXRob2RzLlxuICAgKi9cbiAgZ29vZy5jbG9uZU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgdHlwZSA9IGdvb2cudHlwZU9mKG9iaik7XG4gICAgaWYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnYXJyYXknKSB7XG4gICAgICBpZiAob2JqLmNsb25lKSB7XG4gICAgICAgIHJldHVybiBvYmouY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBjbG9uZSA9IHR5cGUgPT0gJ2FycmF5JyA/IFtdIDoge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGNsb25lW2tleV0gPSBnb29nLmNsb25lT2JqZWN0KG9ialtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBnb29nLmJpbmQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICAgKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IHNlbGZPYmogU3BlY2lmaWVzIHRoZSBvYmplY3Qgd2hpY2ggdGhpcyBzaG91bGRcbiAgICogICAgIHBvaW50IHRvIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIHJ1bi5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXJ0aWFsbHkgYXBwbGllZCB0byB0aGVcbiAgICogICAgIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHshRnVuY3Rpb259IEEgcGFydGlhbGx5LWFwcGxpZWQgZm9ybSBvZiB0aGUgZnVuY3Rpb24gYmluZCgpIHdhc1xuICAgKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAgICogQHByaXZhdGVcbiAgICogQHN1cHByZXNzIHtkZXByZWNhdGVkfSBUaGUgY29tcGlsZXIgdGhpbmtzIHRoYXQgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgaXNcbiAgICogICAgIGRlcHJlY2F0ZWQgYmVjYXVzZSBzb21lIHBlb3BsZSBoYXZlIGRlY2xhcmVkIGEgcHVyZS1KUyB2ZXJzaW9uLlxuICAgKiAgICAgT25seSB0aGUgcHVyZS1KUyB2ZXJzaW9uIGlzIHRydWx5IGRlcHJlY2F0ZWQuXG4gICAqL1xuICBnb29nLmJpbmROYXRpdmVfID0gZnVuY3Rpb24gKGZuLCBzZWxmT2JqLCB2YXJfYXJncykge1xuICAgIHJldHVybiAoLyoqIEB0eXBlIHshRnVuY3Rpb259ICovZm4uY2FsbC5hcHBseShmbi5iaW5kLCBhcmd1bWVudHMpXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQSBwdXJlLUpTIGltcGxlbWVudGF0aW9uIG9mIGdvb2cuYmluZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gc2VsZk9iaiBTcGVjaWZpZXMgdGhlIG9iamVjdCB3aGljaCB0aGlzIHNob3VsZFxuICAgKiAgICAgcG9pbnQgdG8gd2hlbiB0aGUgZnVuY3Rpb24gaXMgcnVuLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZVxuICAgKiAgICAgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gICAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5iaW5kSnNfID0gZnVuY3Rpb24gKGZuLCBzZWxmT2JqLCB2YXJfYXJncykge1xuICAgIGlmICghZm4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdmFyIGJvdW5kQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQcmVwZW5kIHRoZSBib3VuZCBhcmd1bWVudHMgdG8gdGhlIGN1cnJlbnQgYXJndW1lbnRzLlxuICAgICAgICB2YXIgbmV3QXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KG5ld0FyZ3MsIGJvdW5kQXJncyk7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShzZWxmT2JqLCBuZXdBcmdzKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShzZWxmT2JqLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBhcHBsaWVzIHRoaXMgZnVuY3Rpb24gdG8gYSBwYXJ0aWN1bGFyICd0aGlzIG9iamVjdCcgYW5kIHplcm8gb3JcbiAgICogbW9yZSBhcmd1bWVudHMuIFRoZSByZXN1bHQgaXMgYSBuZXcgZnVuY3Rpb24gd2l0aCBzb21lIGFyZ3VtZW50cyBvZiB0aGUgZmlyc3RcbiAgICogZnVuY3Rpb24gcHJlLWZpbGxlZCBhbmQgdGhlIHZhbHVlIG9mIHRoaXMgJ3ByZS1zcGVjaWZpZWQnLlxuICAgKlxuICAgKiBSZW1haW5pbmcgYXJndW1lbnRzIHNwZWNpZmllZCBhdCBjYWxsLXRpbWUgYXJlIGFwcGVuZGVkIHRvIHRoZSBwcmUtc3BlY2lmaWVkXG4gICAqIG9uZXMuXG4gICAqXG4gICAqIEFsc28gc2VlOiB7QGxpbmsgI3BhcnRpYWx9LlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogPHByZT52YXIgYmFyTWV0aEJvdW5kID0gZ29vZy5iaW5kKG15RnVuY3Rpb24sIG15T2JqLCAnYXJnMScsICdhcmcyJyk7XG4gICAqIGJhck1ldGhCb3VuZCgnYXJnMycsICdhcmc0Jyk7PC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9uKHRoaXM6VCwgLi4uKX0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gICAqIEBwYXJhbSB7VH0gc2VsZk9iaiBTcGVjaWZpZXMgdGhlIG9iamVjdCB3aGljaCB0aGlzIHNob3VsZCBwb2ludCB0byB3aGVuIHRoZVxuICAgKiAgICAgZnVuY3Rpb24gaXMgcnVuLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZVxuICAgKiAgICAgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBnb29nLmJpbmQoKSB3YXNcbiAgICogICAgIGludm9rZWQgYXMgYSBtZXRob2Qgb2YuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBzdXBwcmVzcyB7ZGVwcmVjYXRlZH0gU2VlIGFib3ZlLlxuICAgKi9cbiAgZ29vZy5iaW5kID0gZnVuY3Rpb24gKGZuLCBzZWxmT2JqLCB2YXJfYXJncykge1xuICAgIC8vIFRPRE8obmlja3NhbnRvcyk6IG5hcnJvdyB0aGUgdHlwZSBzaWduYXR1cmUuXG4gICAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kICYmXG4gICAgLy8gTk9URShuaWNrc2FudG9zKTogU29tZWJvZHkgcHVsbGVkIGJhc2UuanMgaW50byB0aGUgZGVmYXVsdCBDaHJvbWVcbiAgICAvLyBleHRlbnNpb24gZW52aXJvbm1lbnQuIFRoaXMgbWVhbnMgdGhhdCBmb3IgQ2hyb21lIGV4dGVuc2lvbnMsIHRoZXkgZ2V0XG4gICAgLy8gdGhlIGltcGxlbWVudGF0aW9uIG9mIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHRoYXQgY2FsbHMgZ29vZy5iaW5kXG4gICAgLy8gaW5zdGVhZCBvZiB0aGUgbmF0aXZlIG9uZS4gRXZlbiB3b3JzZSwgd2UgZG9uJ3Qgd2FudCB0byBpbnRyb2R1Y2UgYVxuICAgIC8vIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBnb29nLmJpbmQgYW5kIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBzb1xuICAgIC8vIHdlIGhhdmUgdG8gaGFjayB0aGlzIHRvIG1ha2Ugc3VyZSBpdCB3b3JrcyBjb3JyZWN0bHkuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKCduYXRpdmUgY29kZScpICE9IC0xKSB7XG4gICAgICBnb29nLmJpbmQgPSBnb29nLmJpbmROYXRpdmVfO1xuICAgIH0gZWxzZSB7XG4gICAgICBnb29nLmJpbmQgPSBnb29nLmJpbmRKc187XG4gICAgfVxuICAgIHJldHVybiBnb29nLmJpbmQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvKipcbiAgICogTGlrZSBnb29nLmJpbmQoKSwgZXhjZXB0IHRoYXQgYSAndGhpcyBvYmplY3QnIGlzIG5vdCByZXF1aXJlZC4gVXNlZnVsIHdoZW5cbiAgICogdGhlIHRhcmdldCBmdW5jdGlvbiBpcyBhbHJlYWR5IGJvdW5kLlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogdmFyIGcgPSBnb29nLnBhcnRpYWwoZiwgYXJnMSwgYXJnMik7XG4gICAqIGcoYXJnMywgYXJnNCk7XG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5LlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIGZuLlxuICAgKiBAcmV0dXJuIHshRnVuY3Rpb259IEEgcGFydGlhbGx5LWFwcGxpZWQgZm9ybSBvZiB0aGUgZnVuY3Rpb24gZ29vZy5wYXJ0aWFsKClcbiAgICogICAgIHdhcyBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICAgKi9cbiAgZ29vZy5wYXJ0aWFsID0gZnVuY3Rpb24gKGZuLCB2YXJfYXJncykge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2xvbmUgdGhlIGFycmF5ICh3aXRoIHNsaWNlKCkpIGFuZCBhcHBlbmQgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgIC8vIHRvIHRoZSBleGlzdGluZyBhcmd1bWVudHMuXG4gICAgICB2YXIgbmV3QXJncyA9IGFyZ3Muc2xpY2UoKTtcbiAgICAgIG5ld0FyZ3MucHVzaC5hcHBseShuZXdBcmdzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIG5ld0FyZ3MpO1xuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC4gVGhpcyBtZXRob2RcbiAgICogZG9lcyBub3Qgd29yayBvbiBhbGwgYnJvd3NlcnMgZm9yIGFsbCBvYmplY3RzIHRoYXQgY29udGFpbiBrZXlzIHN1Y2ggYXNcbiAgICogdG9TdHJpbmcgb3IgaGFzT3duUHJvcGVydHkuIFVzZSBnb29nLm9iamVjdC5leHRlbmQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlLlxuICAgKi9cbiAgZ29vZy5taXhpbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHggaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRbeF0gPSBzb3VyY2VbeF07XG4gICAgfVxuXG4gICAgLy8gRm9yIElFNyBvciBsb3dlciwgdGhlIGZvci1pbi1sb29wIGRvZXMgbm90IGNvbnRhaW4gYW55IHByb3BlcnRpZXMgdGhhdCBhcmVcbiAgICAvLyBub3QgZW51bWVyYWJsZSBvbiB0aGUgcHJvdG90eXBlIG9iamVjdCAoZm9yIGV4YW1wbGUsIGlzUHJvdG90eXBlT2YgZnJvbVxuICAgIC8vIE9iamVjdC5wcm90b3R5cGUpIGJ1dCBhbHNvIGl0IHdpbGwgbm90IGluY2x1ZGUgJ3JlcGxhY2UnIG9uIG9iamVjdHMgdGhhdFxuICAgIC8vIGV4dGVuZCBTdHJpbmcgYW5kIGNoYW5nZSAncmVwbGFjZScgKG5vdCB0aGF0IGl0IGlzIGNvbW1vbiBmb3IgYW55b25lIHRvXG4gICAgLy8gZXh0ZW5kIGFueXRoaW5nIGV4Y2VwdCBPYmplY3QpLlxuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIGludGVnZXIgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAqICAgICBiZXR3ZWVuIG1pZG5pZ2h0LCBKYW51YXJ5IDEsIDE5NzAgYW5kIHRoZSBjdXJyZW50IHRpbWUuXG4gICAqL1xuICBnb29nLm5vdyA9IGdvb2cuVFJVU1RFRF9TSVRFICYmIERhdGUubm93IHx8IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBVbmFyeSBwbHVzIG9wZXJhdG9yIGNvbnZlcnRzIGl0cyBvcGVyYW5kIHRvIGEgbnVtYmVyIHdoaWNoIGluXG4gICAgLy8gdGhlIGNhc2Ugb2ZcbiAgICAvLyBhIGRhdGUgaXMgZG9uZSBieSBjYWxsaW5nIGdldFRpbWUoKS5cbiAgICByZXR1cm4gK25ldyBEYXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWxzIEphdmFTY3JpcHQgaW4gdGhlIGdsb2JhbCBzY29wZS4gIEluIElFIHRoaXMgdXNlcyBleGVjU2NyaXB0LCBvdGhlclxuICAgKiBicm93c2VycyB1c2UgZ29vZy5nbG9iYWwuZXZhbC4gSWYgZ29vZy5nbG9iYWwuZXZhbCBkb2VzIG5vdCBldmFsdWF0ZSBpbiB0aGVcbiAgICogZ2xvYmFsIHNjb3BlIChmb3IgZXhhbXBsZSwgaW4gU2FmYXJpKSwgYXBwZW5kcyBhIHNjcmlwdCB0YWcgaW5zdGVhZC5cbiAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBuZWl0aGVyIGV4ZWNTY3JpcHQgb3IgZXZhbCBpcyBkZWZpbmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NyaXB0IEphdmFTY3JpcHQgc3RyaW5nLlxuICAgKi9cbiAgZ29vZy5nbG9iYWxFdmFsID0gZnVuY3Rpb24gKHNjcmlwdCkge1xuICAgIGlmIChnb29nLmdsb2JhbC5leGVjU2NyaXB0KSB7XG4gICAgICBnb29nLmdsb2JhbC5leGVjU2NyaXB0KHNjcmlwdCwgJ0phdmFTY3JpcHQnKTtcbiAgICB9IGVsc2UgaWYgKGdvb2cuZ2xvYmFsLmV2YWwpIHtcbiAgICAgIC8vIFRlc3QgdG8gc2VlIGlmIGV2YWwgd29ya3NcbiAgICAgIGlmIChnb29nLmV2YWxXb3Jrc0Zvckdsb2JhbHNfID09IG51bGwpIHtcbiAgICAgICAgZ29vZy5nbG9iYWwuZXZhbCgndmFyIF9ldmFsVGVzdF8gPSAxOycpO1xuICAgICAgICBpZiAodHlwZW9mIGdvb2cuZ2xvYmFsWydfZXZhbFRlc3RfJ10gIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIGdvb2cuZ2xvYmFsWydfZXZhbFRlc3RfJ107XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7XG4gICAgICAgICAgICAvLyBNaWNyb3NvZnQgZWRnZSBmYWlscyB0aGUgZGVsZXRpb24gYWJvdmUgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgfVxuICAgICAgICAgIGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXykge1xuICAgICAgICBnb29nLmdsb2JhbC5ldmFsKHNjcmlwdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgICB2YXIgZG9jID0gZ29vZy5nbG9iYWwuZG9jdW1lbnQ7XG4gICAgICAgIHZhciBzY3JpcHRFbHQgPVxuICAgICAgICAvKiogQHR5cGUgeyFIVE1MU2NyaXB0RWxlbWVudH0gKi9kb2MuY3JlYXRlRWxlbWVudCgnU0NSSVBUJyk7XG4gICAgICAgIHNjcmlwdEVsdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgICAgIHNjcmlwdEVsdC5kZWZlciA9IGZhbHNlO1xuICAgICAgICAvLyBOb3RlKHVzZXIpOiBjYW4ndCB1c2UgLmlubmVySFRNTCBzaW5jZSBcInQoJzx0ZXN0PicpXCIgd2lsbCBmYWlsIGFuZFxuICAgICAgICAvLyAudGV4dCBkb2Vzbid0IHdvcmsgaW4gU2FmYXJpIDIuICBUaGVyZWZvcmUgd2UgYXBwZW5kIGEgdGV4dCBub2RlLlxuICAgICAgICBzY3JpcHRFbHQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHNjcmlwdCkpO1xuICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRFbHQpO1xuICAgICAgICBkb2MuYm9keS5yZW1vdmVDaGlsZChzY3JpcHRFbHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignZ29vZy5nbG9iYWxFdmFsIG5vdCBhdmFpbGFibGUnKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB3ZSBjYW4gY2FsbCAnZXZhbCcgZGlyZWN0bHkgdG8gZXZhbCBjb2RlIGluIHRoZVxuICAgKiBnbG9iYWwgc2NvcGUuIFNldCB0byBhIEJvb2xlYW4gYnkgdGhlIGZpcnN0IGNhbGwgdG8gZ29vZy5nbG9iYWxFdmFsICh3aGljaFxuICAgKiBlbXBpcmljYWxseSB0ZXN0cyB3aGV0aGVyIGV2YWwgd29ya3MgZm9yIGdsb2JhbHMpLiBAc2VlIGdvb2cuZ2xvYmFsRXZhbFxuICAgKiBAdHlwZSB7P2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmV2YWxXb3Jrc0Zvckdsb2JhbHNfID0gbnVsbDtcblxuICAvKipcbiAgICogT3B0aW9uYWwgbWFwIG9mIENTUyBjbGFzcyBuYW1lcyB0byBvYmZ1c2NhdGVkIG5hbWVzIHVzZWQgd2l0aFxuICAgKiBnb29nLmdldENzc05hbWUoKS5cbiAgICogQHByaXZhdGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fHVuZGVmaW5lZH1cbiAgICogQHNlZSBnb29nLnNldENzc05hbWVNYXBwaW5nXG4gICAqL1xuICBnb29nLmNzc05hbWVNYXBwaW5nXztcblxuICAvKipcbiAgICogT3B0aW9uYWwgb2JmdXNjYXRpb24gc3R5bGUgZm9yIENTUyBjbGFzcyBuYW1lcy4gU2hvdWxkIGJlIHNldCB0byBlaXRoZXJcbiAgICogJ0JZX1dIT0xFJyBvciAnQllfUEFSVCcgaWYgZGVmaW5lZC5cbiAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqIEBzZWUgZ29vZy5zZXRDc3NOYW1lTWFwcGluZ1xuICAgKi9cbiAgZ29vZy5jc3NOYW1lTWFwcGluZ1N0eWxlXztcblxuICAvKipcbiAgICogSGFuZGxlcyBzdHJpbmdzIHRoYXQgYXJlIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgQ1NTIGNsYXNzIG5hbWVzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGluIHRhbmRlbSB3aXRoIEBzZWUgZ29vZy5zZXRDc3NOYW1lTWFwcGluZy5cbiAgICpcbiAgICogV2l0aG91dCBhbnkgbWFwcGluZyBzZXQsIHRoZSBhcmd1bWVudHMgYXJlIHNpbXBsZSBqb2luZWQgd2l0aCBhIGh5cGhlbiBhbmRcbiAgICogcGFzc2VkIHRocm91Z2ggdW5hbHRlcmVkLlxuICAgKlxuICAgKiBXaGVuIHRoZXJlIGlzIGEgbWFwcGluZywgdGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzdHlsZXMgaW4gd2hpY2ggdGhlc2VcbiAgICogbWFwcGluZ3MgYXJlIHVzZWQuIEluIHRoZSBCWV9QQVJUIHN0eWxlLCBlYWNoIHBhcnQgKGkuZS4gaW4gYmV0d2VlbiBoeXBoZW5zKVxuICAgKiBvZiB0aGUgcGFzc2VkIGluIGNzcyBuYW1lIGlzIHJld3JpdHRlbiBhY2NvcmRpbmcgdG8gdGhlIG1hcC4gSW4gdGhlIEJZX1dIT0xFXG4gICAqIHN0eWxlLCB0aGUgZnVsbCBjc3MgbmFtZSBpcyBsb29rZWQgdXAgaW4gdGhlIG1hcCBkaXJlY3RseS4gSWYgYSByZXdyaXRlIGlzXG4gICAqIG5vdCBzcGVjaWZpZWQgYnkgdGhlIG1hcCwgdGhlIGNvbXBpbGVyIHdpbGwgb3V0cHV0IGEgd2FybmluZy5cbiAgICpcbiAgICogV2hlbiB0aGUgbWFwcGluZyBpcyBwYXNzZWQgdG8gdGhlIGNvbXBpbGVyLCBpdCB3aWxsIHJlcGxhY2UgY2FsbHMgdG9cbiAgICogZ29vZy5nZXRDc3NOYW1lIHdpdGggdGhlIHN0cmluZ3MgZnJvbSB0aGUgbWFwcGluZywgZS5nLlxuICAgKiAgICAgdmFyIHggPSBnb29nLmdldENzc05hbWUoJ2ZvbycpO1xuICAgKiAgICAgdmFyIHkgPSBnb29nLmdldENzc05hbWUodGhpcy5iYXNlQ2xhc3MsICdhY3RpdmUnKTtcbiAgICogIGJlY29tZXM6XG4gICAqICAgICB2YXIgeCA9ICdmb28nO1xuICAgKiAgICAgdmFyIHkgPSB0aGlzLmJhc2VDbGFzcyArICctYWN0aXZlJztcbiAgICpcbiAgICogSWYgb25lIGFyZ3VtZW50IGlzIHBhc3NlZCBpdCB3aWxsIGJlIHByb2Nlc3NlZCwgaWYgdHdvIGFyZSBwYXNzZWQgb25seSB0aGVcbiAgICogbW9kaWZpZXIgd2lsbCBiZSBwcm9jZXNzZWQsIGFzIGl0IGlzIGFzc3VtZWQgdGhlIGZpcnN0IGFyZ3VtZW50IHdhcyBnZW5lcmF0ZWRcbiAgICogYXMgYSByZXN1bHQgb2YgY2FsbGluZyBnb29nLmdldENzc05hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21vZGlmaWVyIEEgbW9kaWZpZXIgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIGNsYXNzIG5hbWUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNsYXNzIG5hbWUgb3IgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGNsYXNzIG5hbWUgYW5kXG4gICAqICAgICB0aGUgbW9kaWZpZXIuXG4gICAqL1xuICBnb29nLmdldENzc05hbWUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBvcHRfbW9kaWZpZXIpIHtcbiAgICB2YXIgZ2V0TWFwcGluZyA9IGZ1bmN0aW9uIGdldE1hcHBpbmcoY3NzTmFtZSkge1xuICAgICAgcmV0dXJuIGdvb2cuY3NzTmFtZU1hcHBpbmdfW2Nzc05hbWVdIHx8IGNzc05hbWU7XG4gICAgfTtcblxuICAgIHZhciByZW5hbWVCeVBhcnRzID0gZnVuY3Rpb24gcmVuYW1lQnlQYXJ0cyhjc3NOYW1lKSB7XG4gICAgICAvLyBSZW1hcCBhbGwgdGhlIHBhcnRzIGluZGl2aWR1YWxseS5cbiAgICAgIHZhciBwYXJ0cyA9IGNzc05hbWUuc3BsaXQoJy0nKTtcbiAgICAgIHZhciBtYXBwZWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFwcGVkLnB1c2goZ2V0TWFwcGluZyhwYXJ0c1tpXSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcHBlZC5qb2luKCctJyk7XG4gICAgfTtcblxuICAgIHZhciByZW5hbWU7XG4gICAgaWYgKGdvb2cuY3NzTmFtZU1hcHBpbmdfKSB7XG4gICAgICByZW5hbWUgPSBnb29nLmNzc05hbWVNYXBwaW5nU3R5bGVfID09ICdCWV9XSE9MRScgPyBnZXRNYXBwaW5nIDogcmVuYW1lQnlQYXJ0cztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVuYW1lID0gZnVuY3Rpb24gcmVuYW1lKGEpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChvcHRfbW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBjbGFzc05hbWUgKyAnLScgKyByZW5hbWUob3B0X21vZGlmaWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlbmFtZShjbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0aGUgbWFwIHRvIGNoZWNrIHdoZW4gcmV0dXJuaW5nIGEgdmFsdWUgZnJvbSBnb29nLmdldENzc05hbWUoKS4gRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogZ29vZy5zZXRDc3NOYW1lTWFwcGluZyh7XG4gICAqICAgXCJnb29nXCI6IFwiYVwiLFxuICAgKiAgIFwiZGlzYWJsZWRcIjogXCJiXCIsXG4gICAqIH0pO1xuICAgKlxuICAgKiB2YXIgeCA9IGdvb2cuZ2V0Q3NzTmFtZSgnZ29vZycpO1xuICAgKiAvLyBUaGUgZm9sbG93aW5nIGV2YWx1YXRlcyB0bzogXCJhIGEtYlwiLlxuICAgKiBnb29nLmdldENzc05hbWUoJ2dvb2cnKSArICcgJyArIGdvb2cuZ2V0Q3NzTmFtZSh4LCAnZGlzYWJsZWQnKVxuICAgKiA8L3ByZT5cbiAgICogV2hlbiBkZWNsYXJlZCBhcyBhIG1hcCBvZiBzdHJpbmcgbGl0ZXJhbHMgdG8gc3RyaW5nIGxpdGVyYWxzLCB0aGUgSlNDb21waWxlclxuICAgKiB3aWxsIHJlcGxhY2UgYWxsIGNhbGxzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpIHVzaW5nIHRoZSBzdXBwbGllZCBtYXAgaWYgdGhlXG4gICAqIC0tcHJvY2Vzc19jbG9zdXJlX3ByaW1pdGl2ZXMgZmxhZyBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gbWFwcGluZyBBIG1hcCBvZiBzdHJpbmdzIHRvIHN0cmluZ3Mgd2hlcmUga2V5cyBhcmUgcG9zc2libGVcbiAgICogICAgIGFyZ3VtZW50cyB0byBnb29nLmdldENzc05hbWUoKSBhbmQgdmFsdWVzIGFyZSB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXNcbiAgICogICAgIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdHlsZSBUaGUgc3R5bGUgb2YgY3NzIG5hbWUgbWFwcGluZy4gVGhlcmUgYXJlIHR3byB2YWxpZFxuICAgKiAgICAgb3B0aW9uczogJ0JZX1BBUlQnLCBhbmQgJ0JZX1dIT0xFJy5cbiAgICogQHNlZSBnb29nLmdldENzc05hbWUgZm9yIGEgZGVzY3JpcHRpb24uXG4gICAqL1xuICBnb29nLnNldENzc05hbWVNYXBwaW5nID0gZnVuY3Rpb24gKG1hcHBpbmcsIG9wdF9zdHlsZSkge1xuICAgIGdvb2cuY3NzTmFtZU1hcHBpbmdfID0gbWFwcGluZztcbiAgICBnb29nLmNzc05hbWVNYXBwaW5nU3R5bGVfID0gb3B0X3N0eWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUbyB1c2UgQ1NTIHJlbmFtaW5nIGluIGNvbXBpbGVkIG1vZGUsIG9uZSBvZiB0aGUgaW5wdXQgZmlsZXMgc2hvdWxkIGhhdmUgYVxuICAgKiBjYWxsIHRvIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcoKSB3aXRoIGFuIG9iamVjdCBsaXRlcmFsIHRoYXQgdGhlIEpTQ29tcGlsZXJcbiAgICogY2FuIGV4dHJhY3QgYW5kIHVzZSB0byByZXBsYWNlIGFsbCBjYWxscyB0byBnb29nLmdldENzc05hbWUoKS4gSW4gdW5jb21waWxlZFxuICAgKiBtb2RlLCBKYXZhU2NyaXB0IGNvZGUgc2hvdWxkIGJlIGxvYWRlZCBiZWZvcmUgdGhpcyBiYXNlLmpzIGZpbGUgdGhhdCBkZWNsYXJlc1xuICAgKiBhIGdsb2JhbCB2YXJpYWJsZSwgQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HLCB3aGljaCBpcyB1c2VkIGJlbG93LiBUaGlzIGlzXG4gICAqIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXBwaW5nIGlzIGxvYWRlZCBiZWZvcmUgYW55IGNhbGxzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpXG4gICAqIGFyZSBtYWRlIGluIHVuY29tcGlsZWQgbW9kZS5cbiAgICpcbiAgICogQSBob29rIGZvciBvdmVycmlkaW5nIHRoZSBDU1MgbmFtZSBtYXBwaW5nLlxuICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz58dW5kZWZpbmVkfVxuICAgKi9cbiAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HO1xuXG4gIGlmICghQ09NUElMRUQgJiYgZ29vZy5nbG9iYWwuQ0xPU1VSRV9DU1NfTkFNRV9NQVBQSU5HKSB7XG4gICAgLy8gVGhpcyBkb2VzIG5vdCBjYWxsIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcoKSBiZWNhdXNlIHRoZSBKU0NvbXBpbGVyXG4gICAgLy8gcmVxdWlyZXMgdGhhdCBnb29nLnNldENzc05hbWVNYXBwaW5nKCkgYmUgY2FsbGVkIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgZ29vZy5jc3NOYW1lTWFwcGluZ18gPSBnb29nLmdsb2JhbC5DTE9TVVJFX0NTU19OQU1FX01BUFBJTkc7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGxvY2FsaXplZCBtZXNzYWdlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGEgY29tcGlsZXIgcHJpbWl0aXZlLiBJZiB5b3UgZ2l2ZSB0aGUgY29tcGlsZXIgYSBsb2NhbGl6ZWRcbiAgICogbWVzc2FnZSBidW5kbGUsIGl0IHdpbGwgcmVwbGFjZSB0aGUgc3RyaW5nIGF0IGNvbXBpbGUtdGltZSB3aXRoIGEgbG9jYWxpemVkXG4gICAqIHZlcnNpb24sIGFuZCBleHBhbmQgZ29vZy5nZXRNc2cgY2FsbCB0byBhIGNvbmNhdGVuYXRlZCBzdHJpbmcuXG4gICAqXG4gICAqIE1lc3NhZ2VzIG11c3QgYmUgaW5pdGlhbGl6ZWQgaW4gdGhlIGZvcm06XG4gICAqIDxjb2RlPlxuICAgKiB2YXIgTVNHX05BTUUgPSBnb29nLmdldE1zZygnSGVsbG8geyRwbGFjZWhvbGRlcn0nLCB7J3BsYWNlaG9sZGVyJzogJ3dvcmxkJ30pO1xuICAgKiA8L2NvZGU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVHJhbnNsYXRhYmxlIHN0cmluZywgcGxhY2VzIGhvbGRlcnMgaW4gdGhlIGZvcm0geyRmb299LlxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz49fSBvcHRfdmFsdWVzIE1hcHMgcGxhY2UgaG9sZGVyIG5hbWUgdG8gdmFsdWUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gbWVzc2FnZSB3aXRoIHBsYWNlaG9sZGVycyBmaWxsZWQuXG4gICAqL1xuICBnb29nLmdldE1zZyA9IGZ1bmN0aW9uIChzdHIsIG9wdF92YWx1ZXMpIHtcbiAgICBpZiAob3B0X3ZhbHVlcykge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1xce1xcJChbXn1dKyl9L2csIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICAgIHJldHVybiBvcHRfdmFsdWVzICE9IG51bGwgJiYga2V5IGluIG9wdF92YWx1ZXMgPyBvcHRfdmFsdWVzW2tleV0gOiBtYXRjaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgbG9jYWxpemVkIG1lc3NhZ2UuIElmIHRoZSBtZXNzYWdlIGRvZXMgbm90IGhhdmUgYSB0cmFuc2xhdGlvbiwgZ2l2ZXMgYVxuICAgKiBmYWxsYmFjayBtZXNzYWdlLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGludHJvZHVjaW5nIGEgbmV3IG1lc3NhZ2UgdGhhdCBoYXMgbm90IHlldCBiZWVuXG4gICAqIHRyYW5zbGF0ZWQgaW50byBhbGwgbGFuZ3VhZ2VzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGEgY29tcGlsZXIgcHJpbWl0aXZlLiBNdXN0IGJlIHVzZWQgaW4gdGhlIGZvcm06XG4gICAqIDxjb2RlPnZhciB4ID0gZ29vZy5nZXRNc2dXaXRoRmFsbGJhY2soTVNHX0EsIE1TR19CKTs8L2NvZGU+XG4gICAqIHdoZXJlIE1TR19BIGFuZCBNU0dfQiB3ZXJlIGluaXRpYWxpemVkIHdpdGggZ29vZy5nZXRNc2cuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhIFRoZSBwcmVmZXJyZWQgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGIgVGhlIGZhbGxiYWNrIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJlc3QgdHJhbnNsYXRlZCBtZXNzYWdlLlxuICAgKi9cbiAgZ29vZy5nZXRNc2dXaXRoRmFsbGJhY2sgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBvc2VzIGFuIHVub2JmdXNjYXRlZCBnbG9iYWwgbmFtZXNwYWNlIHBhdGggZm9yIHRoZSBnaXZlbiBvYmplY3QuXG4gICAqIE5vdGUgdGhhdCBmaWVsZHMgb2YgdGhlIGV4cG9ydGVkIG9iamVjdCAqd2lsbCogYmUgb2JmdXNjYXRlZCwgdW5sZXNzIHRoZXkgYXJlXG4gICAqIGV4cG9ydGVkIGluIHR1cm4gdmlhIHRoaXMgZnVuY3Rpb24gb3IgZ29vZy5leHBvcnRQcm9wZXJ0eS5cbiAgICpcbiAgICogQWxzbyBoYW5keSBmb3IgbWFraW5nIHB1YmxpYyBpdGVtcyB0aGF0IGFyZSBkZWZpbmVkIGluIGFub255bW91cyBjbG9zdXJlcy5cbiAgICpcbiAgICogZXguIGdvb2cuZXhwb3J0U3ltYm9sKCdwdWJsaWMucGF0aC5Gb28nLCBGb28pO1xuICAgKlxuICAgKiBleC4gZ29vZy5leHBvcnRTeW1ib2woJ3B1YmxpYy5wYXRoLkZvby5zdGF0aWNGdW5jdGlvbicsIEZvby5zdGF0aWNGdW5jdGlvbik7XG4gICAqICAgICBwdWJsaWMucGF0aC5Gb28uc3RhdGljRnVuY3Rpb24oKTtcbiAgICpcbiAgICogZXguIGdvb2cuZXhwb3J0U3ltYm9sKCdwdWJsaWMucGF0aC5Gb28ucHJvdG90eXBlLm15TWV0aG9kJyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgIEZvby5wcm90b3R5cGUubXlNZXRob2QpO1xuICAgKiAgICAgbmV3IHB1YmxpYy5wYXRoLkZvbygpLm15TWV0aG9kKCk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwdWJsaWNQYXRoIFVub2JmdXNjYXRlZCBuYW1lIHRvIGV4cG9ydC5cbiAgICogQHBhcmFtIHsqfSBvYmplY3QgT2JqZWN0IHRoZSBuYW1lIHNob3VsZCBwb2ludCB0by5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0VG9FeHBvcnRUbyBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgcGF0aCB0bzsgZGVmYXVsdFxuICAgKiAgICAgaXMgZ29vZy5nbG9iYWwuXG4gICAqL1xuICBnb29nLmV4cG9ydFN5bWJvbCA9IGZ1bmN0aW9uIChwdWJsaWNQYXRoLCBvYmplY3QsIG9wdF9vYmplY3RUb0V4cG9ydFRvKSB7XG4gICAgZ29vZy5leHBvcnRQYXRoXyhwdWJsaWNQYXRoLCBvYmplY3QsIG9wdF9vYmplY3RUb0V4cG9ydFRvKTtcbiAgfTtcblxuICAvKipcbiAgICogRXhwb3J0cyBhIHByb3BlcnR5IHVub2JmdXNjYXRlZCBpbnRvIHRoZSBvYmplY3QncyBuYW1lc3BhY2UuXG4gICAqIGV4LiBnb29nLmV4cG9ydFByb3BlcnR5KEZvbywgJ3N0YXRpY0Z1bmN0aW9uJywgRm9vLnN0YXRpY0Z1bmN0aW9uKTtcbiAgICogZXguIGdvb2cuZXhwb3J0UHJvcGVydHkoRm9vLnByb3RvdHlwZSwgJ215TWV0aG9kJywgRm9vLnByb3RvdHlwZS5teU1ldGhvZCk7XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgT2JqZWN0IHdob3NlIHN0YXRpYyBwcm9wZXJ0eSBpcyBiZWluZyBleHBvcnRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY05hbWUgVW5vYmZ1c2NhdGVkIG5hbWUgdG8gZXhwb3J0LlxuICAgKiBAcGFyYW0geyp9IHN5bWJvbCBPYmplY3QgdGhlIG5hbWUgc2hvdWxkIHBvaW50IHRvLlxuICAgKi9cbiAgZ29vZy5leHBvcnRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIHB1YmxpY05hbWUsIHN5bWJvbCkge1xuICAgIG9iamVjdFtwdWJsaWNOYW1lXSA9IHN5bWJvbDtcbiAgfTtcblxuICAvKipcbiAgICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICAgKlxuICAgKiBVc2FnZTpcbiAgICogPHByZT5cbiAgICogZnVuY3Rpb24gUGFyZW50Q2xhc3MoYSwgYikgeyB9XG4gICAqIFBhcmVudENsYXNzLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbihhKSB7IH07XG4gICAqXG4gICAqIGZ1bmN0aW9uIENoaWxkQ2xhc3MoYSwgYiwgYykge1xuICAgKiAgIENoaWxkQ2xhc3MuYmFzZSh0aGlzLCAnY29uc3RydWN0b3InLCBhLCBiKTtcbiAgICogfVxuICAgKiBnb29nLmluaGVyaXRzKENoaWxkQ2xhc3MsIFBhcmVudENsYXNzKTtcbiAgICpcbiAgICogdmFyIGNoaWxkID0gbmV3IENoaWxkQ2xhc3MoJ2EnLCAnYicsICdzZWUnKTtcbiAgICogY2hpbGQuZm9vKCk7IC8vIFRoaXMgd29ya3MuXG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2hpbGRDdG9yIENoaWxkIGNsYXNzLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gcGFyZW50Q3RvciBQYXJlbnQgY2xhc3MuXG4gICAqL1xuICBnb29nLmluaGVyaXRzID0gZnVuY3Rpb24gKGNoaWxkQ3RvciwgcGFyZW50Q3Rvcikge1xuICAgIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgICBmdW5jdGlvbiB0ZW1wQ3RvcigpIHt9XG4gICAgdGVtcEN0b3IucHJvdG90eXBlID0gcGFyZW50Q3Rvci5wcm90b3R5cGU7XG4gICAgY2hpbGRDdG9yLnN1cGVyQ2xhc3NfID0gcGFyZW50Q3Rvci5wcm90b3R5cGU7XG4gICAgY2hpbGRDdG9yLnByb3RvdHlwZSA9IG5ldyB0ZW1wQ3RvcigpO1xuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBjaGlsZEN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2hpbGRDdG9yO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgc3VwZXJjbGFzcyBjb25zdHJ1Y3Rvci9tZXRob2QuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgYXZhaWxhYmxlIGlmIHlvdSB1c2UgZ29vZy5pbmhlcml0cyB0b1xuICAgICAqIGV4cHJlc3MgaW5oZXJpdGFuY2UgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGdvb2cuYmFzZSBhbmQgZm9yIHN1cGVyQ2xhc3NfXG4gICAgICogcHJvcGVydHkgZGVmaW5lZCBpbiBjaGlsZEN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG1lIFNob3VsZCBhbHdheXMgYmUgXCJ0aGlzXCIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIHRvIGNhbGwuIENhbGxpbmdcbiAgICAgKiAgICAgc3VwZXJjbGFzcyBjb25zdHJ1Y3RvciBjYW4gYmUgZG9uZSB3aXRoIHRoZSBzcGVjaWFsIHN0cmluZ1xuICAgICAqICAgICAnY29uc3RydWN0b3InLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHN1cGVyY2xhc3NcbiAgICAgKiAgICAgbWV0aG9kL2NvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kL2NvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNoaWxkQ3Rvci5iYXNlID0gZnVuY3Rpb24gKG1lLCBtZXRob2ROYW1lLCB2YXJfYXJncykge1xuICAgICAgLy8gQ29weWluZyB1c2luZyBsb29wIHRvIGF2b2lkIGRlb3AgZHVlIHRvIHBhc3NpbmcgYXJndW1lbnRzIG9iamVjdCB0b1xuICAgICAgLy8gZnVuY3Rpb24uIFRoaXMgaXMgZmFzdGVyIGluIG1hbnkgSlMgZW5naW5lcyBhcyBvZiBsYXRlIDIwMTQuXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMik7XG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2kgLSAyXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRDdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXS5hcHBseShtZSwgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbCB1cCB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICpcbiAgICogSWYgdGhpcyBpcyBjYWxsZWQgZnJvbSBhIGNvbnN0cnVjdG9yLCB0aGVuIHRoaXMgY2FsbHMgdGhlIHN1cGVyY2xhc3NcbiAgICogY29uc3RydWN0b3Igd2l0aCBhcmd1bWVudHMgMS1OLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGNhbGxlZCBmcm9tIGEgcHJvdG90eXBlIG1ldGhvZCwgdGhlbiB5b3UgbXVzdCBwYXNzIHRoZSBuYW1lIG9mIHRoZVxuICAgKiBtZXRob2QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uLiBJZiB5b3UgZG8gbm90LCB5b3Ugd2lsbCBnZXQgYVxuICAgKiBydW50aW1lIGVycm9yLiBUaGlzIGNhbGxzIHRoZSBzdXBlcmNsYXNzJyBtZXRob2Qgd2l0aCBhcmd1bWVudHMgMi1OLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG9ubHkgd29ya3MgaWYgeW91IHVzZSBnb29nLmluaGVyaXRzIHRvIGV4cHJlc3MgaW5oZXJpdGFuY2VcbiAgICogcmVsYXRpb25zaGlwcyBiZXR3ZWVuIHlvdXIgY2xhc3Nlcy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBhIGNvbXBpbGVyIHByaW1pdGl2ZS4gQXQgY29tcGlsZS10aW1lLCB0aGUgY29tcGlsZXIgd2lsbCBkb1xuICAgKiBtYWNybyBleHBhbnNpb24gdG8gcmVtb3ZlIGEgbG90IG9mIHRoZSBleHRyYSBvdmVyaGVhZCB0aGF0IHRoaXMgZnVuY3Rpb25cbiAgICogaW50cm9kdWNlcy4gVGhlIGNvbXBpbGVyIHdpbGwgYWxzbyBlbmZvcmNlIGEgbG90IG9mIHRoZSBhc3N1bXB0aW9ucyB0aGF0IHRoaXNcbiAgICogZnVuY3Rpb24gbWFrZXMsIGFuZCB0cmVhdCBpdCBhcyBhIGNvbXBpbGVyIGVycm9yIGlmIHlvdSBicmVhayB0aGVtLlxuICAgKlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG1lIFNob3VsZCBhbHdheXMgYmUgXCJ0aGlzXCIuXG4gICAqIEBwYXJhbSB7Kj19IG9wdF9tZXRob2ROYW1lIFRoZSBtZXRob2QgbmFtZSBpZiBjYWxsaW5nIGEgc3VwZXIgbWV0aG9kLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSByZXN0IG9mIHRoZSBhcmd1bWVudHMuXG4gICAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHN1cGVyY2xhc3MgbWV0aG9kLlxuICAgKiBAc3VwcHJlc3Mge2VzNVN0cmljdH0gVGhpcyBtZXRob2QgY2FuIG5vdCBiZSB1c2VkIGluIHN0cmljdCBtb2RlLCBidXRcbiAgICogICAgIGFsbCBDbG9zdXJlIExpYnJhcnkgY29uc3VtZXJzIG11c3QgZGVwZW5kIG9uIHRoaXMgZmlsZS5cbiAgICovXG4gIGdvb2cuYmFzZSA9IGZ1bmN0aW9uIChtZSwgb3B0X21ldGhvZE5hbWUsIHZhcl9hcmdzKSB7XG4gICAgdmFyIGNhbGxlciA9IGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyO1xuXG4gICAgaWYgKGdvb2cuU1RSSUNUX01PREVfQ09NUEFUSUJMRSB8fCBnb29nLkRFQlVHICYmICFjYWxsZXIpIHtcbiAgICAgIHRocm93IEVycm9yKCdhcmd1bWVudHMuY2FsbGVyIG5vdCBkZWZpbmVkLiAgZ29vZy5iYXNlKCkgY2Fubm90IGJlIHVzZWQgJyArICd3aXRoIHN0cmljdCBtb2RlIGNvZGUuIFNlZSAnICsgJ2h0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy1DJyk7XG4gICAgfVxuXG4gICAgaWYgKGNhbGxlci5zdXBlckNsYXNzXykge1xuICAgICAgLy8gQ29weWluZyB1c2luZyBsb29wIHRvIGF2b2lkIGRlb3AgZHVlIHRvIHBhc3NpbmcgYXJndW1lbnRzIG9iamVjdCB0b1xuICAgICAgLy8gZnVuY3Rpb24uIFRoaXMgaXMgZmFzdGVyIGluIG1hbnkgSlMgZW5naW5lcyBhcyBvZiBsYXRlIDIwMTQuXG4gICAgICB2YXIgY3RvckFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3RvckFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yLiBDYWxsIHRoZSBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yLlxuICAgICAgcmV0dXJuIGNhbGxlci5zdXBlckNsYXNzXy5jb25zdHJ1Y3Rvci5hcHBseShtZSwgY3RvckFyZ3MpO1xuICAgIH1cblxuICAgIC8vIENvcHlpbmcgdXNpbmcgbG9vcCB0byBhdm9pZCBkZW9wIGR1ZSB0byBwYXNzaW5nIGFyZ3VtZW50cyBvYmplY3QgdG9cbiAgICAvLyBmdW5jdGlvbi4gVGhpcyBpcyBmYXN0ZXIgaW4gbWFueSBKUyBlbmdpbmVzIGFzIG9mIGxhdGUgMjAxNC5cbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMik7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDJdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICB2YXIgZm91bmRDYWxsZXIgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBjdG9yID0gbWUuY29uc3RydWN0b3I7IGN0b3I7IGN0b3IgPSBjdG9yLnN1cGVyQ2xhc3NfICYmIGN0b3Iuc3VwZXJDbGFzc18uY29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChjdG9yLnByb3RvdHlwZVtvcHRfbWV0aG9kTmFtZV0gPT09IGNhbGxlcikge1xuICAgICAgICBmb3VuZENhbGxlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGZvdW5kQ2FsbGVyKSB7XG4gICAgICAgIHJldHVybiBjdG9yLnByb3RvdHlwZVtvcHRfbWV0aG9kTmFtZV0uYXBwbHkobWUsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGRpZCBub3QgZmluZCB0aGUgY2FsbGVyIGluIHRoZSBwcm90b3R5cGUgY2hhaW4sIHRoZW4gb25lIG9mIHR3b1xuICAgIC8vIHRoaW5ncyBoYXBwZW5lZDpcbiAgICAvLyAxKSBUaGUgY2FsbGVyIGlzIGFuIGluc3RhbmNlIG1ldGhvZC5cbiAgICAvLyAyKSBUaGlzIG1ldGhvZCB3YXMgbm90IGNhbGxlZCBieSB0aGUgcmlnaHQgY2FsbGVyLlxuICAgIGlmIChtZVtvcHRfbWV0aG9kTmFtZV0gPT09IGNhbGxlcikge1xuICAgICAgcmV0dXJuIG1lLmNvbnN0cnVjdG9yLnByb3RvdHlwZVtvcHRfbWV0aG9kTmFtZV0uYXBwbHkobWUsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignZ29vZy5iYXNlIGNhbGxlZCBmcm9tIGEgbWV0aG9kIG9mIG9uZSBuYW1lICcgKyAndG8gYSBtZXRob2Qgb2YgYSBkaWZmZXJlbnQgbmFtZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWxsb3cgZm9yIGFsaWFzaW5nIHdpdGhpbiBzY29wZSBmdW5jdGlvbnMuICBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBmb3JcbiAgICogdW5jb21waWxlZCBjb2RlIC0gaW4gY29tcGlsZWQgY29kZSB0aGUgY2FsbHMgd2lsbCBiZSBpbmxpbmVkIGFuZCB0aGUgYWxpYXNlc1xuICAgKiBhcHBsaWVkLiAgSW4gdW5jb21waWxlZCBjb2RlIHRoZSBmdW5jdGlvbiBpcyBzaW1wbHkgcnVuIHNpbmNlIHRoZSBhbGlhc2VzIGFzXG4gICAqIHdyaXR0ZW4gYXJlIHZhbGlkIEphdmFTY3JpcHQuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm4gRnVuY3Rpb24gdG8gY2FsbC4gIFRoaXMgZnVuY3Rpb24gY2FuIGNvbnRhaW4gYWxpYXNlc1xuICAgKiAgICAgdG8gbmFtZXNwYWNlcyAoZS5nLiBcInZhciBkb20gPSBnb29nLmRvbVwiKSBvciBjbGFzc2VzXG4gICAqICAgICAoZS5nLiBcInZhciBUaW1lciA9IGdvb2cuVGltZXJcIikuXG4gICAqL1xuICBnb29nLnNjb3BlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgZm4uY2FsbChnb29nLmdsb2JhbCk7XG4gIH07XG5cbiAgLypcbiAgICogVG8gc3VwcG9ydCB1bmNvbXBpbGVkLCBzdHJpY3QgbW9kZSBidW5kbGVzIHRoYXQgdXNlIGV2YWwgdG8gZGl2aWRlIHNvdXJjZVxuICAgKiBsaWtlIHNvOlxuICAgKiAgICBldmFsKCdzb21lU291cmNlOy8vIyBzb3VyY2VVcmwgc291cmNlZmlsZS5qcycpO1xuICAgKiBXZSBuZWVkIHRvIGV4cG9ydCB0aGUgZ2xvYmFsbHkgZGVmaW5lZCBzeW1ib2xzIFwiZ29vZ1wiIGFuZCBcIkNPTVBJTEVEXCIuXG4gICAqIEV4cG9ydGluZyBcImdvb2dcIiBicmVha3MgdGhlIGNvbXBpbGVyIG9wdGltaXphdGlvbnMsIHNvIHdlIHJlcXVpcmVkIHRoYXRcbiAgICogYmUgZGVmaW5lZCBleHRlcm5hbGx5LlxuICAgKiBOT1RFOiBXZSBkb24ndCB1c2UgZ29vZy5leHBvcnRTeW1ib2wgaGVyZSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlclxuICAgKiBleHRlcm4gZ2VuZXJhdGlvbiB3aGVuIHRoYXQgY29tcGlsZXIgb3B0aW9uIGlzIGVuYWJsZWQuXG4gICAqL1xuICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgZ29vZy5nbG9iYWxbJ0NPTVBJTEVEJ10gPSBDT01QSUxFRDtcbiAgfVxuXG4gIGdvb2cucHJvdmlkZSgnZ29vZy5zdHJpbmcnKTtcblxuICAvKipcbiAgICogRG9lcyBzaW1wbGUgcHl0aG9uLXN0eWxlIHN0cmluZyBzdWJzdGl0dXRpb24uXG4gICAqIHN1YnMoXCJmb28lcyBob3Qlc1wiLCBcImJhclwiLCBcImRvZ1wiKSBiZWNvbWVzIFwiZm9vYmFyIGhvdGRvZ1wiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgY29udGFpbmluZyB0aGUgcGF0dGVybi5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBwYXR0ZXJuLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgY29weSBvZiB7QGNvZGUgc3RyfSBpbiB3aGljaCBlYWNoIG9jY3VycmVuY2Ugb2ZcbiAgICogICAgIHtAY29kZSAlc30gaGFzIGJlZW4gcmVwbGFjZWQgYW4gYXJndW1lbnQgZnJvbSB7QGNvZGUgdmFyX2FyZ3N9LlxuICAgKi9cbiAgZ29vZy5zdHJpbmcuc3VicyA9IGZ1bmN0aW9uIChzdHIsIHZhcl9hcmdzKSB7XG4gICAgdmFyIHNwbGl0UGFydHMgPSBzdHIuc3BsaXQoJyVzJyk7XG4gICAgdmFyIHJldHVyblN0cmluZyA9ICcnO1xuXG4gICAgdmFyIHN1YnNBcmd1bWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHdoaWxlIChzdWJzQXJndW1lbnRzLmxlbmd0aCAmJlxuICAgIC8vIFJlcGxhY2UgdXAgdG8gdGhlIGxhc3Qgc3BsaXQgcGFydC4gV2UgYXJlIGluc2VydGluZyBpbiB0aGVcbiAgICAvLyBwb3NpdGlvbnMgYmV0d2VlbiBzcGxpdCBwYXJ0cy5cbiAgICBzcGxpdFBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVyblN0cmluZyArPSBzcGxpdFBhcnRzLnNoaWZ0KCkgKyBzdWJzQXJndW1lbnRzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblN0cmluZyArIHNwbGl0UGFydHMuam9pbignJXMnKTsgLy8gSm9pbiB1bnVzZWQgJyVzJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFuIGFtcGVyc2FuZCwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAgICogQGNvbnN0IHshUmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuQU1QX1JFXyA9IC8mL2c7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYSBsZXNzIHRoYW4gc2lnbiwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAgICogQGNvbnN0IHshUmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuTFRfUkVfID0gLzwvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIGdyZWF0ZXIgdGhhbiBzaWduLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5HVF9SRV8gPSAvPi9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgZG91YmxlIHF1b3RlLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5RVU9UX1JFXyA9IC9cIi9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgc2luZ2xlIHF1b3RlLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5TSU5HTEVfUVVPVEVfUkVfID0gLycvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBudWxsIGNoYXJhY3RlciwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAgICogQGNvbnN0IHshUmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuTlVMTF9SRV8gPSAvXFx4MDAvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIGxvd2VyY2FzZSBsZXR0ZXIgXCJlXCIsIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gICAqIEBjb25zdCB7IVJlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuc3RyaW5nLkVfUkVfID0gL2UvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbnkgY2hhcmFjdGVyIHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cbiAgICogQGNvbnN0IHshUmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuQUxMX1JFXyA9IGdvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcgPyAvW1xceDAwJjw+XCInZV0vIDogL1tcXHgwMCY8PlwiJ10vO1xuXG4gIC8qKlxuICAgKiBVbmVzY2FwZXMgYW4gSFRNTCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBbiB1bmVzY2FwZWQgY29weSBvZiB7QGNvZGUgc3RyfS5cbiAgICovXG4gIGdvb2cuc3RyaW5nLnVuZXNjYXBlRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKGdvb2cuc3RyaW5nLmNvbnRhaW5zKHN0ciwgJyYnKSkge1xuICAgICAgLy8gV2UgYXJlIGNhcmVmdWwgbm90IHRvIHVzZSBhIERPTSBpZiB3ZSBkbyBub3QgaGF2ZSBvbmUgb3Igd2UgZXhwbGljaXRseVxuICAgICAgLy8gcmVxdWVzdGVkIG5vbi1ET00gaHRtbCB1bmVzY2FwaW5nLlxuICAgICAgaWYgKCFnb29nLnN0cmluZy5GT1JDRV9OT05fRE9NX0hUTUxfVU5FU0NBUElORyAmJiAnZG9jdW1lbnQnIGluIGdvb2cuZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBnb29nLnN0cmluZy51bmVzY2FwZUVudGl0aWVzVXNpbmdEb21fKHN0cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsIGJhY2sgb24gcHVyZSBYTUwgZW50aXRpZXNcbiAgICAgICAgcmV0dXJuIGdvb2cuc3RyaW5nLnVuZXNjYXBlUHVyZVhtbEVudGl0aWVzXyhzdHIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVbmVzY2FwZXMgYW4gSFRNTCBzdHJpbmcgdXNpbmcgYSBET00gdG8gcmVzb2x2ZSBub24tWE1MLCBub24tbnVtZXJpY1xuICAgKiBlbnRpdGllcy4gVGhpcyBmdW5jdGlvbiBpcyBYU1Mtc2FmZSBhbmQgd2hpdGVzcGFjZS1wcmVzZXJ2aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gICAqIEBwYXJhbSB7RG9jdW1lbnQ9fSBvcHRfZG9jdW1lbnQgQW4gb3B0aW9uYWwgZG9jdW1lbnQgdG8gdXNlIGZvciBjcmVhdGluZ1xuICAgKiAgICAgZWxlbWVudHMuIElmIHRoaXMgaXMgbm90IHNwZWNpZmllZCB0aGVuIHRoZSBkZWZhdWx0IHdpbmRvdy5kb2N1bWVudFxuICAgKiAgICAgd2lsbCBiZSB1c2VkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB1bmVzY2FwZWQge0Bjb2RlIHN0cn0gc3RyaW5nLlxuICAgKi9cbiAgZ29vZy5zdHJpbmcudW5lc2NhcGVFbnRpdGllc1VzaW5nRG9tXyA9IGZ1bmN0aW9uIChzdHIsIG9wdF9kb2N1bWVudCkge1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgdmFyIHNlZW4gPSB7ICcmYW1wOyc6ICcmJywgJyZsdDsnOiAnPCcsICcmZ3Q7JzogJz4nLCAnJnF1b3Q7JzogJ1wiJyB9O1xuICAgIHZhciBkaXY7XG4gICAgaWYgKG9wdF9kb2N1bWVudCkge1xuICAgICAgZGl2ID0gb3B0X2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXYgPSBnb29nLmdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB9XG4gICAgLy8gTWF0Y2ggYXMgbWFueSB2YWxpZCBlbnRpdHkgY2hhcmFjdGVycyBhcyBwb3NzaWJsZS4gSWYgdGhlIGFjdHVhbCBlbnRpdHlcbiAgICAvLyBoYXBwZW5zIHRvIGJlIHNob3J0ZXIsIGl0IHdpbGwgc3RpbGwgd29yayBhcyBpbm5lckhUTUwgd2lsbCByZXR1cm4gdGhlXG4gICAgLy8gdHJhaWxpbmcgY2hhcmFjdGVycyB1bmNoYW5nZWQuIFNpbmNlIHRoZSBlbnRpdHkgY2hhcmFjdGVycyBkbyBub3QgaW5jbHVkZVxuICAgIC8vIG9wZW4gYW5nbGUgYnJhY2tldCwgdGhlcmUgaXMgbm8gY2hhbmNlIG9mIFhTUyBmcm9tIHRoZSBpbm5lckhUTUwgdXNlLlxuICAgIC8vIFNpbmNlIG5vIHdoaXRlc3BhY2UgaXMgcGFzc2VkIHRvIGlubmVySFRNTCwgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWQuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkhUTUxfRU5USVRZX1BBVFRFUk5fLCBmdW5jdGlvbiAocywgZW50aXR5KSB7XG4gICAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGVudGl0eS5cbiAgICAgIHZhciB2YWx1ZSA9IHNlZW5bc107XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIG51bWVyaWMgZW50aXR5LlxuICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT0gJyMnKSB7XG4gICAgICAgIC8vIFByZWZpeCB3aXRoIDAgc28gdGhhdCBoZXggZW50aXRpZXMgKGUuZy4gJiN4MTApIHBhcnNlIGFzIGhleCBudW1iZXJzLlxuICAgICAgICB2YXIgbiA9IE51bWJlcignMCcgKyBlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGlubmVySFRNTCBvdGhlcndpc2UuXG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIC8vIEFwcGVuZCBhIG5vbi1lbnRpdHkgY2hhcmFjdGVyIHRvIGF2b2lkIGEgYnVnIGluIFdlYmtpdCB0aGF0IHBhcnNlc1xuICAgICAgICAvLyBhbiBpbnZhbGlkIGVudGl0eSBhdCB0aGUgZW5kIG9mIGlubmVySFRNTCB0ZXh0IGFzIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBzICsgJyAnO1xuICAgICAgICAvLyBUaGVuIHJlbW92ZSB0aGUgdHJhaWxpbmcgY2hhcmFjdGVyIGZyb20gdGhlIHJlc3VsdC5cbiAgICAgICAgdmFsdWUgPSBkaXYuZmlyc3RDaGlsZC5ub2RlVmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgICAgLy8gQ2FjaGUgYW5kIHJldHVybi5cbiAgICAgIHJldHVybiBzZWVuW3NdID0gdmFsdWU7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuZXNjYXBlcyBYTUwgZW50aXRpZXMuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBbiB1bmVzY2FwZWQgY29weSBvZiB7QGNvZGUgc3RyfS5cbiAgICovXG4gIGdvb2cuc3RyaW5nLnVuZXNjYXBlUHVyZVhtbEVudGl0aWVzXyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoW147XSspOy9nLCBmdW5jdGlvbiAocywgZW50aXR5KSB7XG4gICAgICBzd2l0Y2ggKGVudGl0eSkge1xuICAgICAgICBjYXNlICdhbXAnOlxuICAgICAgICAgIHJldHVybiAnJic7XG4gICAgICAgIGNhc2UgJ2x0JzpcbiAgICAgICAgICByZXR1cm4gJzwnO1xuICAgICAgICBjYXNlICdndCc6XG4gICAgICAgICAgcmV0dXJuICc+JztcbiAgICAgICAgY2FzZSAncXVvdCc6XG4gICAgICAgICAgcmV0dXJuICdcIic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT0gJyMnKSB7XG4gICAgICAgICAgICAvLyBQcmVmaXggd2l0aCAwIHNvIHRoYXQgaGV4IGVudGl0aWVzIChlLmcuICYjeDEwKSBwYXJzZSBhcyBoZXguXG4gICAgICAgICAgICB2YXIgbiA9IE51bWJlcignMCcgKyBlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4obikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEZvciBpbnZhbGlkIGVudGl0aWVzIHdlIGp1c3QgcmV0dXJuIHRoZSBlbnRpdHlcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBIVE1MIGVudGl0eS5cbiAgICogU2VlIGFsc28gSFRNTDU6IFRva2VuaXphdGlvbiAvIFRva2VuaXppbmcgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHshUmVnRXhwfVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuSFRNTF9FTlRJVFlfUEFUVEVSTl8gPSAvJihbXjtcXHM8Jl0rKTs/L2c7XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgd2hldGhlciBhIHN0cmluZyBjb250YWlucyBhIHN1YnN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN1YlN0cmluZyBUaGUgc3Vic3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIge0Bjb2RlIHN0cn0gY29udGFpbnMge0Bjb2RlIHN1YlN0cmluZ30uXG4gICAqL1xuICBnb29nLnN0cmluZy5jb250YWlucyA9IGZ1bmN0aW9uIChzdHIsIHN1YlN0cmluZykge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWJTdHJpbmcpICE9IC0xO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFc2NhcGVzIGRvdWJsZSBxdW90ZSAnXCInIGFuZCBzaW5nbGUgcXVvdGUgJ1xcJycgY2hhcmFjdGVycyBpbiBhZGRpdGlvbiB0b1xuICAgKiAnJicsICc8JywgYW5kICc+JyBzbyB0aGF0IGEgc3RyaW5nIGNhbiBiZSBpbmNsdWRlZCBpbiBhbiBIVE1MIHRhZyBhdHRyaWJ1dGVcbiAgICogdmFsdWUgd2l0aGluIGRvdWJsZSBvciBzaW5nbGUgcXVvdGVzLlxuICAgKlxuICAgKiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCA+IGRvZXNuJ3QgbmVlZCB0byBiZSBlc2NhcGVkIGZvciB0aGUgSFRNTCBvciBYTUwgdG9cbiAgICogYmUgdmFsaWQsIGJ1dCBpdCBoYXMgYmVlbiBkZWNpZGVkIHRvIGVzY2FwZSBpdCBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlclxuICAgKiBpbXBsZW1lbnRhdGlvbnMuXG4gICAqXG4gICAqIFdpdGggZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORywgdGhpcyBmdW5jdGlvbiBlc2NhcGVzIGFsc28gdGhlXG4gICAqIGxvd2VyY2FzZSBsZXR0ZXIgXCJlXCIuXG4gICAqXG4gICAqIE5PVEUodXNlcik6XG4gICAqIEh0bWxFc2NhcGUgaXMgb2Z0ZW4gY2FsbGVkIGR1cmluZyB0aGUgZ2VuZXJhdGlvbiBvZiBsYXJnZSBibG9ja3Mgb2YgSFRNTC5cbiAgICogVXNpbmcgc3RhdGljcyBmb3IgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgYW5kIHN0cmluZ3MgaXMgYW4gb3B0aW1pemF0aW9uXG4gICAqIHRoYXQgY2FuIG1vcmUgdGhhbiBoYWxmIHRoZSBhbW91bnQgb2YgdGltZSBJRSBzcGVuZHMgaW4gdGhpcyBmdW5jdGlvbiBmb3JcbiAgICogbGFyZ2UgYXBwcywgc2luY2Ugc3RyaW5ncyBhbmQgcmVnZXhlcyBib3RoIGNvbnRyaWJ1dGUgdG8gR0MgYWxsb2NhdGlvbnMuXG4gICAqXG4gICAqIFRlc3RpbmcgZm9yIHRoZSBwcmVzZW5jZSBvZiBhIGNoYXJhY3RlciBiZWZvcmUgZXNjYXBpbmcgaW5jcmVhc2VzIHRoZSBudW1iZXJcbiAgICogb2YgZnVuY3Rpb24gY2FsbHMsIGJ1dCBhY3R1YWxseSBwcm92aWRlcyBhIHNwZWVkIGluY3JlYXNlIGZvciB0aGUgYXZlcmFnZVxuICAgKiBjYXNlIC0tIHNpbmNlIHRoZSBhdmVyYWdlIGNhc2Ugb2Z0ZW4gZG9lc24ndCByZXF1aXJlIHRoZSBlc2NhcGluZyBvZiBhbGwgNFxuICAgKiBjaGFyYWN0ZXJzIGFuZCBpbmRleE9mKCkgaXMgbXVjaCBjaGVhcGVyIHRoYW4gcmVwbGFjZSgpLlxuICAgKiBUaGUgd29yc3QgY2FzZSBkb2VzIHN1ZmZlciBzbGlnaHRseSBmcm9tIHRoZSBhZGRpdGlvbmFsIGNhbGxzLCB0aGVyZWZvcmUgdGhlXG4gICAqIG9wdF9pc0xpa2VseVRvQ29udGFpbkh0bWxDaGFycyBvcHRpb24gaGFzIGJlZW4gaW5jbHVkZWQgZm9yIHNpdHVhdGlvbnNcbiAgICogd2hlcmUgYWxsIDQgSFRNTCBlbnRpdGllcyBhcmUgdmVyeSBsaWtlbHkgdG8gYmUgcHJlc2VudCBhbmQgbmVlZCBlc2NhcGluZy5cbiAgICpcbiAgICogU29tZSBiZW5jaG1hcmtzICh0aW1lcyB0ZW5kZWQgdG8gZmx1Y3R1YXRlICstMC4wNW1zKTpcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlyZUZveCAgICAgICAgICAgICAgICAgICAgIElFNlxuICAgKiAobm8gY2hhcnMgLyBhdmVyYWdlIChtaXggb2YgY2FzZXMpIC8gYWxsIDQgY2hhcnMpXG4gICAqIG5vIGNoZWNrcyAgICAgICAgICAgICAgICAgICAgIDAuMTMgLyAwLjIyIC8gMC4yMiAgICAgICAgIDAuMjMgLyAwLjUzIC8gMC44MFxuICAgKiBpbmRleE9mICAgICAgICAgICAgICAgICAgICAgICAwLjA4IC8gMC4xNyAvIDAuMjYgICAgICAgICAwLjIyIC8gMC41NCAvIDAuODRcbiAgICogaW5kZXhPZiArIHJlIHRlc3QgICAgICAgICAgICAgMC4wNyAvIDAuMTcgLyAwLjI4ICAgICAgICAgMC4xOSAvIDAuNTAgLyAwLjg1XG4gICAqXG4gICAqIEFuIGFkZGl0aW9uYWwgYWR2YW50YWdlIG9mIGNoZWNraW5nIGlmIHJlcGxhY2UgYWN0dWFsbHkgbmVlZHMgdG8gYmUgY2FsbGVkXG4gICAqIGlzIGEgcmVkdWN0aW9uIGluIHRoZSBudW1iZXIgb2Ygb2JqZWN0IGFsbG9jYXRpb25zLCBzbyBhcyB0aGUgc2l6ZSBvZiB0aGVcbiAgICogYXBwbGljYXRpb24gZ3Jvd3MgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdmFyaW91cyBtZXRob2RzIHdvdWxkIGluY3JlYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBiZSBlc2NhcGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMgRG9uJ3QgcGVyZm9ybSBhIGNoZWNrIHRvIHNlZVxuICAgKiAgICAgaWYgdGhlIGNoYXJhY3RlciBuZWVkcyByZXBsYWNpbmcgLSB1c2UgdGhpcyBvcHRpb24gaWYgeW91IGV4cGVjdCBlYWNoIG9mXG4gICAqICAgICB0aGUgY2hhcmFjdGVycyB0byBhcHBlYXIgb2Z0ZW4uIExlYXZlIGZhbHNlIGlmIHlvdSBleHBlY3QgZmV3IGh0bWxcbiAgICogICAgIGNoYXJhY3RlcnMgdG8gb2NjdXIgaW4geW91ciBzdHJpbmdzLCBzdWNoIGFzIGlmIHlvdSBhcmUgZXNjYXBpbmcgSFRNTC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN0cn0uXG4gICAqL1xuICBnb29nLnN0cmluZy5odG1sRXNjYXBlID0gZnVuY3Rpb24gKHN0ciwgb3B0X2lzTGlrZWx5VG9Db250YWluSHRtbENoYXJzKSB7XG5cbiAgICBpZiAob3B0X2lzTGlrZWx5VG9Db250YWluSHRtbENoYXJzKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5BTVBfUkVfLCAnJmFtcDsnKS5yZXBsYWNlKGdvb2cuc3RyaW5nLkxUX1JFXywgJyZsdDsnKS5yZXBsYWNlKGdvb2cuc3RyaW5nLkdUX1JFXywgJyZndDsnKS5yZXBsYWNlKGdvb2cuc3RyaW5nLlFVT1RfUkVfLCAnJnF1b3Q7JykucmVwbGFjZShnb29nLnN0cmluZy5TSU5HTEVfUVVPVEVfUkVfLCAnJiMzOTsnKS5yZXBsYWNlKGdvb2cuc3RyaW5nLk5VTExfUkVfLCAnJiMwOycpO1xuICAgICAgaWYgKGdvb2cuc3RyaW5nLkRFVEVDVF9ET1VCTEVfRVNDQVBJTkcpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuRV9SRV8sICcmIzEwMTsnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHF1aWNrIHRlc3QgaGVscHMgaW4gdGhlIGNhc2Ugd2hlbiB0aGVyZSBhcmUgbm8gY2hhcnMgdG8gcmVwbGFjZSwgaW5cbiAgICAgIC8vIHdvcnN0IGNhc2UgdGhpcyBtYWtlcyBiYXJlbHkgYSBkaWZmZXJlbmNlIHRvIHRoZSB0aW1lIHRha2VuXG4gICAgICBpZiAoIWdvb2cuc3RyaW5nLkFMTF9SRV8udGVzdChzdHIpKSByZXR1cm4gc3RyO1xuXG4gICAgICAvLyBzdHIuaW5kZXhPZiBpcyBmYXN0ZXIgdGhhbiByZWdleC50ZXN0IGluIHRoaXMgY2FzZVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCcmJykgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuQU1QX1JFXywgJyZhbXA7Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJzwnKSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5MVF9SRV8sICcmbHQ7Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJz4nKSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5HVF9SRV8sICcmZ3Q7Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1wiJykgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuUVVPVF9SRV8sICcmcXVvdDsnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFwnJykgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuU0lOR0xFX1FVT1RFX1JFXywgJyYjMzk7Jyk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xceDAwJykgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuTlVMTF9SRV8sICcmIzA7Jyk7XG4gICAgICB9XG4gICAgICBpZiAoZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORyAmJiBzdHIuaW5kZXhPZignZScpICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkVfUkVfLCAnJiMxMDE7Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBnb29nLmRlYnVnID0ge307XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgYSB2YWx1ZS4gSWYgYSBjb25zdHJ1Y3RvciBpcyBwYXNzZWQsIGFuZCBhIHN1aXRhYmxlXG4gICAqIHN0cmluZyBjYW5ub3QgYmUgZm91bmQsICd1bmtub3duIHR5cGUgbmFtZScgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogPHA+Rm9ya2VkIHJhdGhlciB0aGFuIG1vdmVkIGZyb20ge0BsaW5rIGdvb2cuYXNzZXJ0cy5nZXRUeXBlX31cbiAgICogdG8gYXZvaWQgYWRkaW5nIGEgZGVwZW5kZW5jeSB0byBnb29nLmFzc2VydHMuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQSBjb25zdHJ1Y3Rvciwgb2JqZWN0LCBvciBwcmltaXRpdmUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJlc3QgZGlzcGxheSBuYW1lIGZvciB0aGUgdmFsdWUsIG9yICd1bmtub3duIHR5cGUgbmFtZScuXG4gICAqL1xuICBnb29nLmRlYnVnLnJ1bnRpbWVUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgIHJldHVybiB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lIHx8ICd1bmtub3duIHR5cGUgbmFtZSc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgcmV0dXJuIHZhbHVlLmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgLy9cbiAgLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAvLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgLy9cbiAgLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgLy9cbiAgLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAvLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gIC8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAvLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gIC8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gIC8qKlxuICAgKiBAZmlsZW92ZXJ2aWV3IFByb3ZpZGVzIGEgYmFzZSBjbGFzcyBmb3IgY3VzdG9tIEVycm9yIG9iamVjdHMgc3VjaCB0aGF0IHRoZVxuICAgKiBzdGFjayBpcyBjb3JyZWN0bHkgbWFpbnRhaW5lZC5cbiAgICpcbiAgICogWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIHRocm93IGdvb2cuZGVidWcuRXJyb3IobXNnKSBkaXJlY3RseSwgRXJyb3IobXNnKSBpc1xuICAgKiBzdWZmaWNpZW50LlxuICAgKlxuICAgKi9cblxuICAvKipcbiAgICogQmFzZSBjbGFzcyBmb3IgY3VzdG9tIGVycm9yIG9iamVjdHMuXG4gICAqIEBwYXJhbSB7Kj19IG9wdF9tc2cgVGhlIG1lc3NhZ2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvci5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtFcnJvcn1cbiAgICovXG4gIGdvb2cuZGVidWcuRXJyb3IgPSBmdW5jdGlvbiAob3B0X21zZykge1xuXG4gICAgLy8gQXR0ZW1wdCB0byBlbnN1cmUgdGhlcmUgaXMgYSBzdGFjayB0cmFjZS5cbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIGdvb2cuZGVidWcuRXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICAgIGlmIChzdGFjaykge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdF9tc2cpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IFN0cmluZyhvcHRfbXNnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHJlcG9ydCB0aGlzIGVycm9yIHRvIHRoZSBzZXJ2ZXIuIFNldHRpbmcgdGhpcyB0byBmYWxzZSB3aWxsXG4gICAgICogY2F1c2UgdGhlIGVycm9yIHJlcG9ydGVyIHRvIG5vdCByZXBvcnQgdGhlIGVycm9yIGJhY2sgdG8gdGhlIHNlcnZlcixcbiAgICAgKiB3aGljaCBjYW4gYmUgdXNlZnVsIGlmIHRoZSBjbGllbnQga25vd3MgdGhhdCB0aGUgZXJyb3IgaGFzIGFscmVhZHkgYmVlblxuICAgICAqIGxvZ2dlZCBvbiB0aGUgc2VydmVyLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVwb3J0RXJyb3JUb1NlcnZlciA9IHRydWU7XG4gIH07XG4gIGdvb2cuaW5oZXJpdHMoZ29vZy5kZWJ1Zy5FcnJvciwgRXJyb3IpO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ29vZy5kZWJ1Zy5FcnJvci5wcm90b3R5cGUubmFtZSA9ICdDdXN0b21FcnJvcic7XG5cbiAgLyoqXG4gICAqIEBmaWxlb3ZlcnZpZXcgRGVmaW5pdGlvbiBvZiBnb29nLmRvbS5Ob2RlVHlwZS5cbiAgICovXG5cbiAgZ29vZy5kb20gPSB7fTtcblxuICAvKipcbiAgICogQ29uc3RhbnRzIGZvciB0aGUgbm9kZVR5cGUgYXR0cmlidXRlIGluIHRoZSBOb2RlIGludGVyZmFjZS5cbiAgICpcbiAgICogVGhlc2UgY29uc3RhbnRzIG1hdGNoIHRob3NlIHNwZWNpZmllZCBpbiB0aGUgTm9kZSBpbnRlcmZhY2UuIFRoZXNlIGFyZVxuICAgKiB1c3VhbGx5IHByZXNlbnQgb24gdGhlIE5vZGUgb2JqZWN0IGluIHJlY2VudCBicm93c2VycywgYnV0IG5vdCBpbiBvbGRlclxuICAgKiBicm93c2VycyAoc3BlY2lmaWNhbGx5LCBlYXJseSBJRXMpIGFuZCB0aHVzIGFyZSBnaXZlbiBoZXJlLlxuICAgKlxuICAgKiBJbiBzb21lIGJyb3dzZXJzIChlYXJseSBJRXMpLCB0aGVzZSBhcmUgbm90IGRlZmluZWQgb24gdGhlIE5vZGUgb2JqZWN0LFxuICAgKiBzbyB0aGV5IGFyZSBwcm92aWRlZCBoZXJlLlxuICAgKlxuICAgKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItQ29yZS9jb3JlLmh0bWwjSUQtMTk1MDY0MTI0N1xuICAgKiBAZW51bSB7bnVtYmVyfVxuICAgKi9cbiAgZ29vZy5kb20uTm9kZVR5cGUgPSB7XG4gICAgRUxFTUVOVDogMSxcbiAgICBBVFRSSUJVVEU6IDIsXG4gICAgVEVYVDogMyxcbiAgICBDREFUQV9TRUNUSU9OOiA0LFxuICAgIEVOVElUWV9SRUZFUkVOQ0U6IDUsXG4gICAgRU5USVRZOiA2LFxuICAgIFBST0NFU1NJTkdfSU5TVFJVQ1RJT046IDcsXG4gICAgQ09NTUVOVDogOCxcbiAgICBET0NVTUVOVDogOSxcbiAgICBET0NVTUVOVF9UWVBFOiAxMCxcbiAgICBET0NVTUVOVF9GUkFHTUVOVDogMTEsXG4gICAgTk9UQVRJT046IDEyXG4gIH07XG5cbiAgLy8gQ29weXJpZ2h0IDIwMDcgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAvL1xuICAvLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAvLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gIC8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAvL1xuICAvLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAvL1xuICAvLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIC8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAgLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIC8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgLyoqXG4gICAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHN1cHBvcnRpbmcgQmlkaSBpc3N1ZXMuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOYW1lc3BhY2UgZm9yIGJpZGkgc3VwcG9ydGluZyBmdW5jdGlvbnMuXG4gICAqL1xuICBnb29nLnByb3ZpZGUoJ2dvb2cuaTE4bi5iaWRpJyk7XG4gIGdvb2cucHJvdmlkZSgnZ29vZy5pMThuLmJpZGkuRGlyJyk7XG4gIGdvb2cucHJvdmlkZSgnZ29vZy5pMThuLmJpZGkuRGlyZWN0aW9uYWxTdHJpbmcnKTtcbiAgZ29vZy5wcm92aWRlKCdnb29nLmkxOG4uYmlkaS5Gb3JtYXQnKTtcblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gRk9SQ0VfUlRMIGZvcmNlcyB0aGUge0BsaW5rIGdvb2cuaTE4bi5iaWRpLklTX1JUTH0gY29uc3RhbnRcbiAgICogdG8gc2F5IHRoYXQgdGhlIGN1cnJlbnQgbG9jYWxlIGlzIGEgUlRMIGxvY2FsZS4gIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICAgKiBpZiB5b3Ugd2FudCB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBmb3IgZGVjaWRpbmcgd2hldGhlciB0aGVcbiAgICogY3VycmVudCBsb2NhbGUgaXMgUlRMIG9yIG5vdC5cbiAgICpcbiAgICoge0BzZWUgZ29vZy5pMThuLmJpZGkuSVNfUlRMfVxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuaTE4bi5iaWRpLkZPUkNFX1JUTCcsIGZhbHNlKTtcblxuICAvKipcbiAgICogQ29uc3RhbnQgdGhhdCBkZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IGxvY2FsZSBpcyBhIFJUTCBsb2NhbGUuXG4gICAqIElmIHtAbGluayBnb29nLmkxOG4uYmlkaS5GT1JDRV9SVEx9IGlzIG5vdCB0cnVlLCB0aGlzIGNvbnN0YW50IHdpbGwgZGVmYXVsdFxuICAgKiB0byBjaGVjayB0aGF0IHtAbGluayBnb29nLkxPQ0FMRX0gaXMgb25lIG9mIGEgZmV3IG1ham9yIFJUTCBsb2NhbGVzLlxuICAgKlxuICAgKiA8cD5UaGlzIGlzIGRlc2lnbmVkIHRvIGJlIGEgbWF4aW1hbGx5IGVmZmljaWVudCBjb21waWxlLXRpbWUgY29uc3RhbnQuIEZvclxuICAgKiBleGFtcGxlLCBmb3IgdGhlIGRlZmF1bHQgZ29vZy5MT0NBTEUsIGNvbXBpbGluZ1xuICAgKiBcImlmIChnb29nLmkxOG4uYmlkaS5JU19SVEwpIGFsZXJ0KCdydGwnKSBlbHNlIHt9XCIgc2hvdWxkIHByb2R1Y2Ugbm8gY29kZS4gSXRcbiAgICogaXMgdGhpcyBkZXNpZ24gY29uc2lkZXJhdGlvbiB0aGF0IGxpbWl0cyB0aGUgaW1wbGVtZW50YXRpb24gdG8gb25seVxuICAgKiBzdXBwb3J0aW5nIGEgZmV3IG1ham9yIFJUTCBsb2NhbGVzLCBhcyBvcHBvc2VkIHRvIHRoZSBicm9hZGVyIHJlcGVydG9pcmUgb2ZcbiAgICogc29tZXRoaW5nIGxpa2UgZ29vZy5pMThuLmJpZGkuaXNSdGxMYW5ndWFnZS5cbiAgICpcbiAgICogPHA+U2luY2UgdGhpcyBjb25zdGFudCByZWZlcnMgdG8gdGhlIGRpcmVjdGlvbmFsaXR5IG9mIHRoZSBsb2NhbGUsIGl0IGlzIHVwXG4gICAqIHRvIHRoZSBjYWxsZXIgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgY29uc3RhbnQgc2hvdWxkIGFsc28gYmUgdXNlZCBmb3IgdGhlXG4gICAqIGRpcmVjdGlvbiBvZiB0aGUgVUkuXG4gICAqXG4gICAqIHtAc2VlIGdvb2cuTE9DQUxFfVxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICpcbiAgICogVE9ETyh1c2VyKTogd3JpdGUgYSB0ZXN0IHRoYXQgY2hlY2tzIHRoYXQgdGhpcyBpcyBhIGNvbXBpbGUtdGltZSBjb25zdGFudC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLklTX1JUTCA9IGdvb2cuaTE4bi5iaWRpLkZPUkNFX1JUTCB8fCAoZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT0gJ2FyJyB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMCwgMikudG9Mb3dlckNhc2UoKSA9PSAnZmEnIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdoZScgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT0gJ2l3JyB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMCwgMikudG9Mb3dlckNhc2UoKSA9PSAncHMnIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdzZCcgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT0gJ3VnJyB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMCwgMikudG9Mb3dlckNhc2UoKSA9PSAndXInIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICd5aScpICYmIChnb29nLkxPQ0FMRS5sZW5ndGggPT0gMiB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMiwgMykgPT0gJy0nIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygyLCAzKSA9PSAnXycpIHx8IGdvb2cuTE9DQUxFLmxlbmd0aCA+PSAzICYmIGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAzKS50b0xvd2VyQ2FzZSgpID09ICdja2InICYmIChnb29nLkxPQ0FMRS5sZW5ndGggPT0gMyB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMywgNCkgPT0gJy0nIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygzLCA0KSA9PSAnXycpO1xuXG4gIC8qKlxuICAgKiBVbmljb2RlIGZvcm1hdHRpbmcgY2hhcmFjdGVycyBhbmQgZGlyZWN0aW9uYWxpdHkgc3RyaW5nIGNvbnN0YW50cy5cbiAgICogQGVudW0ge3N0cmluZ31cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLkZvcm1hdCA9IHtcbiAgICAvKiogVW5pY29kZSBcIkxlZnQtVG8tUmlnaHQgRW1iZWRkaW5nXCIgKExSRSkgY2hhcmFjdGVyLiAqL1xuICAgIExSRTogJ1xcdTIwMkEnLFxuICAgIC8qKiBVbmljb2RlIFwiUmlnaHQtVG8tTGVmdCBFbWJlZGRpbmdcIiAoUkxFKSBjaGFyYWN0ZXIuICovXG4gICAgUkxFOiAnXFx1MjAyQicsXG4gICAgLyoqIFVuaWNvZGUgXCJQb3AgRGlyZWN0aW9uYWwgRm9ybWF0dGluZ1wiIChQREYpIGNoYXJhY3Rlci4gKi9cbiAgICBQREY6ICdcXHUyMDJDJyxcbiAgICAvKiogVW5pY29kZSBcIkxlZnQtVG8tUmlnaHQgTWFya1wiIChMUk0pIGNoYXJhY3Rlci4gKi9cbiAgICBMUk06ICdcXHUyMDBFJyxcbiAgICAvKiogVW5pY29kZSBcIlJpZ2h0LVRvLUxlZnQgTWFya1wiIChSTE0pIGNoYXJhY3Rlci4gKi9cbiAgICBSTE06ICdcXHUyMDBGJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBEaXJlY3Rpb25hbGl0eSBlbnVtLlxuICAgKiBAZW51bSB7bnVtYmVyfVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuRGlyID0ge1xuICAgIC8qKlxuICAgICAqIExlZnQtdG8tcmlnaHQuXG4gICAgICovXG4gICAgTFRSOiAxLFxuXG4gICAgLyoqXG4gICAgICogUmlnaHQtdG8tbGVmdC5cbiAgICAgKi9cbiAgICBSVEw6IC0xLFxuXG4gICAgLyoqXG4gICAgICogTmVpdGhlciBsZWZ0LXRvLXJpZ2h0IG5vciByaWdodC10by1sZWZ0LlxuICAgICAqL1xuICAgIE5FVVRSQUw6IDBcbiAgfTtcblxuICAvKipcbiAgICogJ3JpZ2h0JyBzdHJpbmcgY29uc3RhbnQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5SSUdIVCA9ICdyaWdodCc7XG5cbiAgLyoqXG4gICAqICdsZWZ0JyBzdHJpbmcgY29uc3RhbnQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5MRUZUID0gJ2xlZnQnO1xuXG4gIC8qKlxuICAgKiAnbGVmdCcgaWYgbG9jYWxlIGlzIFJUTCwgJ3JpZ2h0JyBpZiBub3QuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5JMThOX1JJR0hUID0gZ29vZy5pMThuLmJpZGkuSVNfUlRMID8gZ29vZy5pMThuLmJpZGkuTEVGVCA6IGdvb2cuaTE4bi5iaWRpLlJJR0hUO1xuXG4gIC8qKlxuICAgKiAncmlnaHQnIGlmIGxvY2FsZSBpcyBSVEwsICdsZWZ0JyBpZiBub3QuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5JMThOX0xFRlQgPSBnb29nLmkxOG4uYmlkaS5JU19SVEwgPyBnb29nLmkxOG4uYmlkaS5SSUdIVCA6IGdvb2cuaTE4bi5iaWRpLkxFRlQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBkaXJlY3Rpb25hbGl0eSBnaXZlbiBpbiB2YXJpb3VzIGZvcm1hdHMgdG8gYSBnb29nLmkxOG4uYmlkaS5EaXJcbiAgICogY29uc3RhbnQuIFVzZWZ1bCBmb3IgaW50ZXJhY3Rpb24gd2l0aCBkaWZmZXJlbnQgc3RhbmRhcmRzIG9mIGRpcmVjdGlvbmFsaXR5XG4gICAqIHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2dvb2cuaTE4bi5iaWRpLkRpcnxudW1iZXJ8Ym9vbGVhbnxudWxsfSBnaXZlbkRpciBEaXJlY3Rpb25hbGl0eSBnaXZlblxuICAgKiAgICAgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAgICogICAgIDEuIEEgZ29vZy5pMThuLmJpZGkuRGlyIGNvbnN0YW50LlxuICAgKiAgICAgMi4gQSBudW1iZXIgKHBvc2l0aXZlID0gTFRSLCBuZWdhdGl2ZSA9IFJUTCwgMCA9IG5ldXRyYWwpLlxuICAgKiAgICAgMy4gQSBib29sZWFuICh0cnVlID0gUlRMLCBmYWxzZSA9IExUUikuXG4gICAqICAgICA0LiBBIG51bGwgZm9yIHVua25vd24gZGlyZWN0aW9uYWxpdHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub05ldXRyYWwgV2hldGhlciBhIGdpdmVuRGlyIG9mIHplcm8gb3JcbiAgICogICAgIGdvb2cuaTE4bi5iaWRpLkRpci5ORVVUUkFMIHNob3VsZCBiZSB0cmVhdGVkIGFzIG51bGwsIGkuZS4gdW5rbm93biwgaW5cbiAgICogICAgIG9yZGVyIHRvIHByZXNlcnZlIGxlZ2FjeSBiZWhhdmlvci5cbiAgICogQHJldHVybiB7P2dvb2cuaTE4bi5iaWRpLkRpcn0gQSBnb29nLmkxOG4uYmlkaS5EaXIgY29uc3RhbnQgbWF0Y2hpbmcgdGhlXG4gICAqICAgICBnaXZlbiBkaXJlY3Rpb25hbGl0eS4gSWYgZ2l2ZW4gbnVsbCwgcmV0dXJucyBudWxsIChpLmUuIHVua25vd24pLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkudG9EaXIgPSBmdW5jdGlvbiAoZ2l2ZW5EaXIsIG9wdF9ub05ldXRyYWwpIHtcbiAgICBpZiAodHlwZW9mIGdpdmVuRGlyID09ICdudW1iZXInKSB7XG4gICAgICAvLyBUaGlzIGluY2x1ZGVzIHRoZSBub24tbnVsbCBnb29nLmkxOG4uYmlkaS5EaXIgY2FzZS5cbiAgICAgIHJldHVybiBnaXZlbkRpciA+IDAgPyBnb29nLmkxOG4uYmlkaS5EaXIuTFRSIDogZ2l2ZW5EaXIgPCAwID8gZ29vZy5pMThuLmJpZGkuRGlyLlJUTCA6IG9wdF9ub05ldXRyYWwgPyBudWxsIDogZ29vZy5pMThuLmJpZGkuRGlyLk5FVVRSQUw7XG4gICAgfSBlbHNlIGlmIChnaXZlbkRpciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTXVzdCBiZSB0eXBlb2YgZ2l2ZW5EaXIgPT0gJ2Jvb2xlYW4nLlxuICAgICAgcmV0dXJuIGdpdmVuRGlyID8gZ29vZy5pMThuLmJpZGkuRGlyLlJUTCA6IGdvb2cuaTE4bi5iaWRpLkRpci5MVFI7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHByYWN0aWNhbCBwYXR0ZXJuIHRvIGlkZW50aWZ5IHN0cm9uZyBMVFIgY2hhcmFjdGVycy4gVGhpcyBwYXR0ZXJuIGlzIG5vdFxuICAgKiB0aGVvcmV0aWNhbGx5IGNvcnJlY3QgYWNjb3JkaW5nIHRvIHRoZSBVbmljb2RlIHN0YW5kYXJkLiBJdCBpcyBzaW1wbGlmaWVkIGZvclxuICAgKiBwZXJmb3JtYW5jZSBhbmQgc21hbGwgY29kZSBzaXplLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfID0gJ0EtWmEtelxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkI4XFx1MDMwMC1cXHUwNTkwXFx1MDgwMC1cXHUxRkZGJyArICdcXHUyMDBFXFx1MkMwMC1cXHVGQjFDXFx1RkUwMC1cXHVGRTZGXFx1RkVGRC1cXHVGRkZGJztcblxuICAvKipcbiAgICogQSBwcmFjdGljYWwgcGF0dGVybiB0byBpZGVudGlmeSBzdHJvbmcgUlRMIGNoYXJhY3Rlci4gVGhpcyBwYXR0ZXJuIGlzIG5vdFxuICAgKiB0aGVvcmV0aWNhbGx5IGNvcnJlY3QgYWNjb3JkaW5nIHRvIHRoZSBVbmljb2RlIHN0YW5kYXJkLiBJdCBpcyBzaW1wbGlmaWVkXG4gICAqIGZvciBwZXJmb3JtYW5jZSBhbmQgc21hbGwgY29kZSBzaXplLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfID0gJ1xcdTA1OTEtXFx1MDZFRlxcdTA2RkEtXFx1MDdGRlxcdTIwMEZcXHVGQjFELVxcdUZERkZcXHVGRTcwLVxcdUZFRkMnO1xuXG4gIC8qKlxuICAgKiBTaW1wbGlmaWVkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgYW4gSFRNTCB0YWcgKG9wZW5pbmcgb3IgY2xvc2luZykgb3IgYW4gSFRNTFxuICAgKiBlc2NhcGUuIFdlIG1pZ2h0IHdhbnQgdG8gc2tpcCBvdmVyIHN1Y2ggZXhwcmVzc2lvbnMgd2hlbiBlc3RpbWF0aW5nIHRoZSB0ZXh0XG4gICAqIGRpcmVjdGlvbmFsaXR5LlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaHRtbFNraXBSZWdfID0gLzxbXj5dKj58JlteO10rOy9nO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCB0ZXh0IHdpdGggc3BhY2VzIGluc3RlYWQgb2YgSFRNTCB0YWdzIG9yIEhUTUwgZXNjYXBlcywgaWZcbiAgICogb3B0X2lzU3RyaXBOZWVkZWQgaXMgdHJ1ZS4gRWxzZSByZXR1cm5zIHRoZSBpbnB1dCBhcyBpcy5cbiAgICogVXNlZnVsIGZvciB0ZXh0IGRpcmVjdGlvbmFsaXR5IGVzdGltYXRpb24uXG4gICAqIE5vdGU6IHRoZSBmdW5jdGlvbiBzaG91bGQgbm90IGJlIHVzZWQgaW4gb3RoZXIgY29udGV4dHM7IGl0IGlzIG5vdCAxMDAlXG4gICAqIGNvcnJlY3QsIGJ1dCByYXRoZXIgYSBnb29kLWVub3VnaCBpbXBsZW1lbnRhdGlvbiBmb3IgZGlyZWN0aW9uYWxpdHlcbiAgICogZXN0aW1hdGlvbiBwdXJwb3Nlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZ2l2ZW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNTdHJpcE5lZWRlZCBXaGV0aGVyIHRvIHBlcmZvcm0gdGhlIHN0cmlwcGluZy5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlICh0byByZXRhaW4gY29uc2lzdGVuY3kgd2l0aCBjYWxsaW5nIGZ1bmN0aW9ucykuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGdpdmVuIHN0cmluZyBjbGVhbmVkIG9mIEhUTUwgdGFncyAvIGVzY2FwZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8gPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNTdHJpcE5lZWRlZCkge1xuICAgIHJldHVybiBvcHRfaXNTdHJpcE5lZWRlZCA/IHN0ci5yZXBsYWNlKGdvb2cuaTE4bi5iaWRpLmh0bWxTa2lwUmVnXywgJycpIDogc3RyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2sgZm9yIFJUTCBjaGFyYWN0ZXJzLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsQ2hhclJlZ18gPSBuZXcgUmVnRXhwKCdbJyArIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJzXyArICddJyk7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBjaGVjayBmb3IgTFRSIGNoYXJhY3RlcnMuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5sdHJDaGFyUmVnXyA9IG5ldyBSZWdFeHAoJ1snICsgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfICsgJ10nKTtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgaGFzIGFueSBSVEwgY2hhcmFjdGVycyBpbiBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZ2l2ZW4gc3RyaW5nIHRoYXQgbmVlZCB0byBiZSB0ZXN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgY29udGFpbnMgUlRMIGNoYXJhY3RlcnMuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5oYXNBbnlSdGwgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJSZWdfLnRlc3QoZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBoYXMgYW55IFJUTCBjaGFyYWN0ZXJzIGluIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3RyaW5nIGNvbnRhaW5zIFJUTCBjaGFyYWN0ZXJzLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaGFzQW55UnRsLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaGFzUnRsQ2hhciA9IGdvb2cuaTE4bi5iaWRpLmhhc0FueVJ0bDtcblxuICAvKipcbiAgICogVGVzdCB3aGV0aGVyIHRoZSBnaXZlbiBzdHJpbmcgaGFzIGFueSBMVFIgY2hhcmFjdGVycyBpbiBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZ2l2ZW4gc3RyaW5nIHRoYXQgbmVlZCB0byBiZSB0ZXN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgY29udGFpbnMgTFRSIGNoYXJhY3RlcnMuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5oYXNBbnlMdHIgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJSZWdfLnRlc3QoZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBjaGVjayBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmdcbiAgICogaXMgTFRSLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkubHRyUmVfID0gbmV3IFJlZ0V4cCgnXlsnICsgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfICsgJ10nKTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gY2hlY2sgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXG4gICAqIGlzIFJUTC5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnJ0bFJlXyA9IG5ldyBSZWdFeHAoJ15bJyArIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJzXyArICddJyk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBSVEwgb3Igbm90LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHN0ciBpcyBhbiBSVEwgY2hhci5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzUnRsQ2hhciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkucnRsUmVfLnRlc3Qoc3RyKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIExUUiBvciBub3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gc3RyIGlzIGFuIExUUiBjaGFyLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNMdHJDaGFyID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5sdHJSZV8udGVzdChzdHIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgbmV1dHJhbCBvciBub3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gc3RyIGlzIGEgbmV1dHJhbCBjaGFyLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNOZXV0cmFsQ2hhciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gIWdvb2cuaTE4bi5iaWRpLmlzTHRyQ2hhcihzdHIpICYmICFnb29nLmkxOG4uYmlkaS5pc1J0bENoYXIoc3RyKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9ucyB0byBjaGVjayBpZiBhIHBpZWNlIG9mIHRleHQgaXMgb2YgTFRSIGRpcmVjdGlvbmFsaXR5XG4gICAqIG9uIGZpcnN0IGNoYXJhY3RlciB3aXRoIHN0cm9uZyBkaXJlY3Rpb25hbGl0eS5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmx0ckRpckNoZWNrUmVfID0gbmV3IFJlZ0V4cCgnXlteJyArIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJzXyArICddKlsnICsgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfICsgJ10nKTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9ucyB0byBjaGVjayBpZiBhIHBpZWNlIG9mIHRleHQgaXMgb2YgUlRMIGRpcmVjdGlvbmFsaXR5XG4gICAqIG9uIGZpcnN0IGNoYXJhY3RlciB3aXRoIHN0cm9uZyBkaXJlY3Rpb25hbGl0eS5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnJ0bERpckNoZWNrUmVfID0gbmV3IFJlZ0V4cCgnXlteJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddKlsnICsgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfICsgJ10nKTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZmlyc3Qgc3Ryb25nbHkgZGlyZWN0aW9uYWwgY2hhcmFjdGVyIChpZiBhbnkpIGlzIFJUTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgUlRMIGRpcmVjdGlvbmFsaXR5IGlzIGRldGVjdGVkIHVzaW5nIHRoZSBmaXJzdFxuICAgKiAgICAgc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIG1ldGhvZC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhSdGwgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLnJ0bERpckNoZWNrUmVfLnRlc3QoZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBmaXJzdCBzdHJvbmdseSBkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgKGlmIGFueSkgaXMgUlRMLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyBiZWluZyBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBSVEwgZGlyZWN0aW9uYWxpdHkgaXMgZGV0ZWN0ZWQgdXNpbmcgdGhlIGZpcnN0XG4gICAqICAgICBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgbWV0aG9kLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3RhcnRzV2l0aFJ0bC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzUnRsVGV4dCA9IGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhSdGw7XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGZpcnN0IHN0cm9uZ2x5IGRpcmVjdGlvbmFsIGNoYXJhY3RlciAoaWYgYW55KSBpcyBMVFIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIExUUiBkaXJlY3Rpb25hbGl0eSBpcyBkZXRlY3RlZCB1c2luZyB0aGUgZmlyc3RcbiAgICogICAgIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBtZXRob2QuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5zdGFydHNXaXRoTHRyID0gZnVuY3Rpb24gKHN0ciwgb3B0X2lzSHRtbCkge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5sdHJEaXJDaGVja1JlXy50ZXN0KGdvb2cuaTE4bi5iaWRpLnN0cmlwSHRtbElmTmVlZGVkXyhzdHIsIG9wdF9pc0h0bWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZmlyc3Qgc3Ryb25nbHkgZGlyZWN0aW9uYWwgY2hhcmFjdGVyIChpZiBhbnkpIGlzIExUUi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgTFRSIGRpcmVjdGlvbmFsaXR5IGlzIGRldGVjdGVkIHVzaW5nIHRoZSBmaXJzdFxuICAgKiAgICAgc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIG1ldGhvZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIHN0YXJ0c1dpdGhMdHIuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5pc0x0clRleHQgPSBnb29nLmkxOG4uYmlkaS5zdGFydHNXaXRoTHRyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2sgaWYgYSBzdHJpbmcgbG9va3MgbGlrZSBzb21ldGhpbmcgdGhhdCBtdXN0XG4gICAqIGFsd2F5cyBiZSBMVFIgZXZlbiBpbiBSVEwgdGV4dCwgZS5nLiBhIFVSTC4gV2hlbiBlc3RpbWF0aW5nIHRoZVxuICAgKiBkaXJlY3Rpb25hbGl0eSBvZiB0ZXh0IGNvbnRhaW5pbmcgdGhlc2UsIHdlIHRyZWF0IHRoZXNlIGFzIHdlYWtseSBMVFIsXG4gICAqIGxpa2UgbnVtYmVycy5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzUmVxdWlyZWRMdHJSZV8gPSAvXmh0dHA6XFwvXFwvLiovO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBzdHJpbmcgZWl0aGVyIGNvbnRhaW5zIG5vIHN0cm9uZ2x5IGRpcmVjdGlvbmFsXG4gICAqIGNoYXJhY3RlcnMgb3IgbG9va3MgbGlrZSBhIHVybC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgbmV1dHJhbCBkaXJlY3Rpb25hbGl0eSBpcyBkZXRlY3RlZC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzTmV1dHJhbFRleHQgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgc3RyID0gZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCk7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmlzUmVxdWlyZWRMdHJSZV8udGVzdChzdHIpIHx8ICFnb29nLmkxOG4uYmlkaS5oYXNBbnlMdHIoc3RyKSAmJiAhZ29vZy5pMThuLmJpZGkuaGFzQW55UnRsKHN0cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gY2hlY2sgaWYgdGhlIGxhc3Qgc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIGluIGFcbiAgICogcGllY2Ugb2YgdGV4dCBpcyBMVFIuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5sdHJFeGl0RGlyQ2hlY2tSZV8gPSBuZXcgUmVnRXhwKCdbJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddW14nICsgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfICsgJ10qJCcpO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBpbiBhXG4gICAqIHBpZWNlIG9mIHRleHQgaXMgUlRMLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsRXhpdERpckNoZWNrUmVfID0gbmV3IFJlZ0V4cCgnWycgKyBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gKyAnXVteJyArIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJzXyArICddKiQnKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV4aXQgZGlyZWN0aW9uYWxpdHkgYSBwaWVjZSBvZiB0ZXh0IGlzIExUUiwgaS5lLiBpZiB0aGUgbGFzdFxuICAgKiBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBMVFIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIExUUiBleGl0IGRpcmVjdGlvbmFsaXR5IHdhcyBkZXRlY3RlZC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVuZHNXaXRoTHRyID0gZnVuY3Rpb24gKHN0ciwgb3B0X2lzSHRtbCkge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5sdHJFeGl0RGlyQ2hlY2tSZV8udGVzdChnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBleGl0IGRpcmVjdGlvbmFsaXR5IGEgcGllY2Ugb2YgdGV4dCBpcyBMVFIsIGkuZS4gaWYgdGhlIGxhc3RcbiAgICogc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgTFRSLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyBiZWluZyBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBMVFIgZXhpdCBkaXJlY3Rpb25hbGl0eSB3YXMgZGV0ZWN0ZWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmRzV2l0aEx0ci5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzTHRyRXhpdFRleHQgPSBnb29nLmkxOG4uYmlkaS5lbmRzV2l0aEx0cjtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV4aXQgZGlyZWN0aW9uYWxpdHkgYSBwaWVjZSBvZiB0ZXh0IGlzIFJUTCwgaS5lLiBpZiB0aGUgbGFzdFxuICAgKiBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBSVEwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIFJUTCBleGl0IGRpcmVjdGlvbmFsaXR5IHdhcyBkZXRlY3RlZC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVuZHNXaXRoUnRsID0gZnVuY3Rpb24gKHN0ciwgb3B0X2lzSHRtbCkge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5ydGxFeGl0RGlyQ2hlY2tSZV8udGVzdChnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBleGl0IGRpcmVjdGlvbmFsaXR5IGEgcGllY2Ugb2YgdGV4dCBpcyBSVEwsIGkuZS4gaWYgdGhlIGxhc3RcbiAgICogc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgUlRMLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyBiZWluZyBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBSVEwgZXhpdCBkaXJlY3Rpb25hbGl0eSB3YXMgZGV0ZWN0ZWQuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBlbmRzV2l0aFJ0bC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzUnRsRXhpdFRleHQgPSBnb29nLmkxOG4uYmlkaS5lbmRzV2l0aFJ0bDtcblxuICAvKipcbiAgICogQSByZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHJpZ2h0LXRvLWxlZnQgbGFuZ3VhZ2UgY29kZXMuXG4gICAqIFNlZSB7QGxpbmsgI2lzUnRsTGFuZ3VhZ2V9IGZvciB0aGUgZGVzaWduLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsTG9jYWxlc1JlXyA9IG5ldyBSZWdFeHAoJ14oYXJ8Y2tifGR2fGhlfGl3fGZhfG5xb3xwc3xzZHx1Z3x1cnx5aXwnICsgJy4qWy1fXShBcmFifEhlYnJ8VGhhYXxOa29vfFRmbmcpKScgKyAnKD8hLipbLV9dKExhdG58Q3lybCkoJHwtfF8pKSgkfC18XyknLCAnaScpO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIEJDUCA0NyAvIElJSSBsYW5ndWFnZSBjb2RlIGluZGljYXRlcyBhbiBSVEwgbGFuZ3VhZ2UsIGkuZS4gZWl0aGVyOlxuICAgKiAtIGEgbGFuZ3VhZ2UgY29kZSBleHBsaWNpdGx5IHNwZWNpZnlpbmcgb25lIG9mIHRoZSByaWdodC10by1sZWZ0IHNjcmlwdHMsXG4gICAqICAgZS5nLiBcImF6LUFyYWJcIiwgb3I8cD5cbiAgICogLSBhIGxhbmd1YWdlIGNvZGUgc3BlY2lmeWluZyBvbmUgb2YgdGhlIGxhbmd1YWdlcyBub3JtYWxseSB3cml0dGVuIGluIGFcbiAgICogICByaWdodC10by1sZWZ0IHNjcmlwdCwgZS5nLiBcImZhXCIgKEZhcnNpKSwgZXhjZXB0IG9uZXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nXG4gICAqICAgTGF0aW4gb3IgQ3lyaWxsaWMgc2NyaXB0ICh3aGljaCBhcmUgdGhlIHVzdWFsIExUUiBhbHRlcm5hdGl2ZXMpLjxwPlxuICAgKiBUaGUgbGlzdCBvZiByaWdodC10by1sZWZ0IHNjcmlwdHMgYXBwZWFycyBpbiB0aGUgMTAwLTE5OSByYW5nZSBpblxuICAgKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL2lzbzE1OTI0L2lzbzE1OTI0LW51bS5odG1sLCBvZiB3aGljaCBBcmFiaWMgYW5kXG4gICAqIEhlYnJldyBhcmUgYnkgZmFyIHRoZSBtb3N0IHdpZGVseSB1c2VkLiBXZSBhbHNvIHJlY29nbml6ZSBUaGFhbmEsIE4nS28sIGFuZFxuICAgKiBUaWZpbmFnaCwgd2hpY2ggYWxzbyBoYXZlIHNpZ25pZmljYW50IG1vZGVybiB1c2FnZS4gVGhlIHJlc3QgKFN5cmlhYyxcbiAgICogU2FtYXJpdGFuLCBNYW5kYWljLCBldGMuKSBzZWVtIHRvIGhhdmUgZXh0cmVtZWx5IGxpbWl0ZWQgb3Igbm8gbW9kZXJuIHVzYWdlXG4gICAqIGFuZCBhcmUgbm90IHJlY29nbml6ZWQgdG8gc2F2ZSBvbiBjb2RlIHNpemUuXG4gICAqIFRoZSBsYW5ndWFnZXMgdXN1YWxseSB3cml0dGVuIGluIGEgcmlnaHQtdG8tbGVmdCBzY3JpcHQgYXJlIHRha2VuIGFzIHRob3NlXG4gICAqIHdpdGggU3VwcHJlc3MtU2NyaXB0OiBIZWJyfEFyYWJ8VGhhYXxOa29vfFRmbmcgIGluXG4gICAqIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5LFxuICAgKiBhcyB3ZWxsIGFzIENlbnRyYWwgKG9yIFNvcmFuaSkgS3VyZGlzaCAoY2tiKSwgU2luZGhpIChzZCkgYW5kIFV5Z2h1ciAodWcpLlxuICAgKiBPdGhlciBzdWJ0YWdzIG9mIHRoZSBsYW5ndWFnZSBjb2RlLCBlLmcuIHJlZ2lvbnMgbGlrZSBFRyAoRWd5cHQpLCBhcmVcbiAgICogaWdub3JlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgQkNQIDQ3IChhLmsuYSBJSUkpIGxhbmd1YWdlIGNvZGUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGxhbmd1YWdlIGNvZGUgaXMgYW4gUlRMIGxhbmd1YWdlLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNSdGxMYW5ndWFnZSA9IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLnJ0bExvY2FsZXNSZV8udGVzdChsYW5nKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBicmFja2V0IGd1YXJkIHJlcGxhY2VtZW50IGluIHRleHQuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5icmFja2V0R3VhcmRUZXh0UmVfID0gLyhcXCguKj9cXCkrKXwoXFxbLio/XFxdKyl8KFxcey4qP1xcfSspfCg8Lio/PispL2c7XG5cbiAgLyoqXG4gICAqIEFwcGx5IGJyYWNrZXQgZ3VhcmQgdXNpbmcgTFJNIGFuZCBSTE0uIFRoaXMgaXMgdG8gYWRkcmVzcyB0aGUgcHJvYmxlbSBvZlxuICAgKiBtZXNzeSBicmFja2V0IGRpc3BsYXkgZnJlcXVlbnRseSBoYXBwZW5zIGluIFJUTCBsYXlvdXQuXG4gICAqIFRoaXMgZnVuY3Rpb24gd29ya3MgZm9yIHBsYWluIHRleHQsIG5vdCBmb3IgSFRNTC4gSW4gSFRNTCwgdGhlIG9wZW5pbmdcbiAgICogYnJhY2tldCBtaWdodCBiZSBpbiBhIGRpZmZlcmVudCBjb250ZXh0IHRoYW4gdGhlIGNsb3NpbmcgYnJhY2tldCAoc3VjaCBhc1xuICAgKiBhbiBhdHRyaWJ1dGUgdmFsdWUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyBUaGUgc3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc1J0bENvbnRleHQgc3BlY2lmaWVzIGRlZmF1bHQgZGlyZWN0aW9uICh1c3VhbGx5XG4gICAqICAgICBkaXJlY3Rpb24gb2YgdGhlIFVJKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJvY2Vzc2VkIHN0cmluZywgd2l0aCBhbGwgYnJhY2tldCBndWFyZGVkLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZ3VhcmRCcmFja2V0SW5UZXh0ID0gZnVuY3Rpb24gKHMsIG9wdF9pc1J0bENvbnRleHQpIHtcbiAgICB2YXIgdXNlUnRsID0gb3B0X2lzUnRsQ29udGV4dCA9PT0gdW5kZWZpbmVkID8gZ29vZy5pMThuLmJpZGkuaGFzQW55UnRsKHMpIDogb3B0X2lzUnRsQ29udGV4dDtcbiAgICB2YXIgbWFyayA9IHVzZVJ0bCA/IGdvb2cuaTE4bi5iaWRpLkZvcm1hdC5STE0gOiBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuTFJNO1xuICAgIHJldHVybiBzLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkuYnJhY2tldEd1YXJkVGV4dFJlXywgbWFyayArICckJicgKyBtYXJrKTtcbiAgfTtcblxuICAvKipcbiAgICogRW5mb3JjZSB0aGUgaHRtbCBzbmlwcGV0IGluIFJUTCBkaXJlY3Rpb25hbGl0eSByZWdhcmRsZXNzIG92ZXJhbGwgY29udGV4dC5cbiAgICogSWYgdGhlIGh0bWwgcGllY2Ugd2FzIGVuY2xvc2VkIGJ5IHRhZywgZGlyIHdpbGwgYmUgYXBwbGllZCB0byBleGlzdGluZ1xuICAgKiB0YWcsIG90aGVyd2lzZSBhIHNwYW4gdGFnIHdpbGwgYmUgYWRkZWQgYXMgd3JhcHBlci4gRm9yIHRoaXMgcmVhc29uLCBpZlxuICAgKiBodG1sIHNuaXBwZXQgc3RhcnQgd2l0aCB3aXRoIHRhZywgdGhpcyB0YWcgbXVzdCBlbmNsb3NlIHRoZSB3aG9sZSBwaWVjZS4gSWZcbiAgICogdGhlIHRhZyBhbHJlYWR5IGhhcyBhIGRpciBzcGVjaWZpZWQsIHRoaXMgbmV3IG9uZSB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nXG4gICAqIG9uZSBpbiBiZWhhdmlvciAodGVzdGVkIG9uIEZGIGFuZCBJRSkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sIFRoZSBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHByb2Nlc3NlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJvY2Vzc2VkIHN0cmluZywgd2l0aCBkaXJlY3Rpb25hbGl0eSBlbmZvcmNlZCB0byBSVEwuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5lbmZvcmNlUnRsSW5IdG1sID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICBpZiAoaHRtbC5jaGFyQXQoMCkgPT0gJzwnKSB7XG4gICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC88XFx3Ky8sICckJiBkaXI9cnRsJyk7XG4gICAgfVxuICAgIC8vICdcXG4nIGlzIGltcG9ydGFudCBmb3IgRkYgc28gdGhhdCBpdCB3b24ndCBpbmNvcnJlY3RseSBtZXJnZSBzcGFuIGdyb3Vwc1xuICAgIHJldHVybiAnXFxuPHNwYW4gZGlyPXJ0bD4nICsgaHRtbCArICc8L3NwYW4+JztcbiAgfTtcblxuICAvKipcbiAgICogRW5mb3JjZSBSVEwgb24gYm90aCBlbmQgb2YgdGhlIGdpdmVuIHRleHQgcGllY2UgdXNpbmcgdW5pY29kZSBCaURpIGZvcm1hdHRpbmdcbiAgICogY2hhcmFjdGVycyBSTEUgYW5kIFBERi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHBpZWNlIG9mIHRleHQgdGhhdCBuZWVkIHRvIGJlIHdyYXBwZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHdyYXBwZWQgc3RyaW5nIGFmdGVyIHByb2Nlc3MuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5lbmZvcmNlUnRsSW5UZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkuRm9ybWF0LlJMRSArIHRleHQgKyBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuUERGO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmZvcmNlIHRoZSBodG1sIHNuaXBwZXQgaW4gUlRMIGRpcmVjdGlvbmFsaXR5IHJlZ2FyZGxlc3Mgb3ZlcmFsbCBjb250ZXh0LlxuICAgKiBJZiB0aGUgaHRtbCBwaWVjZSB3YXMgZW5jbG9zZWQgYnkgdGFnLCBkaXIgd2lsbCBiZSBhcHBsaWVkIHRvIGV4aXN0aW5nXG4gICAqIHRhZywgb3RoZXJ3aXNlIGEgc3BhbiB0YWcgd2lsbCBiZSBhZGRlZCBhcyB3cmFwcGVyLiBGb3IgdGhpcyByZWFzb24sIGlmXG4gICAqIGh0bWwgc25pcHBldCBzdGFydCB3aXRoIHdpdGggdGFnLCB0aGlzIHRhZyBtdXN0IGVuY2xvc2UgdGhlIHdob2xlIHBpZWNlLiBJZlxuICAgKiB0aGUgdGFnIGFscmVhZHkgaGFzIGEgZGlyIHNwZWNpZmllZCwgdGhpcyBuZXcgb25lIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmdcbiAgICogb25lIGluIGJlaGF2aW9yICh0ZXN0ZWQgb24gRkYgYW5kIElFKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgVGhlIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgcHJvY2Vzc2VkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgc3RyaW5nLCB3aXRoIGRpcmVjdGlvbmFsaXR5IGVuZm9yY2VkIHRvIFJUTC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVuZm9yY2VMdHJJbkh0bWwgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgIGlmIChodG1sLmNoYXJBdCgwKSA9PSAnPCcpIHtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxcXHcrLywgJyQmIGRpcj1sdHInKTtcbiAgICB9XG4gICAgLy8gJ1xcbicgaXMgaW1wb3J0YW50IGZvciBGRiBzbyB0aGF0IGl0IHdvbid0IGluY29ycmVjdGx5IG1lcmdlIHNwYW4gZ3JvdXBzXG4gICAgcmV0dXJuICdcXG48c3BhbiBkaXI9bHRyPicgKyBodG1sICsgJzwvc3Bhbj4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmZvcmNlIExUUiBvbiBib3RoIGVuZCBvZiB0aGUgZ2l2ZW4gdGV4dCBwaWVjZSB1c2luZyB1bmljb2RlIEJpRGkgZm9ybWF0dGluZ1xuICAgKiBjaGFyYWN0ZXJzIExSRSBhbmQgUERGLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgcGllY2Ugb2YgdGV4dCB0aGF0IG5lZWQgdG8gYmUgd3JhcHBlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgd3JhcHBlZCBzdHJpbmcgYWZ0ZXIgcHJvY2Vzcy5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVuZm9yY2VMdHJJblRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuTFJFICsgdGV4dCArIGdvb2cuaTE4bi5iaWRpLkZvcm1hdC5QREY7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaW5kIGRpbWVuc2lvbnMgc3VjaCBhcyBcInBhZGRpbmc6IC4zIDAuNGV4IDVweCA2O1wiXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5kaW1lbnNpb25zUmVfID0gLzpcXHMqKFsuXFxkXVsuXFx3XSopXFxzKyhbLlxcZF1bLlxcd10qKVxccysoWy5cXGRdWy5cXHddKilcXHMrKFsuXFxkXVsuXFx3XSopL2c7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbGVmdC5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmxlZnRSZV8gPSAvbGVmdC9naTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIGZvciByaWdodC5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnJpZ2h0UmVfID0gL3JpZ2h0L2dpO1xuXG4gIC8qKlxuICAgKiBQbGFjZWhvbGRlciByZWd1bGFyIGV4cHJlc3Npb24gZm9yIHN3YXBwaW5nLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkudGVtcFJlXyA9IC8lJSUlL2c7XG5cbiAgLyoqXG4gICAqIFN3YXAgbG9jYXRpb24gcGFyYW1ldGVycyBhbmQgJ2xlZnQnLydyaWdodCcgaW4gQ1NTIHNwZWNpZmljYXRpb24uIFRoZVxuICAgKiBwcm9jZXNzZWQgc3RyaW5nIHdpbGwgYmUgc3VpdGVkIGZvciBSVEwgbGF5b3V0LiBUaG91Z2ggdGhpcyBmdW5jdGlvbiBjYW5cbiAgICogY292ZXIgbW9zdCBjYXNlcywgdGhlcmUgYXJlIGFsd2F5cyBleGNlcHRpb25zLiBJdCBpcyBzdWdnZXN0ZWQgdG8gcHV0XG4gICAqIHRob3NlIGV4Y2VwdGlvbnMgaW4gc2VwYXJhdGUgZ3JvdXAgb2YgQ1NTIHN0cmluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1N0ciBDU1Mgc3BlZmljYXRpb24gc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1Mgc3BlY2lmaWNhdGlvbiBzdHJpbmcuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5taXJyb3JDU1MgPSBmdW5jdGlvbiAoY3NzU3RyKSB7XG4gICAgcmV0dXJuIGNzc1N0ci5cbiAgICAvLyByZXZlcnNlIGRpbWVuc2lvbnNcbiAgICByZXBsYWNlKGdvb2cuaTE4bi5iaWRpLmRpbWVuc2lvbnNSZV8sICc6JDEgJDQgJDMgJDInKS5yZXBsYWNlKGdvb2cuaTE4bi5iaWRpLmxlZnRSZV8sICclJSUlJykuIC8vIHN3YXAgbGVmdCBhbmQgcmlnaHRcbiAgICByZXBsYWNlKGdvb2cuaTE4bi5iaWRpLnJpZ2h0UmVfLCBnb29nLmkxOG4uYmlkaS5MRUZUKS5yZXBsYWNlKGdvb2cuaTE4bi5iaWRpLnRlbXBSZV8sIGdvb2cuaTE4bi5iaWRpLlJJR0hUKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBoZWJyZXcgZG91YmxlIHF1b3RlIHN1YnN0aXR1dGlvbiwgZmluZGluZyBxdW90ZVxuICAgKiBkaXJlY3RseSBhZnRlciBoZWJyZXcgY2hhcmFjdGVycy5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmRvdWJsZVF1b3RlU3Vic3RpdHV0ZVJlXyA9IC8oW1xcdTA1OTEtXFx1MDVmMl0pXCIvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBoZWJyZXcgc2luZ2xlIHF1b3RlIHN1YnN0aXR1dGlvbiwgZmluZGluZyBxdW90ZVxuICAgKiBkaXJlY3RseSBhZnRlciBoZWJyZXcgY2hhcmFjdGVycy5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnNpbmdsZVF1b3RlU3Vic3RpdHV0ZVJlXyA9IC8oW1xcdTA1OTEtXFx1MDVmMl0pJy9nO1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBkb3VibGUgYW5kIHNpbmdsZSBxdW90ZSBkaXJlY3RseSBhZnRlciBhIEhlYnJldyBjaGFyYWN0ZXIgd2l0aFxuICAgKiBHRVJFU0ggYW5kIEdFUlNIQVlJTS4gSW4gc3VjaCBjYXNlLCBtb3N0IGxpa2VseSB0aGF0J3MgdXNlciBpbnRlbnRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUHJvY2Vzc2VkIHN0cmluZyB3aXRoIGRvdWJsZS9zaW5nbGUgcXVvdGUgcmVwbGFjZWQuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5ub3JtYWxpemVIZWJyZXdRdW90ZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkuZG91YmxlUXVvdGVTdWJzdGl0dXRlUmVfLCAnJDFcXHUwNUY0JykucmVwbGFjZShnb29nLmkxOG4uYmlkaS5zaW5nbGVRdW90ZVN1YnN0aXR1dGVSZV8sICckMVxcdTA1RjMnKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRvIHNwbGl0IGEgc3RyaW5nIGludG8gXCJ3b3Jkc1wiIGZvciBkaXJlY3Rpb25hbGl0eVxuICAgKiBlc3RpbWF0aW9uIGJhc2VkIG9uIHJlbGF0aXZlIHdvcmQgY291bnRzLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkud29yZFNlcGFyYXRvclJlXyA9IC9cXHMrLztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRvIGNoZWNrIGlmIGEgc3RyaW5nIGNvbnRhaW5zIGFueSBudW1lcmFscy4gVXNlZCB0b1xuICAgKiBkaWZmZXJlbnRpYXRlIGJldHdlZW4gY29tcGxldGVseSBuZXV0cmFsIHN0cmluZ3MgYW5kIHRob3NlIGNvbnRhaW5pbmdcbiAgICogbnVtYmVycywgd2hpY2ggYXJlIHdlYWtseSBMVFIuXG4gICAqXG4gICAqIE5hdGl2ZSBBcmFiaWMgZGlnaXRzIChcXHUwNjYwIC0gXFx1MDY2OSkgYXJlIG5vdCBpbmNsdWRlZCBiZWNhdXNlIGFsdGhvdWdoIHRoZXlcbiAgICogZG8gZmxvdyBsZWZ0LXRvLXJpZ2h0IGluc2lkZSBhIG51bWJlciwgdGhpcyBpcyB0aGUgY2FzZSBldmVuIGlmIHRoZSAgb3ZlcmFsbFxuICAgKiBkaXJlY3Rpb25hbGl0eSBpcyBSVEwsIGFuZCBhIG1hdGhlbWF0aWNhbCBleHByZXNzaW9uIHVzaW5nIHRoZXNlIGRpZ2l0cyBpc1xuICAgKiBzdXBwb3NlZCB0byBmbG93IHJpZ2h0LXRvLWxlZnQgb3ZlcmFsbCwgaW5jbHVkaW5nIHVuYXJ5IHBsdXMgYW5kIG1pbnVzXG4gICAqIGFwcGVhcmluZyB0byB0aGUgcmlnaHQgb2YgYSBudW1iZXIsIGFuZCB0aGlzIGRvZXMgZGVwZW5kIG9uIHRoZSBvdmVyYWxsXG4gICAqIGRpcmVjdGlvbmFsaXR5IGJlaW5nIFJUTC4gVGhlIGRpZ2l0cyB1c2VkIGluIEZhcnNpIChcXHUwNkYwIC0gXFx1MDZGOSksIG9uIHRoZVxuICAgKiBvdGhlciBoYW5kLCBhcmUgaW5jbHVkZWQsIHNpbmNlIEZhcnNpIG1hdGggKGluY2x1ZGluZyB1bmFyeSBwbHVzIGFuZCBtaW51cylcbiAgICogZG9lcyBmbG93IGxlZnQtdG8tcmlnaHQuXG4gICAqXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5oYXNOdW1lcmFsc1JlXyA9IC9bXFxkXFx1MDZmMC1cXHUwNmY5XS87XG5cbiAgLyoqXG4gICAqIFRoaXMgY29uc3RhbnQgY29udHJvbHMgdGhyZXNob2xkIG9mIFJUTCBkaXJlY3Rpb25hbGl0eS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnJ0bERldGVjdGlvblRocmVzaG9sZF8gPSAwLjQwO1xuXG4gIC8qKlxuICAgKiBFc3RpbWF0ZXMgdGhlIGRpcmVjdGlvbmFsaXR5IG9mIGEgc3RyaW5nIGJhc2VkIG9uIHJlbGF0aXZlIHdvcmQgY291bnRzLlxuICAgKiBJZiB0aGUgbnVtYmVyIG9mIFJUTCB3b3JkcyBpcyBhYm92ZSBhIGNlcnRhaW4gcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgbnVtYmVyXG4gICAqIG9mIHN0cm9uZ2x5IGRpcmVjdGlvbmFsIHdvcmRzLCByZXR1cm5zIFJUTC5cbiAgICogT3RoZXJ3aXNlLCBpZiBhbnkgd29yZHMgYXJlIHN0cm9uZ2x5IG9yIHdlYWtseSBMVFIsIHJldHVybnMgTFRSLlxuICAgKiBPdGhlcndpc2UsIHJldHVybnMgVU5LTk9XTiwgd2hpY2ggaXMgdXNlZCB0byBtZWFuIFwibmV1dHJhbFwiLlxuICAgKiBOdW1iZXJzIGFyZSBjb3VudGVkIGFzIHdlYWtseSBMVFIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBiZSBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Z29vZy5pMThuLmJpZGkuRGlyfSBFc3RpbWF0ZWQgb3ZlcmFsbCBkaXJlY3Rpb25hbGl0eSBvZiB7QGNvZGUgc3RyfS5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVzdGltYXRlRGlyZWN0aW9uID0gZnVuY3Rpb24gKHN0ciwgb3B0X2lzSHRtbCkge1xuICAgIHZhciBydGxDb3VudCA9IDA7XG4gICAgdmFyIHRvdGFsQ291bnQgPSAwO1xuICAgIHZhciBoYXNXZWFrbHlMdHIgPSBmYWxzZTtcbiAgICB2YXIgdG9rZW5zID0gZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkuc3BsaXQoZ29vZy5pMThuLmJpZGkud29yZFNlcGFyYXRvclJlXyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgIGlmIChnb29nLmkxOG4uYmlkaS5zdGFydHNXaXRoUnRsKHRva2VuKSkge1xuICAgICAgICBydGxDb3VudCsrO1xuICAgICAgICB0b3RhbENvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKGdvb2cuaTE4bi5iaWRpLmlzUmVxdWlyZWRMdHJSZV8udGVzdCh0b2tlbikpIHtcbiAgICAgICAgaGFzV2Vha2x5THRyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ29vZy5pMThuLmJpZGkuaGFzQW55THRyKHRva2VuKSkge1xuICAgICAgICB0b3RhbENvdW50Kys7XG4gICAgICB9IGVsc2UgaWYgKGdvb2cuaTE4bi5iaWRpLmhhc051bWVyYWxzUmVfLnRlc3QodG9rZW4pKSB7XG4gICAgICAgIGhhc1dlYWtseUx0ciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvdGFsQ291bnQgPT0gMCA/IGhhc1dlYWtseUx0ciA/IGdvb2cuaTE4bi5iaWRpLkRpci5MVFIgOiBnb29nLmkxOG4uYmlkaS5EaXIuTkVVVFJBTCA6IHJ0bENvdW50IC8gdG90YWxDb3VudCA+IGdvb2cuaTE4bi5iaWRpLnJ0bERldGVjdGlvblRocmVzaG9sZF8gPyBnb29nLmkxOG4uYmlkaS5EaXIuUlRMIDogZ29vZy5pMThuLmJpZGkuRGlyLkxUUjtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgdGhlIGRpcmVjdGlvbmFsaXR5IG9mIGEgcGllY2Ugb2YgdGV4dCwgcmV0dXJuIHRydWUgaWYgdGhlIHBpZWNlIG9mXG4gICAqIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IGluIFJUTCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHBpZWNlIG9mIHRleHQgdGhhdCBuZWVkIHRvIGJlIGRldGVjdGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIHBpZWNlIG9mIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IGluIFJUTC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmRldGVjdFJ0bERpcmVjdGlvbmFsaXR5ID0gZnVuY3Rpb24gKHN0ciwgb3B0X2lzSHRtbCkge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5lc3RpbWF0ZURpcmVjdGlvbihzdHIsIG9wdF9pc0h0bWwpID09IGdvb2cuaTE4bi5iaWRpLkRpci5SVEw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgdGV4dCBpbnB1dCBlbGVtZW50J3MgZGlyZWN0aW9uYWxpdHkgYW5kIHRleHQgYWxpZ25tZW50IGJhc2VkIG9uIGFcbiAgICogZ2l2ZW4gZGlyZWN0aW9uYWxpdHkuIERvZXMgbm90aGluZyBpZiB0aGUgZ2l2ZW4gZGlyZWN0aW9uYWxpdHkgaXMgdW5rbm93biBvclxuICAgKiBuZXV0cmFsLlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgSW5wdXQgZmllbGQgZWxlbWVudCB0byBzZXQgZGlyZWN0aW9uYWxpdHkgdG8uXG4gICAqIEBwYXJhbSB7Z29vZy5pMThuLmJpZGkuRGlyfG51bWJlcnxib29sZWFufG51bGx9IGRpciBEZXNpcmVkIGRpcmVjdGlvbmFsaXR5LFxuICAgKiAgICAgZ2l2ZW4gaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAgICogICAgIDEuIEEgZ29vZy5pMThuLmJpZGkuRGlyIGNvbnN0YW50LlxuICAgKiAgICAgMi4gQSBudW1iZXIgKHBvc2l0aXZlID0gTFJULCBuZWdhdGl2ZSA9IFJUTCwgMCA9IG5ldXRyYWwpLlxuICAgKiAgICAgMy4gQSBib29sZWFuICh0cnVlID0gUlRMLCBmYWxzZSA9IExUUikuXG4gICAqICAgICA0LiBBIG51bGwgZm9yIHVua25vd24gZGlyZWN0aW9uYWxpdHkuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5zZXRFbGVtZW50RGlyQW5kQWxpZ24gPSBmdW5jdGlvbiAoZWxlbWVudCwgZGlyKSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGRpciA9IGdvb2cuaTE4bi5iaWRpLnRvRGlyKGRpcik7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZGlyID09IGdvb2cuaTE4bi5iaWRpLkRpci5SVEwgPyBnb29nLmkxOG4uYmlkaS5SSUdIVCA6IGdvb2cuaTE4bi5iaWRpLkxFRlQ7XG4gICAgICAgIGVsZW1lbnQuZGlyID0gZGlyID09IGdvb2cuaTE4bi5iaWRpLkRpci5SVEwgPyAncnRsJyA6ICdsdHInO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBlbGVtZW50IGRpciBiYXNlZCBvbiBlc3RpbWF0ZWQgZGlyZWN0aW9uYWxpdHkgb2YgdGhlIGdpdmVuIHRleHQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnNldEVsZW1lbnREaXJCeVRleHREaXJlY3Rpb25hbGl0eSA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZXh0KSB7XG4gICAgc3dpdGNoIChnb29nLmkxOG4uYmlkaS5lc3RpbWF0ZURpcmVjdGlvbih0ZXh0KSkge1xuICAgICAgY2FzZSBnb29nLmkxOG4uYmlkaS5EaXIuTFRSOlxuICAgICAgICBlbGVtZW50LmRpciA9ICdsdHInO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ29vZy5pMThuLmJpZGkuRGlyLlJUTDpcbiAgICAgICAgZWxlbWVudC5kaXIgPSAncnRsJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBEZWZhdWx0IGZvciBubyBkaXJlY3Rpb24sIGluaGVyaXQgZnJvbSBkb2N1bWVudC5cbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RpcicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU3RyaW5ncyB0aGF0IGhhdmUgYW4gKG9wdGlvbmFsKSBrbm93biBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGludGVyZmFjZSBhcmUgc3RyaW5nLWxpa2Ugb2JqZWN0cyB0aGF0IGNhcnJ5IGFuXG4gICAqIGF0dGFjaGVkIGRpcmVjdGlvbiwgaWYga25vd24uXG4gICAqIEBpbnRlcmZhY2VcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLkRpcmVjdGlvbmFsU3RyaW5nID0gZnVuY3Rpb24gKCkge307XG5cbiAgLyoqXG4gICAqIEludGVyZmFjZSBtYXJrZXIgb2YgdGhlIERpcmVjdGlvbmFsU3RyaW5nIGludGVyZmFjZS5cbiAgICpcbiAgICogVGhpcyBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgYXQgcnVudGltZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3RcbiAgICogaW1wbGVtZW50cyB0aGlzIGludGVyZmFjZS4gIEFsbCBpbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBpbnRlcmZhY2Ugc2V0IHRoaXNcbiAgICogcHJvcGVydHkgdG8ge0Bjb2RlIHRydWV9LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLkRpcmVjdGlvbmFsU3RyaW5nLnByb3RvdHlwZS5pbXBsZW1lbnRzR29vZ0kxOG5CaWRpRGlyZWN0aW9uYWxTdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGlzIG9iamVjdCdzIGtub3duIGRpcmVjdGlvbiAoaWYgYW55KS5cbiAgICogQHJldHVybiB7P2dvb2cuaTE4bi5iaWRpLkRpcn0gVGhlIGtub3duIGRpcmVjdGlvbi4gTnVsbCBpZiB1bmtub3duLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuRGlyZWN0aW9uYWxTdHJpbmcucHJvdG90eXBlLmdldERpcmVjdGlvbjtcblxuICAvLyBDb3B5cmlnaHQgMjAwOCBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gIC8vXG4gIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIC8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gIC8vXG4gIC8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gIC8vXG4gIC8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICAvLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAvLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAvKipcbiAgICogQGZpbGVvdmVydmlldyBVdGlsaXRpZXMgdG8gY2hlY2sgdGhlIHByZWNvbmRpdGlvbnMsIHBvc3Rjb25kaXRpb25zIGFuZFxuICAgKiBpbnZhcmlhbnRzIHJ1bnRpbWUuXG4gICAqXG4gICAqIE1ldGhvZHMgaW4gdGhpcyBwYWNrYWdlIHNob3VsZCBiZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBieSB0aGUgY29tcGlsZXJcbiAgICogZm9yIHR5cGUtaW5mZXJlbmNlLiBGb3IgZXhhbXBsZSwgPGNvZGU+Z29vZy5hc3NlcnRzLmFzc2VydChmb28pPC9jb2RlPlxuICAgKiB3aWxsIHJlc3RyaWN0IDxjb2RlPmZvbzwvY29kZT4gdG8gYSB0cnV0aHkgdmFsdWUuXG4gICAqXG4gICAqIFRoZSBjb21waWxlciBoYXMgYW4gb3B0aW9uIHRvIGRpc2FibGUgYXNzZXJ0cy4gU28gY29kZSBsaWtlOlxuICAgKiA8Y29kZT5cbiAgICogdmFyIHggPSBnb29nLmFzc2VydHMuYXNzZXJ0KGZvbygpKTsgZ29vZy5hc3NlcnRzLmFzc2VydChiYXIoKSk7XG4gICAqIDwvY29kZT5cbiAgICogd2lsbCBiZSB0cmFuc2Zvcm1lZCBpbnRvOlxuICAgKiA8Y29kZT5cbiAgICogdmFyIHggPSBmb28oKTtcbiAgICogPC9jb2RlPlxuICAgKiBUaGUgY29tcGlsZXIgd2lsbCBsZWF2ZSBpbiBmb28oKSAoYmVjYXVzZSBpdHMgcmV0dXJuIHZhbHVlIGlzIHVzZWQpLFxuICAgKiBidXQgaXQgd2lsbCByZW1vdmUgYmFyKCkgYmVjYXVzZSBpdCBhc3N1bWVzIGl0IGRvZXMgbm90IGhhdmUgc2lkZS1lZmZlY3RzLlxuICAgKlxuICAgKiBAYXV0aG9yIGFncmlldmVAZ29vZ2xlLmNvbSAoQW5kcmV3IEdyaWV2ZSlcbiAgICovXG5cbiAgZ29vZy5wcm92aWRlKCdnb29nLmFzc2VydHMnKTtcblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0byBzdHJpcCBvdXQgYXNzZXJ0cyBvciB0byBsZWF2ZSB0aGVtIGluLlxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUycsIGdvb2cuREVCVUcpO1xuXG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgZm9yIGZhaWxlZCBhc3NlcnRpb25zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVBhdHRlcm4gVGhlIHBhdHRlcm4gdGhhdCB3YXMgdXNlZCB0byBmb3JtIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBtZXNzYWdlQXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBwYXR0ZXJuLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge2dvb2cuZGVidWcuRXJyb3J9XG4gICAqIEBmaW5hbFxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2VQYXR0ZXJuLCBtZXNzYWdlQXJncykge1xuICAgIG1lc3NhZ2VBcmdzLnVuc2hpZnQobWVzc2FnZVBhdHRlcm4pO1xuICAgIGdvb2cuZGVidWcuRXJyb3IuY2FsbCh0aGlzLCBnb29nLnN0cmluZy5zdWJzLmFwcGx5KG51bGwsIG1lc3NhZ2VBcmdzKSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBtZXNzYWdlUGF0dGVybiBhZnRlcndhcmRzIHRvIGF2b2lkIHBlcm1hbmVudGx5IG1vZGlmeWluZyB0aGVcbiAgICAvLyBwYXNzZWQgaW4gYXJyYXkuXG4gICAgbWVzc2FnZUFyZ3Muc2hpZnQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXNzYWdlIHBhdHRlcm4gdXNlZCB0byBmb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2UuIEVycm9yIGhhbmRsZXJzIGNhblxuICAgICAqIHVzZSB0aGlzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBhc3NlcnRpb24uXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2VQYXR0ZXJuID0gbWVzc2FnZVBhdHRlcm47XG4gIH07XG4gIGdvb2cuaW5oZXJpdHMoZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yLCBnb29nLmRlYnVnLkVycm9yKTtcblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvci5wcm90b3R5cGUubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGVycm9yIGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7IWdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gZSBUaGUgZXhjZXB0aW9uIHRvIGJlIGhhbmRsZWQuXG4gICAqL1xuICBnb29nLmFzc2VydHMuREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24gKGUpIHtcbiAgICB0aHJvdyBlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgaGFuZGxlciByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgb3IgbG9nZ2luZyBhc3NlcnRpb24gZXJyb3JzLlxuICAgKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIWdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcil9XG4gICAqL1xuICBnb29nLmFzc2VydHMuZXJyb3JIYW5kbGVyXyA9IGdvb2cuYXNzZXJ0cy5ERUZBVUxUX0VSUk9SX0hBTkRMRVI7XG5cbiAgLyoqXG4gICAqIFRocm93cyBhbiBleGNlcHRpb24gd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZSBhbmQgXCJBc3NlcnRpb24gZmFpbGVkXCIgcHJlZml4ZWRcbiAgICogb250byBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRNZXNzYWdlIFRoZSBtZXNzYWdlIHRvIHVzZSBpZiBnaXZlbk1lc3NhZ2UgaXMgZW1wdHkuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGRlZmF1bHRBcmdzIFRoZSBzdWJzdGl0dXRpb24gYXJndW1lbnRzIGZvciBkZWZhdWx0TWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBnaXZlbk1lc3NhZ2UgTWVzc2FnZSBzdXBwbGllZCBieSB0aGUgY2FsbGVyLlxuICAgKiBAcGFyYW0ge0FycmF5PCo+fSBnaXZlbkFyZ3MgVGhlIHN1YnN0aXR1dGlvbiBhcmd1bWVudHMgZm9yIGdpdmVuTWVzc2FnZS5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXyA9IGZ1bmN0aW9uIChkZWZhdWx0TWVzc2FnZSwgZGVmYXVsdEFyZ3MsIGdpdmVuTWVzc2FnZSwgZ2l2ZW5BcmdzKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZCc7XG4gICAgaWYgKGdpdmVuTWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgZ2l2ZW5NZXNzYWdlO1xuICAgICAgdmFyIGFyZ3MgPSBnaXZlbkFyZ3M7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0TWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgZGVmYXVsdE1lc3NhZ2U7XG4gICAgICBhcmdzID0gZGVmYXVsdEFyZ3M7XG4gICAgfVxuICAgIC8vIFRoZSAnJyArIHdvcmtzIGFyb3VuZCBhbiBPcGVyYSAxMCBidWcgaW4gdGhlIHVuaXQgdGVzdHMuIFdpdGhvdXQgaXQsXG4gICAgLy8gYSBzdGFjayB0cmFjZSBpcyBhZGRlZCB0byB2YXIgbWVzc2FnZSBhYm92ZS4gV2l0aCB0aGlzLCBhIHN0YWNrIHRyYWNlIGlzXG4gICAgLy8gbm90IGFkZGVkIHVudGlsIHRoaXMgbGluZSAoaXQgY2F1c2VzIHRoZSBleHRyYSBnYXJiYWdlIHRvIGJlIGFkZGVkIGFmdGVyXG4gICAgLy8gdGhlIGFzc2VydGlvbiBtZXNzYWdlIGluc3RlYWQgb2YgaW4gdGhlIG1pZGRsZSBvZiBpdCkuXG4gICAgdmFyIGUgPSBuZXcgZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKCcnICsgbWVzc2FnZSwgYXJncyB8fCBbXSk7XG4gICAgZ29vZy5hc3NlcnRzLmVycm9ySGFuZGxlcl8oZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldHMgYSBjdXN0b20gZXJyb3IgaGFuZGxlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3Igb2ZcbiAgICogYXNzZXJ0aW9uIGZhaWx1cmVzLCBmb3IgZXhhbXBsZSBieSB0dXJuaW5nIGFsbCBhc3NlcnRpb24gZmFpbHVyZXMgaW50byBsb2dcbiAgICogbWVzc2FnZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIWdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcil9IGVycm9ySGFuZGxlclxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLnNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnJvckhhbmRsZXIpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTKSB7XG4gICAgICBnb29nLmFzc2VydHMuZXJyb3JIYW5kbGVyXyA9IGVycm9ySGFuZGxlcjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byB0cnVlIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpc1xuICAgKiB0cnVlLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge1R9IGNvbmRpdGlvbiBUaGUgY29uZGl0aW9uIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7VH0gVGhlIHZhbHVlIG9mIHRoZSBjb25kaXRpb24uXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgY29uZGl0aW9uIGV2YWx1YXRlcyB0byBmYWxzZS5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnQgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFjb25kaXRpb24pIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCcnLCBudWxsLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiBjb25kaXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIEZhaWxzIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHdoZW4gd2Ugd2FudCB0byBhZGQgYSBjaGVjayBpbiB0aGUgdW5yZWFjaGFibGUgYXJlYSBsaWtlIHN3aXRjaC1jYXNlXG4gICAqIHN0YXRlbWVudDpcbiAgICpcbiAgICogPHByZT5cbiAgICogIHN3aXRjaCh0eXBlKSB7XG4gICAqICAgIGNhc2UgRk9POiBkb1NvbWV0aGluZygpOyBicmVhaztcbiAgICogICAgY2FzZSBCQVI6IGRvU29tZXRoaW5nRWxzZSgpOyBicmVhaztcbiAgICogICAgZGVmYXVsdDogZ29vZy5hc3NlcnQuZmFpbCgnVW5yZWNvZ25pemVkIHR5cGU6ICcgKyB0eXBlKTtcbiAgICogICAgICAvLyBXZSBoYXZlIG9ubHkgMiB0eXBlcyAtIFwiZGVmYXVsdDpcIiBzZWN0aW9uIGlzIHVucmVhY2hhYmxlIGNvZGUuXG4gICAqICB9XG4gICAqIDwvcHJlPlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBGYWlsdXJlLlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmZhaWwgPSBmdW5jdGlvbiAob3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUykge1xuICAgICAgZ29vZy5hc3NlcnRzLmVycm9ySGFuZGxlcl8obmV3IGdvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcignRmFpbHVyZScgKyAob3B0X21lc3NhZ2UgPyAnOiAnICsgb3B0X21lc3NhZ2UgOiAnJyksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBudW1iZXIgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBudW1iZXIgd2hlbiBhc3NlcnRzIGVuYWJsZWQuXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGEgbnVtYmVyLlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydE51bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc051bWJlcih2YWx1ZSkpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBudW1iZXIgYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiAoLyoqIEB0eXBlIHtudW1iZXJ9ICovdmFsdWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgc3RyaW5nIHdoZW4gYXNzZXJ0cyBlbmFibGVkLlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIHN0cmluZy5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnRTdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgc3RyaW5nIGJ1dCBnb3QgJXM6ICVzLicsIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7c3RyaW5nfSAqL3ZhbHVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn0gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgZnVuY3Rpb24gd2hlbiBhc3NlcnRzXG4gICAqICAgICBlbmFibGVkLlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydEZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgZnVuY3Rpb24gYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiAoLyoqIEB0eXBlIHshRnVuY3Rpb259ICovdmFsdWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIE9iamVjdCBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBub24tbnVsbCBvYmplY3QuXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGFuIG9iamVjdC5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnRPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgb2JqZWN0IGJ1dCBnb3QgJXM6ICVzLicsIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7IU9iamVjdH0gKi92YWx1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYW4gQXJyYXkgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7IUFycmF5PD8+fSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBub24tbnVsbCBhcnJheS5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gYXJyYXkuXG4gICAqL1xuICBnb29nLmFzc2VydHMuYXNzZXJ0QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBhcnJheSBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuICgvKiogQHR5cGUgeyFBcnJheTw/Pn0gKi92YWx1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIGJvb2xlYW4gd2hlbiBhc3NlcnRzIGFyZVxuICAgKiAgICAgZW5hYmxlZC5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBib29sZWFuLlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydEJvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oJ0V4cGVjdGVkIGJvb2xlYW4gYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiAoLyoqIEB0eXBlIHtib29sZWFufSAqL3ZhbHVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIERPTSBFbGVtZW50IGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgdmFsdWUsIGxpa2VseSB0byBiZSBhIERPTSBFbGVtZW50IHdoZW4gYXNzZXJ0cyBhcmVcbiAgICogICAgIGVuYWJsZWQuXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGFuIEVsZW1lbnQuXG4gICAqL1xuICBnb29nLmFzc2VydHMuYXNzZXJ0RWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAoIWdvb2cuaXNPYmplY3QodmFsdWUpIHx8IHZhbHVlLm5vZGVUeXBlICE9IGdvb2cuZG9tLk5vZGVUeXBlLkVMRU1FTlQpKSB7XG4gICAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgRWxlbWVudCBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuICgvKiogQHR5cGUgeyFFbGVtZW50fSAqL3ZhbHVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgdXNlci1kZWZpbmVkIHR5cGUgaWZcbiAgICogZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqXG4gICAqIFRoZSBjb21waWxlciBtYXkgdGlnaHRlbiB0aGUgdHlwZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gez99IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6IFQsIC4uLil9IHR5cGUgQSB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhbiBpbnN0YW5jZSBvZlxuICAgKiAgICAgdHlwZS5cbiAgICogQHJldHVybiB7VH1cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnRJbnN0YW5jZW9mID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICEodmFsdWUgaW5zdGFuY2VvZiB0eXBlKSkge1xuICAgICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oJ0V4cGVjdGVkIGluc3RhbmNlb2YgJXMgYnV0IGdvdCAlcy4nLCBbZ29vZy5hc3NlcnRzLmdldFR5cGVfKHR5cGUpLCBnb29nLmFzc2VydHMuZ2V0VHlwZV8odmFsdWUpXSwgb3B0X21lc3NhZ2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGF0IG5vIGVudW1lcmFibGUga2V5cyBhcmUgcHJlc2VudCBpbiBPYmplY3QucHJvdG90eXBlLiBTdWNoIGtleXNcbiAgICogd291bGQgYnJlYWsgbW9zdCBjb2RlIHRoYXQgdXNlIHtAY29kZSBmb3IgKHZhciAuLi4gaW4gLi4uKX0gbG9vcHMuXG4gICAqL1xuICBnb29nLmFzc2VydHMuYXNzZXJ0T2JqZWN0UHJvdG90eXBlSXNJbnRhY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKGtleSArICcgc2hvdWxkIG5vdCBiZSBlbnVtZXJhYmxlIGluIE9iamVjdC5wcm90b3R5cGUuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgdmFsdWUuIElmIGEgY29uc3RydWN0b3IgaXMgcGFzc2VkLCBhbmQgYSBzdWl0YWJsZVxuICAgKiBzdHJpbmcgY2Fubm90IGJlIGZvdW5kLCAndW5rbm93biB0eXBlIG5hbWUnIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgQSBjb25zdHJ1Y3Rvciwgb2JqZWN0LCBvciBwcmltaXRpdmUuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGJlc3QgZGlzcGxheSBuYW1lIGZvciB0aGUgdmFsdWUsIG9yICd1bmtub3duIHR5cGUgbmFtZScuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmFzc2VydHMuZ2V0VHlwZV8gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUgfHwgJ3Vua25vd24gdHlwZSBuYW1lJztcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBmaWxlb3ZlcnZpZXcgVXRpbGl0eSBmb3IgZmFzdCBzdHJpbmcgY29uY2F0ZW5hdGlvbi5cbiAgICovXG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgY2xhc3MgdG8gZmFjaWxpdGF0ZSBzdHJpbmcgY29uY2F0ZW5hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHsqPX0gb3B0X2ExIE9wdGlvbmFsIGZpcnN0IGluaXRpYWwgaXRlbSB0byBhcHBlbmQuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgT3RoZXIgaW5pdGlhbCBpdGVtcyB0b1xuICAgKiAgICAgYXBwZW5kLCBlLmcuLCBuZXcgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyKCdmb28nLCAnYmFyJykuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyID0gZnVuY3Rpb24gKG9wdF9hMSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAob3B0X2ExICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYXBwZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBidWZmZXIgZm9yIHRoZSBzdHJpbmcgdG8gYmUgY29uY2F0ZW5hdGVkLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5idWZmZXJfID0gJyc7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBzdHJpbmcgYnVmZmVyIG9iamVjdCwgcmVwbGFjaW5nIHdoYXQncyBjdXJyZW50bHlcbiAgICogdGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gcyBTdHJpbmcgdG8gc2V0LlxuICAgKi9cbiAgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYnVmZmVyXyA9ICcnICsgcztcbiAgfTtcblxuICAvKipcbiAgICogQXBwZW5kcyBvbmUgb3IgbW9yZSBpdGVtcyB0byB0aGUgYnVmZmVyLlxuICAgKlxuICAgKiBDYWxsaW5nIHRoaXMgd2l0aCBudWxsLCB1bmRlZmluZWQsIG9yIGVtcHR5IGFyZ3VtZW50cyBpcyBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBhMSBSZXF1aXJlZCBmaXJzdCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Kj19IG9wdF9hMiBPcHRpb25hbCBzZWNvbmQgc3RyaW5nLlxuICAgKiBAcGFyYW0gey4uLj99IHZhcl9hcmdzIE90aGVyIGl0ZW1zIHRvIGFwcGVuZCxcbiAgICogICAgIGUuZy4sIHNiLmFwcGVuZCgnZm9vJywgJ2JhcicsICdiYXonKS5cbiAgICogQHJldHVybiB7IWdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlcn0gVGhpcyBzYW1lIFN0cmluZ0J1ZmZlciBvYmplY3QuXG4gICAqIEBzdXBwcmVzcyB7ZHVwbGljYXRlfVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoYTEsIG9wdF9hMiwgdmFyX2FyZ3MpIHtcbiAgICAvLyBVc2UgYTEgZGlyZWN0bHkgdG8gYXZvaWQgYXJndW1lbnRzIGluc3RhbnRpYXRpb24gZm9yIHNpbmdsZS1hcmcgY2FzZS5cbiAgICB0aGlzLmJ1ZmZlcl8gKz0gU3RyaW5nKGExKTtcbiAgICBpZiAob3B0X2EyICE9IG51bGwpIHtcbiAgICAgIC8vIHNlY29uZCBhcmd1bWVudCBpcyB1bmRlZmluZWQgKG51bGwgPT0gdW5kZWZpbmVkKVxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5idWZmZXJfICs9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgaW50ZXJuYWwgYnVmZmVyLlxuICAgKi9cbiAgZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1ZmZlcl8gPSAnJztcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgbGVuZ3RoIG9mIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBidWZmZXIuXG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJfLmxlbmd0aDtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29uY2F0ZW5hdGVkIHN0cmluZy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcl87XG4gIH07XG5cbiAgLy8gQ29weXJpZ2h0IDIwMTIgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAvL1xuICAvLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAvLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gIC8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAvL1xuICAvLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAvL1xuICAvLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIC8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAgLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIC8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgLyoqXG4gICAqIEBmaWxlb3ZlcnZpZXcgU295IGRhdGEgcHJpbWl0aXZlcy5cbiAgICpcbiAgICogVGhlIGdvYWwgaXMgdG8gZW5jb21wYXNzIGRhdGEgdHlwZXMgdXNlZCBieSBTb3ksIGVzcGVjaWFsbHkgdG8gbWFyayBjb250ZW50XG4gICAqIGFzIGtub3duIHRvIGJlIFwic2FmZVwiLlxuICAgKlxuICAgKiBAYXV0aG9yIGdib3llckBnb29nbGUuY29tIChHYXJyZXR0IEJveWVyKVxuICAgKi9cblxuICBnb29nLnNveSA9IHt9O1xuICBnb29nLnNveS5kYXRhID0ge307XG5cbiAgLyoqXG4gICAqIEEgdHlwZSBvZiB0ZXh0dWFsIGNvbnRlbnQuXG4gICAqXG4gICAqIFRoaXMgaXMgYW4gZW51bSBvZiB0eXBlIE9iamVjdCBzbyB0aGF0IHRoZXNlIHZhbHVlcyBhcmUgdW5mb3JnZWFibGUuXG4gICAqXG4gICAqIEBlbnVtIHshT2JqZWN0fVxuICAgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZCA9IHtcblxuICAgIC8qKlxuICAgICAqIEEgc25pcHBldCBvZiBIVE1MIHRoYXQgZG9lcyBub3Qgc3RhcnQgb3IgZW5kIGluc2lkZSBhIHRhZywgY29tbWVudCwgZW50aXR5LFxuICAgICAqIG9yIERPQ1RZUEU7IGFuZCB0aGF0IGRvZXMgbm90IGNvbnRhaW4gYW55IGV4ZWN1dGFibGUgY29kZVxuICAgICAqIChKUywge0Bjb2RlIDxvYmplY3Q+fXMsIGV0Yy4pIGZyb20gYSBkaWZmZXJlbnQgdHJ1c3QgZG9tYWluLlxuICAgICAqL1xuICAgIEhUTUw6IGdvb2cuREVCVUcgPyB7IHNhbml0aXplZENvbnRlbnRLaW5kSHRtbDogdHJ1ZSB9IDoge30sXG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRhYmxlIEphdmFzY3JpcHQgY29kZSBvciBleHByZXNzaW9uLCBzYWZlIGZvciBpbnNlcnRpb24gaW4gYVxuICAgICAqIHNjcmlwdC10YWcgb3IgZXZlbnQgaGFuZGxlciBjb250ZXh0LCBrbm93biB0byBiZSBmcmVlIG9mIGFueVxuICAgICAqIGF0dGFja2VyLWNvbnRyb2xsZWQgc2NyaXB0cy4gVGhpcyBjYW4gZWl0aGVyIGJlIHNpZGUtZWZmZWN0LWZyZWVcbiAgICAgKiBKYXZhc2NyaXB0IChzdWNoIGFzIEpTT04pIG9yIEphdmFzY3JpcHQgdGhhdCdzIGVudGlyZWx5IHVuZGVyIEdvb2dsZSdzXG4gICAgICogY29udHJvbC5cbiAgICAgKi9cbiAgICBKUzogZ29vZy5ERUJVRyA/IHsgc2FuaXRpemVkQ29udGVudEpzQ2hhcnM6IHRydWUgfSA6IHt9LFxuXG4gICAgLyoqIEEgcHJvcGVybHkgZW5jb2RlZCBwb3J0aW9uIG9mIGEgVVJJLiAqL1xuICAgIFVSSTogZ29vZy5ERUJVRyA/IHsgc2FuaXRpemVkQ29udGVudFVyaTogdHJ1ZSB9IDoge30sXG5cbiAgICAvKiogQSByZXNvdXJjZSBVUkkgbm90IHVuZGVyIGF0dGFja2VyIGNvbnRyb2wuICovXG4gICAgVFJVU1RFRF9SRVNPVVJDRV9VUkk6IGdvb2cuREVCVUcgPyB7IHNhbml0aXplZENvbnRlbnRUcnVzdGVkUmVzb3VyY2VVcmk6IHRydWUgfSA6IHt9LFxuXG4gICAgLyoqXG4gICAgICogUmVwZWF0ZWQgYXR0cmlidXRlIG5hbWVzIGFuZCB2YWx1ZXMuIEZvciBleGFtcGxlLFxuICAgICAqIHtAY29kZSBkaXI9XCJsdHJcIiBmb289XCJiYXJcIiBvbmNsaWNrPVwidHJ1c3RlZEZ1bmN0aW9uKClcIiBjaGVja2VkfS5cbiAgICAgKi9cbiAgICBBVFRSSUJVVEVTOiBnb29nLkRFQlVHID8geyBzYW5pdGl6ZWRDb250ZW50SHRtbEF0dHJpYnV0ZTogdHJ1ZSB9IDoge30sXG5cbiAgICAvLyBUT0RPOiBDb25zaWRlciBzZXBhcmF0aW5nIHJ1bGVzLCBkZWNsYXJhdGlvbnMsIGFuZCB2YWx1ZXMgaW50b1xuICAgIC8vIHNlcGFyYXRlIHR5cGVzLCBidXQgZm9yIHNpbXBsaWNpdHksIHdlJ2xsIHRyZWF0IGV4cGxpY2l0bHkgYmxlc3NlZFxuICAgIC8vIFNhbml0aXplZENvbnRlbnQgYXMgYWxsb3dlZCBpbiBhbGwgb2YgdGhlc2UgY29udGV4dHMuXG4gICAgLyoqXG4gICAgICogQSBDU1MzIGRlY2xhcmF0aW9uLCBwcm9wZXJ0eSwgdmFsdWUgb3IgZ3JvdXAgb2Ygc2VtaWNvbG9uIHNlcGFyYXRlZFxuICAgICAqIGRlY2xhcmF0aW9ucy5cbiAgICAgKi9cbiAgICBDU1M6IGdvb2cuREVCVUcgPyB7IHNhbml0aXplZENvbnRlbnRDc3M6IHRydWUgfSA6IHt9LFxuXG4gICAgLyoqXG4gICAgICogVW5zYW5pdGl6ZWQgcGxhaW4tdGV4dCBjb250ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBlZmZlY3RpdmVseSB0aGUgXCJudWxsXCIgZW50cnkgb2YgdGhpcyBlbnVtLCBhbmQgaXMgc29tZXRpbWVzIHVzZWRcbiAgICAgKiB0byBleHBsaWNpdGx5IG1hcmsgY29udGVudCB0aGF0IHNob3VsZCBuZXZlciBiZSB1c2VkIHVuZXNjYXBlZC4gU2luY2UgYW55XG4gICAgICogc3RyaW5nIGlzIHNhZmUgdG8gdXNlIGFzIHRleHQsIGJlaW5nIG9mIENvbnRlbnRLaW5kLlRFWFQgbWFrZXMgbm9cbiAgICAgKiBndWFyYW50ZWVzIGFib3V0IGl0cyBzYWZldHkgaW4gYW55IG90aGVyIGNvbnRleHQgc3VjaCBhcyBIVE1MLlxuICAgICAqL1xuICAgIFRFWFQ6IGdvb2cuREVCVUcgPyB7IHNhbml0aXplZENvbnRlbnRLaW5kVGV4dDogdHJ1ZSB9IDoge31cbiAgfTtcblxuICAvKipcbiAgICogQSBzdHJpbmctbGlrZSBvYmplY3QgdGhhdCBjYXJyaWVzIGEgY29udGVudC10eXBlIGFuZCBhIGNvbnRlbnQgZGlyZWN0aW9uLlxuICAgKlxuICAgKiBJTVBPUlRBTlQhIERvIG5vdCBjcmVhdGUgdGhlc2UgZGlyZWN0bHksIG5vciBpbnN0YW50aWF0ZSB0aGUgc3ViY2xhc3Nlcy5cbiAgICogSW5zdGVhZCwgdXNlIGEgdHJ1c3RlZCwgY2VudHJhbGx5IHJldmlld2VkIGxpYnJhcnkgYXMgZW5kb3JzZWQgYnkgeW91ciB0ZWFtXG4gICAqIHRvIGdlbmVyYXRlIHRoZXNlIG9iamVjdHMuIE90aGVyd2lzZSwgeW91IHJpc2sgYWNjaWRlbnRhbGx5IGNyZWF0aW5nXG4gICAqIFNhbml0aXplZENvbnRlbnQgdGhhdCBpcyBhdHRhY2tlci1jb250cm9sbGVkIGFuZCBnZXRzIGV2YWx1YXRlZCB1bmVzY2FwZWQgaW5cbiAgICogdGVtcGxhdGVzLlxuICAgKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBFcnJvcignRG8gbm90IGluc3RhbnRpYXRlIGRpcmVjdGx5Jyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBjb250ZXh0IGluIHdoaWNoIHRoaXMgY29udGVudCBpcyBzYWZlIGZyb20gWFNTIGF0dGFja3MuXG4gICAqIEB0eXBlIHtnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kfVxuICAgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50LnByb3RvdHlwZS5jb250ZW50S2luZDtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnQncyBkaXJlY3Rpb247IG51bGwgaWYgdW5rbm93biBhbmQgdGh1cyB0byBiZSBlc3RpbWF0ZWQgd2hlblxuICAgKiBuZWNlc3NhcnkuXG4gICAqIEB0eXBlIHs/Z29vZy5pMThuLmJpZGkuRGlyfVxuICAgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50LnByb3RvdHlwZS5jb250ZW50RGlyID0gbnVsbDtcblxuICAvKipcbiAgICogVGhlIGFscmVhZHktc2FmZSBjb250ZW50LlxuICAgKiBAcHJvdGVjdGVkIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQucHJvdG90eXBlLmNvbnRlbnQ7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFscmVhZHktc2FmZSBjb250ZW50LlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfTtcblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgfTtcblxuICAvKipcbiAgICogQW4gaW50ZXJtZWRpYXJ5IGJhc2UgY2xhc3MgdG8gYWxsb3cgdGhlIHR5cGUgc3lzdGVtIHRvIHNlcGNpZnkgdGV4dCB0ZW1wbGF0ZXNcbiAgICogd2l0aG91dCByZWZlcmVuY2luZyB0aGUgc295ZGF0YSBwYWNrYWdlLlxuICAgKiBAZXh0ZW5kcyB7Z29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fVxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE8oZ2JveWVyKTogRGVsZXRlIHRoaXMgY2xhc3MgYWZ0ZXIgbW92aW5nIHNveWRhdGEgdG8gQ2xvc3VyZS5cbiAgICBnb29nLnNveS5kYXRhLlVuc2FuaXRpemVkVGV4dC5iYXNlKHRoaXMsICdjb25zdHJ1Y3RvcicpO1xuICB9O1xuXG4gIGdvb2cuaW5oZXJpdHMoZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQsIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudCk7XG5cbiAgLyoqXG4gICAqIENvbnRlbnQgb2YgdHlwZSB7QGxpbmsgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZC5IVE1MfS5cbiAgICpcbiAgICogVGhlIGNvbnRlbnQgaXMgYSBzdHJpbmcgb2YgSFRNTCB0aGF0IGNhbiBzYWZlbHkgYmUgZW1iZWRkZWQgaW4gYSBQQ0RBVEFcbiAgICogY29udGV4dCBpbiB5b3VyIGFwcC4gIElmIHlvdSB3b3VsZCBiZSBzdXJwcmlzZWQgdG8gZmluZCB0aGF0IGFuIEhUTUxcbiAgICogc2FuaXRpemVyIHByb2R1Y2VkIHtAY29kZSBzfSAoZS5nLiAgaXQgcnVucyBjb2RlIG9yIGZldGNoZXMgYmFkIFVSTHMpIGFuZFxuICAgKiB5b3Ugd291bGRuJ3Qgd3JpdGUgYSB0ZW1wbGF0ZSB0aGF0IHByb2R1Y2VzIHtAY29kZSBzfSBvbiBzZWN1cml0eSBvciBwcml2YWN5XG4gICAqIGdyb3VuZHMsIHRoZW4gZG9uJ3QgcGFzcyB7QGNvZGUgc30gaGVyZS4gVGhlIGRlZmF1bHQgY29udGVudCBkaXJlY3Rpb24gaXNcbiAgICogdW5rbm93biwgaS5lLiB0byBiZSBlc3RpbWF0ZWQgd2hlbiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBleHRlbmRzIHtnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sID0gZnVuY3Rpb24gKCkge1xuICAgIGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbC5iYXNlKHRoaXMsICdjb25zdHJ1Y3RvcicpO1xuICB9O1xuICBnb29nLmluaGVyaXRzKGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbCwgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50KTtcblxuICAvKiogQG92ZXJyaWRlICovXG4gIGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbC5wcm90b3R5cGUuY29udGVudEtpbmQgPSBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLkhUTUw7XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgY291bGQgYmUgdXNlZCBhcyB0aGUgU295IHR5cGUge2h0bWx9LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZEh0bWwuaXNDb21wYXRpYmxlV2l0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBnb29nLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0IHx8IHZhbHVlIGluc3RhbmNlb2YgZ29vZy5odG1sLlNhZmVIdG1sO1xuICB9O1xuXG4gIC8qXG4gICAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuXG4gICAqXG4gICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gICAqXG4gICAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICpcbiAgICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgKi9cblxuICAvKipcbiAgICogQGZpbGVvdmVydmlld1xuICAgKiBVdGlsaXR5IGZ1bmN0aW9ucyBhbmQgY2xhc3NlcyBmb3IgU295LlxuICAgKlxuICAgKiA8cD5cbiAgICogVGhlIHRvcCBwb3J0aW9uIG9mIHRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgZm9yIFNveSB1c2Vyczo8dWw+XG4gICAqICAgPGxpPiBzb3kuU3RyaW5nQnVpbGRlcjogQ29tcGF0aWJsZSB3aXRoIHRoZSAnc3RyaW5nYnVpbGRlcicgY29kZSBzdHlsZS5cbiAgICogPC91bD5cbiAgICpcbiAgICogPHA+XG4gICAqIFRoZSBib3R0b20gcG9ydGlvbiBvZiB0aGlzIGZpbGUgY29udGFpbnMgdXRpbGl0aWVzIHRoYXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gICAqIGJ5IFNveS1nZW5lcmF0ZWQgSlMgY29kZS4gUGxlYXNlIGRvIG5vdCB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IGZyb21cbiAgICogeW91ciBoYW5kLXdyaXRlbiBjb2RlLiBUaGVpciBuYW1lcyBhbGwgc3RhcnQgd2l0aCAnJCQnLlxuICAgKlxuICAgKi9cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdHJpbmdCdWlsZGVyIChjb21wYXRpYmxlIHdpdGggdGhlICdzdHJpbmdidWlsZGVyJyBjb2RlIHN0eWxlKS5cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzb3kgPSB7fTtcbiAgICBzb3kuYXNzZXJ0cyA9IHt9O1xuICAgIHNveS5lc2MgPSB7fTtcbiAgICB2YXIgc295ZGF0YSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogVXRpbGl0eSBjbGFzcyB0byBmYWNpbGl0YXRlIG11Y2ggZmFzdGVyIHN0cmluZyBjb25jYXRlbmF0aW9uIGluIElFLFxuICAgICAqIHVzaW5nIEFycmF5LmpvaW4oKSByYXRoZXIgdGhhbiB0aGUgJysnIG9wZXJhdG9yLiBGb3Igb3RoZXIgYnJvd3NlcnNcbiAgICAgKiB3ZSBzaW1wbHkgdXNlIHRoZSAnKycgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFyX2FyZ3MgSW5pdGlhbCBpdGVtcyB0byBhcHBlbmQsXG4gICAgICogICAgIGUuZy4sIG5ldyBzb3kuU3RyaW5nQnVpbGRlcignZm9vJywgJ2JhcicpLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHNveS5TdHJpbmdCdWlsZGVyID0gZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBzb3lkYXRhOiBEZWZpbmVzIHR5cGVkIHN0cmluZ3MsIGUuZy4gYW4gSFRNTCBzdHJpbmcge0Bjb2RlIFwiYTxiPmNcIn0gaXNcbiAgICAvLyBzZW1hbnRpY2FsbHkgZGlzdGluY3QgZnJvbSB0aGUgcGxhaW4gdGV4dCBzdHJpbmcge0Bjb2RlIFwiYTxiPmNcIn0gYW5kIHNtYXJ0XG4gICAgLy8gdGVtcGxhdGVzIGNhbiB0YWtlIHRoYXQgZGlzdGluY3Rpb24gaW50byBhY2NvdW50LlxuXG4gICAgLyoqXG4gICAgICogQSB0eXBlIG9mIHRleHR1YWwgY29udGVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gZW51bSBvZiB0eXBlIE9iamVjdCBzbyB0aGF0IHRoZXNlIHZhbHVlcyBhcmUgdW5mb3JnZWFibGUuXG4gICAgICpcbiAgICAgKiBAZW51bSB7IU9iamVjdH1cbiAgICAgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZENvbnRlbnRLaW5kID0gZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZDtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gdmFsdWUgaXMgb2YgYSBnaXZlbiBjb250ZW50IGtpbmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSBleGFtaW5lZC5cbiAgICAgKiBAcGFyYW0ge3NveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmR9IGNvbnRlbnRLaW5kIFRoZSBkZXNpcmVkIGNvbnRlbnRcbiAgICAgKiAgICAga2luZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBvZiB0aGUgZ2l2ZW4ga2luZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveWRhdGEuaXNDb250ZW50S2luZCA9IGZ1bmN0aW9uICh2YWx1ZSwgY29udGVudEtpbmQpIHtcbiAgICAgIC8vIFRPRE8odXNlcik6IFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJlYWxseSBpbmNsdWRlIHRoZSBhc3NlcnQgb25cbiAgICAgIC8vIHZhbHVlLmNvbnN0cnVjdG9yIHRoYXQgaXMgY3VycmVudGx5IHNwcmlua2xlZCBhdCBtb3N0IG9mIHRoZSBjYWxsIHNpdGVzLlxuICAgICAgLy8gVW5mb3J0dW5hdGVseSwgdGhhdCB3b3VsZCByZXF1aXJlIGEgKGRlYnVnLW1vZGUtb25seSkgc3dpdGNoIHN0YXRlbWVudC5cbiAgICAgIC8vIFRPRE8odXNlcik6IFBlcmhhcHMgd2Ugc2hvdWxkIGdldCByaWQgb2YgdGhlIGNvbnRlbnRLaW5kIHByb3BlcnR5XG4gICAgICAvLyBhbHRvZ2V0aGVyIGFuZCBvbmx5IGF0IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmNvbnRlbnRLaW5kID09PSBjb250ZW50S2luZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udGVudCBvZiB0eXBlIHtAbGluayBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLkhUTUx9LlxuICAgICAqXG4gICAgICogVGhlIGNvbnRlbnQgaXMgYSBzdHJpbmcgb2YgSFRNTCB0aGF0IGNhbiBzYWZlbHkgYmUgZW1iZWRkZWQgaW4gYSBQQ0RBVEFcbiAgICAgKiBjb250ZXh0IGluIHlvdXIgYXBwLiAgSWYgeW91IHdvdWxkIGJlIHN1cnByaXNlZCB0byBmaW5kIHRoYXQgYW4gSFRNTFxuICAgICAqIHNhbml0aXplciBwcm9kdWNlZCB7QGNvZGUgc30gKGUuZy4gIGl0IHJ1bnMgY29kZSBvciBmZXRjaGVzIGJhZCBVUkxzKSBhbmRcbiAgICAgKiB5b3Ugd291bGRuJ3Qgd3JpdGUgYSB0ZW1wbGF0ZSB0aGF0IHByb2R1Y2VzIHtAY29kZSBzfSBvbiBzZWN1cml0eSBvciBwcml2YWN5XG4gICAgICogZ3JvdW5kcywgdGhlbiBkb24ndCBwYXNzIHtAY29kZSBzfSBoZXJlLiBUaGUgZGVmYXVsdCBjb250ZW50IGRpcmVjdGlvbiBpc1xuICAgICAqIHVua25vd24sIGkuZS4gdG8gYmUgZXN0aW1hdGVkIHdoZW4gbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbH1cbiAgICAgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZEh0bWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzb3lkYXRhLlNhbml0aXplZEh0bWwuYmFzZSh0aGlzLCAnY29uc3RydWN0b3InKTsgLy8gVGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICB9O1xuICAgIGdvb2cuaW5oZXJpdHMoc295ZGF0YS5TYW5pdGl6ZWRIdG1sLCBnb29nLnNveS5kYXRhLlNhbml0aXplZEh0bWwpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFNhbml0aXplZEh0bWwgb2JqZWN0IGZvciBhIHBhcnRpY3VsYXIgdmFsdWUuIFRoZSBjb250ZW50IGRpcmVjdGlvblxuICAgICAqIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgSFRNTC1lc2NhcGVzIHRoZSB2YWx1ZSB1bmxlc3MgaXQgaXMgYWxyZWFkeSBTYW5pdGl6ZWRIdG1sIG9yIFNhZmVIdG1sLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4gSWYgaXQgaXMgYWxyZWFkeSBhIFNhbml0aXplZEh0bWxcbiAgICAgKiAgICAgb2JqZWN0LCBpdCBpcyBsZWZ0IGFsb25lLlxuICAgICAqIEByZXR1cm4geyFzb3lkYXRhLlNhbml0aXplZEh0bWx9IEEgU2FuaXRpemVkSHRtbCBvYmplY3QgZGVyaXZlZCBmcm9tIHRoZVxuICAgICAqICAgICBzdHJpbmdpZmllZCB2YWx1ZS4gSXQgaXMgZXNjYXBlZCB1bmxlc3MgdGhlIGlucHV0IGlzIFNhbml0aXplZEh0bWwgb3JcbiAgICAgKiAgICAgU2FmZUh0bWwuXG4gICAgICovXG4gICAgc295ZGF0YS5TYW5pdGl6ZWRIdG1sLmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIC8vIFRoZSBjaGVjayBpcyBzb3lkYXRhLmlzQ29udGVudEtpbmRfKCkgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5jb250ZW50S2luZCA9PT0gZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZC5IVE1MKSB7XG4gICAgICAgIGdvb2cuYXNzZXJ0cy5hc3NlcnQodmFsdWUuY29uc3RydWN0b3IgPT09IGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbCB8fCB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gc295ZGF0YS5TYW5pdGl6ZWRIdG1sKTtcbiAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFzb3lkYXRhLlNhbml0aXplZEh0bWx9ICovdmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIGdvb2cuaHRtbC5TYWZlSHRtbCkge1xuICAgICAgICByZXR1cm4gc295ZGF0YS5WRVJZX1VOU0FGRS5vcmRhaW5TYW5pdGl6ZWRIdG1sKGdvb2cuaHRtbC5TYWZlSHRtbC51bndyYXAodmFsdWUpLCB2YWx1ZS5nZXREaXJlY3Rpb24oKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc295ZGF0YS5WRVJZX1VOU0FGRS5vcmRhaW5TYW5pdGl6ZWRIdG1sKHNveS5lc2MuJCRlc2NhcGVIdG1sSGVscGVyKFN0cmluZyh2YWx1ZSkpLCBzb3lkYXRhLmdldENvbnRlbnREaXIodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBjb3VsZCBiZSB1c2VkIGFzIHRoZSBTb3kgdHlwZSB7aHRtbH0uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgc295ZGF0YS5TYW5pdGl6ZWRIdG1sLmlzQ29tcGF0aWJsZVdpdGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBnb29nLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0IHx8IHZhbHVlIGluc3RhbmNlb2YgZ29vZy5odG1sLlNhZmVIdG1sO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IG9mIHR5cGUge0BsaW5rIHNveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQuVVJJfS5cbiAgICAgKlxuICAgICAqIFRoZSBjb250ZW50IGlzIGEgVVJJIGNodW5rIHRoYXQgdGhlIGNhbGxlciBrbm93cyBpcyBzYWZlIHRvIGVtaXQgaW4gYVxuICAgICAqIHRlbXBsYXRlLiBUaGUgY29udGVudCBkaXJlY3Rpb24gaXMgTFRSLlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudH1cbiAgICAgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZFVyaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudC5jYWxsKHRoaXMpOyAvLyBUaHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgIH07XG4gICAgZ29vZy5pbmhlcml0cyhzb3lkYXRhLlNhbml0aXplZFVyaSwgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50KTtcblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZFVyaS5wcm90b3R5cGUuY29udGVudEtpbmQgPSBzb3lkYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLlVSSTtcblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZFVyaS5wcm90b3R5cGUuY29udGVudERpciA9IGdvb2cuaTE4bi5iaWRpLkRpci5MVFI7XG5cbiAgICAvKipcbiAgICAgKiBVbnNhbml0aXplZCBwbGFpbiB0ZXh0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIFdoaWxlIGFsbCBzdHJpbmdzIGFyZSBlZmZlY3RpdmVseSBzYWZlIHRvIHVzZSBhcyBhIHBsYWluIHRleHQsIHRoZXJlIGFyZSBub1xuICAgICAqIGd1YXJhbnRlZXMgYWJvdXQgc2FmZXR5IGluIGFueSBvdGhlciBjb250ZXh0IHN1Y2ggYXMgSFRNTC4gVGhpcyBpc1xuICAgICAqIHNvbWV0aW1lcyB1c2VkIHRvIG1hcmsgdGhhdCBzaG91bGQgbmV2ZXIgYmUgdXNlZCB1bmVzY2FwZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRlbnQgUGxhaW4gdGV4dCB3aXRoIG5vIGd1YXJhbnRlZXMuXG4gICAgICogQHBhcmFtIHs/Z29vZy5pMThuLmJpZGkuRGlyPX0gb3B0X2NvbnRlbnREaXIgVGhlIGNvbnRlbnQgZGlyZWN0aW9uOyBudWxsIGlmXG4gICAgICogICAgIHVua25vd24gYW5kIHRodXMgdG8gYmUgZXN0aW1hdGVkIHdoZW4gbmVjZXNzYXJ5LiBEZWZhdWx0OiBudWxsLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBleHRlbmRzIHtnb29nLnNveS5kYXRhLlVuc2FuaXRpemVkVGV4dH1cbiAgICAgKi9cbiAgICBzb3lkYXRhLlVuc2FuaXRpemVkVGV4dCA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRfY29udGVudERpcikge1xuICAgICAgLyoqIEBvdmVycmlkZSAqL1xuICAgICAgdGhpcy5jb250ZW50ID0gU3RyaW5nKGNvbnRlbnQpO1xuICAgICAgdGhpcy5jb250ZW50RGlyID0gb3B0X2NvbnRlbnREaXIgIT0gbnVsbCA/IG9wdF9jb250ZW50RGlyIDogbnVsbDtcbiAgICB9O1xuICAgIGdvb2cuaW5oZXJpdHMoc295ZGF0YS5VbnNhbml0aXplZFRleHQsIGdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0KTtcblxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBzb3lkYXRhLlVuc2FuaXRpemVkVGV4dC5wcm90b3R5cGUuY29udGVudEtpbmQgPSBzb3lkYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLlRFWFQ7XG5cbiAgICAvKipcbiAgICAgKiBFbXB0eSBzdHJpbmcsIHVzZWQgYXMgYSB0eXBlIGluIFNveSB0ZW1wbGF0ZXMuXG4gICAgICogQGVudW0ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveWRhdGEuJCRFTVBUWV9TVFJJTkdfID0ge1xuICAgICAgVkFMVUU6ICcnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZvciBTYW5pdGl6ZWRDb250ZW50IHR5cGVzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGhhY2sgc28gdGhhdCB0aGUgc295ZGF0YS5WRVJZX1VOU0FGRS5vcmRhaW5TYW5pdGl6ZWQqIGNhblxuICAgICAqIGluc3RhbnRpYXRlIFNhbml0aXplZCogY2xhc3Nlcywgd2l0aG91dCBtYWtpbmcgdGhlIFNhbml0aXplZCogY29uc3RydWN0b3JzXG4gICAgICogcHVibGljbHkgdXNhYmxlLiBSZXF1aXJpbmcgYWxsIGNvbnN0cnVjdGlvbiB0byB1c2UgdGhlIFZFUllfVU5TQUZFIG5hbWVzXG4gICAgICogaGVscHMgY2FsbGVycyBhbmQgdGhlaXIgcmV2aWV3ZXJzIGVhc2lseSB0ZWxsIHRoYXQgY3JlYXRpbmcgU2FuaXRpemVkQ29udGVudFxuICAgICAqIGlzIG5vdCBhbHdheXMgc2FmZSBhbmQgY2FsbHMgZm9yIGNhcmVmdWwgcmV2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6IFQpfSBjdG9yIEEgY29uc3RydWN0b3IuXG4gICAgICogQHJldHVybiB7IWZ1bmN0aW9uKCosID9nb29nLmkxOG4uYmlkaS5EaXI9KTogVH0gQSBmYWN0b3J5IHRoYXQgdGFrZXNcbiAgICAgKiAgICAgY29udGVudCBhbmQgYW4gb3B0aW9uYWwgY29udGVudCBkaXJlY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgaW5zdGFuY2UuIElmXG4gICAgICogICAgIHRoZSBjb250ZW50IGRpcmVjdGlvbiBpcyB1bmRlZmluZWQsIGN0b3IucHJvdG90eXBlLmNvbnRlbnREaXIgaXMgdXNlZC5cbiAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc295ZGF0YS4kJG1ha2VTYW5pdGl6ZWRDb250ZW50RmFjdG9yeV8gPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgKiBAZXh0ZW5kcyB7Z29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbnN0YW50aWFibGVDdG9yKGNvbnRlbnQpIHtcbiAgICAgICAgLyoqIEBvdmVycmlkZSAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgfVxuICAgICAgSW5zdGFudGlhYmxlQ3Rvci5wcm90b3R5cGUgPSBjdG9yLnByb3RvdHlwZTtcbiAgICAgIC8qKlxuICAgICAgICogQ3JlYXRlcyBhIGN0b3ItdHlwZSBTYW5pdGl6ZWRDb250ZW50IGluc3RhbmNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gY29udGVudCBUaGUgY29udGVudCB0byBwdXQgaW4gdGhlIGluc3RhbmNlLlxuICAgICAgICogQHBhcmFtIHs/Z29vZy5pMThuLmJpZGkuRGlyPX0gb3B0X2NvbnRlbnREaXIgVGhlIGNvbnRlbnQgZGlyZWN0aW9uLiBJZlxuICAgICAgICogICAgIHVuZGVmaW5lZCwgY3Rvci5wcm90b3R5cGUuY29udGVudERpciBpcyB1c2VkLlxuICAgICAgICogQHJldHVybiB7IWdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudH0gVGhlIG5ldyBpbnN0YW5jZS4gSXQgaXMgYWN0dWFsbHlcbiAgICAgICAqICAgICBvZiB0eXBlIFQgYWJvdmUgKGN0b3IncyB0eXBlLCBhIGRlc2NlbmRhbnQgb2YgU2FuaXRpemVkQ29udGVudCksIGJ1dFxuICAgICAgICogICAgIHRoZXJlIGlzIG5vIHdheSB0byBleHByZXNzIHRoYXQgaGVyZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gc2FuaXRpemVkQ29udGVudEZhY3RvcnkoY29udGVudCwgb3B0X2NvbnRlbnREaXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnN0YW50aWFibGVDdG9yKFN0cmluZyhjb250ZW50KSk7XG4gICAgICAgIGlmIChvcHRfY29udGVudERpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVzdWx0LmNvbnRlbnREaXIgPSBvcHRfY29udGVudERpcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNhbml0aXplZENvbnRlbnRGYWN0b3J5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmb3IgU2FuaXRpemVkQ29udGVudCB0eXBlcyB0aGF0IHNob3VsZCBhbHdheXMgaGF2ZSB0aGVpclxuICAgICAqIGRlZmF1bHQgZGlyZWN0aW9uYWxpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IHRoZSBzb3lkYXRhLlZFUllfVU5TQUZFLm9yZGFpblNhbml0aXplZCogY2FuXG4gICAgICogaW5zdGFudGlhdGUgU2FuaXRpemVkKiBjbGFzc2VzLCB3aXRob3V0IG1ha2luZyB0aGUgU2FuaXRpemVkKiBjb25zdHJ1Y3RvcnNcbiAgICAgKiBwdWJsaWNseSB1c2FibGUuIFJlcXVpcmluZyBhbGwgY29uc3RydWN0aW9uIHRvIHVzZSB0aGUgVkVSWV9VTlNBRkUgbmFtZXNcbiAgICAgKiBoZWxwcyBjYWxsZXJzIGFuZCB0aGVpciByZXZpZXdlcnMgZWFzaWx5IHRlbGwgdGhhdCBjcmVhdGluZyBTYW5pdGl6ZWRDb250ZW50XG4gICAgICogaXMgbm90IGFsd2F5cyBzYWZlIGFuZCBjYWxscyBmb3IgY2FyZWZ1bCByZXZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogVCwgc3RyaW5nKX0gY3RvciBBIGNvbnN0cnVjdG9yLlxuICAgICAqIEByZXR1cm4geyFmdW5jdGlvbigqKTogVH0gQSBmYWN0b3J5IHRoYXQgdGFrZXMgY29udGVudCBhbmQgcmV0dXJucyBhIG5ld1xuICAgICAqICAgICBpbnN0YW5jZSAod2l0aCBkZWZhdWx0IGRpcmVjdGlvbmFsaXR5LCBpLmUuIGN0b3IucHJvdG90eXBlLmNvbnRlbnREaXIpLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzb3lkYXRhLiQkbWFrZVNhbml0aXplZENvbnRlbnRGYWN0b3J5V2l0aERlZmF1bHREaXJPbmx5XyA9IGZ1bmN0aW9uIChjdG9yKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqIEBleHRlbmRzIHtnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluc3RhbnRpYWJsZUN0b3IoY29udGVudCkge1xuICAgICAgICAvKiogQG92ZXJyaWRlICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBJbnN0YW50aWFibGVDdG9yLnByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgY3Rvci10eXBlIFNhbml0aXplZENvbnRlbnQgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBjb250ZW50IFRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgaW5zdGFuY2UuXG4gICAgICAgKiBAcmV0dXJuIHshZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fSBUaGUgbmV3IGluc3RhbmNlLiBJdCBpcyBhY3R1YWxseVxuICAgICAgICogICAgIG9mIHR5cGUgVCBhYm92ZSAoY3RvcidzIHR5cGUsIGEgZGVzY2VuZGFudCBvZiBTYW5pdGl6ZWRDb250ZW50KSwgYnV0XG4gICAgICAgKiAgICAgdGhlcmUgaXMgbm8gd2F5IHRvIGV4cHJlc3MgdGhhdCBoZXJlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzYW5pdGl6ZWRDb250ZW50RmFjdG9yeShjb250ZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW5zdGFudGlhYmxlQ3RvcihTdHJpbmcoY29udGVudCkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNhbml0aXplZENvbnRlbnRGYWN0b3J5O1xuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNhbml0aXplZCBjb250ZW50IG9yZGFpbmVycy4gUGxlYXNlIHVzZSB0aGVzZSB3aXRoIGV4dHJlbWUgY2F1dGlvbiAod2l0aCB0aGVcbiAgICAvLyBleGNlcHRpb24gb2YgbWFya1Vuc2FuaXRpemVkVGV4dCkuIEEgZ29vZCByZWNvbW1lbmRhdGlvbiBpcyB0byBsaW1pdCB1c2FnZVxuICAgIC8vIG9mIHRoZXNlIHRvIGp1c3QgYSBoYW5kZnVsIG9mIGZpbGVzIGluIHlvdXIgc291cmNlIHRyZWUgd2hlcmUgdXNhZ2VzIGNhbiBiZVxuICAgIC8vIGNhcmVmdWxseSBhdWRpdGVkLlxuXG5cbiAgICAvKipcbiAgICAgKiBQcm90ZWN0cyBhIHN0cmluZyBmcm9tIGJlaW5nIHVzZWQgaW4gYW4gbm9BdXRvZXNjYXBlZCBjb250ZXh0LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbnRlbnQgd2hlcmUgdGhlcmUgaXMgc2lnbmlmaWNhbnQgcmlzayBvZiBhY2NpZGVudGFsXG4gICAgICogdW5lc2NhcGVkIHVzYWdlIGluIGEgU295IHRlbXBsYXRlLiBBIGdyZWF0IGNhc2UgaXMgZm9yIHVzZXItY29udHJvbGxlZFxuICAgICAqIGRhdGEgdGhhdCBoYXMgaGlzdG9yaWNhbGx5IGJlZW4gYSBzb3VyY2Ugb2YgdnVsZXJuYWJpbGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBjb250ZW50IFRleHQgdG8gcHJvdGVjdC5cbiAgICAgKiBAcGFyYW0gez9nb29nLmkxOG4uYmlkaS5EaXI9fSBvcHRfY29udGVudERpciBUaGUgY29udGVudCBkaXJlY3Rpb247IG51bGwgaWZcbiAgICAgKiAgICAgdW5rbm93biBhbmQgdGh1cyB0byBiZSBlc3RpbWF0ZWQgd2hlbiBuZWNlc3NhcnkuIERlZmF1bHQ6IG51bGwuXG4gICAgICogQHJldHVybiB7IXNveWRhdGEuVW5zYW5pdGl6ZWRUZXh0fSBBIHdyYXBwZXIgdGhhdCBpcyByZWplY3RlZCBieSB0aGVcbiAgICAgKiAgICAgU295IG5vQXV0b2VzY2FwZSBwcmludCBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgc295ZGF0YS5tYXJrVW5zYW5pdGl6ZWRUZXh0ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdF9jb250ZW50RGlyKSB7XG4gICAgICByZXR1cm4gbmV3IHNveWRhdGEuVW5zYW5pdGl6ZWRUZXh0KGNvbnRlbnQsIG9wdF9jb250ZW50RGlyKTtcbiAgICB9O1xuXG4gICAgc295ZGF0YS5WRVJZX1VOU0FGRSA9IHt9O1xuXG4gICAgLyoqXG4gICAgKiBUYWtlcyBhIGxlYXAgb2YgZmFpdGggdGhhdCB0aGUgcHJvdmlkZWQgY29udGVudCBpcyBcInNhZmVcIiB0byB1c2UgYXMgYSBVUklcbiAgICAqIGluIGEgU295IHRlbXBsYXRlLlxuICAgICpcbiAgICAqIFRoaXMgY3JlYXRlcyBhIFNveSBTYW5pdGl6ZWRDb250ZW50IG9iamVjdCB3aGljaCBpbmRpY2F0ZXMgdG8gU295IHRoZXJlIGlzXG4gICAgKiBubyBuZWVkIHRvIGVzY2FwZSBpdCB3aGVuIHByaW50ZWQgYXMgYSBVUkkgKGUuZy4gaW4gYW4gaHJlZiBvciBzcmNcbiAgICAqIGF0dHJpYnV0ZSksIHN1Y2ggYXMgaWYgaXQncyBhbHJlYWR5IGJlZW4gZW5jb2RlZCBvciAgaWYgaXQncyBhIEphdmFzY3JpcHQ6XG4gICAgKiBVUkkuXG4gICAgKlxuICAgICogQHBhcmFtIHsqfSBjb250ZW50IEEgY2h1bmsgb2YgVVJJIHRoYXQgdGhlIGNhbGxlciBrbm93cyBpcyBzYWZlIHRvXG4gICAgKiAgICAgZW1pdCBpbiBhIHRlbXBsYXRlLlxuICAgICogQHJldHVybiB7IXNveWRhdGEuU2FuaXRpemVkVXJpfSBTYW5pdGl6ZWQgY29udGVudCB3cmFwcGVyIHRoYXQgaW5kaWNhdGVzIHRvXG4gICAgKiAgICAgU295IG5vdCB0byBlc2NhcGUgb3IgZmlsdGVyIHdoZW4gcHJpbnRlZCBpbiBVUkkgY29udGV4dC5cbiAgICAqL1xuICAgIHNveWRhdGEuVkVSWV9VTlNBRkUub3JkYWluU2FuaXRpemVkVXJpID0gc295ZGF0YS4kJG1ha2VTYW5pdGl6ZWRDb250ZW50RmFjdG9yeVdpdGhEZWZhdWx0RGlyT25seV8oc295ZGF0YS5TYW5pdGl6ZWRVcmkpO1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCZWxvdyBhcmUgcHJpdmF0ZSB1dGlsaXRpZXMgdG8gYmUgdXNlZCBieSBTb3ktZ2VuZXJhdGVkIGNvZGUgb25seS5cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiBhdWdtZW50ZWQgbWFwLiBUaGUgcmV0dXJuZWQgbWFwIHdpbGwgY29udGFpbiBtYXBwaW5ncyBmcm9tIGJvdGhcbiAgICAgKiB0aGUgYmFzZSBtYXAgYW5kIHRoZSBhZGRpdGlvbmFsIG1hcC4gSWYgdGhlIHNhbWUga2V5IGFwcGVhcnMgaW4gYm90aCwgdGhlblxuICAgICAqIHRoZSB2YWx1ZSBmcm9tIHRoZSBhZGRpdGlvbmFsIG1hcCB3aWxsIGJlIHZpc2libGUsIHdoaWxlIHRoZSB2YWx1ZSBmcm9tIHRoZVxuICAgICAqIGJhc2UgbWFwIHdpbGwgYmUgaGlkZGVuLiBUaGUgYmFzZSBtYXAgd2lsbCBiZSB1c2VkLCBidXQgbm90IG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBiYXNlTWFwIFRoZSBvcmlnaW5hbCBtYXAgdG8gYXVnbWVudC5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGFkZGl0aW9uYWxNYXAgQSBtYXAgY29udGFpbmluZyB0aGUgYWRkaXRpb25hbCBtYXBwaW5ncy5cbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fSBBbiBhdWdtZW50ZWQgbWFwIGNvbnRhaW5pbmcgYm90aCB0aGUgb3JpZ2luYWwgYW5kXG4gICAgICogICAgIGFkZGl0aW9uYWwgbWFwcGluZ3MuXG4gICAgICovXG4gICAgc295LiQkYXVnbWVudE1hcCA9IGZ1bmN0aW9uIChiYXNlTWFwLCBhZGRpdGlvbmFsTWFwKSB7XG4gICAgICByZXR1cm4gc295LiQkYXNzaWduRGVmYXVsdHMoc295LiQkYXNzaWduRGVmYXVsdHMoe30sIGFkZGl0aW9uYWxNYXApLCBiYXNlTWFwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29waWVzIGV4dHJhIHByb3BlcnRpZXMgaW50byBhbiBvYmplY3QgaWYgdGhleSBkbyBub3QgYWxyZWFkeSBleGlzdC4gVGhlXG4gICAgICogZGVzdGluYXRpb24gb2JqZWN0IGlzIG11dGF0ZWQgaW4gdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9iaiBUaGUgZGVzdGluYXRpb24gb2JqZWN0IHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcyB0byBhcHBseS5cbiAgICAgKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBjb252ZW5pZW5jZS5cbiAgICAgKi9cbiAgICBzb3kuJCRhc3NpZ25EZWZhdWx0cyA9IGZ1bmN0aW9uIChvYmosIGRlZmF1bHRzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG9iaikpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoYXQgdGhlIGdpdmVuIG1hcCBrZXkgaXMgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHsqfSBrZXkgS2V5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBzb3kuJCRjaGVja01hcEtleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vIFRPRE86IFN1cHBvcnQgbWFwIGxpdGVyYWwgd2l0aCBub25zdHJpbmcga2V5LlxuICAgICAgaWYgKHR5cGVvZiBrZXkgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ01hcCBsaXRlcmFsXFwncyBrZXkgZXhwcmVzc2lvbiBtdXN0IGV2YWx1YXRlIHRvIHN0cmluZycgKyAnIChlbmNvdW50ZXJlZCB0eXBlIFwiJyArICh0eXBlb2Yga2V5ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihrZXkpKSArICdcIikuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBrZXlzIGluIGEgbWFwIGFzIGFuIGFycmF5LiBUaGVyZSBhcmUgbm8gZ3VhcmFudGVlcyBvbiB0aGUgb3JkZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGdldCB0aGUga2V5cyBvZi5cbiAgICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn0gVGhlIGFycmF5IG9mIGtleXMgaW4gdGhlIGdpdmVuIG1hcC5cbiAgICAgKi9cbiAgICBzb3kuJCRnZXRNYXBLZXlzID0gZnVuY3Rpb24gKG1hcCkge1xuICAgICAgdmFyIG1hcEtleXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICAgICAgbWFwS2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwS2V5cztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJndW1lbnQgaWYgaXQgaXMgbm90IG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1R9IHZhbCBUaGUgdmFsdWUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJuIHtUfSB2YWwgaWYgaXMgaXNuJ3QgbnVsbFxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICovXG4gICAgc295LiQkY2hlY2tOb3ROdWxsID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IEVycm9yKCd1bmV4cGVjdGVkIG51bGwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb25zaXN0ZW50IHVuaXF1ZSBpZCBmb3IgdGhlIGdpdmVuIGRlbGVnYXRlIHRlbXBsYXRlIG5hbWUuIFR3byBjYWxsc1xuICAgICAqIHRvIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgaWQgaWYgYW5kIG9ubHkgaWYgdGhlIGlucHV0IG5hbWVzIGFyZVxuICAgICAqIHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogPHA+IEltcG9ydGFudDogVGhpcyBmdW5jdGlvbiBtdXN0IGFsd2F5cyBiZSBjYWxsZWQgd2l0aCBhIHN0cmluZyBjb25zdGFudC5cbiAgICAgKlxuICAgICAqIDxwPiBJZiBDbG9zdXJlIENvbXBpbGVyIGlzIG5vdCBiZWluZyB1c2VkLCB0aGVuIHRoaXMgaXMganVzdCB0aGlzIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24uIElmIENsb3N1cmUgQ29tcGlsZXIgaXMgYmVpbmcgdXNlZCwgdGhlbiBlYWNoIGNhbGwgdG8gdGhpcyBmdW5jdGlvblxuICAgICAqIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhIHNob3J0IHN0cmluZyBjb25zdGFudCwgd2hpY2ggd2lsbCBiZSBjb25zaXN0ZW50IHBlclxuICAgICAqIGlucHV0IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsVGVtcGxhdGVOYW1lIFRoZSBkZWxlZ2F0ZSB0ZW1wbGF0ZSBuYW1lIGZvciB3aGljaCB0byBnZXQgYVxuICAgICAqICAgICBjb25zaXN0ZW50IHVuaXF1ZSBpZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgdW5pcXVlIGlkIHRoYXQgaXMgY29uc2lzdGVudCBwZXIgaW5wdXQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBjb25zaXN0ZW50SWRHZW5lcmF0b3JcbiAgICAgKi9cbiAgICBzb3kuJCRnZXREZWxUZW1wbGF0ZUlkID0gZnVuY3Rpb24gKGRlbFRlbXBsYXRlTmFtZSkge1xuICAgICAgcmV0dXJuIGRlbFRlbXBsYXRlTmFtZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFwIGZyb20gcmVnaXN0ZXJlZCBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgdG8gdGhlIHByaW9yaXR5IG9mIHRoZVxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9QUklPUklUSUVTXyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogTWFwIGZyb20gcmVnaXN0ZXJlZCBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgdG8gdGhlIGltcGxlbWVudGF0aW9uIGZ1bmN0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9GVU5DVElPTlNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBkZWxlZ2F0ZSBpbXBsZW1lbnRhdGlvbi4gSWYgdGhlIHNhbWUgZGVsZWdhdGUgdGVtcGxhdGUga2V5IChpZFxuICAgICAqIGFuZCB2YXJpYW50KSBoYXMgYmVlbiByZWdpc3RlcmVkIHByZXZpb3VzbHksIHRoZW4gcHJpb3JpdHkgdmFsdWVzIGFyZVxuICAgICAqIGNvbXBhcmVkIGFuZCBvbmx5IHRoZSBoaWdoZXIgcHJpb3JpdHkgaW1wbGVtZW50YXRpb24gaXMgc3RvcmVkIChpZlxuICAgICAqIHByaW9yaXRpZXMgYXJlIGVxdWFsLCBhbiBlcnJvciBpcyB0aHJvd24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlbFRlbXBsYXRlSWQgVGhlIGRlbGVnYXRlIHRlbXBsYXRlIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxUZW1wbGF0ZVZhcmlhbnQgVGhlIGRlbGVnYXRlIHRlbXBsYXRlIHZhcmlhbnQgKGNhbiBiZVxuICAgICAqICAgICBlbXB0eSBzdHJpbmcpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxQcmlvcml0eSBUaGUgaW1wbGVtZW50YXRpb24ncyBwcmlvcml0eSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWxGbiBUaGUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgc295LiQkcmVnaXN0ZXJEZWxlZ2F0ZUZuID0gZnVuY3Rpb24gKGRlbFRlbXBsYXRlSWQsIGRlbFRlbXBsYXRlVmFyaWFudCwgZGVsUHJpb3JpdHksIGRlbEZuKSB7XG5cbiAgICAgIHZhciBtYXBLZXkgPSAna2V5XycgKyBkZWxUZW1wbGF0ZUlkICsgJzonICsgZGVsVGVtcGxhdGVWYXJpYW50O1xuICAgICAgdmFyIGN1cnJQcmlvcml0eSA9IHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX1BSSU9SSVRJRVNfW21hcEtleV07XG4gICAgICBpZiAoY3VyclByaW9yaXR5ID09PSB1bmRlZmluZWQgfHwgZGVsUHJpb3JpdHkgPiBjdXJyUHJpb3JpdHkpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXJpbmcgbmV3IG9yIGhpZ2hlci1wcmlvcml0eSBmdW5jdGlvbjogcmVwbGFjZSByZWdpc3RyeSBlbnRyeS5cbiAgICAgICAgc295LiQkREVMRUdBVEVfUkVHSVNUUllfUFJJT1JJVElFU19bbWFwS2V5XSA9IGRlbFByaW9yaXR5O1xuICAgICAgICBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9GVU5DVElPTlNfW21hcEtleV0gPSBkZWxGbjtcbiAgICAgIH0gZWxzZSBpZiAoZGVsUHJpb3JpdHkgPT0gY3VyclByaW9yaXR5KSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyaW5nIHNhbWUtcHJpb3JpdHkgZnVuY3Rpb246IGVycm9yLlxuICAgICAgICB0aHJvdyBFcnJvcignRW5jb3VudGVyZWQgdHdvIGFjdGl2ZSBkZWxlZ2F0ZXMgd2l0aCB0aGUgc2FtZSBwcmlvcml0eSAoXCInICsgZGVsVGVtcGxhdGVJZCArICc6JyArIGRlbFRlbXBsYXRlVmFyaWFudCArICdcIikuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWdpc3RlcmluZyBsb3dlci1wcmlvcml0eSBmdW5jdGlvbjogZG8gbm90aGluZy5cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSAoaGlnaGVzdC1wcmlvcml0eSkgaW1wbGVtZW50YXRpb24gdGhhdCBoYXMgYmVlbiByZWdpc3RlcmVkIGZvclxuICAgICAqIGEgZ2l2ZW4gZGVsZWdhdGUgdGVtcGxhdGUga2V5IChpZCBhbmQgdmFyaWFudCkuIElmIG5vIGltcGxlbWVudGF0aW9uIGhhc1xuICAgICAqIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGtleSwgdGhlbiB0aGUgZmFsbGJhY2sgaXMgdGhlIHNhbWUgaWQgd2l0aCBlbXB0eVxuICAgICAqIHZhcmlhbnQuIElmIHRoZSBmYWxsYmFjayBpcyBhbHNvIG5vdCByZWdpc3RlcmVkLCBhbmQgYWxsb3dzRW1wdHlEZWZhdWx0IGlzXG4gICAgICogdHJ1ZSwgdGhlbiByZXR1cm5zIGFuIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgZXF1aXZhbGVudCB0byBhbiBlbXB0eSB0ZW1wbGF0ZVxuICAgICAqIChpLmUuIHJlbmRlcmVkIG91dHB1dCB3b3VsZCBiZSBlbXB0eSBzdHJpbmcpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlbFRlbXBsYXRlSWQgVGhlIGRlbGVnYXRlIHRlbXBsYXRlIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxUZW1wbGF0ZVZhcmlhbnQgVGhlIGRlbGVnYXRlIHRlbXBsYXRlIHZhcmlhbnQgKGNhbiBiZVxuICAgICAqICAgICBlbXB0eSBzdHJpbmcpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWxsb3dzRW1wdHlEZWZhdWx0IFdoZXRoZXIgdG8gZGVmYXVsdCB0byB0aGUgZW1wdHkgdGVtcGxhdGVcbiAgICAgKiAgICAgZnVuY3Rpb24gaWYgdGhlcmUncyBubyBhY3RpdmUgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSByZXRyaWV2ZWQgaW1wbGVtZW50YXRpb24gZnVuY3Rpb24uXG4gICAgICovXG4gICAgc295LiQkZ2V0RGVsZWdhdGVGbiA9IGZ1bmN0aW9uIChkZWxUZW1wbGF0ZUlkLCBkZWxUZW1wbGF0ZVZhcmlhbnQsIGFsbG93c0VtcHR5RGVmYXVsdCkge1xuXG4gICAgICB2YXIgZGVsRm4gPSBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9GVU5DVElPTlNfWydrZXlfJyArIGRlbFRlbXBsYXRlSWQgKyAnOicgKyBkZWxUZW1wbGF0ZVZhcmlhbnRdO1xuICAgICAgaWYgKCFkZWxGbiAmJiBkZWxUZW1wbGF0ZVZhcmlhbnQgIT0gJycpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gZW1wdHkgdmFyaWFudC5cbiAgICAgICAgZGVsRm4gPSBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9GVU5DVElPTlNfWydrZXlfJyArIGRlbFRlbXBsYXRlSWQgKyAnOiddO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVsRm4pIHtcbiAgICAgICAgcmV0dXJuIGRlbEZuO1xuICAgICAgfSBlbHNlIGlmIChhbGxvd3NFbXB0eURlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIHNveS4kJEVNUFRZX1RFTVBMQVRFX0ZOXztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdGb3VuZCBubyBhY3RpdmUgaW1wbCBmb3IgZGVsZWdhdGUgY2FsbCB0byBcIicgKyBkZWxUZW1wbGF0ZUlkICsgJzonICsgZGVsVGVtcGxhdGVWYXJpYW50ICsgJ1wiIChhbmQgbm90IGFsbG93ZW1wdHlkZWZhdWx0PVwidHJ1ZVwiKS4nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgc295LiQkZ2V0RGVsZWdhdGVGbigpLiBUaGlzIGlzIHRoZSBlbXB0eSB0ZW1wbGF0ZSBmdW5jdGlvblxuICAgICAqIHRoYXQgaXMgcmV0dXJuZWQgd2hlbmV2ZXIgdGhlcmUncyBubyBkZWxlZ2F0ZSBpbXBsZW1lbnRhdGlvbiBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfZGF0YVxuICAgICAqIEBwYXJhbSB7c295LlN0cmluZ0J1aWxkZXI9fSBvcHRfc2JcbiAgICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2lqRGF0YVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveS4kJEVNUFRZX1RFTVBMQVRFX0ZOXyA9IGZ1bmN0aW9uIChvcHRfZGF0YSwgb3B0X3NiLCBvcHRfaWpEYXRhKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQmFzaWMgZGlyZWN0aXZlcy9mdW5jdGlvbnMuXG5cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyBhIHN0cmluZyB0byBhIGdpdmVuIG1heCBsZW5ndGggKGlmIGl0J3MgY3VycmVudGx5IGxvbmdlciksXG4gICAgICogb3B0aW9uYWxseSBhZGRpbmcgZWxsaXBzaXMgYXQgdGhlIGVuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gdHJ1bmNhdGUuIENhbiBiZSBvdGhlciB0eXBlcywgYnV0IHRoZSB2YWx1ZSB3aWxsXG4gICAgICogICAgIGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heExlbiBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciB0cnVuY2F0aW9uXG4gICAgICogICAgIChpbmNsdWRpbmcgZWxsaXBzaXMsIGlmIGFwcGxpY2FibGUpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9BZGRFbGxpcHNpcyBXaGV0aGVyIHRvIGFkZCBlbGxpcHNpcyBpZiB0aGUgc3RyaW5nIG5lZWRzXG4gICAgICogICAgIHRydW5jYXRpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIGFmdGVyIHRydW5jYXRpb24uXG4gICAgICovXG4gICAgc295LiQkdHJ1bmNhdGUgPSBmdW5jdGlvbiAoc3RyLCBtYXhMZW4sIGRvQWRkRWxsaXBzaXMpIHtcblxuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSBtYXhMZW4pIHtcbiAgICAgICAgcmV0dXJuIHN0cjsgLy8gbm8gbmVlZCB0byB0cnVuY2F0ZVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBkb0FkZEVsbGlwc2lzLCBlaXRoZXIgcmVkdWNlIG1heExlbiB0byBjb21wZW5zYXRlLCBvciBlbHNlIGlmIG1heExlbiBpc1xuICAgICAgLy8gdG9vIHNtYWxsLCBqdXN0IHR1cm4gb2ZmIGRvQWRkRWxsaXBzaXMuXG4gICAgICBpZiAoZG9BZGRFbGxpcHNpcykge1xuICAgICAgICBpZiAobWF4TGVuID4gMykge1xuICAgICAgICAgIG1heExlbiAtPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvQWRkRWxsaXBzaXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdHJ1bmNhdGluZyBhdCBtYXhMZW4gZG9lc24ndCBjdXQgdXAgYSB1bmljb2RlIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgaWYgKHNveS4kJGlzSGlnaFN1cnJvZ2F0ZV8oc3RyLmNoYXJBdChtYXhMZW4gLSAxKSkgJiYgc295LiQkaXNMb3dTdXJyb2dhdGVfKHN0ci5jaGFyQXQobWF4TGVuKSkpIHtcbiAgICAgICAgbWF4TGVuIC09IDE7XG4gICAgICB9XG5cbiAgICAgIC8vIFRydW5jYXRlLlxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBtYXhMZW4pO1xuXG4gICAgICAvLyBBZGQgZWxsaXBzaXMuXG4gICAgICBpZiAoZG9BZGRFbGxpcHNpcykge1xuICAgICAgICBzdHIgKz0gJy4uLic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgaGVscGVyIGZvciAkJHRydW5jYXRlKCkgdG8gY2hlY2sgd2hldGhlciBhIGNoYXIgaXMgYSBoaWdoIHN1cnJvZ2F0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2ggVGhlIGNoYXIgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gY2hhciBpcyBhIHVuaWNvZGUgaGlnaCBzdXJyb2dhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzb3kuJCRpc0hpZ2hTdXJyb2dhdGVfID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgICByZXR1cm4gMHhEODAwIDw9IGNoICYmIGNoIDw9IDB4REJGRjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgZm9yICQkdHJ1bmNhdGUoKSB0byBjaGVjayB3aGV0aGVyIGEgY2hhciBpcyBhIGxvdyBzdXJyb2dhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoIFRoZSBjaGFyIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGNoYXIgaXMgYSB1bmljb2RlIGxvdyBzdXJyb2dhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzb3kuJCRpc0xvd1N1cnJvZ2F0ZV8gPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHJldHVybiAweERDMDAgPD0gY2ggJiYgY2ggPD0gMHhERkZGO1xuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEFzc2VydGlvbiBtZXRob2RzIHVzZWQgYnkgcnVudGltZS5cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdHlwZSBhc3NlcnRpb24gaXMgdHJ1ZSBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXNcbiAgICAgKiB0cnVlLiBSZXBvcnQgZXJyb3JzIG9uIHJ1bnRpbWUgdHlwZXMgaWYgZ29vZy5ERUJVRyBpcyB0cnVlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uIFRoZSB0eXBlIGNoZWNrIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1OYW1lIFRoZSBTb3kgbmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7P30gcGFyYW0gVGhlIEpTIG9iamVjdCBmb3IgdGhlIHBhcmFtZXRlci5cbiAgICAgKiBAcGFyYW0geyFzdHJpbmd9IGpzRG9jVHlwZVN0ciBTb3lEb2MgdHlwZSBzdHIuXG4gICAgICogQHJldHVybiB7P30gdGhlIHBhcmFtIHZhbHVlXG4gICAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGZhbHNlLlxuICAgICAqL1xuICAgIHNveS5hc3NlcnRzLmFzc2VydFR5cGUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBwYXJhbU5hbWUsIHBhcmFtLCBqc0RvY1R5cGVTdHIpIHtcbiAgICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWNvbmRpdGlvbikge1xuICAgICAgICB2YXIgbXNnID0gJ2V4cGVjdGVkIHBhcmFtICcgKyBwYXJhbU5hbWUgKyAnIG9mIHR5cGUgJyArIGpzRG9jVHlwZVN0ciArIChnb29nLkRFQlVHID8gJywgYnV0IGdvdCAnICsgZ29vZy5kZWJ1Zy5ydW50aW1lVHlwZShwYXJhbSkgOiAnJykgKyAnLic7XG4gICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKG1zZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyYW07XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gR2VuZXJhdGVkIGNvZGUuXG5cblxuICAgIC8vIFNUQVJUIEdFTkVSQVRFRCBDT0RFIEZPUiBFU0NBUEVSUy5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbiAoKikgOiBzdHJpbmd9XG4gICAgICovXG4gICAgc295LmVzYy4kJGVzY2FwZUh0bWxIZWxwZXIgPSBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIGdvb2cuc3RyaW5nLmh0bWxFc2NhcGUoU3RyaW5nKHYpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIG9ubHkgZGF0YS1wcm90b2NvbCBpbWFnZSBVUkkncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuIE1heSBub3QgYmUgYSBzdHJpbmcsIGJ1dCB0aGUgdmFsdWVcbiAgICAgKiAgICAgd2lsbCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm4geyFzb3lkYXRhLlNhbml0aXplZFVyaX0gQW4gZXNjYXBlZCB2ZXJzaW9uIG9mIHZhbHVlLlxuICAgICAqL1xuICAgIHNveS4kJGZpbHRlckltYWdlRGF0YVVyaSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gTk9URTogRXZlbiBpZiBpdCdzIGEgU2FuaXRpemVkVXJpLCB3ZSB3aWxsIHN0aWxsIGZpbHRlciBpdC5cbiAgICAgIHJldHVybiBzb3lkYXRhLlZFUllfVU5TQUZFLm9yZGFpblNhbml0aXplZFVyaShzb3kuZXNjLiQkZmlsdGVySW1hZ2VEYXRhVXJpSGVscGVyKHZhbHVlKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEEgcGF0dGVybiB0aGF0IHZldHMgdmFsdWVzIHByb2R1Y2VkIGJ5IHRoZSBuYW1lZCBkaXJlY3RpdmVzLlxuICAgICAqIEBwcml2YXRlIHshUmVnRXhwfVxuICAgICAqL1xuICAgIHNveS5lc2MuJCRGSUxURVJfRk9SX0ZJTFRFUl9JTUFHRV9EQVRBX1VSSV8gPSAvXmRhdGE6aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZT9nfHBuZ3x0aWZmfHdlYnApO2Jhc2U2NCxbYS16MC05K1xcL10rPSokL2k7XG5cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmb3IgdGhlIFNveSBkaXJlY3RpdmUgfGZpbHRlckltYWdlRGF0YVVyaVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQ2FuIGJlIG9mIGFueSB0eXBlIGJ1dCB3aWxsIGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZXNjYXBlZCB0ZXh0LlxuICAgICAqL1xuICAgIHNveS5lc2MuJCRmaWx0ZXJJbWFnZURhdGFVcmlIZWxwZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBzdHIgPSBTdHJpbmcodmFsdWUpO1xuICAgICAgaWYgKCFzb3kuZXNjLiQkRklMVEVSX0ZPUl9GSUxURVJfSU1BR0VfREFUQV9VUklfLnRlc3Qoc3RyKSkge1xuICAgICAgICBnb29nLmFzc2VydHMuZmFpbCgnQmFkIHZhbHVlIGAlc2AgZm9yIHxmaWx0ZXJJbWFnZURhdGFVcmknLCBbc3RyXSk7XG4gICAgICAgIHJldHVybiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LHpTb3l6JztcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIHZhciBpbmNyZW1lbnRhbGRvbSA9IEluY3JlbWVudGFsRE9NO1xuICAgIHZhciBzb3lJRE9NID0ge307XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBhbiBleHByZXNzaW9uIGluIGNhc2Ugb2YgYSBmdW5jdGlvbiBvciBvdXRwdXRzIGl0IGFzIHRleHQgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbnxmdW5jdGlvbigpP30gZXhwclxuICAgICAqL1xuICAgIHNveUlET00ucmVuZGVyRHluYW1pY0NvbnRlbnQgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgaWYgKGdvb2cuaXNGdW5jdGlvbihleHByKSkge1xuICAgICAgICBleHByKCk7XG4gICAgICB9IGVsc2UgaWYgKGV4cHIgIT0gbnVsbCkge1xuICAgICAgICBpbmNyZW1lbnRhbGRvbS50ZXh0KGV4cHIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcmludHMgYW4gZXhwcmVzc2lvbiBkZXBlbmRpbmcgb24gaXRzIHR5cGUuXG4gICAgICogQHBhcmFtIHshU2FuaXRpemVkSHRtbHxzdHJpbmd8bnVtYmVyfGJvb2xlYW58ZnVuY3Rpb24oKX0gZXhwclxuICAgICAqL1xuICAgIHNveUlET00ucHJpbnQgPSBmdW5jdGlvbiAoZXhwcikge1xuICAgICAgaWYgKGV4cHIgaW5zdGFuY2VvZiBzb3lkYXRhLlNhbml0aXplZEh0bWwpIHtcbiAgICAgICAgLy8gRm9yIEhUTUwgY29udGVudCB3ZSBuZWVkIHRvIGluc2VydCBhIGN1c3RvbSBlbGVtZW50IHdoZXJlIHdlIGNhbiBwbGFjZVxuICAgICAgICAvLyB0aGUgY29udGVudCB3aXRob3V0IGluY3JlbWVudGFsIGRvbSBtb2RpZnlpbmcgaXQuXG4gICAgICAgIHZhciBlbCA9IGluY3JlbWVudGFsZG9tLmVsZW1lbnRPcGVuKCdodG1sLWJsb2InKTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBleHByLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChlbC5fX2lubmVySFRNTCAhPT0gY29udGVudCkge1xuICAgICAgICAgIHNveS5yZW5kZXJIdG1sKGVsLCBleHByKTtcbiAgICAgICAgICBlbC5fX2lubmVySFRNTCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5jcmVtZW50YWxkb20uc2tpcCgpO1xuICAgICAgICBpbmNyZW1lbnRhbGRvbS5lbGVtZW50Q2xvc2UoJ2h0bWwtYmxvYicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc295SURPTS5yZW5kZXJEeW5hbWljQ29udGVudChleHByKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdvb2cubW9kdWxlKCdzb3kuaWRvbScpO1xuICAgICAgcmV0dXJuIHNveUlET007XG4gICAgfSk7XG5cbiAgICAvLyBFTkQgR0VORVJBVEVEIENPREVcblxuICAgIGdvb2cubG9hZE1vZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICBnb29nLm1vZHVsZSgnc295Jyk7XG4gICAgICByZXR1cm4gc295O1xuICAgIH0pO1xuXG4gICAgZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdvb2cubW9kdWxlKCdzb3lkYXRhJyk7XG4gICAgICByZXR1cm4gc295ZGF0YTtcbiAgICB9KTtcblxuICAgIGdvb2cubG9hZE1vZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICBnb29nLm1vZHVsZSgnc295LmFzc2VydHMnKTtcbiAgICAgIHJldHVybiBzb3k7XG4gICAgfSk7XG4gIH0pKCk7XG5cbiAgZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uICgpIHtcbiAgICBnb29nLm1vZHVsZSgnaW5jcmVtZW50YWxkb20nKTtcbiAgICByZXR1cm4gSW5jcmVtZW50YWxET007XG4gIH0pO1xufSkuY2FsbCh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3cpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS1idW5kbGUvbGliL2J1bmRsZS5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBBIGNhY2hlZCByZWZlcmVuY2UgdG8gdGhlIGhhc093blByb3BlcnR5IGZ1bmN0aW9uLlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCB3aWxsIGNyZWF0ZSBibGFuayBvYmplY3RzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJsYW5rKCkge31cblxuQmxhbmsucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuLyoqXG4gKiBVc2VkIHRvIHByZXZlbnQgcHJvcGVydHkgY29sbGlzaW9ucyBiZXR3ZWVuIG91ciBcIm1hcFwiIGFuZCBpdHMgcHJvdG90eXBlLlxuICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgKj59IG1hcCBUaGUgbWFwIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgbWFwIGhhcyBwcm9wZXJ0eS5cbiAqL1xudmFyIGhhcyA9IGZ1bmN0aW9uIChtYXAsIHByb3BlcnR5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG1hcCBvYmplY3Qgd2l0aG91dCBhIHByb3RvdHlwZS5cbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cbnZhciBjcmVhdGVNYXAgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgQmxhbmsoKTtcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHBlcmZvcm0gZGlmZnMgZm9yIGEgZ2l2ZW4gRE9NIG5vZGUuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5vZGVOYW1lXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOb2RlRGF0YShub2RlTmFtZSwga2V5KSB7XG4gIC8qKlxuICAgKiBUaGUgYXR0cmlidXRlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICAgKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICovXG4gIHRoaXMuYXR0cnMgPSBjcmVhdGVNYXAoKTtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMsIHVzZWQgZm9yIHF1aWNrbHkgZGlmZmluZyB0aGVcbiAgICogaW5jb21taW5nIGF0dHJpYnV0ZXMgdG8gc2VlIGlmIHRoZSBET00gbm9kZSdzIGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgKiB1cGRhdGVkLlxuICAgKiBAY29uc3Qge0FycmF5PCo+fVxuICAgKi9cbiAgdGhpcy5hdHRyc0FyciA9IFtdO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5jb21pbmcgYXR0cmlidXRlcyBmb3IgdGhpcyBOb2RlLCBiZWZvcmUgdGhleSBhcmUgdXBkYXRlZC5cbiAgICogQGNvbnN0IHshT2JqZWN0PHN0cmluZywgKj59XG4gICAqL1xuICB0aGlzLm5ld0F0dHJzID0gY3JlYXRlTWFwKCk7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzdGF0aWNzIGhhdmUgYmVlbiBhcHBsaWVkIGZvciB0aGUgbm9kZSB5ZXQuXG4gICAqIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5zdGF0aWNzQXBwbGllZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBub2RlLCB1c2VkIHRvIHByZXNlcnZlIERPTSBub2RlcyB3aGVuIHRoZXlcbiAgICogbW92ZSB3aXRoaW4gdGhlaXIgcGFyZW50LlxuICAgKiBAY29uc3RcbiAgICovXG4gIHRoaXMua2V5ID0ga2V5O1xuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiBjaGlsZHJlbiB3aXRoaW4gdGhpcyBub2RlIGJ5IHRoZWlyIGtleS5cbiAgICogeyFPYmplY3Q8c3RyaW5nLCAhRWxlbWVudD59XG4gICAqL1xuICB0aGlzLmtleU1hcCA9IGNyZWF0ZU1hcCgpO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUga2V5TWFwIGlzIGN1cnJlbnRseSB2YWxpZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmtleU1hcFZhbGlkID0gdHJ1ZTtcblxuICAvKipcbiAgICogV2hldGhlciBvciB0aGUgYXNzb2NpYXRlZCBub2RlIGlzLCBvciBjb250YWlucywgYSBmb2N1c2VkIEVsZW1lbnQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5mb2N1c2VkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBub2RlIG5hbWUgZm9yIHRoaXMgbm9kZS5cbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHs/c3RyaW5nfVxuICAgKi9cbiAgdGhpcy50ZXh0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIE5vZGVEYXRhIG9iamVjdCBmb3IgYSBOb2RlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBpbml0aWFsaXplIGRhdGEgZm9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlIG5hbWUgb2Ygbm9kZS5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgbm9kZS5cbiAqIEByZXR1cm4geyFOb2RlRGF0YX0gVGhlIG5ld2x5IGluaXRpYWxpemVkIGRhdGEgb2JqZWN0XG4gKi9cbnZhciBpbml0RGF0YSA9IGZ1bmN0aW9uIChub2RlLCBub2RlTmFtZSwga2V5KSB7XG4gIHZhciBkYXRhID0gbmV3IE5vZGVEYXRhKG5vZGVOYW1lLCBrZXkpO1xuICBub2RlWydfX2luY3JlbWVudGFsRE9NRGF0YSddID0gZGF0YTtcbiAgcmV0dXJuIGRhdGE7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTm9kZURhdGEgb2JqZWN0IGZvciBhIE5vZGUsIGNyZWF0aW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0gez9Ob2RlfSBub2RlIFRoZSBOb2RlIHRvIHJldHJpZXZlIHRoZSBkYXRhIGZvci5cbiAqIEByZXR1cm4geyFOb2RlRGF0YX0gVGhlIE5vZGVEYXRhIGZvciB0aGlzIE5vZGUuXG4gKi9cbnZhciBnZXREYXRhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaW1wb3J0Tm9kZShub2RlKTtcbiAgcmV0dXJuIG5vZGVbJ19faW5jcmVtZW50YWxET01EYXRhJ107XG59O1xuXG4vKipcbiAqIEltcG9ydHMgbm9kZSBhbmQgaXRzIHN1YnRyZWUsIGluaXRpYWxpemluZyBjYWNoZXMuXG4gKlxuICogQHBhcmFtIHs/Tm9kZX0gbm9kZSBUaGUgTm9kZSB0byBpbXBvcnQuXG4gKi9cbnZhciBpbXBvcnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGVbJ19faW5jcmVtZW50YWxET01EYXRhJ10pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaXNFbGVtZW50ID0gbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG4gIHZhciBub2RlTmFtZSA9IGlzRWxlbWVudCA/IG5vZGUubG9jYWxOYW1lIDogbm9kZS5ub2RlTmFtZTtcbiAgdmFyIGtleSA9IGlzRWxlbWVudCA/IG5vZGUuZ2V0QXR0cmlidXRlKCdrZXknKSA6IG51bGw7XG4gIHZhciBkYXRhID0gaW5pdERhdGEobm9kZSwgbm9kZU5hbWUsIGtleSk7XG5cbiAgaWYgKGtleSkge1xuICAgIGdldERhdGEobm9kZS5wYXJlbnROb2RlKS5rZXlNYXBba2V5XSA9IG5vZGU7XG4gIH1cblxuICBpZiAoaXNFbGVtZW50KSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgICB2YXIgbmV3QXR0cnMgPSBkYXRhLm5ld0F0dHJzO1xuICAgIHZhciBhdHRyc0FyciA9IGRhdGEuYXR0cnNBcnI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tpXTtcbiAgICAgIHZhciBuYW1lID0gYXR0ci5uYW1lO1xuICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZTtcblxuICAgICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIG5ld0F0dHJzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgYXR0cnNBcnIucHVzaChuYW1lKTtcbiAgICAgIGF0dHJzQXJyLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGltcG9ydE5vZGUoY2hpbGQpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIG5hbWVzcGFjZSB0byBjcmVhdGUgYW4gZWxlbWVudCAob2YgYSBnaXZlbiB0YWcpIGluLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIHRvIGdldCB0aGUgbmFtZXNwYWNlIGZvci5cbiAqIEBwYXJhbSB7P05vZGV9IHBhcmVudFxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIG5hbWVzcGFjZSB0byBjcmVhdGUgdGhlIHRhZyBpbi5cbiAqL1xudmFyIGdldE5hbWVzcGFjZUZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudCkge1xuICBpZiAodGFnID09PSAnc3ZnJykge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICB9XG5cbiAgaWYgKGdldERhdGEocGFyZW50KS5ub2RlTmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGFyZW50Lm5hbWVzcGFjZVVSSTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBFbGVtZW50LlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIFRoZSBkb2N1bWVudCB3aXRoIHdoaWNoIHRvIGNyZWF0ZSB0aGUgRWxlbWVudC5cbiAqIEBwYXJhbSB7P05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgdGFnIGZvciB0aGUgRWxlbWVudC5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBBIGtleSB0byBpZGVudGlmeSB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4geyFFbGVtZW50fVxuICovXG52YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChkb2MsIHBhcmVudCwgdGFnLCBrZXkpIHtcbiAgdmFyIG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZUZvclRhZyh0YWcsIHBhcmVudCk7XG4gIHZhciBlbCA9IHVuZGVmaW5lZDtcblxuICBpZiAobmFtZXNwYWNlKSB7XG4gICAgZWwgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZSwgdGFnKTtcbiAgfSBlbHNlIHtcbiAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIH1cblxuICBpbml0RGF0YShlbCwgdGFnLCBrZXkpO1xuXG4gIHJldHVybiBlbDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRleHQgTm9kZS5cbiAqIEBwYXJhbSB7RG9jdW1lbnR9IGRvYyBUaGUgZG9jdW1lbnQgd2l0aCB3aGljaCB0byBjcmVhdGUgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshVGV4dH1cbiAqL1xudmFyIGNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZG9jKSB7XG4gIHZhciBub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgaW5pdERhdGEobm9kZSwgJyN0ZXh0JywgbnVsbCk7XG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGNvbnN0ICovXG52YXIgbm90aWZpY2F0aW9ucyA9IHtcbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciBwYXRjaCBoYXMgY29tcGxlYXRlZCB3aXRoIGFueSBOb2RlcyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXG4gICAqIGFuZCBhZGRlZCB0byB0aGUgRE9NLlxuICAgKiBAdHlwZSB7P2Z1bmN0aW9uKEFycmF5PCFOb2RlPil9XG4gICAqL1xuICBub2Rlc0NyZWF0ZWQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIENhbGxlZCBhZnRlciBwYXRjaCBoYXMgY29tcGxlYXRlZCB3aXRoIGFueSBOb2RlcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAqIGZyb20gdGhlIERPTS5cbiAgICogTm90ZSBpdCdzIGFuIGFwcGxpY2F0aW9ucyByZXNwb25zaWJpbGl0eSB0byBoYW5kbGUgYW55IGNoaWxkTm9kZXMuXG4gICAqIEB0eXBlIHs/ZnVuY3Rpb24oQXJyYXk8IU5vZGU+KX1cbiAgICovXG4gIG5vZGVzRGVsZXRlZDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgc3RhdGUgb2YgYSBwYXRjaC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb250ZXh0KCkge1xuICAvKipcbiAgICogQHR5cGUgeyhBcnJheTwhTm9kZT58dW5kZWZpbmVkKX1cbiAgICovXG4gIHRoaXMuY3JlYXRlZCA9IG5vdGlmaWNhdGlvbnMubm9kZXNDcmVhdGVkICYmIFtdO1xuXG4gIC8qKlxuICAgKiBAdHlwZSB7KEFycmF5PCFOb2RlPnx1bmRlZmluZWQpfVxuICAgKi9cbiAgdGhpcy5kZWxldGVkID0gbm90aWZpY2F0aW9ucy5ub2Rlc0RlbGV0ZWQgJiYgW107XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICovXG5Db250ZXh0LnByb3RvdHlwZS5tYXJrQ3JlYXRlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLmNyZWF0ZWQpIHtcbiAgICB0aGlzLmNyZWF0ZWQucHVzaChub2RlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLm1hcmtEZWxldGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgIHRoaXMuZGVsZXRlZC5wdXNoKG5vZGUpO1xuICB9XG59O1xuXG4vKipcbiAqIE5vdGlmaWVzIGFib3V0IG5vZGVzIHRoYXQgd2VyZSBjcmVhdGVkIGR1cmluZyB0aGUgcGF0Y2ggb3BlYXJhdGlvbi5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUubm90aWZ5Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuY3JlYXRlZCAmJiB0aGlzLmNyZWF0ZWQubGVuZ3RoID4gMCkge1xuICAgIG5vdGlmaWNhdGlvbnMubm9kZXNDcmVhdGVkKHRoaXMuY3JlYXRlZCk7XG4gIH1cblxuICBpZiAodGhpcy5kZWxldGVkICYmIHRoaXMuZGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgbm90aWZpY2F0aW9ucy5ub2Rlc0RlbGV0ZWQodGhpcy5kZWxldGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAgKiBLZWVwcyB0cmFjayB3aGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gYW4gYXR0cmlidXRlcyBkZWNsYXJhdGlvbiAoYWZ0ZXJcbiAgKiBlbGVtZW50T3BlblN0YXJ0LCBidXQgYmVmb3JlIGVsZW1lbnRPcGVuRW5kKS5cbiAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKi9cbnZhciBpbkF0dHJpYnV0ZXMgPSBmYWxzZTtcblxuLyoqXG4gICogS2VlcHMgdHJhY2sgd2hldGhlciBvciBub3Qgd2UgYXJlIGluIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgbm90IGhhdmUgaXRzXG4gICogY2hpbGRyZW4gY2xlYXJlZC5cbiAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKi9cbnZhciBpblNraXAgPSBmYWxzZTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlcmUgaXMgYSBjdXJyZW50IHBhdGNoIGNvbnRleHQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqL1xudmFyIGFzc2VydEluUGF0Y2ggPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBjb250ZXh0KSB7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgJyArIGZ1bmN0aW9uTmFtZSArICcoKSB1bmxlc3MgaW4gcGF0Y2guJyk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IGEgcGF0Y2ggY2xvc2VzIGV2ZXJ5IG5vZGUgdGhhdCBpdCBvcGVuZWQuXG4gKiBAcGFyYW0gez9Ob2RlfSBvcGVuRWxlbWVudFxuICogQHBhcmFtIHshTm9kZXwhRG9jdW1lbnRGcmFnbWVudH0gcm9vdFxuICovXG52YXIgYXNzZXJ0Tm9VbmNsb3NlZFRhZ3MgPSBmdW5jdGlvbiAob3BlbkVsZW1lbnQsIHJvb3QpIHtcbiAgaWYgKG9wZW5FbGVtZW50ID09PSByb290KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRFbGVtZW50ID0gb3BlbkVsZW1lbnQ7XG4gIHZhciBvcGVuVGFncyA9IFtdO1xuICB3aGlsZSAoY3VycmVudEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICBvcGVuVGFncy5wdXNoKGN1cnJlbnRFbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIGN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignT25lIG9yIG1vcmUgdGFncyB3ZXJlIG5vdCBjbG9zZWQ6XFxuJyArIG9wZW5UYWdzLmpvaW4oJ1xcbicpKTtcbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjYWxsZXIgaXMgbm90IHdoZXJlIGF0dHJpYnV0ZXMgYXJlIGV4cGVjdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICovXG52YXIgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICBpZiAoaW5BdHRyaWJ1dGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZ1bmN0aW9uTmFtZSArICcoKSBjYW4gbm90IGJlIGNhbGxlZCBiZXR3ZWVuICcgKyAnZWxlbWVudE9wZW5TdGFydCgpIGFuZCBlbGVtZW50T3BlbkVuZCgpLicpO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgY2FsbGVyIGlzIG5vdCBpbnNpZGUgYW4gZWxlbWVudCB0aGF0IGhhcyBkZWNsYXJlZCBza2lwLlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICovXG52YXIgYXNzZXJ0Tm90SW5Ta2lwID0gZnVuY3Rpb24gKGZ1bmN0aW9uTmFtZSkge1xuICBpZiAoaW5Ta2lwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZ1bmN0aW9uTmFtZSArICcoKSBtYXkgbm90IGJlIGNhbGxlZCBpbnNpZGUgYW4gZWxlbWVudCAnICsgJ3RoYXQgaGFzIGNhbGxlZCBza2lwKCkuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjYWxsZXIgaXMgd2hlcmUgYXR0cmlidXRlcyBhcmUgZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKi9cbnZhciBhc3NlcnRJbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gIGlmICghaW5BdHRyaWJ1dGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZ1bmN0aW9uTmFtZSArICcoKSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgY2FsbGluZyAnICsgJ2VsZW1lbnRPcGVuU3RhcnQoKS4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoZSBwYXRjaCBjbG9zZXMgdmlydHVhbCBhdHRyaWJ1dGVzIGNhbGxcbiAqL1xudmFyIGFzc2VydFZpcnR1YWxBdHRyaWJ1dGVzQ2xvc2VkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoaW5BdHRyaWJ1dGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbGVtZW50T3BlbkVuZCgpIG11c3QgYmUgY2FsbGVkIGFmdGVyIGNhbGxpbmcgJyArICdlbGVtZW50T3BlblN0YXJ0KCkuJyk7XG4gIH1cbn07XG5cbi8qKlxuICAqIE1ha2VzIHN1cmUgdGhhdCB0YWdzIGFyZSBjb3JyZWN0bHkgbmVzdGVkLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZVxuICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgKi9cbnZhciBhc3NlcnRDbG9zZU1hdGNoZXNPcGVuVGFnID0gZnVuY3Rpb24gKG5vZGVOYW1lLCB0YWcpIHtcbiAgaWYgKG5vZGVOYW1lICE9PSB0YWcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY2VpdmVkIGEgY2FsbCB0byBjbG9zZSBcIicgKyB0YWcgKyAnXCIgYnV0IFwiJyArIG5vZGVOYW1lICsgJ1wiIHdhcyBvcGVuLicpO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCBubyBjaGlsZHJlbiBlbGVtZW50cyBoYXZlIGJlZW4gZGVjbGFyZWQgeWV0IGluIHRoZSBjdXJyZW50XG4gKiBlbGVtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICogQHBhcmFtIHs/Tm9kZX0gcHJldmlvdXNOb2RlXG4gKi9cbnZhciBhc3NlcnROb0NoaWxkcmVuRGVjbGFyZWRZZXQgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwcmV2aW91c05vZGUpIHtcbiAgaWYgKHByZXZpb3VzTm9kZSAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihmdW5jdGlvbk5hbWUgKyAnKCkgbXVzdCBjb21lIGJlZm9yZSBhbnkgY2hpbGQgJyArICdkZWNsYXJhdGlvbnMgaW5zaWRlIHRoZSBjdXJyZW50IGVsZW1lbnQuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoYXQgYSBjYWxsIHRvIHBhdGNoT3V0ZXIgYWN0dWFsbHkgcGF0Y2hlZCB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7P05vZGV9IHN0YXJ0Tm9kZSBUaGUgdmFsdWUgZm9yIHRoZSBjdXJyZW50Tm9kZSB3aGVuIHRoZSBwYXRjaFxuICogICAgIHN0YXJ0ZWQuXG4gKiBAcGFyYW0gez9Ob2RlfSBjdXJyZW50Tm9kZSBUaGUgY3VycmVudE5vZGUgd2hlbiB0aGUgcGF0Y2ggZmluaXNoZWQuXG4gKiBAcGFyYW0gez9Ob2RlfSBleHBlY3RlZE5leHROb2RlIFRoZSBOb2RlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gZm9sbG93IHRoZVxuICogICAgY3VycmVudE5vZGUgYWZ0ZXIgdGhlIHBhdGNoO1xuICogQHBhcmFtIHs/Tm9kZX0gZXhwZWN0ZWRQcmV2Tm9kZSBUaGUgTm9kZSB0aGF0IGlzIGV4cGVjdGVkIHRvIHByZWNlZWQgdGhlXG4gKiAgICBjdXJyZW50Tm9kZSBhZnRlciB0aGUgcGF0Y2guXG4gKi9cbnZhciBhc3NlcnRQYXRjaEVsZW1lbnROb0V4dHJhcyA9IGZ1bmN0aW9uIChzdGFydE5vZGUsIGN1cnJlbnROb2RlLCBleHBlY3RlZE5leHROb2RlLCBleHBlY3RlZFByZXZOb2RlKSB7XG4gIHZhciB3YXNVcGRhdGVkID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmcgPT09IGV4cGVjdGVkTmV4dE5vZGUgJiYgY3VycmVudE5vZGUucHJldmlvdXNTaWJsaW5nID09PSBleHBlY3RlZFByZXZOb2RlO1xuICB2YXIgd2FzQ2hhbmdlZCA9IGN1cnJlbnROb2RlLm5leHRTaWJsaW5nID09PSBzdGFydE5vZGUubmV4dFNpYmxpbmcgJiYgY3VycmVudE5vZGUucHJldmlvdXNTaWJsaW5nID09PSBleHBlY3RlZFByZXZOb2RlO1xuICB2YXIgd2FzUmVtb3ZlZCA9IGN1cnJlbnROb2RlID09PSBzdGFydE5vZGU7XG5cbiAgaWYgKCF3YXNVcGRhdGVkICYmICF3YXNDaGFuZ2VkICYmICF3YXNSZW1vdmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSBtdXN0IGJlIGV4YWN0bHkgb25lIHRvcCBsZXZlbCBjYWxsIGNvcnJlc3BvbmRpbmcgJyArICd0byB0aGUgcGF0Y2hlZCBlbGVtZW50LicpO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIGJlaW5nIGluIGFuIGF0dHJpYnV0ZSBkZWNsYXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAqL1xudmFyIHNldEluQXR0cmlidXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIgcHJldmlvdXMgPSBpbkF0dHJpYnV0ZXM7XG4gIGluQXR0cmlidXRlcyA9IHZhbHVlO1xuICByZXR1cm4gcHJldmlvdXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIGJlaW5nIGluIGEgc2tpcCBlbGVtZW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHByZXZpb3VzIHZhbHVlLlxuICovXG52YXIgc2V0SW5Ta2lwID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcmV2aW91cyA9IGluU2tpcDtcbiAgaW5Ta2lwID0gdmFsdWU7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTYgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBub2RlIHRoZSByb290IG9mIGEgZG9jdW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmFyIGlzRG9jdW1lbnRSb290ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gRm9yIFNoYWRvd1Jvb3RzLCBjaGVjayBpZiB0aGV5IGFyZSBhIERvY3VtZW50RnJhZ21lbnQgaW5zdGVhZCBvZiBpZiB0aGV5XG4gIC8vIGFyZSBhIFNoYWRvd1Jvb3Qgc28gdGhhdCB0aGlzIGNhbiB3b3JrIGluICd1c2Ugc3RyaWN0JyBpZiBTaGFkb3dSb290cyBhcmVcbiAgLy8gbm90IHN1cHBvcnRlZC5cbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgbm9kZSB0byBzdGFydCBhdCwgaW5jbHVzaXZlLlxuICogQHBhcmFtIHs/Tm9kZX0gcm9vdCBUaGUgcm9vdCBhbmNlc3RvciB0byBnZXQgdW50aWwsIGV4Y2x1c2l2ZS5cbiAqIEByZXR1cm4geyFBcnJheTwhTm9kZT59IFRoZSBhbmNlc3RyeSBvZiBET00gbm9kZXMuXG4gKi9cbnZhciBnZXRBbmNlc3RyeSA9IGZ1bmN0aW9uIChub2RlLCByb290KSB7XG4gIHZhciBhbmNlc3RyeSA9IFtdO1xuICB2YXIgY3VyID0gbm9kZTtcblxuICB3aGlsZSAoY3VyICE9PSByb290KSB7XG4gICAgYW5jZXN0cnkucHVzaChjdXIpO1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGFuY2VzdHJ5O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHshTm9kZX0gVGhlIHJvb3Qgbm9kZSBvZiB0aGUgRE9NIHRyZWUgdGhhdCBjb250YWlucyBub2RlLlxuICovXG52YXIgZ2V0Um9vdCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBjdXIgPSBub2RlO1xuICB2YXIgcHJldiA9IGN1cjtcblxuICB3aGlsZSAoY3VyKSB7XG4gICAgcHJldiA9IGN1cjtcbiAgICBjdXIgPSBjdXIucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBwcmV2O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudCBmb3IuXG4gKiBAcmV0dXJuIHs/RWxlbWVudH0gVGhlIGFjdGl2ZUVsZW1lbnQgaW4gdGhlIERvY3VtZW50IG9yIFNoYWRvd1Jvb3RcbiAqICAgICBjb3JyZXNwb25kaW5nIHRvIG5vZGUsIGlmIHByZXNlbnQuXG4gKi9cbnZhciBnZXRBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHJvb3QgPSBnZXRSb290KG5vZGUpO1xuICByZXR1cm4gaXNEb2N1bWVudFJvb3Qocm9vdCkgPyByb290LmFjdGl2ZUVsZW1lbnQgOiBudWxsO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwYXRoIG9mIG5vZGVzIHRoYXQgY29udGFpbiB0aGUgZm9jdXNlZCBub2RlIGluIHRoZSBzYW1lIGRvY3VtZW50IGFzXG4gKiBhIHJlZmVyZW5jZSBub2RlLCB1cCB1bnRpbCB0aGUgcm9vdC5cbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgVGhlIHJlZmVyZW5jZSBub2RlIHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudCBmb3IuXG4gKiBAcGFyYW0gez9Ob2RlfSByb290IFRoZSByb290IHRvIGdldCB0aGUgZm9jdXNlZCBwYXRoIHVudGlsLlxuICogQHJldHVybiB7IUFycmF5PE5vZGU+fVxuICovXG52YXIgZ2V0Rm9jdXNlZFBhdGggPSBmdW5jdGlvbiAobm9kZSwgcm9vdCkge1xuICB2YXIgYWN0aXZlRWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQobm9kZSk7XG5cbiAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFub2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIGdldEFuY2VzdHJ5KGFjdGl2ZUVsZW1lbnQsIHJvb3QpO1xufTtcblxuLyoqXG4gKiBMaWtlIGluc2VydEJlZm9yZSwgYnV0IGluc3RlYWQgaW5zdGVhZCBvZiBtb3ZpbmcgdGhlIGRlc2lyZWQgbm9kZSwgaW5zdGVhZFxuICogbW92ZXMgYWxsIHRoZSBvdGhlciBub2RlcyBhZnRlci5cbiAqIEBwYXJhbSB7P05vZGV9IHBhcmVudE5vZGVcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7P05vZGV9IHJlZmVyZW5jZU5vZGVcbiAqL1xudmFyIG1vdmVCZWZvcmUgPSBmdW5jdGlvbiAocGFyZW50Tm9kZSwgbm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICB2YXIgaW5zZXJ0UmVmZXJlbmNlTm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIHZhciBjdXIgPSByZWZlcmVuY2VOb2RlO1xuXG4gIHdoaWxlIChjdXIgIT09IG5vZGUpIHtcbiAgICB2YXIgbmV4dCA9IGN1ci5uZXh0U2libGluZztcbiAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjdXIsIGluc2VydFJlZmVyZW5jZU5vZGUpO1xuICAgIGN1ciA9IG5leHQ7XG4gIH1cbn07XG5cbi8qKiBAdHlwZSB7P0NvbnRleHR9ICovXG52YXIgY29udGV4dCA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P05vZGV9ICovXG52YXIgY3VycmVudE5vZGUgPSBudWxsO1xuXG4vKiogQHR5cGUgez9Ob2RlfSAqL1xudmFyIGN1cnJlbnRQYXJlbnQgPSBudWxsO1xuXG4vKiogQHR5cGUgez9Eb2N1bWVudH0gKi9cbnZhciBkb2MgPSBudWxsO1xuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5PE5vZGU+fSBmb2N1c1BhdGggVGhlIG5vZGVzIHRvIG1hcmsuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvY3VzZWQgV2hldGhlciBvciBub3QgdGhleSBhcmUgZm9jdXNlZC5cbiAqL1xudmFyIG1hcmtGb2N1c2VkID0gZnVuY3Rpb24gKGZvY3VzUGF0aCwgZm9jdXNlZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGZvY3VzUGF0aC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGdldERhdGEoZm9jdXNQYXRoW2ldKS5mb2N1c2VkID0gZm9jdXNlZDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0Y2hlciBmdW5jdGlvbiB0aGF0IHNldHMgdXAgYW5kIHJlc3RvcmVzIGEgcGF0Y2ggY29udGV4dCxcbiAqIHJ1bm5pbmcgdGhlIHJ1biBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBkYXRhLlxuICogQHBhcmFtIHtmdW5jdGlvbigoIUVsZW1lbnR8IURvY3VtZW50RnJhZ21lbnQpLCFmdW5jdGlvbihUKSxUPSk6ID9Ob2RlfSBydW5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCksIWZ1bmN0aW9uKFQpLFQ9KTogP05vZGV9XG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgcGF0Y2hGYWN0b3J5ID0gZnVuY3Rpb24gKHJ1bikge1xuICAvKipcbiAgICogVE9ETyhtb3opOiBUaGVzZSBhbm5vdGF0aW9ucyB3b24ndCBiZSBuZWNlc3Nhcnkgb25jZSB3ZSBzd2l0Y2ggdG8gQ2xvc3VyZVxuICAgKiBDb21waWxlcidzIG5ldyB0eXBlIGluZmVyZW5jZS4gUmVtb3ZlIHRoZXNlIG9uY2UgdGhlIHN3aXRjaCBpcyBkb25lLlxuICAgKlxuICAgKiBAcGFyYW0geyghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCl9IG5vZGVcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oVCl9IGZuXG4gICAqIEBwYXJhbSB7VD19IGRhdGFcbiAgICogQHJldHVybiB7P05vZGV9IG5vZGVcbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG4gIHZhciBmID0gZnVuY3Rpb24gKG5vZGUsIGZuLCBkYXRhKSB7XG4gICAgdmFyIHByZXZDb250ZXh0ID0gY29udGV4dDtcbiAgICB2YXIgcHJldkRvYyA9IGRvYztcbiAgICB2YXIgcHJldkN1cnJlbnROb2RlID0gY3VycmVudE5vZGU7XG4gICAgdmFyIHByZXZDdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICB2YXIgcHJldmlvdXNJbkF0dHJpYnV0ZXMgPSBmYWxzZTtcbiAgICB2YXIgcHJldmlvdXNJblNraXAgPSBmYWxzZTtcblxuICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuICAgIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByZXZpb3VzSW5BdHRyaWJ1dGVzID0gc2V0SW5BdHRyaWJ1dGVzKGZhbHNlKTtcbiAgICAgIHByZXZpb3VzSW5Ta2lwID0gc2V0SW5Ta2lwKGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgZm9jdXNQYXRoID0gZ2V0Rm9jdXNlZFBhdGgobm9kZSwgY3VycmVudFBhcmVudCk7XG4gICAgbWFya0ZvY3VzZWQoZm9jdXNQYXRoLCB0cnVlKTtcbiAgICB2YXIgcmV0VmFsID0gcnVuKG5vZGUsIGZuLCBkYXRhKTtcbiAgICBtYXJrRm9jdXNlZChmb2N1c1BhdGgsIGZhbHNlKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRWaXJ0dWFsQXR0cmlidXRlc0Nsb3NlZCgpO1xuICAgICAgc2V0SW5BdHRyaWJ1dGVzKHByZXZpb3VzSW5BdHRyaWJ1dGVzKTtcbiAgICAgIHNldEluU2tpcChwcmV2aW91c0luU2tpcCk7XG4gICAgfVxuXG4gICAgY29udGV4dC5ub3RpZnlDaGFuZ2VzKCk7XG5cbiAgICBjb250ZXh0ID0gcHJldkNvbnRleHQ7XG4gICAgZG9jID0gcHJldkRvYztcbiAgICBjdXJyZW50Tm9kZSA9IHByZXZDdXJyZW50Tm9kZTtcbiAgICBjdXJyZW50UGFyZW50ID0gcHJldkN1cnJlbnRQYXJlbnQ7XG5cbiAgICByZXR1cm4gcmV0VmFsO1xuICB9O1xuICByZXR1cm4gZjtcbn07XG5cbi8qKlxuICogUGF0Y2hlcyB0aGUgZG9jdW1lbnQgc3RhcnRpbmcgYXQgbm9kZSB3aXRoIHRoZSBwcm92aWRlZCBmdW5jdGlvbi4gVGhpc1xuICogZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBkdXJpbmcgYW4gZXhpc3RpbmcgcGF0Y2ggb3BlcmF0aW9uLlxuICogQHBhcmFtIHshRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudH0gbm9kZSBUaGUgRWxlbWVudCBvciBEb2N1bWVudFxuICogICAgIHRvIHBhdGNoLlxuICogQHBhcmFtIHshZnVuY3Rpb24oVCl9IGZuIEEgZnVuY3Rpb24gY29udGFpbmluZyBlbGVtZW50T3Blbi9lbGVtZW50Q2xvc2UvZXRjLlxuICogICAgIGNhbGxzIHRoYXQgZGVzY3JpYmUgdGhlIERPTS5cbiAqIEBwYXJhbSB7VD19IGRhdGEgQW4gYXJndW1lbnQgcGFzc2VkIHRvIGZuIHRvIHJlcHJlc2VudCBET00gc3RhdGUuXG4gKiBAcmV0dXJuIHshTm9kZX0gVGhlIHBhdGNoZWQgbm9kZS5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBwYXRjaElubmVyID0gcGF0Y2hGYWN0b3J5KGZ1bmN0aW9uIChub2RlLCBmbiwgZGF0YSkge1xuICBjdXJyZW50Tm9kZSA9IG5vZGU7XG5cbiAgZW50ZXJOb2RlKCk7XG4gIGZuKGRhdGEpO1xuICBleGl0Tm9kZSgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Tm9VbmNsb3NlZFRhZ3MoY3VycmVudE5vZGUsIG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59KTtcblxuLyoqXG4gKiBQYXRjaGVzIGFuIEVsZW1lbnQgd2l0aCB0aGUgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBFeGFjdGx5IG9uZSB0b3AgbGV2ZWxcbiAqIGVsZW1lbnQgY2FsbCBzaG91bGQgYmUgbWFkZSBjb3JyZXNwb25kaW5nIHRvIGBub2RlYC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgVGhlIEVsZW1lbnQgd2hlcmUgdGhlIHBhdGNoIHNob3VsZCBzdGFydC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKFQpfSBmbiBBIGZ1bmN0aW9uIGNvbnRhaW5pbmcgZWxlbWVudE9wZW4vZWxlbWVudENsb3NlL2V0Yy5cbiAqICAgICBjYWxscyB0aGF0IGRlc2NyaWJlIHRoZSBET00uIFRoaXMgc2hvdWxkIGhhdmUgYXQgbW9zdCBvbmUgdG9wIGxldmVsXG4gKiAgICAgZWxlbWVudCBjYWxsLlxuICogQHBhcmFtIHtUPX0gZGF0YSBBbiBhcmd1bWVudCBwYXNzZWQgdG8gZm4gdG8gcmVwcmVzZW50IERPTSBzdGF0ZS5cbiAqIEByZXR1cm4gez9Ob2RlfSBUaGUgbm9kZSBpZiBpdCB3YXMgdXBkYXRlZCwgaXRzIHJlcGxhY2VkbWVudCBvciBudWxsIGlmIGl0XG4gKiAgICAgd2FzIHJlbW92ZWQuXG4gKiBAdGVtcGxhdGUgVFxuICovXG52YXIgcGF0Y2hPdXRlciA9IHBhdGNoRmFjdG9yeShmdW5jdGlvbiAobm9kZSwgZm4sIGRhdGEpIHtcbiAgdmFyIHN0YXJ0Tm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICoveyBuZXh0U2libGluZzogbm9kZSB9O1xuICB2YXIgZXhwZWN0ZWROZXh0Tm9kZSA9IG51bGw7XG4gIHZhciBleHBlY3RlZFByZXZOb2RlID0gbnVsbDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGV4cGVjdGVkTmV4dE5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgIGV4cGVjdGVkUHJldk5vZGUgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgfVxuXG4gIGN1cnJlbnROb2RlID0gc3RhcnROb2RlO1xuICBmbihkYXRhKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydFBhdGNoRWxlbWVudE5vRXh0cmFzKHN0YXJ0Tm9kZSwgY3VycmVudE5vZGUsIGV4cGVjdGVkTmV4dE5vZGUsIGV4cGVjdGVkUHJldk5vZGUpO1xuICB9XG5cbiAgaWYgKG5vZGUgIT09IGN1cnJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUsIGdldERhdGEoY3VycmVudFBhcmVudCkua2V5TWFwKTtcbiAgfVxuXG4gIHJldHVybiBzdGFydE5vZGUgPT09IGN1cnJlbnROb2RlID8gbnVsbCA6IGN1cnJlbnROb2RlO1xufSk7XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIG5vZGVOYW1lIGFuZFxuICoga2V5LlxuICpcbiAqIEBwYXJhbSB7IU5vZGV9IG1hdGNoTm9kZSBBIG5vZGUgdG8gbWF0Y2ggdGhlIGRhdGEgdG8uXG4gKiBAcGFyYW0gez9zdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBmb3IgdGhpcyBub2RlLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IEFuIG9wdGlvbmFsIGtleSB0aGF0IGlkZW50aWZpZXMgYSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgbm9kZSBtYXRjaGVzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZhciBtYXRjaGVzID0gZnVuY3Rpb24gKG1hdGNoTm9kZSwgbm9kZU5hbWUsIGtleSkge1xuICB2YXIgZGF0YSA9IGdldERhdGEobWF0Y2hOb2RlKTtcblxuICAvLyBLZXkgY2hlY2sgaXMgZG9uZSB1c2luZyBkb3VibGUgZXF1YWxzIGFzIHdlIHdhbnQgdG8gdHJlYXQgYSBudWxsIGtleSB0aGVcbiAgLy8gc2FtZSBhcyB1bmRlZmluZWQuIFRoaXMgc2hvdWxkIGJlIG9rYXkgYXMgdGhlIG9ubHkgdmFsdWVzIGFsbG93ZWQgYXJlXG4gIC8vIHN0cmluZ3MsIG51bGwgYW5kIHVuZGVmaW5lZCBzbyB0aGUgPT0gc2VtYW50aWNzIGFyZSBub3QgdG9vIHdlaXJkLlxuICByZXR1cm4gbm9kZU5hbWUgPT09IGRhdGEubm9kZU5hbWUgJiYga2V5ID09IGRhdGEua2V5O1xufTtcblxuLyoqXG4gKiBBbGlnbnMgdGhlIHZpcnR1YWwgRWxlbWVudCBkZWZpbml0aW9uIHdpdGggdGhlIGFjdHVhbCBET00sIG1vdmluZyB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgRE9NIG5vZGUgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24gb3IgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIEZvciBhbiBFbGVtZW50LCB0aGlzIHNob3VsZCBiZSBhIHZhbGlkIHRhZyBzdHJpbmcuXG4gKiAgICAgRm9yIGEgVGV4dCwgdGhpcyBzaG91bGQgYmUgI3RleHQuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC5cbiAqL1xudmFyIGFsaWduV2l0aERPTSA9IGZ1bmN0aW9uIChub2RlTmFtZSwga2V5KSB7XG4gIGlmIChjdXJyZW50Tm9kZSAmJiBtYXRjaGVzKGN1cnJlbnROb2RlLCBub2RlTmFtZSwga2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYXJlbnREYXRhID0gZ2V0RGF0YShjdXJyZW50UGFyZW50KTtcbiAgdmFyIGN1cnJlbnROb2RlRGF0YSA9IGN1cnJlbnROb2RlICYmIGdldERhdGEoY3VycmVudE5vZGUpO1xuICB2YXIga2V5TWFwID0gcGFyZW50RGF0YS5rZXlNYXA7XG4gIHZhciBub2RlID0gdW5kZWZpbmVkO1xuXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgbm9kZSBoYXMgbW92ZWQgd2l0aGluIHRoZSBwYXJlbnQuXG4gIGlmIChrZXkpIHtcbiAgICB2YXIga2V5Tm9kZSA9IGtleU1hcFtrZXldO1xuICAgIGlmIChrZXlOb2RlKSB7XG4gICAgICBpZiAobWF0Y2hlcyhrZXlOb2RlLCBub2RlTmFtZSwga2V5KSkge1xuICAgICAgICBub2RlID0ga2V5Tm9kZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Tm9kZSA9PT0gY3VycmVudE5vZGUpIHtcbiAgICAgICAgY29udGV4dC5tYXJrRGVsZXRlZChrZXlOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIGtleU5vZGUsIGtleU1hcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIHRoZSBub2RlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gIGlmICghbm9kZSkge1xuICAgIGlmIChub2RlTmFtZSA9PT0gJyN0ZXh0Jykge1xuICAgICAgbm9kZSA9IGNyZWF0ZVRleHQoZG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoZG9jLCBjdXJyZW50UGFyZW50LCBub2RlTmFtZSwga2V5KTtcbiAgICB9XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBrZXlNYXBba2V5XSA9IG5vZGU7XG4gICAgfVxuXG4gICAgY29udGV4dC5tYXJrQ3JlYXRlZChub2RlKTtcbiAgfVxuXG4gIC8vIFJlLW9yZGVyIHRoZSBub2RlIGludG8gdGhlIHJpZ2h0IHBvc2l0aW9uLCBwcmVzZXJ2aW5nIGZvY3VzIGlmIGVpdGhlclxuICAvLyBub2RlIG9yIGN1cnJlbnROb2RlIGFyZSBmb2N1c2VkIGJ5IG1ha2luZyBzdXJlIHRoYXQgdGhleSBhcmUgbm90IGRldGFjaGVkXG4gIC8vIGZyb20gdGhlIERPTS5cbiAgaWYgKGdldERhdGEobm9kZSkuZm9jdXNlZCkge1xuICAgIC8vIE1vdmUgZXZlcnl0aGluZyBlbHNlIGJlZm9yZSB0aGUgbm9kZS5cbiAgICBtb3ZlQmVmb3JlKGN1cnJlbnRQYXJlbnQsIG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgfSBlbHNlIGlmIChjdXJyZW50Tm9kZURhdGEgJiYgY3VycmVudE5vZGVEYXRhLmtleSAmJiAhY3VycmVudE5vZGVEYXRhLmZvY3VzZWQpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbnROb2RlLCB3aGljaCBjYW4gYWx3YXlzIGJlIGFkZGVkIGJhY2sgc2luY2Ugd2UgaG9sZCBhXG4gICAgLy8gcmVmZXJlbmNlIHRocm91Z2ggdGhlIGtleU1hcC4gVGhpcyBwcmV2ZW50cyBhIGxhcmdlIG51bWJlciBvZiBtb3ZlcyB3aGVuXG4gICAgLy8gYSBrZXllZCBpdGVtIGlzIHJlbW92ZWQgb3IgbW92ZWQgYmFja3dhcmRzIGluIHRoZSBET00uXG4gICAgY3VycmVudFBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgY3VycmVudE5vZGUpO1xuICAgIHBhcmVudERhdGEua2V5TWFwVmFsaWQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50UGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBjdXJyZW50Tm9kZSk7XG4gIH1cblxuICBjdXJyZW50Tm9kZSA9IG5vZGU7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7P05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7P05vZGV9IGNoaWxkXG4gKiBAcGFyYW0gez9PYmplY3Q8c3RyaW5nLCAhRWxlbWVudD59IGtleU1hcFxuICovXG52YXIgcmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiAobm9kZSwgY2hpbGQsIGtleU1hcCkge1xuICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgY29udGV4dC5tYXJrRGVsZXRlZCggLyoqIEB0eXBlIHshTm9kZX0qL2NoaWxkKTtcblxuICB2YXIga2V5ID0gZ2V0RGF0YShjaGlsZCkua2V5O1xuICBpZiAoa2V5KSB7XG4gICAgZGVsZXRlIGtleU1hcFtrZXldO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFycyBvdXQgYW55IHVudmlzaXRlZCBOb2RlcywgYXMgdGhlIGNvcnJlc3BvbmRpbmcgdmlydHVhbCBlbGVtZW50XG4gKiBmdW5jdGlvbnMgd2VyZSBuZXZlciBjYWxsZWQgZm9yIHRoZW0uXG4gKi9cbnZhciBjbGVhclVudmlzaXRlZERPTSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB2YXIgZGF0YSA9IGdldERhdGEobm9kZSk7XG4gIHZhciBrZXlNYXAgPSBkYXRhLmtleU1hcDtcbiAgdmFyIGtleU1hcFZhbGlkID0gZGF0YS5rZXlNYXBWYWxpZDtcbiAgdmFyIGNoaWxkID0gbm9kZS5sYXN0Q2hpbGQ7XG4gIHZhciBrZXkgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGNoaWxkID09PSBjdXJyZW50Tm9kZSAmJiBrZXlNYXBWYWxpZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHdoaWxlIChjaGlsZCAhPT0gY3VycmVudE5vZGUpIHtcbiAgICByZW1vdmVDaGlsZChub2RlLCBjaGlsZCwga2V5TWFwKTtcbiAgICBjaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICB9XG5cbiAgLy8gQ2xlYW4gdGhlIGtleU1hcCwgcmVtb3ZpbmcgYW55IHVudXN1ZWQga2V5cy5cbiAgaWYgKCFrZXlNYXBWYWxpZCkge1xuICAgIGZvciAoa2V5IGluIGtleU1hcCkge1xuICAgICAgY2hpbGQgPSBrZXlNYXBba2V5XTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnROb2RlICE9PSBub2RlKSB7XG4gICAgICAgIGNvbnRleHQubWFya0RlbGV0ZWQoY2hpbGQpO1xuICAgICAgICBkZWxldGUga2V5TWFwW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0YS5rZXlNYXBWYWxpZCA9IHRydWU7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0byB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqL1xudmFyIGVudGVyTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgY3VycmVudFBhcmVudCA9IGN1cnJlbnROb2RlO1xuICBjdXJyZW50Tm9kZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEByZXR1cm4gez9Ob2RlfSBUaGUgbmV4dCBOb2RlIHRvIGJlIHBhdGNoZWQuXG4gKi9cbnZhciBnZXROZXh0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGN1cnJlbnROb2RlLm5leHRTaWJsaW5nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjdXJyZW50UGFyZW50LmZpcnN0Q2hpbGQ7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlcyB0byB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKi9cbnZhciBuZXh0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgY3VycmVudE5vZGUgPSBnZXROZXh0Tm9kZSgpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRvIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZSwgcmVtb3ZpbmcgYW55IHVudmlzaXRlZCBjaGlsZHJlbi5cbiAqL1xudmFyIGV4aXROb2RlID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclVudmlzaXRlZERPTSgpO1xuXG4gIGN1cnJlbnROb2RlID0gY3VycmVudFBhcmVudDtcbiAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQucGFyZW50Tm9kZTtcbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjdXJyZW50IG5vZGUgaXMgYW4gRWxlbWVudCB3aXRoIGEgbWF0Y2hpbmcgdGFnTmFtZSBhbmRcbiAqIGtleS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgY29yZUVsZW1lbnRPcGVuID0gZnVuY3Rpb24gKHRhZywga2V5KSB7XG4gIG5leHROb2RlKCk7XG4gIGFsaWduV2l0aERPTSh0YWcsIGtleSk7XG4gIGVudGVyTm9kZSgpO1xuICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovY3VycmVudFBhcmVudFxuICApO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGN1cnJlbnRseSBvcGVuIEVsZW1lbnQsIHJlbW92aW5nIGFueSB1bnZpc2l0ZWQgY2hpbGRyZW4gaWZcbiAqIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xudmFyIGNvcmVFbGVtZW50Q2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgc2V0SW5Ta2lwKGZhbHNlKTtcbiAgfVxuXG4gIGV4aXROb2RlKCk7XG4gIHJldHVybiAoLyoqIEB0eXBlIHshRWxlbWVudH0gKi9jdXJyZW50Tm9kZVxuICApO1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoZSBjdXJyZW50IG5vZGUgaXMgYSBUZXh0IG5vZGUgYW5kIGNyZWF0ZXMgYSBUZXh0IG5vZGUgaWYgaXQgaXNcbiAqIG5vdC5cbiAqXG4gKiBAcmV0dXJuIHshVGV4dH0gVGhlIGNvcnJlc3BvbmRpbmcgVGV4dCBOb2RlLlxuICovXG52YXIgY29yZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gIG5leHROb2RlKCk7XG4gIGFsaWduV2l0aERPTSgnI3RleHQnLCBudWxsKTtcbiAgcmV0dXJuICgvKiogQHR5cGUgeyFUZXh0fSAqL2N1cnJlbnROb2RlXG4gICk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnQgRWxlbWVudCBiZWluZyBwYXRjaGVkLlxuICogQHJldHVybiB7IUVsZW1lbnR9XG4gKi9cbnZhciBjdXJyZW50RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRJblBhdGNoKCdjdXJyZW50RWxlbWVudCcsIGNvbnRleHQpO1xuICAgIGFzc2VydE5vdEluQXR0cmlidXRlcygnY3VycmVudEVsZW1lbnQnKTtcbiAgfVxuICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovY3VycmVudFBhcmVudFxuICApO1xufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtOb2RlfSBUaGUgTm9kZSB0aGF0IHdpbGwgYmUgZXZhbHVhdGVkIGZvciB0aGUgbmV4dCBpbnN0cnVjdGlvbi5cbiAqL1xudmFyIGN1cnJlbnRQb2ludGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydEluUGF0Y2goJ2N1cnJlbnRQb2ludGVyJywgY29udGV4dCk7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCdjdXJyZW50UG9pbnRlcicpO1xuICB9XG4gIHJldHVybiBnZXROZXh0Tm9kZSgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgY2hpbGRyZW4gaW4gYSBzdWJ0cmVlLCBhbGxvd2luZyBhbiBFbGVtZW50IHRvIGJlIGNsb3NlZCB3aXRob3V0XG4gKiBjbGVhcmluZyBvdXQgdGhlIGNoaWxkcmVuLlxuICovXG52YXIgc2tpcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb0NoaWxkcmVuRGVjbGFyZWRZZXQoJ3NraXAnLCBjdXJyZW50Tm9kZSk7XG4gICAgc2V0SW5Ta2lwKHRydWUpO1xuICB9XG4gIGN1cnJlbnROb2RlID0gY3VycmVudFBhcmVudC5sYXN0Q2hpbGQ7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IE5vZGUgdG8gYmUgcGF0Y2hlZCwgbW92aW5nIHRoZSBwb2ludGVyIGZvcndhcmQgdG8gdGhlIG5leHRcbiAqIHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgcG9pbnRlci5cbiAqL1xudmFyIHNraXBOb2RlID0gbmV4dE5vZGU7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUgVGhlIEluY3JlbWVudGFsIERPTSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBjb25zdCAqL1xudmFyIHN5bWJvbHMgPSB7XG4gIGRlZmF1bHQ6ICdfX2RlZmF1bHQnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgbmFtZXNwYWNlIHRvIHVzZSBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGdldE5hbWVzcGFjZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmIChuYW1lLmxhc3RJbmRleE9mKCd4bWw6JywgMCkgPT09IDApIHtcbiAgICByZXR1cm4gJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XG4gIH1cblxuICBpZiAobmFtZS5sYXN0SW5kZXhPZigneGxpbms6JywgMCkgPT09IDApIHtcbiAgICByZXR1cm4gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IHRvIGEgZ2l2ZW4gRWxlbWVudC4gSWYgdGhlIHZhbHVlIGlzIG51bGxcbiAqIG9yIHVuZGVmaW5lZCwgaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBFbGVtZW50LiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBpcyBzZXRcbiAqIGFzIGFuIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB7Pyhib29sZWFufG51bWJlcnxzdHJpbmcpPX0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG52YXIgYXBwbHlBdHRyID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYXR0ck5TID0gZ2V0TmFtZXNwYWNlKG5hbWUpO1xuICAgIGlmIChhdHRyTlMpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKGF0dHJOUywgbmFtZSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgcHJvcGVydHkgdG8gYSBnaXZlbiBFbGVtZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBwcm9wZXJ0eSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICovXG52YXIgYXBwbHlQcm9wID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICBlbFtuYW1lXSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgdmFsdWUgdG8gYSBzdHlsZSBkZWNsYXJhdGlvbi4gU3VwcG9ydHMgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzIGJ5XG4gKiBzZXR0aW5nIHByb3BlcnRpZXMgY29udGFpbmluZyBhIGRhc2ggdXNpbmcgQ1NTU3R5bGVEZWNsYXJhdGlvbi5zZXRQcm9wZXJ0eS5cbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVcbiAqIEBwYXJhbSB7IXN0cmluZ30gcHJvcFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG52YXIgc2V0U3R5bGVWYWx1ZSA9IGZ1bmN0aW9uIChzdHlsZSwgcHJvcCwgdmFsdWUpIHtcbiAgaWYgKHByb3AuaW5kZXhPZignLScpID49IDApIHtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCAvKiogQHR5cGUge3N0cmluZ30gKi92YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgc3R5bGUgdG8gYW4gRWxlbWVudC4gTm8gdmVuZG9yIHByZWZpeCBleHBhbnNpb24gaXMgZG9uZSBmb3JcbiAqIHByb3BlcnR5IG5hbWVzL3ZhbHVlcy5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gc3R5bGUgVGhlIHN0eWxlIHRvIHNldC4gRWl0aGVyIGEgc3RyaW5nIG9mIGNzcyBvciBhbiBvYmplY3RcbiAqICAgICBjb250YWluaW5nIHByb3BlcnR5LXZhbHVlIHBhaXJzLlxuICovXG52YXIgYXBwbHlTdHlsZSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgc3R5bGUpIHtcbiAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgIHZhciBlbFN0eWxlID0gZWwuc3R5bGU7XG4gICAgdmFyIG9iaiA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsc3RyaW5nPn0gKi9zdHlsZTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgICBpZiAoaGFzKG9iaiwgcHJvcCkpIHtcbiAgICAgICAgc2V0U3R5bGVWYWx1ZShlbFN0eWxlLCBwcm9wLCBvYmpbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhbiBFbGVtZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgb3JcbiAqICAgICBmdW5jdGlvbiBpdCBpcyBzZXQgb24gdGhlIEVsZW1lbnQsIG90aGVyd2lzZSwgaXQgaXMgc2V0IGFzIGFuIEhUTUxcbiAqICAgICBhdHRyaWJ1dGUuXG4gKi9cbnZhciBhcHBseUF0dHJpYnV0ZVR5cGVkID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5UHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGFwcGx5QXR0cihlbCwgbmFtZSwgLyoqIEB0eXBlIHs/KGJvb2xlYW58bnVtYmVyfHN0cmluZyl9ICovdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBhcHByb3ByaWF0ZSBhdHRyaWJ1dGUgbXV0YXRvciBmb3IgdGhpcyBhdHRyaWJ1dGUuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAqL1xudmFyIHVwZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKGVsKTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcblxuICBpZiAoYXR0cnNbbmFtZV0gPT09IHZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG11dGF0b3IgPSBhdHRyaWJ1dGVzW25hbWVdIHx8IGF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XTtcbiAgbXV0YXRvcihlbCwgbmFtZSwgdmFsdWUpO1xuXG4gIGF0dHJzW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEEgcHVibGljbHkgbXV0YWJsZSBvYmplY3QgdG8gcHJvdmlkZSBjdXN0b20gbXV0YXRvcnMgZm9yIGF0dHJpYnV0ZXMuXG4gKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCBmdW5jdGlvbighRWxlbWVudCwgc3RyaW5nLCAqKT59XG4gKi9cbnZhciBhdHRyaWJ1dGVzID0gY3JlYXRlTWFwKCk7XG5cbi8vIFNwZWNpYWwgZ2VuZXJpYyBtdXRhdG9yIHRoYXQncyBjYWxsZWQgZm9yIGFueSBhdHRyaWJ1dGUgdGhhdCBkb2VzIG5vdFxuLy8gaGF2ZSBhIHNwZWNpZmljIG11dGF0b3IuXG5hdHRyaWJ1dGVzW3N5bWJvbHMuZGVmYXVsdF0gPSBhcHBseUF0dHJpYnV0ZVR5cGVkO1xuXG5hdHRyaWJ1dGVzWydzdHlsZSddID0gYXBwbHlTdHlsZTtcblxuLyoqXG4gKiBUaGUgb2Zmc2V0IGluIHRoZSB2aXJ0dWFsIGVsZW1lbnQgZGVjbGFyYXRpb24gd2hlcmUgdGhlIGF0dHJpYnV0ZXMgYXJlXG4gKiBzcGVjaWZpZWQuXG4gKiBAY29uc3RcbiAqL1xudmFyIEFUVFJJQlVURVNfT0ZGU0VUID0gMztcblxuLyoqXG4gKiBCdWlsZHMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGZvciB1c2Ugd2l0aCBlbGVtZW50T3BlblN0YXJ0LCBhdHRyIGFuZFxuICogZWxlbWVudE9wZW5FbmQuXG4gKiBAY29uc3Qge0FycmF5PCo+fVxuICovXG52YXIgYXJnc0J1aWxkZXIgPSBbXTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MsIEF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIGF0dHJpYnV0ZXNcbiAqICAgICBmb3IgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xudmFyIGVsZW1lbnRPcGVuID0gZnVuY3Rpb24gKHRhZywga2V5LCBzdGF0aWNzLCB2YXJfYXJncykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE5vdEluQXR0cmlidXRlcygnZWxlbWVudE9wZW4nKTtcbiAgICBhc3NlcnROb3RJblNraXAoJ2VsZW1lbnRPcGVuJyk7XG4gIH1cblxuICB2YXIgbm9kZSA9IGNvcmVFbGVtZW50T3Blbih0YWcsIGtleSk7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcblxuICBpZiAoIWRhdGEuc3RhdGljc0FwcGxpZWQpIHtcbiAgICBpZiAoc3RhdGljcykge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHN0YXRpY3MubGVuZ3RoOyBfaSArPSAyKSB7XG4gICAgICAgIHZhciBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovc3RhdGljc1tfaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0YXRpY3NbX2kgKyAxXTtcbiAgICAgICAgdXBkYXRlQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRG93biB0aGUgcm9hZCwgd2UgbWF5IHdhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgc3RhdGljcyBhcnJheSB0byB1c2UgaXRcbiAgICAvLyBhcyBhbiBhZGRpdGlvbmFsIHNpZ25hbCBhYm91dCB3aGV0aGVyIGEgbm9kZSBtYXRjaGVzIG9yIG5vdC4gRm9yIG5vdyxcbiAgICAvLyBqdXN0IHVzZSBhIG1hcmtlciBzbyB0aGF0IHdlIGRvIG5vdCByZWFwcGx5IHN0YXRpY3MuXG4gICAgZGF0YS5zdGF0aWNzQXBwbGllZCA9IHRydWU7XG4gIH1cblxuICAvKlxuICAgKiBDaGVja3MgdG8gc2VlIGlmIG9uZSBvciBtb3JlIGF0dHJpYnV0ZXMgaGF2ZSBjaGFuZ2VkIGZvciBhIGdpdmVuIEVsZW1lbnQuXG4gICAqIFdoZW4gbm8gYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQsIHRoaXMgaXMgbXVjaCBmYXN0ZXIgdGhhbiBjaGVja2luZyBlYWNoXG4gICAqIGluZGl2aWR1YWwgYXJndW1lbnQuIFdoZW4gYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQsIHRoZSBvdmVyaGVhZCBvZiB0aGlzIGlzXG4gICAqIG1pbmltYWwuXG4gICAqL1xuICB2YXIgYXR0cnNBcnIgPSBkYXRhLmF0dHJzQXJyO1xuICB2YXIgbmV3QXR0cnMgPSBkYXRhLm5ld0F0dHJzO1xuICB2YXIgaXNOZXcgPSAhYXR0cnNBcnIubGVuZ3RoO1xuICB2YXIgaSA9IEFUVFJJQlVURVNfT0ZGU0VUO1xuICB2YXIgaiA9IDA7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDIsIGogKz0gMikge1xuICAgIHZhciBfYXR0ciA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGF0dHJzQXJyW2pdID0gX2F0dHI7XG4gICAgICBuZXdBdHRyc1tfYXR0cl0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChhdHRyc0FycltqXSAhPT0gX2F0dHIpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgaWYgKGlzTmV3IHx8IGF0dHJzQXJyW2ogKyAxXSAhPT0gdmFsdWUpIHtcbiAgICAgIGF0dHJzQXJyW2ogKyAxXSA9IHZhbHVlO1xuICAgICAgdXBkYXRlQXR0cmlidXRlKG5vZGUsIF9hdHRyLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGkgPCBhcmd1bWVudHMubGVuZ3RoIHx8IGogPCBhdHRyc0Fyci5sZW5ndGgpIHtcbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSwgaiArPSAxKSB7XG4gICAgICBhdHRyc0FycltqXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBpZiAoaiA8IGF0dHJzQXJyLmxlbmd0aCkge1xuICAgICAgYXR0cnNBcnIubGVuZ3RoID0gajtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFjdHVhbGx5IHBlcmZvcm0gdGhlIGF0dHJpYnV0ZSB1cGRhdGUuXG4gICAgICovXG4gICAgZm9yIChpID0gMDsgaSA8IGF0dHJzQXJyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICB2YXIgbmFtZSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqL2F0dHJzQXJyW2ldO1xuICAgICAgdmFyIHZhbHVlID0gYXR0cnNBcnJbaSArIDFdO1xuICAgICAgbmV3QXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfYXR0cjIgaW4gbmV3QXR0cnMpIHtcbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZShub2RlLCBfYXR0cjIsIG5ld0F0dHJzW19hdHRyMl0pO1xuICAgICAgbmV3QXR0cnNbX2F0dHIyXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LiBUaGlzXG4gKiBjb3JyZXNwb25kcyB0byBhbiBvcGVuaW5nIHRhZyBhbmQgYSBlbGVtZW50Q2xvc2UgdGFnIGlzIHJlcXVpcmVkLiBUaGlzIGlzXG4gKiBsaWtlIGVsZW1lbnRPcGVuLCBidXQgdGhlIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQgdXNpbmcgdGhlIGF0dHIgZnVuY3Rpb25cbiAqIHJhdGhlciB0aGFuIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudHMuIE11c3QgYmUgZm9sbGxvd2VkIGJ5IDAgb3IgbW9yZSBjYWxsc1xuICogdG8gYXR0ciwgdGhlbiBhIGNhbGwgdG8gZWxlbWVudE9wZW5FbmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqL1xudmFyIGVsZW1lbnRPcGVuU3RhcnQgPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMoJ2VsZW1lbnRPcGVuU3RhcnQnKTtcbiAgICBzZXRJbkF0dHJpYnV0ZXModHJ1ZSk7XG4gIH1cblxuICBhcmdzQnVpbGRlclswXSA9IHRhZztcbiAgYXJnc0J1aWxkZXJbMV0gPSBrZXk7XG4gIGFyZ3NCdWlsZGVyWzJdID0gc3RhdGljcztcbn07XG5cbi8qKipcbiAqIERlZmluZXMgYSB2aXJ0dWFsIGF0dHJpYnV0ZSBhdCB0aGlzIHBvaW50IG9mIHRoZSBET00uIFRoaXMgaXMgb25seSB2YWxpZFxuICogd2hlbiBjYWxsZWQgYmV0d2VlbiBlbGVtZW50T3BlblN0YXJ0IGFuZCBlbGVtZW50T3BlbkVuZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG52YXIgYXR0ciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydEluQXR0cmlidXRlcygnYXR0cicpO1xuICB9XG5cbiAgYXJnc0J1aWxkZXIucHVzaChuYW1lKTtcbiAgYXJnc0J1aWxkZXIucHVzaCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBhbiBvcGVuIHRhZyBzdGFydGVkIHdpdGggZWxlbWVudE9wZW5TdGFydC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgZWxlbWVudE9wZW5FbmQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0SW5BdHRyaWJ1dGVzKCdlbGVtZW50T3BlbkVuZCcpO1xuICAgIHNldEluQXR0cmlidXRlcyhmYWxzZSk7XG4gIH1cblxuICB2YXIgbm9kZSA9IGVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3NCdWlsZGVyKTtcbiAgYXJnc0J1aWxkZXIubGVuZ3RoID0gMDtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENsb3NlcyBhbiBvcGVuIHZpcnR1YWwgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbnZhciBlbGVtZW50Q2xvc2UgPSBmdW5jdGlvbiAodGFnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCdlbGVtZW50Q2xvc2UnKTtcbiAgfVxuXG4gIHZhciBub2RlID0gY29yZUVsZW1lbnRDbG9zZSgpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Q2xvc2VNYXRjaGVzT3BlblRhZyhnZXREYXRhKG5vZGUpLm5vZGVOYW1lLCB0YWcpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgdmlydHVhbCBFbGVtZW50IGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudCB0aGF0IGhhc1xuICogbm8gY2hpbGRyZW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBlbGVtZW50J3MgdGFnLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgYXR0cmlidXRlc1xuICogICAgIGZvciB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgZWxlbWVudFZvaWQgPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MsIHZhcl9hcmdzKSB7XG4gIGVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIHJldHVybiBlbGVtZW50Q2xvc2UodGFnKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIFRleHQgYXQgdGhpcyBwb2ludCBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgVGV4dC5cbiAqIEBwYXJhbSB7Li4uKGZ1bmN0aW9uKChzdHJpbmd8bnVtYmVyfGJvb2xlYW4pKTpzdHJpbmcpfSB2YXJfYXJnc1xuICogICAgIEZ1bmN0aW9ucyB0byBmb3JtYXQgdGhlIHZhbHVlIHdoaWNoIGFyZSBjYWxsZWQgb25seSB3aGVuIHRoZSB2YWx1ZSBoYXNcbiAqICAgICBjaGFuZ2VkLlxuICogQHJldHVybiB7IVRleHR9IFRoZSBjb3JyZXNwb25kaW5nIHRleHQgbm9kZS5cbiAqL1xudmFyIHRleHQgPSBmdW5jdGlvbiAodmFsdWUsIHZhcl9hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCd0ZXh0Jyk7XG4gICAgYXNzZXJ0Tm90SW5Ta2lwKCd0ZXh0Jyk7XG4gIH1cblxuICB2YXIgbm9kZSA9IGNvcmVUZXh0KCk7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcblxuICBpZiAoZGF0YS50ZXh0ICE9PSB2YWx1ZSkge1xuICAgIGRhdGEudGV4dCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqL3ZhbHVlO1xuXG4gICAgdmFyIGZvcm1hdHRlZCA9IHZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAvKlxuICAgICAgICogQ2FsbCB0aGUgZm9ybWF0dGVyIGZ1bmN0aW9uIGRpcmVjdGx5IHRvIHByZXZlbnQgbGVha2luZyBhcmd1bWVudHMuXG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2luY3JlbWVudGFsLWRvbS9wdWxsLzIwNCNpc3N1ZWNvbW1lbnQtMTc4MjIzNTc0XG4gICAgICAgKi9cbiAgICAgIHZhciBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvcm1hdHRlZCA9IGZuKGZvcm1hdHRlZCk7XG4gICAgfVxuXG4gICAgbm9kZS5kYXRhID0gZm9ybWF0dGVkO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2hJbm5lcjtcbmV4cG9ydHMucGF0Y2hJbm5lciA9IHBhdGNoSW5uZXI7XG5leHBvcnRzLnBhdGNoT3V0ZXIgPSBwYXRjaE91dGVyO1xuZXhwb3J0cy5jdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50O1xuZXhwb3J0cy5jdXJyZW50UG9pbnRlciA9IGN1cnJlbnRQb2ludGVyO1xuZXhwb3J0cy5za2lwID0gc2tpcDtcbmV4cG9ydHMuc2tpcE5vZGUgPSBza2lwTm9kZTtcbmV4cG9ydHMuZWxlbWVudFZvaWQgPSBlbGVtZW50Vm9pZDtcbmV4cG9ydHMuZWxlbWVudE9wZW5TdGFydCA9IGVsZW1lbnRPcGVuU3RhcnQ7XG5leHBvcnRzLmVsZW1lbnRPcGVuRW5kID0gZWxlbWVudE9wZW5FbmQ7XG5leHBvcnRzLmVsZW1lbnRPcGVuID0gZWxlbWVudE9wZW47XG5leHBvcnRzLmVsZW1lbnRDbG9zZSA9IGVsZW1lbnRDbG9zZTtcbmV4cG9ydHMudGV4dCA9IHRleHQ7XG5leHBvcnRzLmF0dHIgPSBhdHRyO1xuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9scztcbmV4cG9ydHMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5leHBvcnRzLmFwcGx5QXR0ciA9IGFwcGx5QXR0cjtcbmV4cG9ydHMuYXBwbHlQcm9wID0gYXBwbHlQcm9wO1xuZXhwb3J0cy5ub3RpZmljYXRpb25zID0gbm90aWZpY2F0aW9ucztcbmV4cG9ydHMuaW1wb3J0Tm9kZSA9IGltcG9ydE5vZGU7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluY3JlbWVudGFsLWRvbS1janMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW5jcmVtZW50YWwtZG9tL2Rpc3QvaW5jcmVtZW50YWwtZG9tLWNqcy5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLkluY3JlbWVudGFsRE9NID0gZ2xvYmFsLkluY3JlbWVudGFsRE9NIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGFycmF5IHVzZWQgdG8gc3RvcmUgdGhlIHN0cmluZ3MgZ2VuZXJhdGVkIGJ5IGNhbGxzIHRvXG4gKiBlbGVtZW50T3BlbiwgZWxlbWVudE9wZW5TdGFydCwgZWxlbWVudE9wZW5FbmQsIGVsZW1lbnRFbmQgYW5kIGVsZW1lbnRWb2lkXG4gKi9cbmV4cG9ydHMuYnVmZmVyID0gW107XG5cbi8qKiBAdHlwZSB7P09iamVjdH0gKi9cbmV4cG9ydHMuY3VycmVudFBhcmVudCA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBFbGVtZW50IGJlaW5nIHBhdGNoZWQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH1cbiAqL1xudmFyIGN1cnJlbnRFbGVtZW50ID0gZnVuY3Rpb24gY3VycmVudEVsZW1lbnQoKSB7XG4gIHJldHVybiBleHBvcnRzLmN1cnJlbnRQYXJlbnQ7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge05vZGV9IFRoZSBOb2RlIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgZm9yIHRoZSBuZXh0IGluc3RydWN0aW9uLlxuICovXG52YXIgY3VycmVudFBvaW50ZXIgPSBmdW5jdGlvbiBjdXJyZW50UG9pbnRlcigpIHtcbiAgcmV0dXJuIHt9O1xufTtcblxuLyoqXG4gKiBQYXRjaGVzIGFuIEVsZW1lbnQgd2l0aCB0aGUgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBFeGFjdGx5IG9uZSB0b3AgbGV2ZWxcbiAqIGVsZW1lbnQgY2FsbCBzaG91bGQgYmUgbWFkZSBjb3JyZXNwb25kaW5nIHRvIGBub2RlYC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG5vZGUgVGhlIEVsZW1lbnQgd2hlcmUgdGhlIHBhdGNoIHNob3VsZCBzdGFydC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKFQpfSBmbiBBIGZ1bmN0aW9uIGNvbnRhaW5pbmcgb3Blbi9jbG9zZS9ldGMuIGNhbGxzIHRoYXRcbiAqICAgICBkZXNjcmliZSB0aGUgRE9NLiBUaGlzIHNob3VsZCBoYXZlIGF0IG1vc3Qgb25lIHRvcCBsZXZlbCBlbGVtZW50IGNhbGwuXG4gKiBAcGFyYW0ge1Q9fSBkYXRhIEFuIGFyZ3VtZW50IHBhc3NlZCB0byBmbiB0byByZXByZXNlbnQgRE9NIHN0YXRlLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xudmFyIHBhdGNoID0gZnVuY3Rpb24gcGF0Y2gobm9kZSwgZm4sIGRhdGEpIHtcbiAgZXhwb3J0cy5jdXJyZW50UGFyZW50ID0gbm9kZTtcbiAgZm4oZGF0YSk7XG4gIGV4cG9ydHMuY3VycmVudFBhcmVudC5pbm5lckhUTUwgPSBleHBvcnRzLmJ1ZmZlci5qb2luKCcnKTtcbiAgZXhwb3J0cy5idWZmZXIgPSBbXTtcbiAgcmV0dXJuIGV4cG9ydHMuY3VycmVudFBhcmVudDtcbn07XG5cbnZhciBwYXRjaE91dGVyID0gcGF0Y2g7XG52YXIgcGF0Y2hJbm5lciA9IHBhdGNoO1xuXG4vKipcbiAqIERlY2xhcmVzIGEgdmlydHVhbCBUZXh0IGF0IHRoaXMgcG9pbnQgaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIFRleHQuXG4gKiBAcGFyYW0gey4uLihmdW5jdGlvbigoc3RyaW5nfG51bWJlcnxib29sZWFuKSk6c3RyaW5nKX0gdmFyX2FyZ3NcbiAqICAgICBGdW5jdGlvbnMgdG8gZm9ybWF0IHRoZSB2YWx1ZSB3aGljaCBhcmUgY2FsbGVkIG9ubHkgd2hlbiB0aGUgdmFsdWUgaGFzXG4gKiAgICAgY2hhbmdlZC5cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgdGV4dCA9IGZ1bmN0aW9uIHRleHQodmFsdWUsIHZhcl9hcmdzKSB7XG4gIHZhciBmb3JtYXR0ZWQgPSB2YWx1ZTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgZm4gPSBhcmd1bWVudHNbaV07XG4gICAgZm9ybWF0dGVkID0gZm4oZm9ybWF0dGVkKTtcbiAgfVxuICBleHBvcnRzLmJ1ZmZlci5wdXNoKGZvcm1hdHRlZCk7XG59O1xuXG4vKiogQGNvbnN0ICovXG52YXIgc3ltYm9scyA9IHtcbiAgZGVmYXVsdDogJ19fZGVmYXVsdCdcbn07XG5cbi8qKiBAY29uc3QgKi9cbnZhciBhdHRyaWJ1dGVzID0ge307XG5cbi8qKlxuICogQ2FsbHMgdGhlIGFwcHJvcHJpYXRlIGF0dHJpYnV0ZSBtdXRhdG9yIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBlbCBCdWZmZXIgdG8gYXBwZW5kIGVsZW1lbnQgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gKi9cbnZhciB1cGRhdGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBtdXRhdG9yID0gYXR0cmlidXRlc1tuYW1lXSB8fCBhdHRyaWJ1dGVzW3N5bWJvbHMuZGVmYXVsdF07XG4gIG11dGF0b3IoZWwsIG5hbWUsIHZhbHVlKTtcbn07XG5cbi8vIFNwZWNpYWwgZ2VuZXJpYyBtdXRhdG9yIHRoYXQncyBjYWxsZWQgZm9yIGFueSBhdHRyaWJ1dGUgdGhhdCBkb2VzIG5vdFxuLy8gaGF2ZSBhIHNwZWNpZmljIG11dGF0b3IuXG5hdHRyaWJ1dGVzW3N5bWJvbHMuZGVmYXVsdF0gPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgIGVsLnB1c2goJyAnICsgbmFtZSArICc9XCInICsgdmFsdWUgKyAnXCInKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUcnVuY2F0ZXMgYW4gYXJyYXksIHJlbW92aW5nIGl0ZW1zIHVwIHVudGlsIGxlbmd0aC5cbiAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIgVGhlIGFycmF5IHRvIHRydW5jYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKi9cbnZhciB0cnVuY2F0ZUFycmF5ID0gZnVuY3Rpb24gdHJ1bmNhdGVBcnJheShhcnIsIGxlbmd0aCkge1xuICB3aGlsZSAoYXJyLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgIGFyci5wb3AoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgb2Zmc2V0IGluIHRoZSB2aXJ0dWFsIGVsZW1lbnQgZGVjbGFyYXRpb24gd2hlcmUgdGhlIGF0dHJpYnV0ZXMgYXJlXG4gKiBzcGVjaWZpZWQuXG4gKiBAY29uc3RcbiAqL1xudmFyIEFUVFJJQlVURVNfT0ZGU0VUID0gMztcblxuLyoqXG4gKiBCdWlsZHMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGZvciB1c2Ugd2l0aCBlbGVtZW50T3BlblN0YXJ0LCBhdHRyIGFuZFxuICogZWxlbWVudE9wZW5FbmQuXG4gKiBAY29uc3QgeyFBcnJheTwqPn1cbiAqL1xudmFyIGFyZ3NCdWlsZGVyID0gW107XG5cbi8qKlxuICogRGVmaW5lcyBhIHZpcnR1YWwgYXR0cmlidXRlIGF0IHRoaXMgcG9pbnQgb2YgdGhlIERPTS4gVGhpcyBpcyBvbmx5IHZhbGlkXG4gKiB3aGVuIGNhbGxlZCBiZXR3ZWVuIGVsZW1lbnRPcGVuU3RhcnQgYW5kIGVsZW1lbnRPcGVuRW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgYXR0ciA9IGZ1bmN0aW9uIGF0dHIobmFtZSwgdmFsdWUpIHtcbiAgYXJnc0J1aWxkZXIucHVzaChuYW1lKTtcbiAgYXJnc0J1aWxkZXIucHVzaCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBhbiBvcGVuIHZpcnR1YWwgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIEVsZW1lbnQncyB0YWcuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgZWxlbWVudENsb3NlID0gZnVuY3Rpb24gZWxlbWVudENsb3NlKG5hbWVPckN0b3IpIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JDdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmV3IG5hbWVPckN0b3IoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgZXhwb3J0cy5idWZmZXIucHVzaCgnPC8nICsgbmFtZU9yQ3RvciArICc+Jyk7XG59O1xuXG4vKipcbiAqIERlY2xhcmVzIGEgdmlydHVhbCBFbGVtZW50IGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudCB0aGF0IGhhc1xuICogbm8gY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFRoZSBFbGVtZW50J3MgdGFnIG9yIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgYXR0cmlidXRlc1xuICogICAgIGZvciB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciBlbGVtZW50Vm9pZCA9IGZ1bmN0aW9uIGVsZW1lbnRWb2lkKG5hbWVPckN0b3IsIGtleSwgc3RhdGljcywgdmFyX2FyZ3MpIHtcbiAgZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGVsZW1lbnRDbG9zZShuYW1lT3JDdG9yKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lT3JDdG9yIFRoZSBFbGVtZW50J3MgdGFnIG9yIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MsIEF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZSBkeW5hbWljIGF0dHJpYnV0ZXNcbiAqICAgICBmb3IgdGhlIEVsZW1lbnQuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgZWxlbWVudE9wZW4gPSBmdW5jdGlvbiBlbGVtZW50T3BlbihuYW1lT3JDdG9yLCBrZXksIHN0YXRpY3MsIHZhcl9hcmdzKSB7XG4gIGlmICh0eXBlb2YgbmFtZU9yQ3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG5ldyBuYW1lT3JDdG9yKCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuY3VycmVudFBhcmVudDtcbiAgfVxuXG4gIGV4cG9ydHMuYnVmZmVyLnB1c2goJzwnICsgbmFtZU9yQ3Rvcik7XG5cbiAgaWYgKHN0YXRpY3MpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc3RhdGljcy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICAgIHZhciBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovc3RhdGljc1tfaV07XG4gICAgICB2YXIgdmFsdWUgPSBzdGF0aWNzW19pICsgMV07XG4gICAgICB1cGRhdGVBdHRyaWJ1dGUoZXhwb3J0cy5idWZmZXIsIG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgaSA9IEFUVFJJQlVURVNfT0ZGU0VUO1xuICB2YXIgaiA9IDA7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDIsIGogKz0gMikge1xuICAgIHZhciBfbmFtZSA9IGFyZ3VtZW50c1tpXTtcbiAgICB2YXIgX3ZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICB1cGRhdGVBdHRyaWJ1dGUoZXhwb3J0cy5idWZmZXIsIF9uYW1lLCBfdmFsdWUpO1xuICB9XG5cbiAgZXhwb3J0cy5idWZmZXIucHVzaCgnPicpO1xuXG4gIHJldHVybiBleHBvcnRzLmN1cnJlbnRQYXJlbnQ7XG59O1xuXG4vKipcbiAqIENsb3NlcyBhbiBvcGVuIHRhZyBzdGFydGVkIHdpdGggZWxlbWVudE9wZW5TdGFydC5cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgZWxlbWVudE9wZW5FbmQgPSBmdW5jdGlvbiBlbGVtZW50T3BlbkVuZCgpIHtcbiAgZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJnc0J1aWxkZXIpO1xuICB0cnVuY2F0ZUFycmF5KGFyZ3NCdWlsZGVyLCAwKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LiBUaGlzXG4gKiBjb3JyZXNwb25kcyB0byBhbiBvcGVuaW5nIHRhZyBhbmQgYSBlbGVtZW50Q2xvc2UgdGFnIGlzIHJlcXVpcmVkLiBUaGlzIGlzXG4gKiBsaWtlIGVsZW1lbnRPcGVuLCBidXQgdGhlIGF0dHJpYnV0ZXMgYXJlIGRlZmluZWQgdXNpbmcgdGhlIGF0dHIgZnVuY3Rpb25cbiAqIHJhdGhlciB0aGFuIGJlaW5nIHBhc3NlZCBhcyBhcmd1bWVudHMuIE11c3QgYmUgZm9sbGxvd2VkIGJ5IDAgb3IgbW9yZSBjYWxsc1xuICogdG8gYXR0ciwgdGhlbiBhIGNhbGwgdG8gZWxlbWVudE9wZW5FbmQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZU9yQ3RvciBUaGUgRWxlbWVudCdzIHRhZyBvciBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LiBUaGlzIGNhbiBiZSBhblxuICogICAgIGVtcHR5IHN0cmluZywgYnV0IHBlcmZvcm1hbmNlIG1heSBiZSBiZXR0ZXIgaWYgYSB1bmlxdWUgdmFsdWUgaXMgdXNlZFxuICogICAgIHdoZW4gaXRlcmF0aW5nIG92ZXIgYW4gYXJyYXkgb2YgaXRlbXMuXG4gKiBAcGFyYW0gez9BcnJheTwqPj19IHN0YXRpY3MgQW4gYXJyYXkgb2YgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlXG4gKiAgICAgc3RhdGljIGF0dHJpYnV0ZXMgZm9yIHRoZSBFbGVtZW50LiBUaGVzZSB3aWxsIG9ubHkgYmUgc2V0IG9uY2Ugd2hlbiB0aGVcbiAqICAgICBFbGVtZW50IGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgZWxlbWVudE9wZW5TdGFydCA9IGZ1bmN0aW9uIGVsZW1lbnRPcGVuU3RhcnQobmFtZU9yQ3Rvciwga2V5LCBzdGF0aWNzKSB7XG4gIGFyZ3NCdWlsZGVyWzBdID0gbmFtZU9yQ3RvcjtcbiAgYXJnc0J1aWxkZXJbMV0gPSBrZXk7XG4gIGFyZ3NCdWlsZGVyWzJdID0gc3RhdGljcztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29uc3RydWN0cmVkIERPTSBzdHJpbmcgYXQgdGhpcyBwb2ludC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb25zdHJ1Y3RlZCBET00gc3RyaW5nLlxuICovXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbiByZW5kZXJUb1N0cmluZyhmbikge1xuICBwYXRjaCh7fSwgZm4pO1xuICByZXR1cm4gY3VycmVudEVsZW1lbnQoKS5pbm5lckhUTUw7XG59O1xuXG5leHBvcnRzLmN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG5leHBvcnRzLmN1cnJlbnRQb2ludGVyID0gY3VycmVudFBvaW50ZXI7XG5leHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5leHBvcnRzLnBhdGNoSW5uZXIgPSBwYXRjaElubmVyO1xuZXhwb3J0cy5wYXRjaE91dGVyID0gcGF0Y2hPdXRlcjtcbmV4cG9ydHMudGV4dCA9IHRleHQ7XG5leHBvcnRzLmF0dHIgPSBhdHRyO1xuZXhwb3J0cy5lbGVtZW50Q2xvc2UgPSBlbGVtZW50Q2xvc2U7XG5leHBvcnRzLmVsZW1lbnRPcGVuID0gZWxlbWVudE9wZW47XG5leHBvcnRzLmVsZW1lbnRPcGVuRW5kID0gZWxlbWVudE9wZW5FbmQ7XG5leHBvcnRzLmVsZW1lbnRPcGVuU3RhcnQgPSBlbGVtZW50T3BlblN0YXJ0O1xuZXhwb3J0cy5lbGVtZW50Vm9pZCA9IGVsZW1lbnRWb2lkO1xuZXhwb3J0cy5yZW5kZXJUb1N0cmluZyA9IHJlbmRlclRvU3RyaW5nO1xuZXhwb3J0cy5zeW1ib2xzID0gc3ltYm9scztcbmV4cG9ydHMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5leHBvcnRzLnVwZGF0ZUF0dHJpYnV0ZSA9IHVwZGF0ZUF0dHJpYnV0ZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWRvbS1zdHJpbmcvZGlzdC9pbmNyZW1lbnRhbC1kb20tc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuYWJzdHJhY3RNZXRob2QgPSBhYnN0cmFjdE1ldGhvZDtcbmV4cG9ydHMuZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5lbmFibGVDb21wYXRpYmlsaXR5TW9kZSA9IGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5nZXRDb21wYXRpYmlsaXR5TW9kZURhdGEgPSBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGE7XG5leHBvcnRzLmdldEZ1bmN0aW9uTmFtZSA9IGdldEZ1bmN0aW9uTmFtZTtcbmV4cG9ydHMuZ2V0U3RhdGljUHJvcGVydHkgPSBnZXRTdGF0aWNQcm9wZXJ0eTtcbmV4cG9ydHMuZ2V0VWlkID0gZ2V0VWlkO1xuZXhwb3J0cy5pZGVudGl0eUZ1bmN0aW9uID0gaWRlbnRpdHlGdW5jdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc0RlZiA9IGlzRGVmO1xuZXhwb3J0cy5pc0RlZkFuZE5vdE51bGwgPSBpc0RlZkFuZE5vdE51bGw7XG5leHBvcnRzLmlzRG9jdW1lbnQgPSBpc0RvY3VtZW50O1xuZXhwb3J0cy5pc0RvY3VtZW50RnJhZ21lbnQgPSBpc0RvY3VtZW50RnJhZ21lbnQ7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NlcnZlclNpZGUgPSBpc1NlcnZlclNpZGU7XG5leHBvcnRzLm51bGxGdW5jdGlvbiA9IG51bGxGdW5jdGlvbjtcbnZhciBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdm9pZCAwO1xuXG4vKipcbiAqIENvdW50ZXIgZm9yIHVuaXF1ZSBpZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBVSURfUFJPUEVSVFkgPSBleHBvcnRzLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAqIEZvby5wcm90b3R5cGUuYmFyID0gYWJzdHJhY3RNZXRob2RcbiAqXG4gKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiB3aGVuIGJhcigpIGlzIGludm9rZWQuXG4gKlxuICogQHR5cGUgeyFGdW5jdGlvbn1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG4gIHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIERpc2FibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRW5hYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZSB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgZnJvbSByY1xuICogYW5kIDEueCB2ZXJzaW9uczpcbiAqICAgICAtIFVzaW5nIFwia2V5XCIgdG8gcmVmZXJlbmNlIGNvbXBvbmVudCBpbnN0YW5jZXMuIEluIHRoZSBjdXJyZW50IHZlcnNpb25cbiAqICAgICAgIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFwicmVmXCIgaW5zdGVhZC4gVGhpcyBhbGxvd3Mgb2xkIGNvZGUgc3RpbGxcbiAqICAgICAgIHVzaW5nIFwia2V5XCIgdG8ga2VlcCB3b3JraW5nIGxpa2UgYmVmb3JlLiBOT1RFOiB0aGlzIG1heSBjYXVzZVxuICogICAgICAgcHJvYmxlbXMsIHNpbmNlIFwia2V5XCIgaXMgbWVhbnQgdG8gYmUgdXNlZCBkaWZmZXJlbnRseS4gT25seSB1c2UgdGhpc1xuICogICAgICAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gdXBncmFkZSB0aGUgY29kZSB0byB1c2UgXCJyZWZcIiBpbnN0ZWFkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBPcHRpb25hbCBvYmplY3Qgd2l0aCBkYXRhIHRvIHNwZWNpZnkgbW9yZVxuICogICAgIGRldGFpbHMsIHN1Y2ggYXM6XG4gKiAgICAgICAgIC0gcmVuZGVyZXJzIHtBcnJheX0gdGhlIHRlbXBsYXRlIHJlbmRlcmVycyB0aGF0IHNob3VsZCBiZSBpblxuICogICAgICAgICAgIGNvbXBhdGliaWxpdHkgbW9kZSwgZWl0aGVyIHRoZWlyIGNvbnN0cnVjdG9ycyBvciBzdHJpbmdzXG4gKiAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZW0gKGUuZy4gJ3NveScgb3IgJ2pzeCcpLiBCeSBkZWZhdWx0LCBhbGwgdGhlIG9uZXNcbiAqICAgICAgICAgICB0aGF0IGV4dGVuZCBmcm9tIEluY3JlbWVudGFsRG9tUmVuZGVyZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgdmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gb3B0X2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSB1c2VkIGZvciBjb21wYXRpYmlsaXR5IG1vZGUsIG9yIG5vdGhpbmcgaWYgaXQgaGFzbid0IGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhdGliaWxpdHlNb2RlRGF0YSgpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBtb2RlIGNhbiBiZSBzZXQgdmlhIHRoZSBfX01FVEFMX0NPTVBBVElCSUxJVFlfXyBnbG9iYWwgdmFyLlxuICBpZiAoY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXykge1xuICAgICAgZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUod2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyB0cnV0aHksIG9yIHRoZSBzZWNvbmQgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0VHJ1dGh5XyhhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24uIElmIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndFxuICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3NcbiAqIGNvbnRlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGZuLm5hbWUgPSBzdHIuc3Vic3RyaW5nKDksIHN0ci5pbmRleE9mKCcoJykpO1xuICB9XG4gIHJldHVybiBmbi5uYW1lO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIHByb3BlcnR5IGluIHRoZSBnaXZlbiBjbGFzcy4gVGhlIHZhbHVlIHdpbGwgYmVcbiAqIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyBhcyBleHBlY3RlZCwgdW5sZXNzIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICogd2hpY2ggY2FuIGNoYW5nZSBob3cgdGhlIHN1cGVyIGNsYXNzZXMnIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5IHdpbGwgYmUgbWVyZ2VkXG4gKiB0b2dldGhlci5cbiAqIFRoZSBmaW5hbCBtZXJnZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQgaW4gYW5vdGhlciBwcm9wZXJ0eSwgc28gdGhhdCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkIGV2ZW4gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG1lcmdlZFxuICogICAgIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBzbyBmYXIgYW5kIHRoZSBuZXh0IHZhbHVlIHRvIGJlIG1lcmdlZCB0byBpdC5cbiAqICAgICBTaG91bGQgcmV0dXJuIHRoZXNlIHR3byBtZXJnZWQgdG9nZXRoZXIuIElmIG5vdCBwYXNzZWQgdGhlIGZpbmFsIHByb3BlcnR5XG4gKiAgICAgd2lsbCBiZSB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIGFtb25nIGFuY2VzdG9ycy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljUHJvcGVydHkoY3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuICB2YXIgbWVyZ2VkTmFtZSA9IHByb3BlcnR5TmFtZSArICdfTUVSR0VEJztcbiAgaWYgKCFjdG9yLmhhc093blByb3BlcnR5KG1lcmdlZE5hbWUpKSB7XG4gICAgdmFyIG1lcmdlZCA9IGN0b3IuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSA/IGN0b3JbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgaWYgKGN0b3IuX19wcm90b19fICYmICFjdG9yLl9fcHJvdG9fXy5pc1Byb3RvdHlwZU9mKEZ1bmN0aW9uKSkge1xuICAgICAgdmFyIG1lcmdlRm4gPSBvcHRfbWVyZ2VGbiB8fCBnZXRGaXJzdFRydXRoeV87XG4gICAgICBtZXJnZWQgPSBtZXJnZUZuKG1lcmdlZCwgZ2V0U3RhdGljUHJvcGVydHkoY3Rvci5fX3Byb3RvX18sIHByb3BlcnR5TmFtZSwgbWVyZ2VGbikpO1xuICAgIH1cbiAgICBjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuICB9XG4gIHJldHVybiBjdG9yW21lcmdlZE5hbWVdO1xufVxuXG4vKipcbiAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gKiBtdXRhdGVkIHdpdGggYW4gdW5pcXVlIGlkLiBDb25zZWN1dGl2ZSBjYWxscyB3aXRoIHRoZSBzYW1lIG9iamVjdFxuICogcmVmZXJlbmNlIHdvbid0IG11dGF0ZSB0aGUgb2JqZWN0IGFnYWluLCBpbnN0ZWFkIHRoZSBjdXJyZW50IG9iamVjdCB1aWRcbiAqIHJldHVybnMuIFNlZSB7QGxpbmsgVUlEX1BST1BFUlRZfS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gKiAgICAgbm90IHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub0luaGVyaXRhbmNlIE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzXG4gKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG4gIGlmIChvcHRfb2JqZWN0KSB7XG4gICAgdmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuICAgIGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG4gICAgICBpZCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG4gIHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBpc0RlZih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEZWZBbmROb3ROdWxsKHZhbCkge1xuICByZXR1cm4gaXNEZWYodmFsKSAmJiAhaXNOdWxsKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC1mcmFnbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gKiBhbmQgZnVuY3Rpb25zLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICByZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIFNldHMgdG8gdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBOb2RlLmpzIGVudmlyb25tZW50IHdpdGggZXh0cmEgY2hlY2sgZm9yXG4gKiBgcHJvY2Vzcy5icm93c2VyYCB0byBza2lwIEthcm1hIHJ1bm5lciBlbnZpcm9ubWVudC4gS2FybWEgZW52aXJvbm1lbnQgaGFzXG4gKiBgcHJvY2Vzc2AgZGVmaW5lZCBldmVuIHRob3VnaCBpdCBydW5zIG9uIHRoZSBicm93c2VyLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJTaWRlKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLmVudiAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhcHJvY2Vzcy5icm93c2VyO1xufVxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBudWxsRnVuY3Rpb24oKSB7fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhhcnJheSwgbnVsbCwgW3tcblx0XHRrZXk6ICdlcXVhbCcsXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdFx0aWYgKGFycjEgPT09IGFycjIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHshQXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmlyc3REZWZpbmVkVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuICAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmbGF0dGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdFx0dmFyIHJ2ID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG4gICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzbGljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHRcdHZhciBlbmQgPSAoMCwgX2NvcmUuaXNEZWYpKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNsaWNlZDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFycmF5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbnZhciBhc3luYyA9IHt9O1xuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbCA9IHZvaWQgMDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbiBDaGFubmVsKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24gKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEaXNwb3NhYmxlIHV0aWxpdHkuIFdoZW4gaW5oZXJpdGVkIHByb3ZpZGVzIHRoZSBgZGlzcG9zZWAgZnVuY3Rpb24gdG8gaXRzXG4gKiBzdWJjbGFzcywgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyBvZiBhbnkgb2JqZWN0IHJlZmVyZW5jZXNcbiAqIHdoZW4gYW4gaW5zdGFuY2Ugd29uJ3QgYmUgdXNlZCBhbnltb3JlLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICogYGRpc3Bvc2VJbnRlcm5hbGAgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpYyBkaXNwb3NpbmcgbG9naWMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcG9zYWJsZSk7XG5cblx0XHQvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRGlzcG9zYWJsZSwgW3tcblx0XHRrZXk6ICdkaXNwb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdFx0dGhpcy5kaXNwb3NlSW50ZXJuYWwoKTtcblx0XHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG4gICAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuICAgKiBkaXNwb3NhYmxlcykuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0Rpc3Bvc2VkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRGlzcG9zYWJsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGlzcG9zYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKG9iamVjdCwgbnVsbCwgW3tcblx0XHRrZXk6ICdtaXhpbicsXG5cblx0XHQvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdFx0dmFyIGtleSA9IHZvaWQgMCxcblx0XHRcdCAgICBzb3VyY2UgPSB2b2lkIDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPYmplY3RCeU5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeU5hbWUobmFtZSwgb3B0X29iaikge1xuXHRcdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0XHRyZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChwYXJ0LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHRcdH0sIHNjb3BlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuICAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaGFsbG93RXF1YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuXHRcdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmoxW2tleXMxW2ldXSAhPT0gb2JqMltrZXlzMVtpXV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIHN0cmluZygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgc3RyaW5nKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhzdHJpbmcsIG51bGwsIFt7XG5cdFx0a2V5OiAnY2FzZUluc2Vuc2l0aXZlQ29tcGFyZScsXG5cblx0XHQvKipcbiAgICogQ29tcGFyZXMgdGhlIGdpdmVuIHN0cmluZ3Mgd2l0aG91dCB0YWtpbmcgdGhlIGNhc2UgaW50byBhY2NvdW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjFcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIyXG4gICAqIEByZXR1cm4ge251bWJlcn0gRWl0aGVyIC0xLCAwIG9yIDEsIGFjY29yZGluZyB0byBpZiB0aGUgZmlyc3Qgc3RyaW5nIGlzXG4gICAqICAgICBcInNtYWxsZXJcIiwgZXF1YWwgb3IgXCJiaWdnZXJcIiB0aGFuIHRoZSBzZWNvbmQgZ2l2ZW4gc3RyaW5nLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FzZUluc2Vuc2l0aXZlQ29tcGFyZShzdHIxLCBzdHIyKSB7XG5cdFx0XHR2YXIgdGVzdDEgPSBTdHJpbmcoc3RyMSkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB0ZXN0MiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAodGVzdDEgPCB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRlc3QxID09PSB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBicmVha2luZyBzcGFjZXMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHN0cmluZyBhbmRcbiAgICogY29sbGFwc2VzIHRoZSBzZXF1ZW5jZXMgb2YgYnJlYWtpbmcgc3BhY2VzIGluIHRoZSBtaWRkbGUgaW50byBzaW5nbGUgc3BhY2VzLlxuICAgKiBUaGUgb3JpZ2luYWwgYW5kIHRoZSByZXN1bHQgc3RyaW5ncyByZW5kZXIgdGhlIHNhbWUgd2F5IGluIEhUTUwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgaW4gd2hpY2ggdG8gY29sbGFwc2Ugc3BhY2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvcHkgb2YgdGhlIHN0cmluZyB3aXRoIG5vcm1hbGl6ZWQgYnJlYWtpbmcgc3BhY2VzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29sbGFwc2VCcmVha2luZ1NwYWNlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbGxhcHNlQnJlYWtpbmdTcGFjZXMoc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IHNhZmUgdG8gdXNlIGluIGEgUmVnRXhwLlxuICAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gZXNjYXBlLiBJZiBub3QgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY2FzdGVkXG4gICogICAgIHRvIG9uZS5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVnRXhwIHNhZmUsIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc30uXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2VzY2FwZVJlZ2V4Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRSYW5kb21TdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGhhc2hjb2RlIGZvciBhIHN0cmluZy4gVGhlIGhhc2hjb2RlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5XG4gICAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG4gICAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuICAgKiBhIHNoaWZ0IGFuZCBhIHN1YnRyYWN0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6IDMxKmkgPT0gKGk8PDUpLWkuXG4gICAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIGhhc2hjb2RlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzaENvZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNoQ29kZSh2YWwpIHtcblx0XHRcdHZhciBoYXNoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuICAgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlSW50ZXJ2YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIHN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0UGF0Y2hpbmdDb21wb25lbnQgPSBnZXRQYXRjaGluZ0NvbXBvbmVudDtcbmV4cG9ydHMucGF0Y2ggPSBwYXRjaDtcblxudmFyIF9tZXRhbERvbSA9IHJlcXVpcmUoJ21ldGFsLWRvbScpO1xuXG52YXIgX2RhdGEgPSByZXF1aXJlKCcuLi9kYXRhJyk7XG5cbnZhciBfcmVuZGVyID0gcmVxdWlyZSgnLi9yZW5kZXInKTtcblxudmFyIHBhdGNoaW5nQ29tcG9uZW50c18gPSBbXTtcblxuLyoqXG4gKiBHdWFyYW50ZWVzIHRoYXQgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgaGFzIGEgcGFyZW50LiBUaGF0J3MgbmVjZXNzYXJ5XG4gKiB3aGVuIGNhbGxpbmcgaW5jcmVtZW50YWwgZG9tJ3MgYHBhdGNoT3V0ZXJgIGZvciBub3csIGFzIG90aGVyd2lzZSBpdCB3aWxsXG4gKiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSByZXBsYWNlZC5cbiAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBwYXJlbnQsIGluIGNhc2UgaXQgd2FzIGFkZGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRQYXJlbnRJZk5lY2Vzc2FyeV8oZWxlbWVudCkge1xuXHRpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSkge1xuXHRcdHZhciBwYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0KDAsIF9tZXRhbERvbS5hcHBlbmQpKHBhcmVudCwgZWxlbWVudCk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJlbnQ7XG5cdH1cbn1cblxuLyoqXG4gKiBDYWxscyBpbmNyZW1lbnRhbCBkb20ncyBwYXRjaCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcGF0Y2guXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHBhdGNoZWQgb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfb3V0ZXIgRmxhZyBpbmRpY2F0aW5nIGlmIGBwYXRjaE91dGVyYCBzaG91bGQgYmUgdXNlZFxuICogICAgIGluc3RlYWQgb2YgYHBhdGNoYC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxQYXRjaF8oY29tcG9uZW50LCBlbGVtZW50LCBvcHRfb3V0ZXIpIHtcblx0cGF0Y2hpbmdDb21wb25lbnRzXy5wdXNoKGNvbXBvbmVudCk7XG5cblx0dmFyIGRhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KTtcblx0aWYgKCFkYXRhLnJlbmRlcikge1xuXHRcdC8vIFN0b3JlIHJlZmVyZW5jZSB0byBhdm9pZCBiaW5kcyBvbiBldmVyeSBwYXRjaC5cblx0XHRkYXRhLnJlbmRlciA9IF9yZW5kZXIucmVuZGVyLmJpbmQobnVsbCwgY29tcG9uZW50KTtcblx0fVxuXG5cdHZhciBwYXRjaEZuID0gb3B0X291dGVyID8gSW5jcmVtZW50YWxET00ucGF0Y2hPdXRlciA6IEluY3JlbWVudGFsRE9NLnBhdGNoO1xuXHRwYXRjaEZuKGVsZW1lbnQsIGRhdGEucmVuZGVyKTtcblxuXHRwYXRjaGluZ0NvbXBvbmVudHNfLnBvcCgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJlZCB0aGUgY3VycmVudCBwYXRjaCBvcGVyYXRpb24uXG4gKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGNoaW5nQ29tcG9uZW50KCkge1xuXHRyZXR1cm4gcGF0Y2hpbmdDb21wb25lbnRzX1twYXRjaGluZ0NvbXBvbmVudHNfLmxlbmd0aCAtIDFdO1xufVxuXG4vKipcbiAqIFBhdGNoZXMgdGhlIGNvbXBvbmVudCB3aXRoIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbiBjYWxscy5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIHBhdGNoKGNvbXBvbmVudCkge1xuXHRpZiAoIXRyeVBhdGNoRW1wdHlXaXRoUGFyZW50Xyhjb21wb25lbnQpKSB7XG5cdFx0aWYgKCF0cnlQYXRjaFdpdGhOb1BhcmVudF8oY29tcG9uZW50KSkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSBjb21wb25lbnQuZWxlbWVudDtcblx0XHRcdGNhbGxQYXRjaF8oY29tcG9uZW50LCBlbGVtZW50LCB0cnVlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGNvbXBvbmVudCBoYXMgbm8gY29udGVudCBidXQgd2FzIHJlbmRlcmVkIGZyb20gYW5vdGhlclxuICogY29tcG9uZW50LiBJZiBzbywgd2UnbGwgbmVlZCB0byBwYXRjaCB0aGlzIHBhcmVudCB0byBtYWtlIHN1cmUgdGhhdCBhbnkgbmV3XG4gKiBjb250ZW50IHdpbGwgYmUgYWRkZWQgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4gez9ib29sZWFufSBUcnVlIGlmIHRoZSBwYXRjaCBoYXBwZW5lZC4gTm90aGluZyBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cnlQYXRjaEVtcHR5V2l0aFBhcmVudF8oY29tcG9uZW50KSB7XG5cdHZhciBkYXRhID0gKDAsIF9kYXRhLmdldERhdGEpKGNvbXBvbmVudCk7XG5cdGlmICghY29tcG9uZW50LmVsZW1lbnQgJiYgZGF0YS5wYXJlbnQpIHtcblx0XHRkYXRhLnBhcmVudC5nZXRSZW5kZXJlcigpLnBhdGNoKGRhdGEucGFyZW50KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50J3MgZWxlbWVudCBleGlzdHMgYW5kIGhhcyBhIHBhcmVudC4gSWYgdGhhdCdzIG5vdCB0aGVcbiAqIGNhc2UsIGEgdGVtcG9yYXJ5IHBhcmVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHBhc3NlZCB0byB0aGUgYHBhdGNoYCBmdW5jdGlvbixcbiAqIHNpbmNlIGluY3JlbWVudGFsIGRvbSByZXF1aXJlcyBpdC4gT25jZSB0aGUgcGF0Y2ggaXMgZG9uZSB0aGUgdGVtcG9yYXJ5XG4gKiBwYXJlbnQgaXMgcmVtb3ZlZCBhbmQgdGhlIGNvbXBvbmVudCdzIGNvbnRlbnQgaXMgcmVhdHRhY2hlZCB0byB0aGUgY29ycmVjdFxuICogZmluYWwgcG9zaXRpb24uXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7P2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhdGNoIGhhcHBlbmVkLiBOb3RoaW5nIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyeVBhdGNoV2l0aE5vUGFyZW50Xyhjb21wb25lbnQpIHtcblx0dmFyIHRlbXBQYXJlbnQgPSBidWlsZFBhcmVudElmTmVjZXNzYXJ5Xyhjb21wb25lbnQuZWxlbWVudCk7XG5cdGlmICh0ZW1wUGFyZW50KSB7XG5cdFx0Y2FsbFBhdGNoXyhjb21wb25lbnQsIHRlbXBQYXJlbnQpO1xuXHRcdCgwLCBfbWV0YWxEb20uZXhpdERvY3VtZW50KShjb21wb25lbnQuZWxlbWVudCk7XG5cdFx0aWYgKGNvbXBvbmVudC5lbGVtZW50ICYmIGNvbXBvbmVudC5pbkRvY3VtZW50KSB7XG5cdFx0XHR2YXIgYXR0YWNoID0gY29tcG9uZW50LmdldEF0dGFjaERhdGEoKTtcblx0XHRcdGNvbXBvbmVudC5hdHRhY2hFbGVtZW50KGF0dGFjaC5wYXJlbnQsIGF0dGFjaC5zaWJsaW5nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL3JlbmRlci9wYXRjaC5qc1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcHBseUF0dHJpYnV0ZSA9IGFwcGx5QXR0cmlidXRlO1xuZXhwb3J0cy5jb252ZXJ0TGlzdGVuZXJOYW1lc1RvRm5zID0gY29udmVydExpc3RlbmVyTmFtZXNUb0ZucztcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfbWV0YWxEb20gPSByZXF1aXJlKCdtZXRhbC1kb20nKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG52YXIgX2luY3JlbWVudGFsRG9tQW9wID0gcmVxdWlyZSgnLi4vaW5jcmVtZW50YWwtZG9tLWFvcCcpO1xuXG52YXIgSEFORExFX1NVRkZJWCA9ICdfX2hhbmRsZV9fJztcbnZhciBMSVNURU5FUl9SRUdFWCA9IC9eKD86b24oW0EtWl0uKykpfCg/OmRhdGEtb24oLispKSQvO1xuXG4vKipcbiAqIEFwcGxpZXMgYW4gYXR0cmlidXRlIHRvIGEgc3BlY2lmaWVkIGVsZW1lbnQgb3duZWQgYnkgdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhcHBseUF0dHJpYnV0ZShjb21wb25lbnQsIGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBldmVudE5hbWUgPSBnZXRFdmVudEZyb21MaXN0ZW5lckF0dHJfKG5hbWUpO1xuICBpZiAoZXZlbnROYW1lKSB7XG4gICAgYXR0YWNoRXZlbnRfKGNvbXBvbmVudCwgZWxlbWVudCwgbmFtZSwgZXZlbnROYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFsdWUgPSBmaXhDaGVja2VkQXR0cl8obmFtZSwgdmFsdWUpO1xuICBzZXRWYWx1ZUF0dHJBc1Byb3BlcnR5XyhlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG5cbiAgaWYgKCgwLCBfbWV0YWwuaXNCb29sZWFuKSh2YWx1ZSkpIHtcbiAgICBzZXRCb29sZWFuQXR0cl8oZWxlbWVudCwgbmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgICgwLCBfaW5jcmVtZW50YWxEb21Bb3AuZ2V0T3JpZ2luYWxGbikoJ2F0dHJpYnV0ZXMnKShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMaXN0ZW5zIHRvIHRoZSBzcGVjaWZpZWQgZXZlbnQsIGF0dGFjaGVkIHZpYSBpbmNyZW1lbnRhbCBkb20gY2FsbHMuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEV2ZW50Xyhjb21wb25lbnQsIGVsZW1lbnQsIGF0dHIsIGV2ZW50TmFtZSwgZm4pIHtcbiAgaWYgKCgwLCBfbWV0YWwuaXNTZXJ2ZXJTaWRlKSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoYW5kbGVLZXkgPSBldmVudE5hbWUgKyBIQU5ETEVfU1VGRklYO1xuICBpZiAoZWxlbWVudFtoYW5kbGVLZXldKSB7XG4gICAgZWxlbWVudFtoYW5kbGVLZXldLnJlbW92ZUxpc3RlbmVyKCk7XG4gICAgZWxlbWVudFtoYW5kbGVLZXldID0gbnVsbDtcbiAgfVxuICBpZiAoZm4pIHtcbiAgICBlbGVtZW50W2F0dHJdID0gZm47XG4gICAgZWxlbWVudFtoYW5kbGVLZXldID0gKDAsIF9tZXRhbERvbS5kZWxlZ2F0ZSkoZG9jdW1lbnQsIGV2ZW50TmFtZSwgZWxlbWVudCwgZm4pO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYWxsIGV2ZW50IGxpc3RlbmVyIGF0dHJpYnV0ZXMgZ2l2ZW4gYXMgZnVuY3Rpb24gbmFtZXMgdG8gYWN0dWFsXG4gKiBmdW5jdGlvbiByZWZlcmVuY2VzLiBJdCdzIGltcG9ydGFudCB0byBkbyB0aGlzIGJlZm9yZSBjYWxsaW5nIHRoZSByZWFsXG4gKiBpbmNyZW1lbnRhbCBkb20gYGVsZW1lbnRPcGVuYCBmdW5jdGlvbiwgb3RoZXJ3aXNlIGlmIGEgY29tcG9uZW50IHBhc3Nlc1xuICogdGhlIHNhbWUgZnVuY3Rpb24gbmFtZSB0aGF0IGFuIGVsZW1lbnQgd2FzIGFscmVhZHkgdXNpbmcgZm9yIGFub3RoZXJcbiAqIGNvbXBvbmVudCwgdGhhdCBldmVudCB3b24ndCBiZSByZWF0dGFjaGVkIGFzIGluY3JlbWVudGFsIGRvbSB3aWxsIHRoaW5rIHRoYXRcbiAqIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZC4gUGFzc2luZyB0aGUgZnVuY3Rpb24gcmVmZXJlbmNlcyBhcyB0aGUgdmFsdWUgd2lsbFxuICogZ3VhcmFudGVlIHRoYXQgZGlmZmVyZW50IGZ1bmN0aW9ucyB3aWxsIGNhdXNlIGV2ZW50cyB0byBiZSByZWF0dGFjaGVkLFxuICogcmVnYXJkbGVzcyBvZiB0aGVpciBvcmlnaW5hbCBuYW1lcy5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBjb252ZXJ0TGlzdGVuZXJOYW1lc1RvRm5zKGNvbXBvbmVudCwgY29uZmlnKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgY29uZmlnW2tleV0gPSBjb252ZXJ0TGlzdGVuZXJOYW1lVG9Gbl8oY29tcG9uZW50LCBrZXksIGNvbmZpZ1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhdHRyaWJ1dGUncyB2YWx1ZSB0byBhIGZ1bmN0aW9uIHJlZmVyZW5jZSwgaWYgaXQnc1xuICogY3VycmVudGx5IGEgbGlzdGVuZXIgbmFtZS4gSXQgYWxzbyByZWdpc3RlciB0aGUgbGlzdGVuZXIgbmFtZSBmb3JcbiAqIGZ1cnRoZXIgdXNhZ2UuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0TGlzdGVuZXJOYW1lVG9Gbl8oY29tcG9uZW50LCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykodmFsdWUpKSB7XG4gICAgdmFyIGV2ZW50TmFtZSA9IGdldEV2ZW50RnJvbUxpc3RlbmVyQXR0cl8obmFtZSk7XG4gICAgaWYgKGV2ZW50TmFtZSkge1xuICAgICAgdmFyIGZuID0gKDAsIF9tZXRhbENvbXBvbmVudC5nZXRDb21wb25lbnRGbikoY29tcG9uZW50LCB2YWx1ZSk7XG4gICAgICBpZiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hhbmdlcyB0aGUgdmFsdWUgb2YgdGhlIGBjaGVja2VkYCBhdHRyaWJ1dGUgdG8gYmUgYSBib29sZWFuLlxuICogTk9URTogVGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggdG8gYWNjb3VudCBmb3IgaW5jcmVtZW50YWwgZG9tIHNldHRpbmdcbiAqIFwiY2hlY2tlZFwiIGFzIGFuIGF0dHJpYnV0ZSBvbmx5LCB3aGljaCBjYW4gY2F1c2UgYnVncyBzaW5jZSB0aGF0IHdvbid0XG4gKiBuZWNlc3NhcmlseSBjaGVjay91bmNoZWNrIHRoZSBlbGVtZW50IGl0J3Mgc2V0IG9uLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvaW5jcmVtZW50YWwtZG9tL2lzc3Vlcy8xOTggZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHsqfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZml4Q2hlY2tlZEF0dHJfKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChuYW1lID09PSAnY2hlY2tlZCcpIHtcbiAgICB2YWx1ZSA9ICgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKSh2YWx1ZSkgJiYgdmFsdWUgIT09IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldmVudCBuYW1lIGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGUgaXMgYSBsaXN0ZW5lciAobWF0Y2hpbmcgdGhlXG4gKiBgTElTVEVORVJfUkVHRVhgIHJlZ2V4KSwgb3IgbnVsbCBpZiBpdCBpc24ndC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRGcm9tTGlzdGVuZXJBdHRyXyhhdHRyKSB7XG4gIHZhciBtYXRjaGVzID0gTElTVEVORVJfUkVHRVguZXhlYyhhdHRyKTtcbiAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoZXMgPyBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXSA6IG1hdGNoZXNbMl0gOiBudWxsO1xuICByZXR1cm4gZXZlbnROYW1lID8gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuXG4vKipcbiAqIFNldHMgYm9vbGVhbiBhdHRyaWJ1dGVzIG1hbnVhbGx5LiBUaGlzIGlzIGRvbmUgYmVjYXVzZSBpbmNyZW1lbnRhbCBkb20gc2V0c1xuICogYm9vbGVhbiB2YWx1ZXMgYXMgc3RyaW5nIGRhdGEgYXR0cmlidXRlcyBieSBkZWZhdWx0LCB3aGljaCBpcyBjb3VudGVyXG4gKiBpbnR1aXRpdmUuIFRoaXMgY2hhbmdlcyB0aGUgYmVoYXZpb3IgdG8gdXNlIHRoZSBhY3R1YWwgYm9vbGVhbiB2YWx1ZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRCb29sZWFuQXR0cl8oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCgwLCBfbWV0YWwuaXNTZXJ2ZXJTaWRlKSgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnRbbmFtZV0gPSB2YWx1ZTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGB2YWx1ZWAgYXR0cmlidXRlIGRpcmVjdGx5IGluIHRoZSBlbGVtZW50LlxuICogTk9URTogVGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggdG8gYWNjb3VudCBmb3IgaW5jcmVtZW50YWwgZG9tIHNldHRpbmcgXCJ2YWx1ZVwiXG4gKiBhcyBhbiBhdHRyaWJ1dGUgb25seSwgd2hpY2ggY2FuIGNhdXNlIGJ1Z3Mgc2luY2UgdGhhdCB3b24ndCBuZWNlc3NhcmlseVxuICogdXBkYXRlIHRoZSBpbnB1dCdzIGNvbnRlbnQgaXQncyBzZXQgb24uIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9pbmNyZW1lbnRhbC1kb20vaXNzdWVzLzIzOSBmb3IgbW9yZSBkZXRhaWxzLiBXZVxuICogb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgdmFsdWUgaXMgZGlmZmVyZW50IHRob3VnaCwgYXMgb3RoZXJ3aXNlIHRoZSBicm93c2VyXG4gKiB3aWxsIGF1dG9tYXRpY2FsbHkgbW92ZSB0aGUgdHlwaW5nIGN1cnNvciB0byB0aGUgZW5kIG9mIHRoZSBmaWVsZC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUF0dHJBc1Byb3BlcnR5XyhlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoKDAsIF9tZXRhbC5pc1NlcnZlclNpZGUpKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5hbWUgPT09ICd2YWx1ZScgJiYgZWxlbWVudC52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICBlbGVtZW50W25hbWVdID0gdmFsdWU7XG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL3JlbmRlci9hdHRyaWJ1dGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRpc3Bvc2VVbnVzZWQgPSBkaXNwb3NlVW51c2VkO1xuZXhwb3J0cy5zY2hlZHVsZSA9IHNjaGVkdWxlO1xuXG52YXIgX2RhdGEgPSByZXF1aXJlKCcuLi9kYXRhJyk7XG5cbnZhciBjb21wc18gPSBbXTtcbnZhciBkaXNwb3NpbmdfID0gZmFsc2U7XG5cbi8qKlxuICogRGlzcG9zZXMgYWxsIHN1YiBjb21wb25lbnRzIHRoYXQgd2VyZSBub3QgcmVyZW5kZXJlZCBzaW5jZSB0aGUgbGFzdFxuICogdGltZSB0aGlzIGZ1bmN0aW9uIHdhcyBzY2hlZHVsZWQuXG4gKi9cbmZ1bmN0aW9uIGRpc3Bvc2VVbnVzZWQoKSB7XG5cdGlmIChkaXNwb3NpbmdfKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdGRpc3Bvc2luZ18gPSB0cnVlO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29tcHNfLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGNvbXAgPSBjb21wc19baV07XG5cdFx0aWYgKCFjb21wLmlzRGlzcG9zZWQoKSAmJiAhKDAsIF9kYXRhLmdldERhdGEpKGNvbXApLnBhcmVudCkge1xuXHRcdFx0Ly8gRG9uJ3QgbGV0IGRpc3Bvc2luZyBjYXVzZSB0aGUgZWxlbWVudCB0byBiZSByZW1vdmVkLCBzaW5jZSBpdCBtYXlcblx0XHRcdC8vIGJlIGN1cnJlbnRseSBiZWluZyByZXVzZWQgYnkgYW5vdGhlciBjb21wb25lbnQuXG5cdFx0XHRjb21wLmVsZW1lbnQgPSBudWxsO1xuXHRcdFx0Y29tcC5kaXNwb3NlKCk7XG5cdFx0fVxuXHR9XG5cdGNvbXBzXyA9IFtdO1xuXHRkaXNwb3NpbmdfID0gZmFsc2U7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSBnaXZlbiBjb21wb25lbnRzIHRvIGJlIGNoZWNrZWQgYW5kIGRpc3Bvc2VkIGlmIG5vdCB1c2VkXG4gKiBhbnltb3JlIHdoZW4gYGRpc3Bvc2VVbnVzZWRgIGlzIGNhbGxlZC5cbiAqIEBwYXJhbSB7IUFycmF5PCFDb21wb25lbnQ+fSBjb21wc1xuICovXG5mdW5jdGlvbiBzY2hlZHVsZShjb21wcykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKCFjb21wc1tpXS5pc0Rpc3Bvc2VkKCkpIHtcblx0XHRcdCgwLCBfZGF0YS5nZXREYXRhKShjb21wc1tpXSkucGFyZW50ID0gbnVsbDtcblx0XHRcdGNvbXBzXy5wdXNoKGNvbXBzW2ldKTtcblx0XHR9XG5cdH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2NsZWFudXAvdW51c2VkLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0cmluZyA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5hc3luYyA9IGV4cG9ydHMuYXJyYXkgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5PYmplY3Qua2V5cyhfY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hcnJheSA9IHJlcXVpcmUoJy4vYXJyYXkvYXJyYXknKTtcblxudmFyIF9hcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jL2FzeW5jJyk7XG5cbnZhciBfYXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmMpO1xuXG52YXIgX0Rpc3Bvc2FibGUgPSByZXF1aXJlKCcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZScpO1xuXG52YXIgX0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlzcG9zYWJsZSk7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3Qvb2JqZWN0Jyk7XG5cbnZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG5cbnZhciBfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcvc3RyaW5nJyk7XG5cbnZhciBfc3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuYXJyYXkgPSBfYXJyYXkyLmRlZmF1bHQ7XG5leHBvcnRzLmFzeW5jID0gX2FzeW5jMi5kZWZhdWx0O1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gX0Rpc3Bvc2FibGUyLmRlZmF1bHQ7XG5leHBvcnRzLm9iamVjdCA9IF9vYmplY3QyLmRlZmF1bHQ7XG5leHBvcnRzLnN0cmluZyA9IF9zdHJpbmcyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9tZXRhbC5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb3JlIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmFic3RyYWN0TWV0aG9kID0gYWJzdHJhY3RNZXRob2Q7XG5leHBvcnRzLmRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSA9IGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBlbmFibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhID0gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhO1xuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbk5hbWU7XG5leHBvcnRzLmdldFN0YXRpY1Byb3BlcnR5ID0gZ2V0U3RhdGljUHJvcGVydHk7XG5leHBvcnRzLmdldFVpZCA9IGdldFVpZDtcbmV4cG9ydHMuaWRlbnRpdHlGdW5jdGlvbiA9IGlkZW50aXR5RnVuY3Rpb247XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbmV4cG9ydHMuaXNEZWYgPSBpc0RlZjtcbmV4cG9ydHMuaXNEZWZBbmROb3ROdWxsID0gaXNEZWZBbmROb3ROdWxsO1xuZXhwb3J0cy5pc0RvY3VtZW50ID0gaXNEb2N1bWVudDtcbmV4cG9ydHMuaXNEb2N1bWVudEZyYWdtZW50ID0gaXNEb2N1bWVudEZyYWdtZW50O1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5leHBvcnRzLmlzV2luZG93ID0gaXNXaW5kb3c7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNTZXJ2ZXJTaWRlID0gaXNTZXJ2ZXJTaWRlO1xuZXhwb3J0cy5udWxsRnVuY3Rpb24gPSBudWxsRnVuY3Rpb247XG52YXIgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHZvaWQgMDtcblxuLyoqXG4gKiBDb3VudGVyIGZvciB1bmlxdWUgaWQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVuaXF1ZUlkQ291bnRlcl8gPSAxO1xuXG4vKipcbiAqIFVuaXF1ZSBpZCBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG52YXIgVUlEX1BST1BFUlRZID0gZXhwb3J0cy5VSURfUFJPUEVSVFkgPSAnY29yZV8nICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApO1xuXG4vKipcbiAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG4gKiBGb28ucHJvdG90eXBlLmJhciA9IGFic3RyYWN0TWV0aG9kXG4gKlxuICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICpcbiAqIEB0eXBlIHshRnVuY3Rpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kKCkge1xuICB0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUgd2l0aCB0aGUgZm9sbG93aW5nIGZlYXR1cmVzIGZyb20gcmNcbiAqIGFuZCAxLnggdmVyc2lvbnM6XG4gKiAgICAgLSBVc2luZyBcImtleVwiIHRvIHJlZmVyZW5jZSBjb21wb25lbnQgaW5zdGFuY2VzLiBJbiB0aGUgY3VycmVudCB2ZXJzaW9uXG4gKiAgICAgICB0aGlzIHNob3VsZCBiZSBkb25lIHZpYSBcInJlZlwiIGluc3RlYWQuIFRoaXMgYWxsb3dzIG9sZCBjb2RlIHN0aWxsXG4gKiAgICAgICB1c2luZyBcImtleVwiIHRvIGtlZXAgd29ya2luZyBsaWtlIGJlZm9yZS4gTk9URTogdGhpcyBtYXkgY2F1c2VcbiAqICAgICAgIHByb2JsZW1zLCBzaW5jZSBcImtleVwiIGlzIG1lYW50IHRvIGJlIHVzZWQgZGlmZmVyZW50bHkuIE9ubHkgdXNlIHRoaXNcbiAqICAgICAgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVwZ3JhZGUgdGhlIGNvZGUgdG8gdXNlIFwicmVmXCIgaW5zdGVhZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGEgT3B0aW9uYWwgb2JqZWN0IHdpdGggZGF0YSB0byBzcGVjaWZ5IG1vcmVcbiAqICAgICBkZXRhaWxzLCBzdWNoIGFzOlxuICogICAgICAgICAtIHJlbmRlcmVycyB7QXJyYXl9IHRoZSB0ZW1wbGF0ZSByZW5kZXJlcnMgdGhhdCBzaG91bGQgYmUgaW5cbiAqICAgICAgICAgICBjb21wYXRpYmlsaXR5IG1vZGUsIGVpdGhlciB0aGVpciBjb25zdHJ1Y3RvcnMgb3Igc3RyaW5nc1xuICogICAgICAgICAgIHJlcHJlc2VudGluZyB0aGVtIChlLmcuICdzb3knIG9yICdqc3gnKS4gQnkgZGVmYXVsdCwgYWxsIHRoZSBvbmVzXG4gKiAgICAgICAgICAgdGhhdCBleHRlbmQgZnJvbSBJbmNyZW1lbnRhbERvbVJlbmRlcmVyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIHZhciBvcHRfZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG9wdF9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlLCBvciBub3RoaW5nIGlmIGl0IGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGEoKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgbW9kZSBjYW4gYmUgc2V0IHZpYSB0aGUgX19NRVRBTF9DT01QQVRJQklMSVRZX18gZ2xvYmFsIHZhci5cbiAgaWYgKGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pIHtcbiAgICAgIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wYXRpYmlsaXR5TW9kZURhdGFfO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgdHJ1dGh5LCBvciB0aGUgc2Vjb25kIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBnZXRGaXJzdFRydXRoeV8oYSwgYikge1xuICByZXR1cm4gYSB8fCBiO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiBjb250ZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAoIWZuLm5hbWUpIHtcbiAgICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICBmbi5uYW1lID0gc3RyLnN1YnN0cmluZyg5LCBzdHIuaW5kZXhPZignKCcpKTtcbiAgfVxuICByZXR1cm4gZm4ubmFtZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBwcm9wZXJ0eSBpbiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gKiBpbmhlcml0ZWQgZnJvbSBhbmNlc3RvcnMgYXMgZXhwZWN0ZWQsIHVubGVzcyBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiBpcyBnaXZlbixcbiAqIHdoaWNoIGNhbiBjaGFuZ2UgaG93IHRoZSBzdXBlciBjbGFzc2VzJyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eSB3aWxsIGJlIG1lcmdlZFxuICogdG9nZXRoZXIuXG4gKiBUaGUgZmluYWwgbWVyZ2VkIHZhbHVlIHdpbGwgYmUgc3RvcmVkIGluIGFub3RoZXIgcHJvcGVydHksIHNvIHRoYXQgaXQgd29uJ3RcbiAqIGJlIHJlY2FsY3VsYXRlZCBldmVuIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOio9fSBvcHRfbWVyZ2VGbiBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBtZXJnZWRcbiAqICAgICB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgc28gZmFyIGFuZCB0aGUgbmV4dCB2YWx1ZSB0byBiZSBtZXJnZWQgdG8gaXQuXG4gKiAgICAgU2hvdWxkIHJldHVybiB0aGVzZSB0d28gbWVyZ2VkIHRvZ2V0aGVyLiBJZiBub3QgcGFzc2VkIHRoZSBmaW5hbCBwcm9wZXJ0eVxuICogICAgIHdpbGwgYmUgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSBhbW9uZyBhbmNlc3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IsIHByb3BlcnR5TmFtZSwgb3B0X21lcmdlRm4pIHtcbiAgdmFyIG1lcmdlZE5hbWUgPSBwcm9wZXJ0eU5hbWUgKyAnX01FUkdFRCc7XG4gIGlmICghY3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuICAgIHZhciBtZXJnZWQgPSBjdG9yLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgPyBjdG9yW3Byb3BlcnR5TmFtZV0gOiBudWxsO1xuICAgIGlmIChjdG9yLl9fcHJvdG9fXyAmJiAhY3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcbiAgICAgIHZhciBtZXJnZUZuID0gb3B0X21lcmdlRm4gfHwgZ2V0Rmlyc3RUcnV0aHlfO1xuICAgICAgbWVyZ2VkID0gbWVyZ2VGbihtZXJnZWQsIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IuX19wcm90b19fLCBwcm9wZXJ0eU5hbWUsIG1lcmdlRm4pKTtcbiAgICB9XG4gICAgY3RvclttZXJnZWROYW1lXSA9IG1lcmdlZDtcbiAgfVxuICByZXR1cm4gY3RvclttZXJnZWROYW1lXTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIHVuaXF1ZSBpZC4gSWYgYG9wdF9vYmplY3RgIGFyZ3VtZW50IGlzIHBhc3NlZCwgdGhlIG9iamVjdCBpc1xuICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG4gKiByZXR1cm5zLiBTZWUge0BsaW5rIFVJRF9QUk9QRVJUWX0uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3QgT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZlxuICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9Jbmhlcml0YW5jZSBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhpc1xuICogICAgIG9iamVjdCdzIHVpZCBwcm9wZXJ0eSBjYW4gYmUgaW5oZXJpdGVkIGZyb20gcGFyZW50cyBvciBub3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGdldFVpZChvcHRfb2JqZWN0LCBvcHRfbm9Jbmhlcml0YW5jZSkge1xuICBpZiAob3B0X29iamVjdCkge1xuICAgIHZhciBpZCA9IG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXTtcbiAgICBpZiAob3B0X25vSW5oZXJpdGFuY2UgJiYgIW9wdF9vYmplY3QuaGFzT3duUHJvcGVydHkoVUlEX1BST1BFUlRZKSkge1xuICAgICAgaWQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaWQgfHwgKG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXSA9IHVuaXF1ZUlkQ291bnRlcl8rKyk7XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZUlkQ291bnRlcl8rKztcbn1cblxuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uIFJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7P30gVGhlIGZpcnN0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWYodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcbiAgcmV0dXJuIGlzRGVmKHZhbCkgJiYgIWlzTnVsbCh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQtZnJhZ21lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb20gZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHdpbmRvdy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuICogYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcbiAgcmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuLyoqXG4gKiBTZXRzIHRvIHRydWUgaWYgcnVubmluZyBpbnNpZGUgTm9kZS5qcyBlbnZpcm9ubWVudCB3aXRoIGV4dHJhIGNoZWNrIGZvclxuICogYHByb2Nlc3MuYnJvd3NlcmAgdG8gc2tpcCBLYXJtYSBydW5uZXIgZW52aXJvbm1lbnQuIEthcm1hIGVudmlyb25tZW50IGhhc1xuICogYHByb2Nlc3NgIGRlZmluZWQgZXZlbiB0aG91Z2ggaXQgcnVucyBvbiB0aGUgYnJvd3Nlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2VydmVyU2lkZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgIXByb2Nlc3MuYnJvd3Nlcjtcbn1cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge31cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlTmFtZWQuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGFycmF5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBhcnJheSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoYXJyYXksIG51bGwsIFt7XG5cdFx0a2V5OiAnZXF1YWwnLFxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudC5cbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjFcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRcdGlmIChhcnIxID09PSBhcnIyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7IUFycmF5fSBhcnJcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZpcnN0RGVmaW5lZFZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoYXJyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJyW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cbiAgICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhdHRlbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gb3B0X291dHB1dCB8fCBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0XHRhcnJheS5mbGF0dGVuKGFycltpXSwgb3V0cHV0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgcGFydGljdWxhciB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyIEFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1R9IG9iaiBPYmplY3QgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcblx0XHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHRcdHZhciBydiA9IHZvaWQgMDtcblx0XHRcdGlmIChydiA9IGkgPj0gMCkge1xuXHRcdFx0XHRhcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ2O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUF0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXQoYXJyLCBpKSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTbGljZXMgdGhlIGdpdmVuIGFycmF5LCBqdXN0IGxpa2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgdGhpc1xuICAgKiBpcyBmYXN0ZXIgYW5kIHdvcmtpbmcgb24gYWxsIGFycmF5LWxpa2Ugb2JqZWN0cyAobGlrZSBhcmd1bWVudHMpLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGFyciBBcnJheS1saWtlIG9iamVjdCB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0aGF0IHNob3VsZCBzdGFydCB0aGUgc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggd2hlcmUgdGhlIHNsaWNlIHNob3VsZCBlbmQsIG5vdFxuICAgKiAgIGluY2x1ZGVkIGluIHRoZSBmaW5hbCBhcnJheS4gSWYgbm90IGdpdmVuLCBhbGwgZWxlbWVudHMgYWZ0ZXIgdGhlXG4gICAqICAgc3RhcnQgaW5kZXggd2lsbCBiZSBpbmNsdWRlZC5cbiAgICogQHJldHVybiB7IUFycmF5fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2xpY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0XHR2YXIgc2xpY2VkID0gW107XG5cdFx0XHR2YXIgZW5kID0gKDAsIF9jb3JlLmlzRGVmKShvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzbGljZWQ7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGFycmF5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcnJheTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXN5bmMgPSB7fTtcblxuLyoqXG4gKiBUaHJvdyBhbiBpdGVtIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LiAgRm9yXG4gKiBleGFtcGxlLCBpZiBwcm9jZXNzaW5nIGEgZ3JvdXAgb2YgaXRlbXMgaW4gYSBsb29wLCBzb21ldGltZXMgaXQgaXMgdXNlZnVsXG4gKiB0byByZXBvcnQgYW4gZXJyb3Igd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIHRvIGJlXG4gKiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0geyp9IGV4Y2VwdGlvblxuICovXG5hc3luYy50aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgY2FsbHN0YWNrIHVud2luZHMsIG9yIGFzXG4gKiBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbiBjb250ZXh0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpfSBjYWxsYmFja1xuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgT2JqZWN0IHRvIHVzZSBhcyB0aGUgXCJ0aGlzIHZhbHVlXCIgd2hlbiBjYWxsaW5nXG4gKiAgICAgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuYXN5bmMucnVuID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2gobmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG4vKiogQHByaXZhdGUgeyFBcnJheS48IWFzeW5jLnJ1bi5Xb3JrSXRlbV8+fSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblxuLyoqXG4gKiBSdW4gYW55IHBlbmRpbmcgYXN5bmMucnVuIHdvcmsgaXRlbXMuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGludGVuZGVkXG4gKiBmb3IgZ2VuZXJhbCB1c2UsIGJ1dCBmb3IgdXNlIGJ5IGVudHJ5IHBvaW50IGhhbmRsZXJzIHRvIHJ1biBpdGVtcyBhaGVhZCBvZlxuICogYXN5bmMubmV4dFRpY2suXG4gKi9cbmFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuZm4gPSBmbjtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG4vKipcbiAqIENhY2hlIGZvciB0aGUgc2V0SW1tZWRpYXRlIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IG51bGw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24gKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWwgPSB2b2lkIDA7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8qKiBAY29uc3RydWN0b3IgKi9cblx0XHRDaGFubmVsID0gZnVuY3Rpb24gQ2hhbm5lbCgpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIFZhbGlkYXRlIG9yaWdpbiBhbmQgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG1lc3NhZ2Ugd2FzXG5cdFx0XHRcdC8vIGludGVuZGVkIGZvciB1cy5cblx0XHRcdFx0aWYgKGUub3JpZ2luICE9PSBvcmlnaW4gJiYgZS5kYXRhICE9PSBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucG9ydDEub25tZXNzYWdlKCk7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5wb3J0MSA9IHt9O1xuXHRcdFx0dGhpcy5wb3J0MiA9IHtcblx0XHRcdFx0cG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKCkge1xuXHRcdFx0XHRcdHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlLCBvcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGVvZiBDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBjaGFubmVsID0gbmV3IENoYW5uZWwoKTtcblx0XHQvLyBVc2UgYSBmaWZvIGxpbmtlZCBsaXN0IHRvIGNhbGwgY2FsbGJhY2tzIGluIHRoZSByaWdodCBvcmRlci5cblx0XHR2YXIgaGVhZCA9IHt9O1xuXHRcdHZhciB0YWlsID0gaGVhZDtcblx0XHRjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0c2V0VGltZW91dChjYiwgMCk7XG5cdH07XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uIChvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFzeW5jO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBEaXNwb3NhYmxlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuXHRcdC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG4gICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLiBDYWxscyBgZGlzcG9zZUludGVybmFsYC5cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEaXNwb3NhYmxlLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0aWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcbiAgICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG4gICAqIGRpc3Bvc2FibGVzKS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRGlzcG9zZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcG9zZWRfO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEaXNwb3NhYmxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwb3NhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKG9iamVjdCwgbnVsbCwgW3tcblx0XHRrZXk6ICdtaXhpbicsXG5cblx0XHQvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdFx0dmFyIGtleSA9IHZvaWQgMCxcblx0XHRcdCAgICBzb3VyY2UgPSB2b2lkIDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPYmplY3RCeU5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeU5hbWUobmFtZSwgb3B0X29iaikge1xuXHRcdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0XHRyZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChwYXJ0LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHRcdH0sIHNjb3BlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuICAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaGFsbG93RXF1YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuXHRcdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmoxW2tleXMxW2ldXSAhPT0gb2JqMltrZXlzMVtpXV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBzdHJpbmcoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIHN0cmluZyk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Moc3RyaW5nLCBudWxsLCBbe1xuXHRcdGtleTogJ2Nhc2VJbnNlbnNpdGl2ZUNvbXBhcmUnLFxuXG5cdFx0LyoqXG4gICAqIENvbXBhcmVzIHRoZSBnaXZlbiBzdHJpbmdzIHdpdGhvdXQgdGFraW5nIHRoZSBjYXNlIGludG8gYWNjb3VudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIxXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEVpdGhlciAtMSwgMCBvciAxLCBhY2NvcmRpbmcgdG8gaWYgdGhlIGZpcnN0IHN0cmluZyBpc1xuICAgKiAgICAgXCJzbWFsbGVyXCIsIGVxdWFsIG9yIFwiYmlnZ2VyXCIgdGhhbiB0aGUgc2Vjb25kIGdpdmVuIHN0cmluZy5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmUoc3RyMSwgc3RyMikge1xuXHRcdFx0dmFyIHRlc3QxID0gU3RyaW5nKHN0cjEpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgdGVzdDIgPSBTdHJpbmcoc3RyMikudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKHRlc3QxIDwgdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSBlbHNlIGlmICh0ZXN0MSA9PT0gdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG4gICAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cbiAgICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NvbGxhcHNlQnJlYWtpbmdTcGFjZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx0XFxyXFxuIF0rL2csICcgJykucmVwbGFjZSgvXltcXHRcXHJcXG4gXSt8W1xcdFxcclxcbiBdKyQvZywgJycpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cbiAgKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuICAqICAgICB0byBvbmUuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIFJlZ0V4cCBzYWZlLCBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN9LlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlc2NhcGVSZWdleCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFx4MDgnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UmFuZG9tU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZG9tU3RyaW5nKCkge1xuXHRcdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArIE1hdGguYWJzKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpIF4gRGF0ZS5ub3coKSkudG9TdHJpbmcoMzYpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuICAgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuICAgKiBwcm9wZXJ0eSBvZiB1c2luZyAzMSBwcmltZSBpcyB0aGF0IHRoZSBtdWx0aXBsaWNhdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnlcbiAgICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuICAgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUYXJnZXQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc2hDb2RlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFzaENvZGUodmFsKSB7XG5cdFx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXBsYWNlcyBpbnRlcnZhbCBpbnRvIHRoZSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgdmFsdWUsIGUuZy5cbiAgICogYHJlcGxhY2VJbnRlcnZhbChcImFiY2RlXCIsIDEsIDQsIFwiXCIpYCByZXR1cm5zIFwiYWVcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgaW5wdXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcmVwbGFjZXMgdGhlIHNwZWNpZmllZCBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVwbGFjZUludGVydmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBzdHJpbmc7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG5yZXF1aXJlKCcuL0hUTUxQYXJzZXInKTtcblxudmFyIF9IVE1MMkluY0RvbSA9IHJlcXVpcmUoJy4vSFRNTDJJbmNEb20nKTtcblxudmFyIF9IVE1MMkluY0RvbTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9IVE1MMkluY0RvbSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9IVE1MMkluY0RvbTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9odG1sMmluY2RvbS9saWIvd2l0aFBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5cbi8qXG4gKiBIVE1MNSBQYXJzZXIgQnkgU2FtIEJsb3dlc1xuICpcbiAqIERlc2lnbmVkIGZvciBIVE1MNSBkb2N1bWVudHNcbiAqXG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9wdXJlLWphdmFzY3JpcHQtaHRtbC1wYXJzZXIvXG4gKiBPcmlnaW5hbCBjb2RlIGJ5IEVyaWsgQXJ2aWRzc29uLCBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIExpY2Vuc2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiBUaGlzIGNvZGUgaXMgdHJpcGxlIGxpY2Vuc2VkIHVzaW5nIEFwYWNoZSBTb2Z0d2FyZSBMaWNlbnNlIDIuMCxcbiAqIE1vemlsbGEgUHVibGljIExpY2Vuc2Ugb3IgR05VIFB1YmxpYyBMaWNlbnNlXG4gKlxuICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90XG4gKiB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHlcbiAqIG9mIHRoZSBMaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAqXG4gKiBUaGUgY29udGVudHMgb2YgdGhpcyBmaWxlIGFyZSBzdWJqZWN0IHRvIHRoZSBNb3ppbGxhIFB1YmxpYyBMaWNlbnNlXG4gKiBWZXJzaW9uIDEuMSAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW5cbiAqIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKiBodHRwOi8vd3d3Lm1vemlsbGEub3JnL01QTC9cbiAqXG4gKiBTb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCJcbiAqIGJhc2lzLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlXG4gKiBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHJpZ2h0cyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIFRoZSBPcmlnaW5hbCBDb2RlIGlzIFNpbXBsZSBIVE1MIFBhcnNlci5cbiAqXG4gKiBUaGUgSW5pdGlhbCBEZXZlbG9wZXIgb2YgdGhlIE9yaWdpbmFsIENvZGUgaXMgRXJpayBBcnZpZHNzb24uXG4gKiBQb3J0aW9ucyBjcmVhdGVkIGJ5IEVyaWsgQXJ2aWRzc3NvbiBhcmUgQ29weXJpZ2h0IChDKSAyMDA0LiBBbGwgUmlnaHRzXG4gKiBSZXNlcnZlZC5cbiAqXG4gKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICogbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uOyBlaXRoZXIgdmVyc2lvbiAyXG4gKiBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAgMDIxMTAtMTMwMSwgVVNBLlxuICogQGxpY2Vuc2VcbiAqL1xuXG4vKlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFVzYWdlXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogLy8gVXNlIGxpa2Ugc286XG4gKiBIVE1MUGFyc2VyKGh0bWxTdHJpbmcsIHtcbiAqICAgICBzdGFydDogZnVuY3Rpb24odGFnLCBhdHRycywgdW5hcnkpIHt9LFxuICogICAgIGVuZDogZnVuY3Rpb24odGFnKSB7fSxcbiAqICAgICBjaGFyczogZnVuY3Rpb24odGV4dCkge30sXG4gKiAgICAgY29tbWVudDogZnVuY3Rpb24odGV4dCkge31cbiAqIH0pO1xuICpcbiAqIC8vIG9yIHRvIGdldCBhbiBYTUwgc3RyaW5nOlxuICogSFRNTHRvWE1MKGh0bWxTdHJpbmcpO1xuICpcbiAqIC8vIG9yIHRvIGdldCBhbiBYTUwgRE9NIERvY3VtZW50XG4gKiBIVE1MdG9ET00oaHRtbFN0cmluZyk7XG4gKlxuICogLy8gb3IgdG8gaW5qZWN0IGludG8gYW4gZXhpc3RpbmcgZG9jdW1lbnQvRE9NIG5vZGVcbiAqIEhUTUx0b0RPTShodG1sU3RyaW5nLCBkb2N1bWVudCk7XG4gKiBIVE1MdG9ET00oaHRtbFN0cmluZywgZG9jdW1lbnQuYm9keSk7XG4gKlxuICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuXHR2YXIgc3RhcnRUYWcgPSAvXjwoWy1BLVphLXowLTlfXSspKCg/OlxccytbYS16QS1aXzpdWy1hLXpBLVowLTlfOi5dKig/Olxccyo9XFxzKig/Oig/OlwiW15cIl0qXCIpfCg/OidbXiddKicpfFtePlxcc10rKSk/KSopXFxzKihcXC8/KT4vLFxuXHQgICAgZW5kVGFnID0gL148XFwvKFstQS1aYS16MC05X10rKVtePl0qPi8sXG5cdCAgICBhdHRyID0gLyhbYS16QS1aXzpdWy1hLXpBLVowLTlfOi5dKikoPzpcXHMqPVxccyooPzooPzpcIigoPzpcXFxcLnxbXlwiXSkqKVwiKXwoPzonKCg/OlxcXFwufFteJ10pKiknKXwoW14+XFxzXSspKSk/L2c7XG5cblx0Ly8gRW1wdHkgRWxlbWVudHMgLSBIVE1MIDVcblx0dmFyIGVtcHR5ID0gbWFrZU1hcChcImFyZWEsYmFzZSxiYXNlZm9udCxicixjb2wsZnJhbWUsaHIsaW1nLGlucHV0LGxpbmssbWV0YSxwYXJhbSxlbWJlZCxjb21tYW5kLGtleWdlbixzb3VyY2UsdHJhY2ssd2JyXCIpO1xuXG5cdC8vIEJsb2NrIEVsZW1lbnRzIC0gSFRNTCA1XG5cdHZhciBibG9jayA9IG1ha2VNYXAoXCJhLGFkZHJlc3MsYXJ0aWNsZSxhcHBsZXQsYXNpZGUsYXVkaW8sYmxvY2txdW90ZSxidXR0b24sY2FudmFzLGNlbnRlcixkZCxkZWwsZGlyLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSxmcmFtZXNldCxoMSxoMixoMyxoNCxoNSxoNixoZWFkZXIsaGdyb3VwLGhyLGlmcmFtZSxpbnMsaXNpbmRleCxsaSxtYXAsbWVudSxub2ZyYW1lcyxub3NjcmlwdCxvYmplY3Qsb2wsb3V0cHV0LHAscHJlLHNlY3Rpb24sc2NyaXB0LHRhYmxlLHRib2R5LHRkLHRmb290LHRoLHRoZWFkLHRyLHVsLHZpZGVvXCIpO1xuXG5cdC8vIElubGluZSBFbGVtZW50cyAtIEhUTUwgNVxuXHR2YXIgaW5saW5lID0gbWFrZU1hcChcImFiYnIsYWNyb255bSxhcHBsZXQsYixiYXNlZm9udCxiZG8sYmlnLGJyLGJ1dHRvbixjaXRlLGNvZGUsZGVsLGRmbixlbSxmb250LGksaWZyYW1lLGltZyxpbnB1dCxpbnMsa2JkLGxhYmVsLG1hcCxvYmplY3QscSxzLHNhbXAsc2NyaXB0LHNlbGVjdCxzbWFsbCxzcGFuLHN0cmlrZSxzdHJvbmcsc3ViLHN1cCx0ZXh0YXJlYSx0dCx1LHZhclwiKTtcblxuXHQvLyBFbGVtZW50cyB0aGF0IHlvdSBjYW4sIGludGVudGlvbmFsbHksIGxlYXZlIG9wZW5cblx0Ly8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuXHR2YXIgY2xvc2VTZWxmID0gbWFrZU1hcChcImNvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0clwiKTtcblxuXHQvLyBBdHRyaWJ1dGVzIHRoYXQgaGF2ZSB0aGVpciB2YWx1ZXMgZmlsbGVkIGluIGRpc2FibGVkPVwiZGlzYWJsZWRcIlxuXHR2YXIgZmlsbEF0dHJzID0gbWFrZU1hcChcImNoZWNrZWQsY29tcGFjdCxkZWNsYXJlLGRlZmVyLGRpc2FibGVkLGlzbWFwLG11bHRpcGxlLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vd3JhcCxyZWFkb25seSxzZWxlY3RlZFwiKTtcblxuXHQvLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcblx0dmFyIHNwZWNpYWwgPSBtYWtlTWFwKFwic2NyaXB0LHN0eWxlXCIpO1xuXG5cdHZhciBIVE1MUGFyc2VyID0gd2luZG93LkhUTUxQYXJzZXIgPSBmdW5jdGlvbiAoaHRtbCwgaGFuZGxlcikge1xuXHRcdHZhciBpbmRleCxcblx0XHQgICAgY2hhcnMsXG5cdFx0ICAgIG1hdGNoLFxuXHRcdCAgICBzdGFjayA9IFtdLFxuXHRcdCAgICBsYXN0ID0gaHRtbDtcblx0XHRzdGFjay5sYXN0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcblx0XHR9O1xuXG5cdFx0d2hpbGUgKGh0bWwpIHtcblx0XHRcdGNoYXJzID0gdHJ1ZTtcblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHNjcmlwdCBvciBzdHlsZSBlbGVtZW50XG5cdFx0XHRpZiAoIXN0YWNrLmxhc3QoKSB8fCAhc3BlY2lhbFtzdGFjay5sYXN0KCldKSB7XG5cblx0XHRcdFx0Ly8gQ29tbWVudFxuXHRcdFx0XHRpZiAoaHRtbC5pbmRleE9mKFwiPCEtLVwiKSA9PSAwKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBodG1sLmluZGV4T2YoXCItLT5cIik7XG5cblx0XHRcdFx0XHRpZiAoaW5kZXggPj0gMCkge1xuXHRcdFx0XHRcdFx0aWYgKGhhbmRsZXIuY29tbWVudCkgaGFuZGxlci5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGluZGV4KSk7XG5cdFx0XHRcdFx0XHRodG1sID0gaHRtbC5zdWJzdHJpbmcoaW5kZXggKyAzKTtcblx0XHRcdFx0XHRcdGNoYXJzID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZW5kIHRhZ1xuXHRcdFx0XHR9IGVsc2UgaWYgKGh0bWwuaW5kZXhPZihcIjwvXCIpID09IDApIHtcblx0XHRcdFx0XHRcdG1hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuXG5cdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0aHRtbCA9IGh0bWwuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdG1hdGNoWzBdLnJlcGxhY2UoZW5kVGFnLCBwYXJzZUVuZFRhZyk7XG5cdFx0XHRcdFx0XHRcdGNoYXJzID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIHN0YXJ0IHRhZ1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaHRtbC5pbmRleE9mKFwiPFwiKSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoID0gaHRtbC5tYXRjaChzdGFydFRhZyk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdFx0XHRcdFx0aHRtbCA9IGh0bWwuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0bWF0Y2hbMF0ucmVwbGFjZShzdGFydFRhZywgcGFyc2VTdGFydFRhZyk7XG5cdFx0XHRcdFx0XHRcdFx0Y2hhcnMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjaGFycykge1xuXHRcdFx0XHRcdGluZGV4ID0gaHRtbC5pbmRleE9mKFwiPFwiKTtcblxuXHRcdFx0XHRcdHZhciB0ZXh0ID0gaW5kZXggPCAwID8gaHRtbCA6IGh0bWwuc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0XHRcdFx0XHRodG1sID0gaW5kZXggPCAwID8gXCJcIiA6IGh0bWwuc3Vic3RyaW5nKGluZGV4KTtcblxuXHRcdFx0XHRcdGlmIChoYW5kbGVyLmNoYXJzKSBoYW5kbGVyLmNoYXJzKHRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoW1xcXFxzXFxcXFNdKj8pPFxcL1wiICsgc3RhY2subGFzdCgpICsgXCJbXj5dKj5cIiksIGZ1bmN0aW9uIChhbGwsIHRleHQpIHtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+fDwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgXCIkMSQyXCIpO1xuXHRcdFx0XHRcdGlmIChoYW5kbGVyLmNoYXJzKSBoYW5kbGVyLmNoYXJzKHRleHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChodG1sID09IGxhc3QpIHRocm93IFwiUGFyc2UgRXJyb3I6IFwiICsgaHRtbDtcblx0XHRcdGxhc3QgPSBodG1sO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuXHRcdHBhcnNlRW5kVGFnKCk7XG5cblx0XHRmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnKHRhZywgdGFnTmFtZSwgcmVzdCwgdW5hcnkpIHtcblx0XHRcdHRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmIChibG9ja1t0YWdOYW1lXSkge1xuXHRcdFx0XHQvLyBDbG9zZSBsYXN0IHRhZyBpZiBpdCdzIGlubGluZSwgZXhjZXB0IGlmIGl0J3MgYSBcInNwYW5cIiAoc2luY2UgcGVvcGxlXG5cdFx0XHRcdC8vIHVzdWFsbHkgYWRkIGFueXRoaW5nIHRoZXkgd2FudCB0byBzcGFucywgYW5kIGJyb3dzZXJzIGFsbG93IGl0KS5cblx0XHRcdFx0Ly8gTm90ZTogdGhpcyBleGNlcHRpb24gZm9yIFwic3BhblwiIHdhcyBhZGRlZCBtYW51YWxseSAoaS5lLiBpdCdzIG5vdFxuXHRcdFx0XHQvLyBwcmVzZW50IGluIHRoZSBvcmlnaW5hbCBjb2RlKS5cblx0XHRcdFx0d2hpbGUgKHN0YWNrLmxhc3QoKSAmJiBpbmxpbmVbc3RhY2subGFzdCgpXSAmJiBzdGFjay5sYXN0KCkgIT09ICdzcGFuJykge1xuXHRcdFx0XHRcdHBhcnNlRW5kVGFnKFwiXCIsIHN0YWNrLmxhc3QoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsb3NlU2VsZlt0YWdOYW1lXSAmJiBzdGFjay5sYXN0KCkgPT0gdGFnTmFtZSkge1xuXHRcdFx0XHRwYXJzZUVuZFRhZyhcIlwiLCB0YWdOYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0dW5hcnkgPSBlbXB0eVt0YWdOYW1lXSB8fCAhIXVuYXJ5O1xuXG5cdFx0XHRpZiAoIXVuYXJ5KSBzdGFjay5wdXNoKHRhZ05hbWUpO1xuXG5cdFx0XHRpZiAoaGFuZGxlci5zdGFydCkge1xuXHRcdFx0XHR2YXIgYXR0cnMgPSBbXTtcblxuXHRcdFx0XHRyZXN0LnJlcGxhY2UoYXR0ciwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gYXJndW1lbnRzWzJdID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzNdID8gYXJndW1lbnRzWzNdIDogYXJndW1lbnRzWzRdID8gYXJndW1lbnRzWzRdIDogZmlsbEF0dHJzW25hbWVdID8gbmFtZSA6IFwiXCI7XG5cblx0XHRcdFx0XHRhdHRycy5wdXNoKHtcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogdmFsdWUsXG5cdFx0XHRcdFx0XHRlc2NhcGVkOiB2YWx1ZS5yZXBsYWNlKC8oXnxbXlxcXFxdKVwiL2csICckMVxcXFxcXFwiJykgLy9cIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRpZiAoaGFuZGxlci5zdGFydCkgaGFuZGxlci5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZywgdGFnTmFtZSkge1xuXHRcdFx0Ly8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3Bcblx0XHRcdGlmICghdGFnTmFtZSkgdmFyIHBvcyA9IDA7XG5cblx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG5cdFx0XHRlbHNlIGZvciAodmFyIHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuXHRcdFx0XHRcdGlmIChzdGFja1twb3NdID09IHRhZ05hbWUpIGJyZWFrO1xuXHRcdFx0XHR9aWYgKHBvcyA+PSAwKSB7XG5cdFx0XHRcdC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG5cdFx0XHRcdGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGhhbmRsZXIuZW5kKSBoYW5kbGVyLmVuZChzdGFja1tpXSk7XG5cdFx0XHRcdH0gLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IHBvcztcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gbWFrZU1hcChzdHIpIHtcblx0XHR2YXIgb2JqID0ge30sXG5cdFx0ICAgIGl0ZW1zID0gc3RyLnNwbGl0KFwiLFwiKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRvYmpbaXRlbXNbaV1dID0gdHJ1ZTtcblx0XHR9cmV0dXJuIG9iajtcblx0fVxufSkuY2FsbCh1bmRlZmluZWQpO1xuXG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2h0bWwyaW5jZG9tL2xpYi9IVE1MUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX3VuZXNjYXBlID0gcmVxdWlyZSgnLi91bmVzY2FwZScpO1xuXG52YXIgX3VuZXNjYXBlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VuZXNjYXBlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHBhcnNlcl87XG5cbnZhciBIVE1MMkluY0RvbSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gSFRNTDJJbmNEb20oKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhUTUwySW5jRG9tKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhIVE1MMkluY0RvbSwgbnVsbCwgW3tcblx0XHRrZXk6ICdidWlsZEZuJyxcblxuXHRcdC8qKlxuICAgKiBTaG91bGQgY29udmVydCB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcgdG8gYSBmdW5jdGlvbiB3aXRoIGNhbGxzIHRvXG4gICAqIGluY3JlbWVudGFsIGRvbSBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX0gRnVuY3Rpb24gd2l0aCBpbmNyZW1lbnRhbCBkb20gY2FsbHMgZm9yIGJ1aWxkaW5nXG4gICAqICAgICB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBidWlsZEZuKGh0bWwpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHJldHVybiBIVE1MMkluY0RvbS5ydW4oaHRtbCk7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBodG1sIHBhcnNlciBiZWluZyBjdXJyZW50bHkgdXNlZC5cbiAgICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXJzZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJzZXIoKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VyXyB8fCB3aW5kb3cuSFRNTFBhcnNlcjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2hvdWxkIGNvbnZlcnQgdGhlIGdpdmVuIGh0bWwgc3RyaW5nIHRvIGNhbGxzIHRvIGluY3JlbWVudGFsIGRvbSBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuKGh0bWwpIHtcblx0XHRcdEhUTUwySW5jRG9tLmdldFBhcnNlcigpKGh0bWwsIHtcblx0XHRcdFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KHRhZywgYXR0cnMsIHVuYXJ5KSB7XG5cdFx0XHRcdFx0dmFyIGZuID0gdW5hcnkgPyBJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZCA6IEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuO1xuXHRcdFx0XHRcdHZhciBhcmdzID0gW3RhZywgbnVsbCwgW11dO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGFyZ3MucHVzaChhdHRyc1tpXS5uYW1lLCBhdHRyc1tpXS52YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGVuZDogZnVuY3Rpb24gZW5kKHRhZykge1xuXHRcdFx0XHRcdEluY3JlbWVudGFsRE9NLmVsZW1lbnRDbG9zZSh0YWcpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGNoYXJzOiBmdW5jdGlvbiBjaGFycyh0ZXh0KSB7XG5cdFx0XHRcdFx0SW5jcmVtZW50YWxET00udGV4dCh0ZXh0LCBfdW5lc2NhcGUyLmRlZmF1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hhbmdlcyB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgaHRtbCBzdHJpbmdzLiBCeSBkZWZhdWx0XG4gICAqIHRoaXMgd2lsbCB1c2UgdGhlIGBIVE1MUGFyc2VyYCBmdW5jdGlvbiBmcm9tXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibG93c2llL1B1cmUtSmF2YVNjcmlwdC1IVE1MNS1QYXJzZXIuIFRoaXMgd2lsbCBhY2NlcHRcbiAgICogYW55IGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGF0IHNhbWUgYXBpLCBiYXNpY2FsbHkgYWNjZXB0aW5nIHRoZSBodG1sXG4gICAqIHN0cmluZyBhbmQgYW4gb2JqZWN0IHdpdGggYHN0YXJ0YCwgYGVuZGAgYW5kIGBjaGFyc2AgZnVuY3Rpb25zIHRvIGJlIGNhbGxlZFxuICAgKiBkdXJpbmcgdGhlIHBhcnNpbmcuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKHN0cmluZywgIU9iamVjdH0gbmV3UGFyc2VyXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRQYXJzZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJzZXIobmV3UGFyc2VyKSB7XG5cdFx0XHRwYXJzZXJfID0gbmV3UGFyc2VyO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBIVE1MMkluY0RvbTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSFRNTDJJbmNEb207XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL0hUTUwySW5jRG9tLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBDb3B5cmlnaHQgMjAwNiBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuLyoqXG4gKiBVbmVzY2FwZXMgYW4gSFRNTCBzdHJpbmcgdXNpbmcgYSBET00gdG8gcmVzb2x2ZSBub24tWE1MLCBub24tbnVtZXJpY1xuICogZW50aXRpZXMuIFRoaXMgZnVuY3Rpb24gaXMgWFNTLXNhZmUgYW5kIHdoaXRlc3BhY2UtcHJlc2VydmluZy5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gdW5lc2NhcGUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB1bmVzY2FwZWQge0Bjb2RlIHN0cn0gc3RyaW5nLlxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5mdW5jdGlvbiB1bmVzY2FwZShzdHIpIHtcbiAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgdmFyIHNlZW4gPSB7ICcmYW1wOyc6ICcmJywgJyZsdDsnOiAnPCcsICcmZ3Q7JzogJz4nLCAnJnF1b3Q7JzogJ1wiJyB9O1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgLy8gTWF0Y2ggYXMgbWFueSB2YWxpZCBlbnRpdHkgY2hhcmFjdGVycyBhcyBwb3NzaWJsZS4gSWYgdGhlIGFjdHVhbCBlbnRpdHlcbiAgLy8gaGFwcGVucyB0byBiZSBzaG9ydGVyLCBpdCB3aWxsIHN0aWxsIHdvcmsgYXMgaW5uZXJIVE1MIHdpbGwgcmV0dXJuIHRoZVxuICAvLyB0cmFpbGluZyBjaGFyYWN0ZXJzIHVuY2hhbmdlZC4gU2luY2UgdGhlIGVudGl0eSBjaGFyYWN0ZXJzIGRvIG5vdCBpbmNsdWRlXG4gIC8vIG9wZW4gYW5nbGUgYnJhY2tldCwgdGhlcmUgaXMgbm8gY2hhbmNlIG9mIFhTUyBmcm9tIHRoZSBpbm5lckhUTUwgdXNlLlxuICAvLyBTaW5jZSBubyB3aGl0ZXNwYWNlIGlzIHBhc3NlZCB0byBpbm5lckhUTUwsIHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkLlxuICByZXR1cm4gc3RyLnJlcGxhY2UoSFRNTF9FTlRJVFlfUEFUVEVSTl8sIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAvLyBDaGVjayBmb3IgY2FjaGVkIGVudGl0eS5cbiAgICB2YXIgdmFsdWUgPSBzZWVuW3NdO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgbnVtZXJpYyBlbnRpdHkuXG4gICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgLy8gUHJlZml4IHdpdGggMCBzbyB0aGF0IGhleCBlbnRpdGllcyAoZS5nLiAmI3gxMCkgcGFyc2UgYXMgaGV4IG51bWJlcnMuXG4gICAgICB2YXIgbiA9IE51bWJlcignMCcgKyBlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgIGlmICghaXNOYU4obikpIHtcbiAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBGYWxsIGJhY2sgdG8gaW5uZXJIVE1MIG90aGVyd2lzZS5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAvLyBBcHBlbmQgYSBub24tZW50aXR5IGNoYXJhY3RlciB0byBhdm9pZCBhIGJ1ZyBpbiBXZWJraXQgdGhhdCBwYXJzZXNcbiAgICAgIC8vIGFuIGludmFsaWQgZW50aXR5IGF0IHRoZSBlbmQgb2YgaW5uZXJIVE1MIHRleHQgYXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIGRpdi5pbm5lckhUTUwgPSBzICsgJyAnO1xuICAgICAgLy8gVGhlbiByZW1vdmUgdGhlIHRyYWlsaW5nIGNoYXJhY3RlciBmcm9tIHRoZSByZXN1bHQuXG4gICAgICB2YWx1ZSA9IGRpdi5maXJzdENoaWxkLm5vZGVWYWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8vIENhY2hlIGFuZCByZXR1cm4uXG4gICAgc2VlbltzXSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVuZXNjYXBlO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW4gSFRNTCBlbnRpdHkuXG4gKiBAdHlwZSB7IVJlZ0V4cH1cbiAqL1xuXG52YXIgSFRNTF9FTlRJVFlfUEFUVEVSTl8gPSAvJihbXjtcXHM8Jl0rKTs/L2c7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL3VuZXNjYXBlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xudmFyIFNveUFvcCA9IHtcblx0LyoqXG4gICogVGhlIGZ1bmN0aW9ucyB0aGF0IHNob3VsZCBiZSBjYWxsZWQgaW5zdGVhZCBvZiBhIHRlbXBsYXRlIGNhbGwuIFRoZSBsYXN0XG4gICogZnVuY3Rpb24gaW4gdGhlIGFycmF5IGlzIHRoZSBvbmUgdGhhdCBpcyBpbnRlcmNlcHRpbmcgYXQgdGhlIG1vbWVudC4gSWYgdGhlXG4gICogYXJyYXkgaXMgZW1wdHksIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbnN0ZWFkLlxuICAqIEB0eXBlIHshQXJyYXk8ZnVuY3Rpb24oKT59XG4gICogQHByb3RlY3RlZFxuICAqL1xuXHRpbnRlcmNlcHRGbnNfOiBbXSxcblxuXHQvKipcbiAgKiBHZXRzIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBvZiB0aGUgZ2l2ZW4gdGVtcGxhdGUgZnVuY3Rpb24uIElmIG5vIG9yaWdpbmFsIGV4aXN0cyxcbiAgKiByZXR1cm5zIHRoZSBnaXZlbiBmdW5jdGlvbiBpdHNlbGYuXG4gICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0Z2V0T3JpZ2luYWxGbjogZnVuY3Rpb24gZ2V0T3JpZ2luYWxGbihmbikge1xuXHRcdHJldHVybiBmbi5vcmlnaW5hbEZuID8gZm4ub3JpZ2luYWxGbiA6IGZuO1xuXHR9LFxuXG5cdC8qKlxuICAqIEhhbmRsZXMgYSB0ZW1wbGF0ZSBjYWxsLCBjYWxsaW5nIHRoZSBjdXJyZW50IGludGVyY2VwdGlvbiBmdW5jdGlvbiBpZiBvbmVcbiAgKiBpcyBzZXQsIG9yIG90aGVyd2lzZSBqdXN0IGNhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGluc3RlYWQuXG4gICogQHBhcmFtIHshZnVuY3Rpb24oKX0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCB3YXNcbiAgKiAgICAgaW50ZXJjZXB0ZWQuXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdF9kYXRhIFRlbXBsYXRlIGRhdGEgb2JqZWN0LlxuICAqIEBwYXJhbSB7Kn0gb3B0X2lnbm9yZWRcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0X2lqRGF0YSBUZW1wbGF0ZSBpbmplY3RlZCBkYXRhIG9iamVjdC5cbiAgKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB0byBoYW5kbGUgdGhpc1xuICAqICAgICBpbnRlcmNlcHRpb24uXG4gICovXG5cdGhhbmRsZVRlbXBsYXRlQ2FsbF86IGZ1bmN0aW9uIGhhbmRsZVRlbXBsYXRlQ2FsbF8ob3JpZ2luYWxGbiwgb3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG5cdFx0dmFyIGludGVyY2VwdEZuID0gU295QW9wLmludGVyY2VwdEZuc19bU295QW9wLmludGVyY2VwdEZuc18ubGVuZ3RoIC0gMV07XG5cdFx0aWYgKGludGVyY2VwdEZuKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXJjZXB0Rm4uY2FsbChudWxsLCBvcmlnaW5hbEZuLCBvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gb3JpZ2luYWxGbi5jYWxsKG51bGwsIG9wdF9kYXRhLCBvcHRfaWdub3JlZCwgb3B0X2lqRGF0YSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuICAqIFJlZ2lzdGVycyBhIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGludGVyY2VwdGVkLlxuICAqIEBwYXJhbSB7IU9iamVjdH0gdGVtcGxhdGVzIFRoZSBvcmlnaW5hbCB0ZW1wbGF0ZXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlXG4gICogICAgIGZ1bmN0aW9uIHRvIGJlIGludGVyY2VwdGVkLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbiB0byBpbnRlcmNlcHQuXG4gICovXG5cdHJlZ2lzdGVyRm9ySW50ZXJjZXB0aW9uOiBmdW5jdGlvbiByZWdpc3RlckZvckludGVyY2VwdGlvbih0ZW1wbGF0ZXMsIG5hbWUpIHtcblx0XHR2YXIgb3JpZ2luYWxGbiA9IHRlbXBsYXRlc1tuYW1lXTtcblx0XHRpZiAoIW9yaWdpbmFsRm4ub3JpZ2luYWxGbikge1xuXHRcdFx0dGVtcGxhdGVzW25hbWVdID0gU295QW9wLmhhbmRsZVRlbXBsYXRlQ2FsbF8uYmluZChudWxsLCBvcmlnaW5hbEZuKTtcblx0XHRcdHRlbXBsYXRlc1tuYW1lXS5vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG4gICogU3RhcnRzIGludGVyY2VwdGluZyBhbGwgdGVtcGxhdGUgY2FsbHMsIHJlcGxhY2luZyB0aGVtIHdpdGggYSBjYWxsIHRvIHRoZVxuICAqIGdpdmVuIGZ1bmN0aW9uIGluc3RlYWQuXG4gICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAgKi9cblx0c3RhcnRJbnRlcmNlcHRpb246IGZ1bmN0aW9uIHN0YXJ0SW50ZXJjZXB0aW9uKGZuKSB7XG5cdFx0U295QW9wLmludGVyY2VwdEZuc18ucHVzaChmbik7XG5cdH0sXG5cblx0LyoqXG4gICogU3RvcHMgaW50ZXJjZXB0aW5nIHRlbXBsYXRlIGNhbGxzLlxuICAqL1xuXHRzdG9wQWxsSW50ZXJjZXB0aW9uczogZnVuY3Rpb24gc3RvcEFsbEludGVyY2VwdGlvbnMoKSB7XG5cdFx0U295QW9wLmludGVyY2VwdEZuc18gPSBbXTtcblx0fSxcblxuXHQvKipcbiAgKiBTdG9wcyBpbnRlcmNlcHRpbmcgdGVtcGxhdGUgY2FsbHMgd2l0aCB0aGUgbGFzdCByZWdpc3RlcmVkIGZ1bmN0aW9uLlxuICAqL1xuXHRzdG9wSW50ZXJjZXB0aW9uOiBmdW5jdGlvbiBzdG9wSW50ZXJjZXB0aW9uKCkge1xuXHRcdFNveUFvcC5pbnRlcmNlcHRGbnNfLnBvcCgpO1xuXHR9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTb3lBb3A7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L2xpYi9Tb3lBb3AuanNcbi8vIG1vZHVsZSBpZCA9IDEwOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0cmluZyA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5hc3luYyA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmNvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG52YXIgX2NvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29yZSk7XG5cbnZhciBfYXJyYXkgPSByZXF1aXJlKCcuL2FycmF5L2FycmF5Jyk7XG5cbnZhciBfYXJyYXkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXkpO1xuXG52YXIgX2FzeW5jID0gcmVxdWlyZSgnLi9hc3luYy9hc3luYycpO1xuXG52YXIgX2FzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FzeW5jKTtcblxudmFyIF9EaXNwb3NhYmxlID0gcmVxdWlyZSgnLi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUnKTtcblxudmFyIF9EaXNwb3NhYmxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0Rpc3Bvc2FibGUpO1xuXG52YXIgX29iamVjdCA9IHJlcXVpcmUoJy4vb2JqZWN0L29iamVjdCcpO1xuXG52YXIgX29iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3QpO1xuXG52YXIgX3N0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5nL3N0cmluZycpO1xuXG52YXIgX3N0cmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zdHJpbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcbmV4cG9ydHMuY29yZSA9IF9jb3JlMi5kZWZhdWx0O1xuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvbWV0YWwuanNcbi8vIG1vZHVsZSBpZCA9IDEwOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGFycmF5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBhcnJheSk7XG5cdH1cblxuXHQvKipcbiAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG4gICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjFcbiAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICovXG5cdGFycmF5LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgKiBAcGFyYW0geyFBcnJheX0gYXJyXG4gICogQHJldHVybiB7Kn1cbiAgKi9cblxuXG5cdGFycmF5LmZpcnN0RGVmaW5lZFZhbHVlID0gZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoYXJyKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRyZXR1cm4gYXJyW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcbiAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dCBuZXN0ZWQgYXJyYXkgdG8gYmVjb21lIGZsYXQuXG4gICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG4gICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAqIEByZXR1cm4ge0FycmF5LjwqPn0gRmxhdCBhcnJheS5cbiAgKi9cblxuXG5cdGFycmF5LmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuKGFyciwgb3B0X291dHB1dCkge1xuXHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG5cdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goYXJyW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fTtcblxuXHQvKipcbiAgKiBSZW1vdmVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgcGFydGljdWxhciB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICogQHRlbXBsYXRlIFRcbiAgKi9cblxuXG5cdGFycmF5LnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHR2YXIgcnY7XG5cdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRhcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcnY7XG5cdH07XG5cblx0LyoqXG4gICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcbiAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICovXG5cblxuXHRhcnJheS5yZW1vdmVBdCA9IGZ1bmN0aW9uIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdH07XG5cblx0LyoqXG4gICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcbiAgKiBpcyBmYXN0ZXIgYW5kIHdvcmtpbmcgb24gYWxsIGFycmF5LWxpa2Ugb2JqZWN0cyAobGlrZSBhcmd1bWVudHMpLlxuICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggd2hlcmUgdGhlIHNsaWNlIHNob3VsZCBlbmQsIG5vdFxuICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG4gICogQHJldHVybiB7IUFycmF5fVxuICAqL1xuXG5cblx0YXJyYXkuc2xpY2UgPSBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdHZhciBlbmQgPSBfY29yZTIuZGVmYXVsdC5pc0RlZihvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc2xpY2VkO1xuXHR9O1xuXG5cdHJldHVybiBhcnJheTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXJyYXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXN5bmMgPSB7fTtcblxuLyoqXG4gKiBUaHJvdyBhbiBpdGVtIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LiAgRm9yXG4gKiBleGFtcGxlLCBpZiBwcm9jZXNzaW5nIGEgZ3JvdXAgb2YgaXRlbXMgaW4gYSBsb29wLCBzb21ldGltZXMgaXQgaXMgdXNlZnVsXG4gKiB0byByZXBvcnQgYW4gZXJyb3Igd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIHRvIGJlXG4gKiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0geyp9IGV4Y2VwdGlvblxuICovXG5hc3luYy50aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgY2FsbHN0YWNrIHVud2luZHMsIG9yIGFzXG4gKiBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbiBjb250ZXh0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpfSBjYWxsYmFja1xuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgT2JqZWN0IHRvIHVzZSBhcyB0aGUgXCJ0aGlzIHZhbHVlXCIgd2hlbiBjYWxsaW5nXG4gKiAgICAgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuYXN5bmMucnVuID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2gobmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG4vKiogQHByaXZhdGUgeyFBcnJheS48IWFzeW5jLnJ1bi5Xb3JrSXRlbV8+fSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblxuLyoqXG4gKiBSdW4gYW55IHBlbmRpbmcgYXN5bmMucnVuIHdvcmsgaXRlbXMuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGludGVuZGVkXG4gKiBmb3IgZ2VuZXJhbCB1c2UsIGJ1dCBmb3IgdXNlIGJ5IGVudHJ5IHBvaW50IGhhbmRsZXJzIHRvIHJ1biBpdGVtcyBhaGVhZCBvZlxuICogYXN5bmMubmV4dFRpY2suXG4gKi9cbmFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuZm4gPSBmbjtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG4vKipcbiAqIENhY2hlIGZvciB0aGUgc2V0SW1tZWRpYXRlIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IG51bGw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24gKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWw7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8qKiBAY29uc3RydWN0b3IgKi9cblx0XHRDaGFubmVsID0gZnVuY3Rpb24gQ2hhbm5lbCgpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIFZhbGlkYXRlIG9yaWdpbiBhbmQgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG1lc3NhZ2Ugd2FzXG5cdFx0XHRcdC8vIGludGVuZGVkIGZvciB1cy5cblx0XHRcdFx0aWYgKGUub3JpZ2luICE9PSBvcmlnaW4gJiYgZS5kYXRhICE9PSBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucG9ydDEub25tZXNzYWdlKCk7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5wb3J0MSA9IHt9O1xuXHRcdFx0dGhpcy5wb3J0MiA9IHtcblx0XHRcdFx0cG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKCkge1xuXHRcdFx0XHRcdHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlLCBvcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGVvZiBDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBjaGFubmVsID0gbmV3IENoYW5uZWwoKTtcblx0XHQvLyBVc2UgYSBmaWZvIGxpbmtlZCBsaXN0IHRvIGNhbGwgY2FsbGJhY2tzIGluIHRoZSByaWdodCBvcmRlci5cblx0XHR2YXIgaGVhZCA9IHt9O1xuXHRcdHZhciB0YWlsID0gaGVhZDtcblx0XHRjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0c2V0VGltZW91dChjYiwgMCk7XG5cdH07XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uIChvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFzeW5jO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEaXNwb3NhYmxlIHV0aWxpdHkuIFdoZW4gaW5oZXJpdGVkIHByb3ZpZGVzIHRoZSBgZGlzcG9zZWAgZnVuY3Rpb24gdG8gaXRzXG4gKiBzdWJjbGFzcywgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyBvZiBhbnkgb2JqZWN0IHJlZmVyZW5jZXNcbiAqIHdoZW4gYW4gaW5zdGFuY2Ugd29uJ3QgYmUgdXNlZCBhbnltb3JlLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICogYGRpc3Bvc2VJbnRlcm5hbGAgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpYyBkaXNwb3NpbmcgbG9naWMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcG9zYWJsZSk7XG5cblx0XHQvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG4gICovXG5cblxuXHREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcbiAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG4gICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG4gICogZGlzcG9zYWJsZXMpLlxuICAqL1xuXG5cblx0RGlzcG9zYWJsZS5wcm90b3R5cGUuZGlzcG9zZUludGVybmFsID0gZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge307XG5cblx0LyoqXG4gICogQ2hlY2tzIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgKiBAcmV0dXJuIHtib29sZWFufVxuICAqL1xuXG5cblx0RGlzcG9zYWJsZS5wcm90b3R5cGUuaXNEaXNwb3NlZCA9IGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGlzcG9zZWRfO1xuXHR9O1xuXG5cdHJldHVybiBEaXNwb3NhYmxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwb3NhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIG9iamVjdCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgb2JqZWN0KTtcblx0fVxuXG5cdC8qKlxuICAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIFRoZSBvYmplY3RzIGZyb20gd2hpY2ggdmFsdWVzIHdpbGwgYmUgY29waWVkLlxuICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG4gICovXG5cdG9iamVjdC5taXhpbiA9IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdHZhciBrZXksIHNvdXJjZTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAqICAgICA8Y29kZT53aW5kb3c8L2NvZGU+LlxuICAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuICAqL1xuXG5cblx0b2JqZWN0LmdldE9iamVjdEJ5TmFtZSA9IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnQsIGtleSkge1xuXHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHR9LCBzY29wZSk7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAqL1xuXG5cblx0b2JqZWN0Lm1hcCA9IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0dmFyIG1hcHBlZE9iaiA9IHt9O1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcHBlZE9ialtrZXlzW2ldXSA9IGZuKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdH07XG5cblx0LyoqXG4gICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG4gICogY2hlY2ssIGluY2x1ZGluZyBvbmx5IHRoZSBrZXlzIGRpcmVjdGx5IGNvbnRhaW5lZCBieSB0aGUgMiBvYmplY3RzLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICovXG5cblxuXHRvYmplY3Quc2hhbGxvd0VxdWFsID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gc3RyaW5nKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdHJpbmcpO1xuXHR9XG5cblx0LyoqXG4gICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG4gICogY29sbGFwc2VzIHRoZSBzZXF1ZW5jZXMgb2YgYnJlYWtpbmcgc3BhY2VzIGluIHRoZSBtaWRkbGUgaW50byBzaW5nbGUgc3BhY2VzLlxuICAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cbiAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IENvcHkgb2YgdGhlIHN0cmluZyB3aXRoIG5vcm1hbGl6ZWQgYnJlYWtpbmcgc3BhY2VzLlxuICAqL1xuXHRzdHJpbmcuY29sbGFwc2VCcmVha2luZ1NwYWNlcyA9IGZ1bmN0aW9uIGNvbGxhcHNlQnJlYWtpbmdTcGFjZXMoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx0XFxyXFxuIF0rL2csICcgJykucmVwbGFjZSgvXltcXHRcXHJcXG4gXSt8W1xcdFxcclxcbiBdKyQvZywgJycpO1xuXHR9O1xuXG5cdC8qKlxuICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IHNhZmUgdG8gdXNlIGluIGEgUmVnRXhwLlxuICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcbiAqICAgICB0byBvbmUuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVnRXhwIHNhZmUsIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc30uXG4gKi9cblxuXG5cdHN0cmluZy5lc2NhcGVSZWdleCA9IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy0oKVxcW1xcXXt9Kz8qLiRcXF58LDojPCFcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdH07XG5cblx0LyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuICogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuICovXG5cblxuXHRzdHJpbmcuZ2V0UmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gZ2V0UmFuZG9tU3RyaW5nKCkge1xuXHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdH07XG5cblx0LyoqXG4gICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcbiAgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuICAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuICAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cbiAgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG4gICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG4gICovXG5cblxuXHRzdHJpbmcuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSh2YWwpIHtcblx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHR9XG5cdFx0cmV0dXJuIGhhc2g7XG5cdH07XG5cblx0LyoqXG4gICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG4gICogYHJlcGxhY2VJbnRlcnZhbChcImFiY2RlXCIsIDEsIDQsIFwiXCIpYCByZXR1cm5zIFwiYWVcIi5cbiAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG4gICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICAqIEByZXR1cm4ge3N0cmluZ31cbiAgKi9cblxuXG5cdHN0cmluZy5yZXBsYWNlSW50ZXJ2YWwgPSBmdW5jdGlvbiByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHR9O1xuXG5cdHJldHVybiBzdHJpbmc7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gMTE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDExNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ29tcG9uZW50IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG5pbXBvcnQgZG9tIGZyb20gJ21ldGFsLWRvbSc7XG5pbXBvcnQgRW1pdHRlciBmcm9tICcuLi8uLi9VdGlscy9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHRlbXBsYXRlcyBmcm9tICcuL0Ryb3Bkb3duLnNveS5qcyc7XG5pbXBvcnQgeyBJVEVNU19EQVRBIH0gZnJvbSAnLi9Ecm9wZG93blV0aWxzJ1xuXG5cbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIERyb3Bkb3duIGNvbXBvbmVudC5cblx0ICovXG5cdGNyZWF0ZWQoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdFxuXHRcdGluc3RhbmNlLmNhc2hJdGVtc0RhdGEgPSBJVEVNU19EQVRBO1xuXHRcdGluc3RhbmNlLkxpc3RlbmVyLm9uKCdMSVNURU5fRFJPUERPV05fRVJST1InLCBlcnIgPT4gaW5zdGFuY2Uud2FybmluZyA9IGVycik7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZXQgdGhlIGNsaWNrIGV2ZW50IHdoZW4gdGhlIGJvZHkgd2FzIHByZXNzZWRcblx0ICovXG5cdGF0dGFjaGVkKCl7XG5cdFx0Y29uc3Qgc2hvd0l0ZW1zID0gdGhpcy5zaG93SXRlbXM7XG5cdFx0ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2hvd0l0ZW1zLmJpbmQodGhpcykpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU2hvdyB0aGUgZHJvcGRvd25zIGl0ZW1zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqL1xuXHRzaG93SXRlbXMoZSl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcyxcblx0XHRcdGFjdGl2ZSxcblx0XHRcdGVsZW1lbnRDbGFzcyA9IGUudGFyZ2V0LmNsYXNzTmFtZTtcblx0XHRcblx0XHRpZigoZWxlbWVudENsYXNzLmluZGV4T2YoJ2Ryb3Bkb3duLWRpc3BsYXknKSAhPSAtMSkgfHwgKGVsZW1lbnRDbGFzcy5pbmRleE9mKCdkcm9wZG93bi1pbnB1dCcpICE9IC0xKSl7XG5cdFx0XHRhY3RpdmUgPSB0cnVlO1xuXHRcdFx0c2V0VGltZW91dCgoKSA9PiBpbnN0YW5jZS5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kcm9wZG93bi1pbnB1dCcpLmZvY3VzKCksIDIwMCk7XG5cdFx0fWVsc2Uge1xuXHRcdFx0aW5zdGFuY2UuZm9jdXNPdXQoKTtcblx0XHR9XG5cdFx0XG5cdFx0aW5zdGFuY2Uuc2hvd24gPSBhY3RpdmU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGFuZ2UgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gdGhlIGRyb3Bkb3duXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqL1xuXHRjaGFuZ2VBY3RpdmVQbGFuKGUpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0Y29uc3QgaXRlbSA9IGUudGFyZ2V0O1xuXHRcdGNvbnN0IGRhdGEgPSBpbnN0YW5jZS5jYXNoSXRlbXNEYXRhLmZpbHRlcihvYmogPT4gb2JqLmlkID09IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWlkJykpO1xuXHRcdFxuXHRcdGl0ZW0uY2xhc3NMaXN0LmFkZCgnZHJvcGRvd24tbGlzdC1pdGVtLS1zZWxlY3RlZCcpO1xuXHRcdFxuXHRcdGlmKGRhdGEubGVuZ3RoKSB7XG5cdFx0XHRpbnN0YW5jZS5iaW5kU2VsZWN0ZWRJdGVtQ2xhc3MoZGF0YVswXSk7XG5cdFx0XHRpbnN0YW5jZS5zZXRTdGF0ZSh7YWN0aXZlRHJvcGRvd25JdGVtOiBkYXRhWzBdfSk7XG5cdFx0XHRpbnN0YW5jZS5lbWl0TGlzdGVuZXIoZGF0YVswXSk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogQ2xlYXIgdGhlIGlucHV0IGFuZCByZW1vdmUgdGhlIGlucHV0IGZvY3VzXG5cdCAqL1xuXHRmb2N1c091dCgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0Y29uc3QgaXRlbSA9IGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLWlucHV0Jyk7XG5cdFx0XG5cdFx0aXRlbS52YWx1ZSA9ICcnO1xuXHRcdGluc3RhbmNlLml0ZW1zID0gaW5zdGFuY2UuY2FzaEl0ZW1zRGF0YTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNlYXJjaCBpdGVtcyB0aHJvdWdoIG9mIHRoZSBpbnB1dCBpbnRlcmFjdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKi9cblx0c2VhcmNoSXRlbShlKXtcblx0XHRjb25zdCBpdGVtID0gZS50YXJnZXQ7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRpbnN0YW5jZS5pdGVtcyA9IGluc3RhbmNlLmNhc2hJdGVtc0RhdGEuZmlsdGVyKG9iaiA9PiBvYmoubmFtZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoaXRlbS52YWx1ZS50b0xvd2VyQ2FzZSgpKSAhPSAtMSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFbWl0IGFuIGV2ZW50IHRvIHRoZSBvdGhlciBjb21wb25lbnRzIHByZXNlbnQgaW4gdGhlIGFwcGxpY2F0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqL1xuXHRlbWl0TGlzdGVuZXIoZGF0YSl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRpbnN0YW5jZS53YXJuaW5nID0gZmFsc2U7XG5cdFx0aW5zdGFuY2UuTGlzdGVuZXIuZW1pdCgnTElTVEVOX0RST1BET1dOX0VWRU5UJywgZGF0YSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayB0aGUga2V5IGNvZGUgb2YgdGhlIGtleWJvYXJkIGludGVyYWN0aW9uc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gZVxuXHQgKi9cblx0YmluZEtleUNvZGUoZSl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRpZihlLmtleUNvZGUgPT0gMjcpIHJldHVybiBpbnN0YW5jZS5iaW5kRVNDS2V5KCk7XG5cdFx0aWYoZS5rZXlDb2RlID09IDEzKSByZXR1cm4gaW5zdGFuY2UuYmluZEVOVEVSS2V5KGluc3RhbmNlLml0ZW1zWzBdKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIExlYXZlIG9mIHRoZSBkcm9wZG93biBzZWFyY2ggYW5kXG5cdCAqIGhpZGUgdGhlIGxpc3Qgb2YgaXRlbXNcblx0ICovXG5cdGJpbmRFU0NLZXkoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLWlucHV0JykuYmx1cigpO1xuXHRcdGluc3RhbmNlLnNob3duID0gZmFsc2U7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTZWxlY3QgdGhlIGZpcnN0IGl0ZW0gcHJlc2VudCBpbiB0aGUgc2FyY2hcblx0ICogaWYgdGhlIHVzZXIgZGlkbid0IHNlYXJjaCBhbnkgaXRlbVxuXHQgKiBzZWxlY3QgdGhlIGZpcnN0IGRlZmF1bHQgaXRlbVxuXHQgKi9cblx0YmluZEVOVEVSS2V5KGRhdGEpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0XG5cdFx0aW5zdGFuY2Uuc2V0U3RhdGUoe2FjdGl2ZURyb3Bkb3duSXRlbTogZGF0YX0pO1xuXHRcdGluc3RhbmNlLmVtaXRMaXN0ZW5lcihkYXRhKTtcblx0XHRpbnN0YW5jZS5iaW5kU2VsZWN0ZWRJdGVtQ2xhc3MoZGF0YSk7XG5cdFx0aW5zdGFuY2Uuc2hvd24gPSBmYWxzZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgc2VsZWN0ZWQgaXRlbSBwcm9wZXJ0eVxuXHQgKiB0byBhZGQgdGhlIGNsYXNzIHNlbGVjdGVkIGluIHRoZSBjb21wb25lbnRcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICovXG5cdGJpbmRTZWxlY3RlZEl0ZW1DbGFzcyhkYXRhKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdGluc3RhbmNlLmNhc2hJdGVtc0RhdGEuZm9yRWFjaChpdGVtID0+IGl0ZW0uaWQgPT0gZGF0YS5pZCA/IGl0ZW0uc2VsZWN0ZWQgPSB0cnVlIDogZGVsZXRlIGl0ZW0uc2VsZWN0ZWQpO1xuXHR9XG59XG5Tb3kucmVnaXN0ZXIoRHJvcGRvd24sIHRlbXBsYXRlcyk7XG5cbi8qKlxuICogRHJvcGRvd24gc3RhdGUgZGVmaW5pdGlvblxuICovXG5Ecm9wZG93bi5TVEFURSA9IHtcblx0LyoqXG5cdCAqIFRvIHNob3cgdGhlIGRyb3Bkb3duIGl0ZW1zXG5cdCAqL1xuXHRzaG93bjoge1xuXHRcdHZhbHVlOiBmYWxzZVxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEFjdGl2ZSBpdGVtIHNlbGVjdGVkIGluIHRoZSBkcm9wZG93blxuXHQgKi9cblx0YWN0aXZlRHJvcGRvd25JdGVtOiB7XG5cdFx0dmFsdWU6IGZhbHNlXG5cdH0sXG5cdFxuXHQvKipcblx0ICogTGlzdCBvZiBpdGVtcyB0byB0aGUgZHJvcGRvd24gaXRlbXMgbGlzdFxuXHQgKi9cblx0aXRlbXM6IHtcblx0XHR2YWx1ZTogSVRFTVNfREFUQVxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIE1lc3NhZ2Ugb2Ygd2FybmluZyBvZiB0aGUgY2FsY3VsYXRvclxuXHQgKi9cblx0d2FybmluZzoge1xuXHRcdHZhbHVlOiAnJ1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIExpc3RlbmVyIGZvciB0aGUgb3RoZXJzIGNvbXBvbmVudHNcblx0ICovXG5cdExpc3RlbmVyOiB7XG5cdFx0dmFsdWU6IG5ldyBFbWl0dGVyKClcblx0fVxufTtcblxuXG5leHBvcnQgZGVmYXVsdCBEcm9wZG93bjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvRHJvcGRvd24vRHJvcGRvd24uanNcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG52YXIgdGVtcGxhdGVzO1xuZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uKGV4cG9ydHMpIHtcblxuLy8gVGhpcyBmaWxlIHdhcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBmcm9tIERyb3Bkb3duLnNveS5cbi8vIFBsZWFzZSBkb24ndCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGVtcGxhdGVzIGluIG5hbWVzcGFjZSBEcm9wZG93bi5cbiAqIEBwdWJsaWNcbiAqL1xuXG5nb29nLm1vZHVsZSgnRHJvcGRvd24uaW5jcmVtZW50YWxkb20nKTtcblxuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xudmFyIHNveSA9IGdvb2cucmVxdWlyZSgnc295Jyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ZGF0YSA9IGdvb2cucmVxdWlyZSgnc295ZGF0YScpO1xuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xuZ29vZy5yZXF1aXJlKCdnb29nLmkxOG4uYmlkaScpO1xuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xuZ29vZy5yZXF1aXJlKCdnb29nLmFzc2VydHMnKTtcbnZhciBJbmNyZW1lbnRhbERvbSA9IGdvb2cucmVxdWlyZSgnaW5jcmVtZW50YWxkb20nKTtcbnZhciBpZV9vcGVuID0gSW5jcmVtZW50YWxEb20uZWxlbWVudE9wZW47XG52YXIgaWVfY2xvc2UgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50Q2xvc2U7XG52YXIgaWVfdm9pZCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRWb2lkO1xudmFyIGllX29wZW5fc3RhcnQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlblN0YXJ0O1xudmFyIGllX29wZW5fZW5kID0gSW5jcmVtZW50YWxEb20uZWxlbWVudE9wZW5FbmQ7XG52YXIgaXRleHQgPSBJbmNyZW1lbnRhbERvbS50ZXh0O1xudmFyIGlhdHRyID0gSW5jcmVtZW50YWxEb20uYXR0cjtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfZGF0YVxuICogQHBhcmFtIHsobnVsbHx1bmRlZmluZWQpPX0gb3B0X2lnbm9yZWRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfaWpEYXRhXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5mdW5jdGlvbiAkcmVuZGVyKG9wdF9kYXRhLCBvcHRfaWdub3JlZCwgb3B0X2lqRGF0YSkge1xuICBpZV9vcGVuKCdkaXYnLCBudWxsLCBudWxsLFxuICAgICAgJ2NsYXNzJywgJ2Ryb3Bkb3duJyk7XG4gICAgaWVfdm9pZCgnc3BhbicsIG51bGwsIG51bGwsXG4gICAgICAgICdjbGFzcycsICdhcnJvd19ib3gnKTtcbiAgICBpZV9vcGVuKCdpbnB1dCcsIG51bGwsIG51bGwsXG4gICAgICAgICd0eXBlJywgJ3RleHQnLFxuICAgICAgICAnY2xhc3MnLCAnZHJvcGRvd24tZGlzcGxheSAnICsgKG9wdF9kYXRhLndhcm5pbmcgPyAnaW5wdXQtZXJyb3InIDogJycpLFxuICAgICAgICAncGxhY2Vob2xkZXInLCBvcHRfZGF0YS5hY3RpdmVEcm9wZG93bkl0ZW0gPyBvcHRfZGF0YS5hY3RpdmVEcm9wZG93bkl0ZW0ubmFtZSA6ICdTZWxlY3QgeW91ciBwbGFuJyxcbiAgICAgICAgJ3JlYWRvbmx5JywgJ3RydWUnKTtcbiAgICBpZV9jbG9zZSgnaW5wdXQnKTtcbiAgICBpZV9vcGVuKCdzcGFuJywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ2NsYXNzJywgJ3dhcm5pbmctbGFiZWwgJyArIChvcHRfZGF0YS53YXJuaW5nID8gJ3Nob3cnIDogJycpKTtcbiAgICAgIGl0ZXh0KChnb29nLmFzc2VydHMuYXNzZXJ0KChvcHRfZGF0YS53YXJuaW5nKSAhPSBudWxsKSwgb3B0X2RhdGEud2FybmluZykpO1xuICAgIGllX2Nsb3NlKCdzcGFuJyk7XG4gICAgaWVfb3BlbignZGl2JywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ2NsYXNzJywgb3B0X2RhdGEuc2hvd24gPyAnZHJvcGRvd24tbGlzdC13cmFwcGVyIHNob3cnIDogJ2Ryb3Bkb3duLWxpc3Qtd3JhcHBlcicpO1xuICAgICAgaWVfb3BlbignaW5wdXQnLCBudWxsLCBudWxsLFxuICAgICAgICAgICd0eXBlJywgJ3RleHQnLFxuICAgICAgICAgICdkYXRhLW9uS2V5ZG93bicsICdiaW5kS2V5Q29kZScsXG4gICAgICAgICAgJ2RhdGEtb25LZXl1cCcsICdzZWFyY2hJdGVtJyxcbiAgICAgICAgICAncGxhY2Vob2xkZXInLCAnVHlwZSB5b3VyIHNlYXJjaCcsXG4gICAgICAgICAgJ2NsYXNzJywgJ2Ryb3Bkb3duLWlucHV0Jyk7XG4gICAgICBpZV9jbG9zZSgnaW5wdXQnKTtcbiAgICAgIGllX29wZW4oJ3VsJywgbnVsbCwgbnVsbCxcbiAgICAgICAgICAnY2xhc3MnLCAnZHJvcGRvd24tbGlzdCcpO1xuICAgICAgICB2YXIgaXRlbUxpc3Q1OSA9IG9wdF9kYXRhLml0ZW1zO1xuICAgICAgICB2YXIgaXRlbUxpc3RMZW41OSA9IGl0ZW1MaXN0NTkubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpdGVtSW5kZXg1OSA9IDA7IGl0ZW1JbmRleDU5IDwgaXRlbUxpc3RMZW41OTsgaXRlbUluZGV4NTkrKykge1xuICAgICAgICAgIHZhciBpdGVtRGF0YTU5ID0gaXRlbUxpc3Q1OVtpdGVtSW5kZXg1OV07XG4gICAgICAgICAgaWVfb3BlbignbGknLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAnY2xhc3MnLCAnZHJvcGRvd24tbGlzdC1pdGVtJyxcbiAgICAgICAgICAgICAgJ2RhdGEtc2VsZWN0ZWQnLCBpdGVtRGF0YTU5LnNlbGVjdGVkLFxuICAgICAgICAgICAgICAnZGF0YS1pZCcsIGl0ZW1EYXRhNTkuaWQsXG4gICAgICAgICAgICAgICdkYXRhLW9uQ2xpY2snLCAnY2hhbmdlQWN0aXZlUGxhbicpO1xuICAgICAgICAgICAgaXRleHQoKGdvb2cuYXNzZXJ0cy5hc3NlcnQoKGl0ZW1EYXRhNTkubmFtZSkgIT0gbnVsbCksIGl0ZW1EYXRhNTkubmFtZSkpO1xuICAgICAgICAgICAgaXRleHQoJyAoJyk7XG4gICAgICAgICAgICBpdGV4dCgoZ29vZy5hc3NlcnRzLmFzc2VydCgoaXRlbURhdGE1OS5tb250aHMpICE9IG51bGwpLCBpdGVtRGF0YTU5Lm1vbnRocykpO1xuICAgICAgICAgICAgaXRleHQoJyBtZXNlcyknKTtcbiAgICAgICAgICBpZV9jbG9zZSgnbGknKTtcbiAgICAgICAgfVxuICAgICAgaWVfY2xvc2UoJ3VsJyk7XG4gICAgaWVfY2xvc2UoJ2RpdicpO1xuICBpZV9jbG9zZSgnZGl2Jyk7XG59XG5leHBvcnRzLnJlbmRlciA9ICRyZW5kZXI7XG5pZiAoZ29vZy5ERUJVRykge1xuICAkcmVuZGVyLnNveVRlbXBsYXRlTmFtZSA9ICdEcm9wZG93bi5yZW5kZXInO1xufVxuXG5leHBvcnRzLnJlbmRlci5wYXJhbXMgPSBbXCJzaG93blwiLFwiaXRlbXNcIixcImFjdGl2ZURyb3Bkb3duSXRlbVwiLFwid2FybmluZ1wiXTtcbmV4cG9ydHMucmVuZGVyLnR5cGVzID0ge1wic2hvd25cIjpcImFueVwiLFwiaXRlbXNcIjpcImFueVwiLFwiYWN0aXZlRHJvcGRvd25JdGVtXCI6XCJhbnlcIixcIndhcm5pbmdcIjpcImFueVwifTtcbnRlbXBsYXRlcyA9IGV4cG9ydHM7XG5yZXR1cm4gZXhwb3J0cztcblxufSk7XG5cbmNsYXNzIERyb3Bkb3duIGV4dGVuZHMgQ29tcG9uZW50IHt9XG5Tb3kucmVnaXN0ZXIoRHJvcGRvd24sIHRlbXBsYXRlcyk7XG5leHBvcnQgeyBEcm9wZG93biwgdGVtcGxhdGVzIH07XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZXM7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93bi5zb3kuanNcbi8vIG1vZHVsZSBpZCA9IDExN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgSVRFTVNfREFUQSA9IFtcblx0e2lkOiAwLCBtb250aHM6IDEyLCBpbnRlcmVzdDo1LCBuYW1lOiBcIkluaXRpYWxcIn0sXG5cdHtpZDogMSwgbW9udGhzOiAyNCwgaW50ZXJlc3Q6NywgbmFtZTogXCJCcm9uemVcIn0sXG5cdHtpZDogMiwgbW9udGhzOiAzNiwgaW50ZXJlc3Q6OSwgbmFtZTogXCJHb2xkXCJ9LFxuXHR7aWQ6IDMsIG1vbnRoczogNDgsIGludGVyZXN0OjE1LCBuYW1lOiBcIlNwaGVyZVwifVxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvRHJvcGRvd24vRHJvcGRvd25VdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IENvbXBvbmVudCBmcm9tICdtZXRhbC1jb21wb25lbnQnO1xuaW1wb3J0IFNveSBmcm9tICdtZXRhbC1zb3knO1xuaW1wb3J0IHRlbXBsYXRlcyBmcm9tICcuL0NhbGN1bGF0b3Iuc295LmpzJztcbmltcG9ydCB7IGxhYmVscywgb3BlcmF0b3JzIH0gZnJvbSAnLi9DYWxjdWxhdG9yVXRpbHMnO1xuaW1wb3J0IEVtaXR0ZXIgZnJvbSAnLi4vLi4vVXRpbHMvRXZlbnRFbWl0dGVyJztcblxuY2xhc3MgQ2FsY3VsYXRvciBleHRlbmRzIENvbXBvbmVudCB7XG5cdC8qKlxuXHRcdENhbGN1bGF0b3IgY29tcG9uZW50XG5cdCAqL1xuXHRjcmVhdGVkKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRcblx0XHRpbnN0YW5jZS5sYWJlbHMuZm9yRWFjaChsYWJlbCA9PiBpbnN0YW5jZS5zZXRDYWxjdWxhdG9yQnV0dG9uc0V2ZW50cyhsYWJlbCkpO1xuXHRcdGluc3RhbmNlLm9wZXJhdG9ycy5mb3JFYWNoKG9wZXJhdG9yID0+IGluc3RhbmNlLnNldENhbGN1bGF0b3JCdXR0b25zRXZlbnRzKG9wZXJhdG9yKSk7XG5cdFx0aW5zdGFuY2UuTGlzdGVuZXIub24oJ0xJU1RFTl9DQUxDVUxBVE9SX0VSUk9SJywgZXJyID0+IGluc3RhbmNlLndhcm5pbmcgPSBlcnIpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQWRkIGV2ZW50cyBmb3IgYWxsIGJ1dHRvbnMgaW4gdGhlIGNhbGN1bGF0b3IgY29tcG9uZW50XG5cdCAqIGxvY2F0ZWQgaW4gQ2FsY3VsYXRvclV0aWxzXG5cdCAqL1xuXHRzZXRDYWxjdWxhdG9yQnV0dG9uc0V2ZW50cyhidXR0b24pe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0XG5cdFx0aWYoYnV0dG9uLmlzQ2xlYXJCdXR0b24pe1xuXHRcdFx0YnV0dG9uLmNsaWNrRm4gPSBpbnN0YW5jZS5kZWxlZ2F0ZURlbGV0ZUJ1dHRvbi5iaW5kKGluc3RhbmNlKTtcblx0XHR9ZWxzZSBpZihidXR0b24uaXNSZXN1bHRCdXR0b20pe1xuXHRcdFx0YnV0dG9uLmNsaWNrRm4gPSBpbnN0YW5jZS5yZXN1bHRPZkRpc3BsYXlFeHByZXNzaW9ucy5iaW5kKGluc3RhbmNlKTtcblx0XHR9ZWxzZSB7XG5cdFx0XHRidXR0b24uY2xpY2tGbiA9IGluc3RhbmNlLmFwcGVuZEludG9EaXNwbGF5LmJpbmQoaW5zdGFuY2UpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIFJlbW92ZSBkaWdpdHMgaW4gdGhlIGNhbGN1bGF0b3IgZGlzcGxheVxuXHQgKiB0byB1cGRhdGUgbGFiZWxEaXNwbGF5XG5cdCAqIGFuZCBlbWl0IHRoZSBsaXN0ZW5lciB0byB0aGUgb3RoZXJzIGNvbXBvbmVudHNcblx0ICovXG5cdGRlbGVnYXRlRGVsZXRlQnV0dG9uKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRcblx0XHRpbnN0YW5jZS5sYWJlbERpc3BsYXkgPSBpbnN0YW5jZS5yZW1vdmVMYXN0RGlnaXQ7XG5cdFx0aW5zdGFuY2Uud2FybmluZyA9IGZhbHNlO1xuXHRcdGluc3RhbmNlLmVtaXRMaXN0ZW5lcihpbnN0YW5jZS5sYWJlbERpc3BsYXkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQXBwZW5kIGRpZ2l0cyBpbiB0aGUgY2FsY3VsYXRvciBkaXNwbGF5XG5cdCAqL1xuXHRhcHBlbmRJbnRvRGlzcGxheShlKXtcblx0XHRjb25zdCB0ZXh0ID0gZS50YXJnZXQuZGF0YXNldC50ZXh0O1xuXHRcdFxuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXMsbGFiZWxEaXNwbGF5ID0gaW5zdGFuY2UubGFiZWxEaXNwbGF5LFxuXHRcdFx0XHRsYXN0RGlndE9mTGFiZWxEaXNwbGF5ID0gbGFiZWxEaXNwbGF5W2xhYmVsRGlzcGxheS5sZW5ndGgtMV07XG5cdFx0XG5cdFx0aWYoaW5zdGFuY2UuaGFzT3BlcmF0b3IodGV4dCkgJiYgaW5zdGFuY2UuaXNMYXN0RGlnaXRBbk9wZXJhdG9yKGxhc3REaWd0T2ZMYWJlbERpc3BsYXkpKXtcblx0XHRcdGxhc3REaWd0T2ZMYWJlbERpc3BsYXkgPSAnJztcblx0XHRcdGluc3RhbmNlLmxhYmVsRGlzcGxheSA9IGluc3RhbmNlLnJlbW92ZUxhc3REaWdpdDtcblx0XHR9XG5cdFx0XG5cdFx0aWYoaW5zdGFuY2UuY2hlY2tDYWxjdWxhdG9yRXhwcmVzc2lvbnModGV4dCwgbGFzdERpZ3RPZkxhYmVsRGlzcGxheSkpe1xuXHRcdFx0aW5zdGFuY2UubGFiZWxEaXNwbGF5ICs9IHRleHQ7XG5cdFx0fVxuXG5cdFx0aW5zdGFuY2Uud2FybmluZyA9IGZhbHNlO1xuXHRcdHJldHVybiBpbnN0YW5jZS5lbWl0TGlzdGVuZXIoaW5zdGFuY2UubGFiZWxEaXNwbGF5KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGlzIG5vdCBhIGRpZ2l0IG9yXG5cdCAqIGlmIGlzIGEgZGlnaXQsIGNoZWNrIGlmIHRoZSBkaWdpdFxuXHQgKiBjb21lcyBhZnRlciBhIG51bWJlciBvciBhbiBleHByZXNzaW9uXG5cdCAqL1xuXHRjaGVja0NhbGN1bGF0b3JFeHByZXNzaW9ucyh0ZXh0LCBsYXN0RGlndE9mTGFiZWxEaXNwbGF5KXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzLGxhYmVsRGlzcGxheSA9IGluc3RhbmNlLmxhYmVsRGlzcGxheTtcblxuXHRcdGlmKCghaW5zdGFuY2UuaGFzT3BlcmF0b3IodGV4dCkpIHx8XG5cdFx0XHQoIWluc3RhbmNlLmhhc0RvdWJsZVBlcmlvZChsYWJlbERpc3BsYXksIHRleHQpKSAmJlxuXHRcdFx0KCFpbnN0YW5jZS5pc0ZpcnN0RGlnaXRBbk9wZXJhdG9yKGxhYmVsRGlzcGxheSt0ZXh0KSAmJlxuXHRcdFx0XHRpbnN0YW5jZS5oYXNPcGVyYXRvcih0ZXh0KSAmJlxuXHRcdFx0XHQhaW5zdGFuY2UuaXNMYXN0RGlnaXRBbk9wZXJhdG9yKGxhc3REaWd0T2ZMYWJlbERpc3BsYXkpKSkgcmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0aGFzRG91YmxlUGVyaW9kKGNhbGN1bGF0b3JFeHByZXNzaW9uLCBpbnB1dCl7XG5cdFx0Y29uc3QgbnVtYmVycyA9IGNhbGN1bGF0b3JFeHByZXNzaW9uK2lucHV0O1xuXHRcdGNvbnN0IHJlZ2V4ID0gL14oWzAtOV0pKlxcLihbMC05XSkqXFwuLztcblx0XHRjb25zdCBsYXN0TnVtYmVyID0gbnVtYmVycy5zcGxpdCgvWytcXC1cXC8qXS8pO1xuXHRcdHJldHVybiByZWdleC50ZXN0KGxhc3ROdW1iZXJbbGFzdE51bWJlci5sZW5ndGgtMV0pO1xuXHR9XG5cdFxuXHQvKipcblx0ICogRW1pdCBldmVudCB0byB0aGUgb3RoZXJzIGNvbXBvbmVudHNcblx0ICovXG5cdGVtaXRMaXN0ZW5lcihkYXRhKXtcblx0XHRyZXR1cm4gdGhpcy5MaXN0ZW5lci5lbWl0KCdMSVNURU5fQ0FMQ1VMQVRPUl9FVkVOVCcsIGRhdGEpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBjYWxjdWxhdG9yIGRpZ2l0c1xuXHQgKi9cblx0Z2V0IHJlbW92ZUxhc3REaWdpdCgpe1xuXHRcdGxldCB0ZXh0RGlzcGxheSA9IHRoaXMubGFiZWxEaXNwbGF5O1xuXG5cdFx0cmV0dXJuIHRleHREaXNwbGF5LnN1YnN0cigwLCB0ZXh0RGlzcGxheS5sZW5ndGggLSAxKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFByb2Nlc3MgdGhlIHJlc3VsdCBvZiB0aGUgZXhwcmVzc2lvbnMgaW4gdGhlIGNhbGN1bGF0b3IgZGlzcGxheVxuXHQgKi9cblx0cmVzdWx0T2ZEaXNwbGF5RXhwcmVzc2lvbnMoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzLFxuXHRcdFx0XHR0ZXh0RGlzcGxheSA9IGluc3RhbmNlLmxhYmVsRGlzcGxheTtcblx0XHRcblx0XHRpZighdGV4dERpc3BsYXkpIHJldHVybjtcblx0XHRcblx0XHRpZihpbnN0YW5jZS5pc0xhc3REaWdpdEFuT3BlcmF0b3IodGV4dERpc3BsYXlbdGV4dERpc3BsYXkubGVuZ3RoLTFdKSl7XG5cdFx0XHR0ZXh0RGlzcGxheSA9IGluc3RhbmNlLnJlbW92ZUxhc3REaWdpdDtcblx0XHR9XG5cdFx0XG5cdFx0aWYoaW5zdGFuY2UuaGFzRGlmZmVyZW50TnVtYmVyT2ZQYXJlbnRoZXNlcyh0ZXh0RGlzcGxheSkpIHJldHVybiBpbnN0YW5jZS53YXJuaW5nID0gXCJVbm1hdGNoZWQgcGFyZW50aGVzaXNcIjtcblx0XHRcblx0XHR0cnkge1xuXHRcdFx0aW5zdGFuY2Uud2FybmluZyA9IGZhbHNlO1xuXHRcdFx0aW5zdGFuY2UubGFiZWxEaXNwbGF5ID0gTWF0aC5hYnMoZXZhbCh0ZXh0RGlzcGxheSkpLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2UuZW1pdExpc3RlbmVyKGluc3RhbmNlLmxhYmVsRGlzcGxheSk7XG5cdFx0fWNhdGNoKGUpIHtcblx0XHRcdHJldHVybiBpbnN0YW5jZS53YXJuaW5nID0gXCJQbGVhc2UgdHlwZSBhIHZhbGlkIGV4cHJlc3Npb25cIjtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBoYXMgZGlmZmVyZW50IG51bWJlciBvZiBwYXJlbnRoZXNlc1xuXHQgKiBpbiB0aGUgY2FsY3VsYXRvciBkaXNwbGF5XG5cdCAqL1xuXHRoYXNEaWZmZXJlbnROdW1iZXJPZlBhcmVudGhlc2VzKHRleHREaXNwbGF5KXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzLFxuXHRcdFx0XHRvcGVuUGFyZW50aGVzZXMgPSBpbnN0YW5jZS5jb3VudERpZ2l0T2NjdXJyZW5jZXModGV4dERpc3BsYXksICcoJyksXG5cdFx0XHRcdGNsb3NlZFBhcmVudGhlc2VzID0gaW5zdGFuY2UuY291bnREaWdpdE9jY3VycmVuY2VzKHRleHREaXNwbGF5LCAnKScpO1xuXHRcdFxuXHRcdGlmKG9wZW5QYXJlbnRoZXNlcyAhPSBjbG9zZWRQYXJlbnRoZXNlcykgcmV0dXJuIHRydWU7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDb3VudCB0aGUgbnVtYmVyIG9mIG9jY3VycmVuY2VzIG9mIGEgZGV0ZXJtaW5hdGUgZGlnaXRcblx0ICovXG5cdGNvdW50RGlnaXRPY2N1cnJlbmNlcyh0ZXh0LCBzMSl7XG5cdFx0cmV0dXJuIHRleHQuc3BsaXQoczEpLmxlbmd0aCAtIDE7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgbGFzdCBkaWdpdCBpcyBhbiBvcGVyYXRvclxuXHQgKi9cblx0aXNMYXN0RGlnaXRBbk9wZXJhdG9yKHRleHQpe1xuXHRcdGNvbnN0IHJlZ2V4ID0gL1srLVxcLyouXSQvO1xuXHRcdHJldHVybiByZWdleC50ZXN0KHRleHQpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIGZpcnN0IGRpZ2l0IGlzIGFuIG9wZXJhdG9yXG5cdCAqL1xuXHRpc0ZpcnN0RGlnaXRBbk9wZXJhdG9yKHRleHQpe1xuXHRcdGNvbnN0IHJlZ2V4ID0gL15bKy1cXC8qLl0vO1xuXHRcdHJldHVybiByZWdleC50ZXN0KHRleHQpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgaGFzIG9wZXJhdG9yIGluIHRoZSBwYXJhbVxuXHQgKi9cblx0aGFzT3BlcmF0b3IodGV4dCl7XG5cdFx0Y29uc3QgcmVnZXggPSAvWystXFwvKi5dLztcblx0XHRyZXR1cm4gcmVnZXgudGVzdCh0ZXh0KTtcblx0fVxufVxuXG5Tb3kucmVnaXN0ZXIoQ2FsY3VsYXRvciwgdGVtcGxhdGVzKTtcblxuXG4vKipcbiAqIEFsZXJ0IENvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5DYWxjdWxhdG9yLlNUQVRFID0ge1xuXHQvKipcblx0ICogQXJyYXkgb2YgbGFiZWxzIHRoYXQgYXJlIGNhbGN1bGF0b3IgYnV0dG9uc1xuXHQgKi9cblx0bGFiZWxzOiB7XG5cdFx0dmFsdWU6IGxhYmVsc1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIE1lc3NhZ2Ugb2Ygd2FybmluZyBvZiB0aGUgY2FsY3VsYXRvclxuXHQgKi9cblx0d2FybmluZzoge1xuXHRcdHZhbHVlOiAnJ1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEFycmF5IG9mIG9wZXJhdG9ycyB0aGF0IGFyZSBjYWxjdWxhdG9yIGJ1dHRvbnNcblx0ICovXG5cdG9wZXJhdG9yczoge1xuXHRcdHZhbHVlOiBvcGVyYXRvcnNcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBMYWJlbCB3aGVyZSB3aWxsIHN0YXkgdGhlIHVzZXIgbnVtZXJpYyBleHByZXNzaW9uXG5cdCAqL1xuXHRsYWJlbERpc3BsYXk6IHtcblx0XHR2YWx1ZTogJydcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBMaXN0ZW5lciBmb3IgdGhlIG90aGVycyBjb21wb25lbnRzXG5cdCAqL1xuXHRMaXN0ZW5lcjoge1xuXHRcdHZhbHVlOiBuZXcgRW1pdHRlcigpXG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhbGN1bGF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3IvQ2FsY3VsYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcbnZhciB0ZW1wbGF0ZXM7XG5nb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykge1xuXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gQ2FsY3VsYXRvci5zb3kuXG4vLyBQbGVhc2UgZG9uJ3QgZWRpdCB0aGlzIGZpbGUgYnkgaGFuZC5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRlbXBsYXRlcyBpbiBuYW1lc3BhY2UgQ2FsY3VsYXRvci5cbiAqIEBwdWJsaWNcbiAqL1xuXG5nb29nLm1vZHVsZSgnQ2FsY3VsYXRvci5pbmNyZW1lbnRhbGRvbScpO1xuXG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ID0gZ29vZy5yZXF1aXJlKCdzb3knKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3lkYXRhID0gZ29vZy5yZXF1aXJlKCdzb3lkYXRhJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuaTE4bi5iaWRpJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xudmFyIEluY3JlbWVudGFsRG9tID0gZ29vZy5yZXF1aXJlKCdpbmNyZW1lbnRhbGRvbScpO1xudmFyIGllX29wZW4gPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbjtcbnZhciBpZV9jbG9zZSA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRDbG9zZTtcbnZhciBpZV92b2lkID0gSW5jcmVtZW50YWxEb20uZWxlbWVudFZvaWQ7XG52YXIgaWVfb3Blbl9zdGFydCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuU3RhcnQ7XG52YXIgaWVfb3Blbl9lbmQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbkVuZDtcbnZhciBpdGV4dCA9IEluY3JlbWVudGFsRG9tLnRleHQ7XG52YXIgaWF0dHIgPSBJbmNyZW1lbnRhbERvbS5hdHRyO1xuXG52YXIgJHRlbXBsYXRlQWxpYXMxID0gU295LmdldFRlbXBsYXRlKCdDYWxjdWxhdG9yQnV0dG9uLmluY3JlbWVudGFsZG9tJywgJ3JlbmRlcicpO1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9kYXRhXG4gKiBAcGFyYW0geyhudWxsfHVuZGVmaW5lZCk9fSBvcHRfaWdub3JlZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9pakRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gKi9cbmZ1bmN0aW9uICRyZW5kZXIob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG4gIG9wdF9kYXRhID0gb3B0X2RhdGEgfHwge307XG4gIGllX29wZW4oJ2RpdicsIG51bGwsIG51bGwsXG4gICAgICAnY2xhc3MnLCAnY2FsY3VsYXRvcicpO1xuICAgIGllX29wZW4oJ3NlY3Rpb24nLCBudWxsLCBudWxsLFxuICAgICAgICAnY2xhc3MnLCAnY2FsY3VsYXRvci1kaXNwbGF5ICcgKyAob3B0X2RhdGEud2FybmluZyA/ICdpbnB1dC1lcnJvcicgOiAnJyksXG4gICAgICAgICdpZCcsICdjYWxjdWxhdG9yLWRpc3BsYXknKTtcbiAgICAgIGl0ZXh0KChnb29nLmFzc2VydHMuYXNzZXJ0KChvcHRfZGF0YS5sYWJlbERpc3BsYXkpICE9IG51bGwpLCBvcHRfZGF0YS5sYWJlbERpc3BsYXkpKTtcbiAgICBpZV9jbG9zZSgnc2VjdGlvbicpO1xuICAgIGllX29wZW4oJ2RpdicsIG51bGwsIG51bGwsXG4gICAgICAgICdjbGFzcycsICd3YXJuaW5nLWxhYmVsICcgKyAob3B0X2RhdGEud2FybmluZyA/ICdzaG93JyA6ICcnKSk7XG4gICAgICBpdGV4dCgoZ29vZy5hc3NlcnRzLmFzc2VydCgob3B0X2RhdGEud2FybmluZykgIT0gbnVsbCksIG9wdF9kYXRhLndhcm5pbmcpKTtcbiAgICBpZV9jbG9zZSgnZGl2Jyk7XG4gICAgaWVfb3Blbignc2VjdGlvbicsIG51bGwsIG51bGwsXG4gICAgICAgICdjbGFzcycsICdjYWxjdWxhdG9yLWJ1dHRvbnMtd3JhcHBlcicpO1xuICAgICAgaWVfb3Blbignc2VjdGlvbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgJ2NsYXNzJywgJ2NhbGN1bGF0b3ItZGlnaXRzJyk7XG4gICAgICAgIHZhciBsYWJlbExpc3QxNiA9IG9wdF9kYXRhLmxhYmVscztcbiAgICAgICAgdmFyIGxhYmVsTGlzdExlbjE2ID0gbGFiZWxMaXN0MTYubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBsYWJlbEluZGV4MTYgPSAwOyBsYWJlbEluZGV4MTYgPCBsYWJlbExpc3RMZW4xNjsgbGFiZWxJbmRleDE2KyspIHtcbiAgICAgICAgICB2YXIgbGFiZWxEYXRhMTYgPSBsYWJlbExpc3QxNltsYWJlbEluZGV4MTZdO1xuICAgICAgICAgICR0ZW1wbGF0ZUFsaWFzMSh7dGV4dDogbGFiZWxEYXRhMTYudGV4dCwgY2xpY2s6IGxhYmVsRGF0YTE2LmNsaWNrRm4sIGJ1dHRvbkNsYXNzOiBsYWJlbERhdGExNi5idXR0b25DbGFzc30sIG51bGwsIG9wdF9pakRhdGEpO1xuICAgICAgICB9XG4gICAgICBpZV9jbG9zZSgnc2VjdGlvbicpO1xuICAgICAgaWVfb3Blbignc2VjdGlvbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgJ2NsYXNzJywgJ2NhbGN1bGF0b3Itb3BlcmF0b3JzJyk7XG4gICAgICAgIHZhciBvcGVyYXRvckxpc3QyMyA9IG9wdF9kYXRhLm9wZXJhdG9ycztcbiAgICAgICAgdmFyIG9wZXJhdG9yTGlzdExlbjIzID0gb3BlcmF0b3JMaXN0MjMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBvcGVyYXRvckluZGV4MjMgPSAwOyBvcGVyYXRvckluZGV4MjMgPCBvcGVyYXRvckxpc3RMZW4yMzsgb3BlcmF0b3JJbmRleDIzKyspIHtcbiAgICAgICAgICB2YXIgb3BlcmF0b3JEYXRhMjMgPSBvcGVyYXRvckxpc3QyM1tvcGVyYXRvckluZGV4MjNdO1xuICAgICAgICAgICR0ZW1wbGF0ZUFsaWFzMSh7dGV4dDogb3BlcmF0b3JEYXRhMjMudGV4dCwgY2xpY2s6IG9wZXJhdG9yRGF0YTIzLmNsaWNrRm4sIGJ1dHRvbkNsYXNzOiBvcGVyYXRvckRhdGEyMy5idXR0b25DbGFzc30sIG51bGwsIG9wdF9pakRhdGEpO1xuICAgICAgICB9XG4gICAgICBpZV9jbG9zZSgnc2VjdGlvbicpO1xuICAgIGllX2Nsb3NlKCdzZWN0aW9uJyk7XG4gIGllX2Nsb3NlKCdkaXYnKTtcbn1cbmV4cG9ydHMucmVuZGVyID0gJHJlbmRlcjtcbmlmIChnb29nLkRFQlVHKSB7XG4gICRyZW5kZXIuc295VGVtcGxhdGVOYW1lID0gJ0NhbGN1bGF0b3IucmVuZGVyJztcbn1cblxuZXhwb3J0cy5yZW5kZXIucGFyYW1zID0gW1wibGFiZWxzXCIsXCJsYWJlbERpc3BsYXlcIixcIm9wZXJhdG9yc1wiLFwid2FybmluZ1wiXTtcbmV4cG9ydHMucmVuZGVyLnR5cGVzID0ge1wibGFiZWxzXCI6XCJhbnlcIixcImxhYmVsRGlzcGxheVwiOlwiYW55XCIsXCJvcGVyYXRvcnNcIjpcImFueVwiLFwid2FybmluZ1wiOlwiYW55XCJ9O1xudGVtcGxhdGVzID0gZXhwb3J0cztcbnJldHVybiBleHBvcnRzO1xuXG59KTtcblxuY2xhc3MgQ2FsY3VsYXRvciBleHRlbmRzIENvbXBvbmVudCB7fVxuU295LnJlZ2lzdGVyKENhbGN1bGF0b3IsIHRlbXBsYXRlcyk7XG5leHBvcnQgeyBDYWxjdWxhdG9yLCB0ZW1wbGF0ZXMgfTtcbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlcztcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3IvQ2FsY3VsYXRvci5zb3kuanNcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgbGFiZWxzID0gW1xuXHR7dGV4dDogJzwnLCBpc0NsZWFyQnV0dG9uOiB0cnVlfSxcblx0e3RleHQ6ICcoJ30sXG5cdHt0ZXh0OiAnKSd9LFxuXHR7dGV4dDogJzEnfSxcblx0e3RleHQ6ICcyJ30sXG5cdHt0ZXh0OiAnMyd9LFxuXHR7dGV4dDogJzQnfSxcblx0e3RleHQ6ICc1J30sXG5cdHt0ZXh0OiAnNid9LFxuXHR7dGV4dDogJzcnfSxcblx0e3RleHQ6ICc4J30sXG5cdHt0ZXh0OiAnOSd9LFxuXHR7dGV4dDogJzAnLCBidXR0b25DbGFzczogJ2NhbGN1bGF0b3ItYnV0dG9uLS1kb3VibGUtc2l6ZSd9LFxuXHR7dGV4dDogJy4nfVxuXTtcblxuZXhwb3J0IGNvbnN0IG9wZXJhdG9ycyA9IFtcblx0e3RleHQ6ICcrJ30sXG5cdHt0ZXh0OiAnLSd9LFxuXHR7dGV4dDogJyonfSxcblx0e3RleHQ6ICcvJ30sXG5cdHt0ZXh0OiAnPScsIGlzUmVzdWx0QnV0dG9tOiB0cnVlfVxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2FsY3VsYXRvci9DYWxjdWxhdG9yVXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0ZW1wbGF0ZXMgZnJvbSAnLi9DYWxjdWxhdG9yQnV0dG9uLnNveS5qcyc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG5cbmNsYXNzIENhbGN1bGF0b3JCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge1xufVxuXG5Tb3kucmVnaXN0ZXIoQ2FsY3VsYXRvckJ1dHRvbiwgdGVtcGxhdGVzKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yQnV0dG9uIFN0YXRlIERlZmluaXRpb25cbiAqL1xuQ2FsY3VsYXRvckJ1dHRvbi5TVEFURSA9IHtcblx0LyoqXG5cdCAqIFRleHQgcHJlc2VudCBpbiBidXR0b25cblx0ICovXG5cdHRleHQ6IHtcblx0XHR2YWx1ZTogJydcblx0fSxcblx0LyoqXG5cdCAqIFRoZSBhY3Rpb24gdGhhdCB0aGUgYnV0dG9uIHdpbGwgZG9cblx0ICovXG5cdGNsaWNrOiB7XG5cdFx0dmFsdWU6IGZhbHNlXG5cdH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhbGN1bGF0b3JCdXR0b247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3JCdXR0b24vQ2FsY3VsYXRvckJ1dHRvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcbnZhciB0ZW1wbGF0ZXM7XG5nb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykge1xuXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gQ2FsY3VsYXRvckJ1dHRvbi5zb3kuXG4vLyBQbGVhc2UgZG9uJ3QgZWRpdCB0aGlzIGZpbGUgYnkgaGFuZC5cblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFRlbXBsYXRlcyBpbiBuYW1lc3BhY2UgQ2FsY3VsYXRvckJ1dHRvbi5cbiAqIEBwdWJsaWNcbiAqL1xuXG5nb29nLm1vZHVsZSgnQ2FsY3VsYXRvckJ1dHRvbi5pbmNyZW1lbnRhbGRvbScpO1xuXG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ID0gZ29vZy5yZXF1aXJlKCdzb3knKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3lkYXRhID0gZ29vZy5yZXF1aXJlKCdzb3lkYXRhJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuaTE4bi5iaWRpJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xudmFyIEluY3JlbWVudGFsRG9tID0gZ29vZy5yZXF1aXJlKCdpbmNyZW1lbnRhbGRvbScpO1xudmFyIGllX29wZW4gPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbjtcbnZhciBpZV9jbG9zZSA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRDbG9zZTtcbnZhciBpZV92b2lkID0gSW5jcmVtZW50YWxEb20uZWxlbWVudFZvaWQ7XG52YXIgaWVfb3Blbl9zdGFydCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuU3RhcnQ7XG52YXIgaWVfb3Blbl9lbmQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbkVuZDtcbnZhciBpdGV4dCA9IEluY3JlbWVudGFsRG9tLnRleHQ7XG52YXIgaWF0dHIgPSBJbmNyZW1lbnRhbERvbS5hdHRyO1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9kYXRhXG4gKiBAcGFyYW0geyhudWxsfHVuZGVmaW5lZCk9fSBvcHRfaWdub3JlZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9pakRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gKi9cbmZ1bmN0aW9uICRyZW5kZXIob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG4gIGllX29wZW4oJ2J1dHRvbicsIG51bGwsIG51bGwsXG4gICAgICAnZGF0YS10ZXh0Jywgb3B0X2RhdGEudGV4dCxcbiAgICAgICdjbGFzcycsICdcXHQnICsgKG9wdF9kYXRhLmJ1dHRvbkNsYXNzID8gb3B0X2RhdGEuYnV0dG9uQ2xhc3MgOiAnY2FsY3VsYXRvci1idXR0b24nKSxcbiAgICAgICdkYXRhLW9uQ2xpY2snLCBvcHRfZGF0YS5jbGljayk7XG4gICAgaXRleHQoKGdvb2cuYXNzZXJ0cy5hc3NlcnQoKG9wdF9kYXRhLnRleHQpICE9IG51bGwpLCBvcHRfZGF0YS50ZXh0KSk7XG4gIGllX2Nsb3NlKCdidXR0b24nKTtcbn1cbmV4cG9ydHMucmVuZGVyID0gJHJlbmRlcjtcbmlmIChnb29nLkRFQlVHKSB7XG4gICRyZW5kZXIuc295VGVtcGxhdGVOYW1lID0gJ0NhbGN1bGF0b3JCdXR0b24ucmVuZGVyJztcbn1cblxuZXhwb3J0cy5yZW5kZXIucGFyYW1zID0gW1wiYnV0dG9uQ2xhc3NcIixcInRleHRcIixcImNsaWNrXCJdO1xuZXhwb3J0cy5yZW5kZXIudHlwZXMgPSB7XCJidXR0b25DbGFzc1wiOlwiYW55XCIsXCJ0ZXh0XCI6XCJhbnlcIixcImNsaWNrXCI6XCJhbnlcIn07XG50ZW1wbGF0ZXMgPSBleHBvcnRzO1xucmV0dXJuIGV4cG9ydHM7XG5cbn0pO1xuXG5jbGFzcyBDYWxjdWxhdG9yQnV0dG9uIGV4dGVuZHMgQ29tcG9uZW50IHt9XG5Tb3kucmVnaXN0ZXIoQ2FsY3VsYXRvckJ1dHRvbiwgdGVtcGxhdGVzKTtcbmV4cG9ydCB7IENhbGN1bGF0b3JCdXR0b24sIHRlbXBsYXRlcyB9O1xuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVzO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2FsY3VsYXRvckJ1dHRvbi9DYWxjdWxhdG9yQnV0dG9uLnNveS5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=