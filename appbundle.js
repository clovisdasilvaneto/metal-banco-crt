/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 38);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ComponentRenderer = exports.ComponentRegistry = exports.ComponentDataManager = exports.Component = undefined;

var _events = __webpack_require__(17);

Object.keys(_events).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _events[key];
    }
  });
});

var _Component = __webpack_require__(53);

var _Component2 = _interopRequireDefault(_Component);

var _ComponentDataManager = __webpack_require__(24);

var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);

var _ComponentRegistry = __webpack_require__(84);

var _ComponentRegistry2 = _interopRequireDefault(_ComponentRegistry);

var _ComponentRenderer = __webpack_require__(28);

var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Component2.default;
exports.Component = _Component2.default;
exports.ComponentDataManager = _ComponentDataManager2.default;
exports.ComponentRegistry = _ComponentRegistry2.default;
exports.ComponentRenderer = _ComponentRenderer2.default;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.validators = exports.SoyAop = exports.Soy = exports.Config = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

__webpack_require__(85);

var _metalComponent = __webpack_require__(0);

var _metal = __webpack_require__(97);

var _metalState = __webpack_require__(25);

var _html2incdom = __webpack_require__(104);

var _html2incdom2 = _interopRequireDefault(_html2incdom);

var _metalIncrementalDom = __webpack_require__(29);

var _metalIncrementalDom2 = _interopRequireDefault(_metalIncrementalDom);

var _SoyAop = __webpack_require__(108);

var _SoyAop2 = _interopRequireDefault(_SoyAop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// The injected data that will be passed to soy templates.
var ijData = {};

var Soy = function (_IncrementalDomRender) {
	_inherits(Soy, _IncrementalDomRender);

	function Soy() {
		_classCallCheck(this, Soy);

		return _possibleConstructorReturn(this, (Soy.__proto__ || Object.getPrototypeOf(Soy)).apply(this, arguments));
	}

	_createClass(Soy, [{
		key: 'getExtraDataConfig',

		/**
   * Adds the template params to the component's state, if they don't exist yet.
   * @param {!Component} component
   * @return {Object}
   */
		value: function getExtraDataConfig(component) {
			var elementTemplate = component.constructor.TEMPLATE;
			if (!(0, _metal.isFunction)(elementTemplate)) {
				return;
			}

			elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
			this.soyParamTypes_ = elementTemplate.types || {};

			var keys = elementTemplate.params || [];
			var configs = {};
			for (var i = 0; i < keys.length; i++) {
				if (!component[keys[i]]) {
					configs[keys[i]] = {};
				}
			}
			return configs;
		}

		/**
   * Copies the component's state to an object so it can be passed as it's
   * template call's data. The copying needs to be done because, if the component
   * itself is passed directly, some problems occur when soy tries to merge it
   * with other data, due to property getters and setters. This is safer.
   * Also calls the component's "prepareStateForRender" to let it change the
   * data passed to the template.
   * @param {!Component} component
   * @param {!Array<string>} params The params used by this template.
   * @return {!Object}
   * @protected
   */

	}, {
		key: 'buildTemplateData_',
		value: function buildTemplateData_(component, params) {
			var _this2 = this;

			var data = _metal.object.mixin({}, this.getConfig(component));
			component.getStateKeys().forEach(function (key) {
				var value = component[key];
				if (_this2.isHtmlParam_(component, key)) {
					value = soyRenderer_.toIncDom(value);
				}
				data[key] = value;
			});

			for (var i = 0; i < params.length; i++) {
				if (!data[params[i]] && (0, _metal.isFunction)(component[params[i]])) {
					data[params[i]] = component[params[i]].bind(component);
				}
			}

			if ((0, _metal.isFunction)(component.prepareStateForRender)) {
				return component.prepareStateForRender(data) || data;
			} else {
				return data;
			}
		}

		/**
   * Returns the requested template function. This function will be wrapped in
   * another though, just to defer the requirement of the template's module
   * being ready until the function is actually called.
   * @param {string} namespace The soy template's namespace.
   * @param {string} templateName The name of the template function.
   * @return {!function()}
   */

	}, {
		key: 'getTemplate',
		value: function getTemplate(namespace, templateName) {
			return function (opt_data, opt_ignored, opt_ijData) {
				if (!goog.loadedModules_[namespace]) {
					throw new Error('No template with namespace "' + namespace + '" has been loaded yet.');
				}
				return goog.loadedModules_[namespace][templateName](opt_data, opt_ignored, opt_ijData);
			};
		}

		/**
   * Handles an intercepted soy template call. If the call is for a component's
   * main template, then it will be replaced with a call that incremental dom
   * can use for both handling an instance of that component and rendering it.
   * @param {!function()} originalFn The original template function that was
   *     intercepted.
   * @param {Object} data The data the template was called with.
   * @protected
   */

	}, {
		key: 'handleInterceptedCall_',
		value: function handleInterceptedCall_(originalFn) {
			var opt_data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			var args = [originalFn.componentCtor, null, []];
			for (var key in opt_data) {
				args.push(key, opt_data[key]);
			}
			IncrementalDOM.elementVoid.apply(null, args);
		}

		/**
   * Checks if the given param type is html.
   * @param {!Component} component
   * @param {string} name
   * @protected
   */

	}, {
		key: 'isHtmlParam_',
		value: function isHtmlParam_(component, name) {
			var state = component.getDataManager().getStateInstance(component);
			if (state.getStateKeyConfig(name).isHtml) {
				return true;
			}

			var elementTemplate = _SoyAop2.default.getOriginalFn(component.constructor.TEMPLATE);
			var type = (elementTemplate.types || {})[name] || '';
			return type.split('|').indexOf('html') !== -1;
		}

		/**
   * Registers the given templates to be used by `Soy` for the specified
   * component constructor.
   * @param {!Function} componentCtor The constructor of the component that
   *     should use the given templates.
   * @param {!Object} templates Object containing soy template functions.
   * @param {string=} mainTemplate The name of the main template that should be
   *     used to render the component. Defaults to "render".
   */

	}, {
		key: 'register',
		value: function register(componentCtor, templates) {
			var mainTemplate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'render';

			componentCtor.RENDERER = soyRenderer_;
			componentCtor.TEMPLATE = _SoyAop2.default.getOriginalFn(templates[mainTemplate]);
			componentCtor.TEMPLATE.componentCtor = componentCtor;
			_SoyAop2.default.registerForInterception(templates, mainTemplate);
			_metalComponent.ComponentRegistry.register(componentCtor);
		}

		/**
   * Overrides the default method from `IncrementalDomRenderer` so the component's
   * soy template can be used for rendering.
   * @param {!Component} component
   * @param {!Object} data Data passed to the component when rendering it.
   * @override
   */

	}, {
		key: 'renderIncDom',
		value: function renderIncDom(component) {
			var elementTemplate = component.constructor.TEMPLATE;
			if ((0, _metal.isFunction)(elementTemplate) && !component.render) {
				elementTemplate = _SoyAop2.default.getOriginalFn(elementTemplate);
				_SoyAop2.default.startInterception(this.handleInterceptedCall_);
				var data = this.buildTemplateData_(component, elementTemplate.params || []);
				elementTemplate(data, null, ijData);
				_SoyAop2.default.stopInterception();
			} else {
				_get(Soy.prototype.__proto__ || Object.getPrototypeOf(Soy.prototype), 'renderIncDom', this).call(this, component);
			}
		}

		/**
   * Sets the injected data object that should be passed to templates.
   * @param {Object} data
   */

	}, {
		key: 'setInjectedData',
		value: function setInjectedData(data) {
			ijData = data || {};
		}

		/**
   * Overrides the original `IncrementalDomRenderer` method so that only
   * state keys used by the main template can cause updates.
   * @param {!Component} component
   * @param {Object} changes
   * @return {boolean}
   */

	}, {
		key: 'shouldUpdate',
		value: function shouldUpdate(component, changes) {
			var should = _get(Soy.prototype.__proto__ || Object.getPrototypeOf(Soy.prototype), 'shouldUpdate', this).call(this, component, changes);
			if (!should || component.shouldUpdate) {
				return should;
			}

			var fn = component.constructor.TEMPLATE;
			var params = fn ? _SoyAop2.default.getOriginalFn(fn).params : [];
			for (var i = 0; i < params.length; i++) {
				if (changes.props[params[i]]) {
					return true;
				}
			}
			return false;
		}

		/**
   * Converts the given incremental dom function into an html string.
   * @param {!function()} incDomFn
   * @return {string}
   */

	}, {
		key: 'toHtmlString',
		value: function toHtmlString(incDomFn) {
			var element = document.createElement('div');
			IncrementalDOM.patch(element, incDomFn);
			return element.innerHTML;
		}

		/**
   * Converts the given html string into an incremental dom function.
   * @param {string|{contentKind: string, content: string}} value
   * @return {!function()}
   */

	}, {
		key: 'toIncDom',
		value: function toIncDom(value) {
			if ((0, _metal.isObject)(value) && (0, _metal.isString)(value.content) && value.contentKind === 'HTML') {
				value = value.content;
			}
			if ((0, _metal.isString)(value)) {
				value = _html2incdom2.default.buildFn(value);
			}
			return value;
		}
	}]);

	return Soy;
}(_metalIncrementalDom2.default.constructor);

var soyRenderer_ = new Soy();
soyRenderer_.RENDERER_NAME = 'soy';

exports.default = soyRenderer_;
exports.Config = _metalState.Config;
exports.Soy = soyRenderer_;
exports.SoyAop = _SoyAop2.default;
exports.validators = _metalState.validators;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(49);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dom = undefined;

var _domNamed = __webpack_require__(55);

Object.keys(_domNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _domNamed[key];
    }
  });
});

var dom = _interopRequireWildcard(_domNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = dom;
exports.dom = dom;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(18);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(47);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(48);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(50);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(51);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(52);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.globalEvalStyles = exports.globalEval = exports.features = exports.DomEventHandle = exports.DomEventEmitterProxy = exports.domData = undefined;

var _dom = __webpack_require__(4);

Object.keys(_dom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _dom[key];
    }
  });
});

var _dom2 = _interopRequireDefault(_dom);

var _domData = __webpack_require__(13);

var _domData2 = _interopRequireDefault(_domData);

var _DomEventEmitterProxy = __webpack_require__(72);

var _DomEventEmitterProxy2 = _interopRequireDefault(_DomEventEmitterProxy);

var _DomEventHandle = __webpack_require__(22);

var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

var _features = __webpack_require__(23);

var _features2 = _interopRequireDefault(_features);

var _globalEval = __webpack_require__(73);

var _globalEval2 = _interopRequireDefault(_globalEval);

var _globalEvalStyles = __webpack_require__(74);

var _globalEvalStyles2 = _interopRequireDefault(_globalEvalStyles);

__webpack_require__(75);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.domData = _domData2.default;
exports.DomEventEmitterProxy = _DomEventEmitterProxy2.default;
exports.DomEventHandle = _DomEventHandle2.default;
exports.features = _features2.default;
exports.globalEval = _globalEval2.default;
exports.globalEvalStyles = _globalEvalStyles2.default;
exports.default = _dom2.default;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(19);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(57);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(58);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(59);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(60);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(61);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventHandler = exports.EventHandle = exports.EventEmitterProxy = exports.EventEmitter = undefined;

var _EventEmitter = __webpack_require__(63);

var _EventEmitter2 = _interopRequireDefault(_EventEmitter);

var _EventEmitterProxy = __webpack_require__(70);

var _EventEmitterProxy2 = _interopRequireDefault(_EventEmitterProxy);

var _EventHandle = __webpack_require__(21);

var _EventHandle2 = _interopRequireDefault(_EventHandle);

var _EventHandler = __webpack_require__(71);

var _EventHandler2 = _interopRequireDefault(_EventHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _EventEmitter2.default;
exports.EventEmitter = _EventEmitter2.default;
exports.EventEmitterProxy = _EventEmitterProxy2.default;
exports.EventHandle = _EventHandle2.default;
exports.EventHandler = _EventHandler2.default;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearData = clearData;
exports.getData = getData;
var RENDERER_DATA = '__METAL_IC_RENDERER_DATA__';

/**
 * Removes the incremental dom renderer data object for this component.
 * @param {!Component} component
 */
function clearData(component) {
  component[RENDERER_DATA] = null;
}

/**
 * Gets the incremental dom renderer data object for this component, creating
 * it if it doesn't exist yet.
 * @param {!Component} component
 * @return {!Object}
 */
function getData(component) {
  if (!component[RENDERER_DATA]) {
    component[RENDERER_DATA] = {};
  }
  return component[RENDERER_DATA];
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(20);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(65);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(66);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(67);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(68);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(69);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(31);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(89);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(90);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(91);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(92);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(93);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var METAL_DATA = '__metal_data__';

var domData = function () {
	function domData() {
		_classCallCheck(this, domData);
	}

	_createClass(domData, null, [{
		key: 'get',

		/**
   * Gets Metal.js's data for the given element.
   * @param {!Element} element
   * @param {string=} opt_name Optional property from the data to be returned.
   * @param {*} opt_initialVal Optinal value to the set the requested property
   *     to if it doesn't exist yet in the data.
   * @return {!Object}
   */
		value: function get(element, opt_name, opt_initialVal) {
			if (!element[METAL_DATA]) {
				element[METAL_DATA] = {};
			}
			if (!opt_name) {
				return element[METAL_DATA];
			}
			if (!element[METAL_DATA][opt_name] && opt_initialVal) {
				element[METAL_DATA][opt_name] = opt_initialVal;
			}
			return element[METAL_DATA][opt_name];
		}

		/**
   * Checks if the given element has data stored in it.
   * @param {!Element} element
   * @return {boolean}
   */

	}, {
		key: 'has',
		value: function has(element) {
			return !!element[METAL_DATA];
		}
	}]);

	return domData;
}();

exports.default = domData;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(27);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(77);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(78);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(79);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(80);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(81);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getOriginalFns = getOriginalFns;
exports.getOriginalFn = getOriginalFn;
exports.startInterception = startInterception;
exports.stopInterception = stopInterception;

__webpack_require__(30);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Gets the original incremental dom functions.
 * @return {!Object}
 */
function getOriginalFns() {
	return originalFns;
}

/**
 * Gets the original incremental dom function with the given name.
 * @param {string} name
 * @return {!Object}
 */
function getOriginalFn(name) {
	return originalFns[name];
}

/**
 * Starts intercepting calls to incremental dom, replacing them with the given
 * functions. Note that `elementVoid`, `elementOpenStart`, `elementOpenEnd`
 * and `attr` are the only ones that can't be intercepted, since they'll
 * automatically be converted into equivalent calls to `elementOpen` and
 * `elementClose`.
 * @param {!Object} fns Functions to be called instead of the original ones
 *     from incremental DOM. Should be given as a map from the function name
 *     to the function that should intercept it. All interceptors will receive
 *     the original function as the first argument, the actual arguments from
 *     from the original call following it.
 */
function startInterception(fns) {
	fns.attr = fnAttr;
	fns.elementOpenEnd = fnOpenEnd;
	fns.elementOpenStart = fnOpenStart;
	fns.elementVoid = fnVoid;
	fnStack.push(fns);
}

/**
 * Restores the original `elementOpen` function from incremental dom to the
 * implementation it used before the last call to `startInterception`.
 */
function stopInterception() {
	fnStack.pop();
}

var originalFns = {
	attr: IncrementalDOM.attr,
	attributes: IncrementalDOM.attributes[IncrementalDOM.symbols.default],
	elementClose: IncrementalDOM.elementClose,
	elementOpen: IncrementalDOM.elementOpen,
	elementOpenEnd: IncrementalDOM.elementOpenEnd,
	elementOpenStart: IncrementalDOM.elementOpenStart,
	elementVoid: IncrementalDOM.elementVoid,
	text: IncrementalDOM.text
};

var fnStack = [];

var collectedArgs = [];

function fnAttr(name, value) {
	collectedArgs.push(name, value);
}

function fnOpenStart(tag, key, statics) {
	collectedArgs = [tag, key, statics];
}

function fnOpenEnd() {
	var _IncrementalDOM;

	return (_IncrementalDOM = IncrementalDOM).elementOpen.apply(_IncrementalDOM, _toConsumableArray(collectedArgs));
}

function fnVoid() {
	IncrementalDOM.elementOpen.apply(null, arguments);
	return IncrementalDOM.elementClose.apply(null, arguments);
}

function getStack() {
	return fnStack.length > 0 ? fnStack[fnStack.length - 1] : null;
}

function buildHandleCall(name) {
	var data = {
		name: name
	};
	var fn = handleCall.bind(data);
	return fn;
}

function handleCall() {
	var name = this.name; // eslint-disable-line
	var stack = getStack();
	var fn = stack && stack[name] || originalFns[name];
	return fn.apply(null, arguments);
}

IncrementalDOM.attr = buildHandleCall('attr');
IncrementalDOM.elementClose = buildHandleCall('elementClose');
IncrementalDOM.elementOpen = buildHandleCall('elementOpen');
IncrementalDOM.elementOpenEnd = buildHandleCall('elementOpenEnd');
IncrementalDOM.elementOpenStart = buildHandleCall('elementOpenStart');
IncrementalDOM.elementVoid = buildHandleCall('elementVoid');
IncrementalDOM.text = buildHandleCall('text');

IncrementalDOM.attributes[IncrementalDOM.symbols.default] = buildHandleCall('attributes');

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_events___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_events__);

class EventEmitter extends __WEBPACK_IMPORTED_MODULE_0_events___default.a{
	constructor(){
		super();
	}
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EventEmitter;



/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.addListenersFromObj = addListenersFromObj;
exports.getComponentFn = getComponentFn;

var _metal = __webpack_require__(5);

/**
 * Adds the listeners specified in the given object.
 * @param {!Component} component
 * @param {Object} events
 * @return {!Array<!EventHandle>} Handles from all subscribed events.
 */
function addListenersFromObj(component, events) {
	var eventNames = Object.keys(events || {});
	var handles = [];
	for (var i = 0; i < eventNames.length; i++) {
		var info = extractListenerInfo_(component, events[eventNames[i]]);
		if (info.fn) {
			var handle = void 0;
			if (info.selector) {
				handle = component.delegate(eventNames[i], info.selector, info.fn);
			} else {
				handle = component.on(eventNames[i], info.fn);
			}
			handles.push(handle);
		}
	}
	return handles;
}

/**
 * Extracts listener info from the given value.
 * @param {!Component} component
 * @param {!Component} component
 * @param {function()|string|{selector:string,fn:function()|string}} value
 * @return {!{selector:string,fn:function()}}
 * @protected
 */
function extractListenerInfo_(component, value) {
	var info = {
		fn: value
	};
	if ((0, _metal.isObject)(value) && !(0, _metal.isFunction)(value)) {
		info.selector = value.selector;
		info.fn = value.fn;
	}
	if ((0, _metal.isString)(info.fn)) {
		info.fn = getComponentFn(component, info.fn);
	}
	return info;
}

/**
 * Gets the listener function from its name. Throws an error if none exist.
 * @param {!Component} component
 * @param {string} fnName
 * @return {function()}
 */
function getComponentFn(component, fnName) {
	if ((0, _metal.isFunction)(component[fnName])) {
		return component[fnName].bind(component);
	} else {
		console.error('No function named ' + fnName + ' was found in the component\n\t\t\t"' + (0, _metal.getFunctionName)(component.constructor) + '". Make sure that you specify\n\t\t\tvalid function names when adding inline listeners');
	}
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(46);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(56);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(64);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventHandle utility. Holds information about an event subscription, and
 * allows removing them easily.
 * EventHandle is a Disposable, but it's important to note that the
 * EventEmitter that created it is not the one responsible for disposing it.
 * That responsibility is for the code that holds a reference to it.
 * @param {!EventEmitter} emitter Emitter the event was subscribed to.
 * @param {string} event The name of the event that was subscribed to.
 * @param {!Function} listener The listener subscribed to the event.
 * @constructor
 * @extends {Disposable}
 */
var EventHandle = function (_Disposable) {
	_inherits(EventHandle, _Disposable);

	function EventHandle(emitter, event, listener) {
		_classCallCheck(this, EventHandle);

		/**
   * The EventEmitter instance that the event was subscribed to.
   * @type {EventEmitter}
   * @protected
   */
		var _this = _possibleConstructorReturn(this, (EventHandle.__proto__ || Object.getPrototypeOf(EventHandle)).call(this));

		_this.emitter_ = emitter;

		/**
   * The name of the event that was subscribed to.
   * @type {string}
   * @protected
   */
		_this.event_ = event;

		/**
   * The listener subscribed to the event.
   * @type {Function}
   * @protected
   */
		_this.listener_ = listener;
		return _this;
	}

	/**
  * Disposes of this instance's object references.
  * @override
  */


	_createClass(EventHandle, [{
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.removeListener();
			this.emitter_ = null;
			this.listener_ = null;
		}

		/**
   * Removes the listener subscription from the emitter.
   */

	}, {
		key: 'removeListener',
		value: function removeListener() {
			if (!this.emitter_.isDisposed()) {
				this.emitter_.removeListener(this.event_, this.listener_);
			}
		}
	}]);

	return EventHandle;
}(_metal.Disposable);

exports.default = EventHandle;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metalEvents = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is a special EventHandle, that is responsible for dom events, instead
 * of EventEmitter events.
 * @extends {EventHandle}
 */
var DomEventHandle = function (_EventHandle) {
	_inherits(DomEventHandle, _EventHandle);

	/**
  * The constructor for `DomEventHandle`.
  * @param {!EventEmitter} emitter Emitter the event was subscribed to.
  * @param {string} event The name of the event that was subscribed to.
  * @param {!Function} listener The listener subscribed to the event.
  * @param {boolean} opt_capture Flag indicating if listener should be triggered
  *   during capture phase, instead of during the bubbling phase. Defaults to false.
  * @constructor
  */
	function DomEventHandle(emitter, event, listener, opt_capture) {
		_classCallCheck(this, DomEventHandle);

		var _this = _possibleConstructorReturn(this, (DomEventHandle.__proto__ || Object.getPrototypeOf(DomEventHandle)).call(this, emitter, event, listener));

		_this.capture_ = opt_capture;
		return _this;
	}

	/**
  * @inheritDoc
  */


	_createClass(DomEventHandle, [{
		key: 'removeListener',
		value: function removeListener() {
			this.emitter_.removeEventListener(this.event_, this.listener_, this.capture_);
		}
	}]);

	return DomEventHandle;
}(_metalEvents.EventHandle);

exports.default = DomEventHandle;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dom = __webpack_require__(4);

var _metal = __webpack_require__(7);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Class with static methods responsible for doing browser feature checks.
 */
var features = function () {
	function features() {
		_classCallCheck(this, features);
	}

	_createClass(features, null, [{
		key: 'checkAnimationEventName',

		/**
   * Some browsers still supports prefixed animation events. This method can
   * be used to retrieve the current browser event name for both, animation
   * and transition.
   * @return {object}
   */
		value: function checkAnimationEventName() {
			if (features.animationEventName_ === undefined) {
				features.animationEventName_ = {
					animation: features.checkAnimationEventName_('animation'),
					transition: features.checkAnimationEventName_('transition')
				};
			}
			return features.animationEventName_;
		}

		/**
   * @protected
   * @param {string} type Type to test: animation, transition.
   * @return {string} Browser event name.
   */

	}, {
		key: 'checkAnimationEventName_',
		value: function checkAnimationEventName_(type) {
			var prefixes = ['Webkit', 'MS', 'O', ''];
			var typeTitleCase = _metal.string.replaceInterval(type, 0, 1, type.substring(0, 1).toUpperCase());
			var suffixes = [typeTitleCase + 'End', typeTitleCase + 'End', typeTitleCase + 'End', type + 'end'];
			for (var i = 0; i < prefixes.length; i++) {
				if (features.animationElement_.style[prefixes[i] + typeTitleCase] !== undefined) {
					return prefixes[i].toLowerCase() + suffixes[i];
				}
			}
			return type + 'end';
		}

		/**
   * Some browsers (like IE9) change the order of element attributes, when html
   * is rendered. This method can be used to check if this behavior happens on
   * the current browser.
   * @return {boolean}
   */

	}, {
		key: 'checkAttrOrderChange',
		value: function checkAttrOrderChange() {
			if (features.attrOrderChange_ === undefined) {
				var originalContent = '<div data-component="" data-ref=""></div>';
				var element = document.createElement('div');
				(0, _dom.append)(element, originalContent);
				features.attrOrderChange_ = originalContent !== element.innerHTML;
			}
			return features.attrOrderChange_;
		}
	}]);

	return features;
}();

features.animationElement_ = document.createElement('div');
features.animationEventName_ = undefined;
features.attrOrderChange_ = undefined;

exports.default = features;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(5);

var _metalState = __webpack_require__(25);

var _metalState2 = _interopRequireDefault(_metalState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BLACKLIST = {
	components: true,
	context: true,
	element: true,
	refs: true,
	state: true,
	stateKey: true,
	wasRendered: true
};
var DATA_MANAGER_DATA = '__DATA_MANAGER_DATA__';

var ComponentDataManager = function () {
	function ComponentDataManager() {
		_classCallCheck(this, ComponentDataManager);
	}

	_createClass(ComponentDataManager, [{
		key: 'createState_',

		/**
   * Creates the `State` instance that will handle the main component data.
   * @param {!Component} component
   * @param {!Object} data
   * @protected
   */
		value: function createState_(component, data) {
			var state = new _metalState2.default(component.getInitialConfig(), component, component);
			state.setKeysBlacklist(BLACKLIST);
			state.configState(_metal.object.mixin({}, data, _metalState2.default.getStateStatic(component.constructor)));
			this.getManagerData(component).state_ = state;
		}

		/**
   * Disposes of any data being used by the manager in this component.
   * @param {!Component} component
   */

	}, {
		key: 'dispose',
		value: function dispose(component) {
			var data = this.getManagerData(component);
			if (data.state_) {
				data.state_.dispose();
			}
			component[DATA_MANAGER_DATA] = null;
		}

		/**
   * Gets the data with the given name.
   * @param {!Component} component
   * @param {string} name
   * @return {*}
   */

	}, {
		key: 'get',
		value: function get(component, name) {
			return this.getManagerData(component).state_.get(name);
		}

		/**
   * Gets the manager data for the given component.
   * @param {!Component} component
   * @return {Object}
   */

	}, {
		key: 'getManagerData',
		value: function getManagerData(component) {
			return component[DATA_MANAGER_DATA];
		}

		/**
   * Gets the keys for state data that can be synced via `sync` functions.
   * @param {!Component} component
   * @return {!Array<string>}
   */

	}, {
		key: 'getSyncKeys',
		value: function getSyncKeys(component) {
			return this.getManagerData(component).state_.getStateKeys();
		}

		/**
   * Gets the keys for state data.
   * @param {!Component} component
   * @return {!Array<string>}
   */

	}, {
		key: 'getStateKeys',
		value: function getStateKeys(component) {
			return this.getManagerData(component).state_.getStateKeys();
		}

		/**
   * Gets the whole state data.
   * @param {!Component} component
   * @return {!Object}
   */

	}, {
		key: 'getState',
		value: function getState(component) {
			return this.getManagerData(component).state_.getState();
		}

		/**
   * Gets the `State` instance being used.
   * @param {!Component} component
   * @return {!Object}
   */

	}, {
		key: 'getStateInstance',
		value: function getStateInstance(component) {
			return this.getManagerData(component).state_;
		}

		/**
   * Updates all non internal data with the given values (or to the default
   * value if none is given).
   * @param {!Component} component
   * @param {!Object} data
   * @param {State=} opt_state
   */

	}, {
		key: 'replaceNonInternal',
		value: function replaceNonInternal(component, data, opt_state) {
			var state = opt_state || this.getManagerData(component).state_;
			var keys = state.getStateKeys();
			for (var i = 0; i < keys.length; i++) {
				var key = keys[i];
				if (!state.getStateKeyConfig(key).internal) {
					if (data.hasOwnProperty(key)) {
						state.set(key, data[key]);
					} else {
						state.setDefaultValue(key);
					}
				}
			}
		}

		/**
   * Sets the value of all the specified state keys.
   * @param {!Component} component
   * @param {!Object.<string,*>} values A map of state keys to the values they
   *   should be set to.
   * @param {function()=} opt_callback An optional function that will be run
   *   after the next batched update is triggered.
   */

	}, {
		key: 'setState',
		value: function setState(component, state, opt_callback) {
			this.getManagerData(component).state_.setState(state, opt_callback);
		}

		/**
   * Sets up the specified component's data.
   * @param {!Component} component
   * @param {!Object} data
   */

	}, {
		key: 'setUp',
		value: function setUp(component, data) {
			component[DATA_MANAGER_DATA] = {};
			this.createState_(component, data);
		}
	}]);

	return ComponentDataManager;
}();

exports.default = new ComponentDataManager();

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.State = exports.Config = exports.validators = undefined;

var _validators = __webpack_require__(26);

var _validators2 = _interopRequireDefault(_validators);

var _Config = __webpack_require__(82);

var _Config2 = _interopRequireDefault(_Config);

var _State = __webpack_require__(83);

var _State2 = _interopRequireDefault(_State);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _State2.default;
exports.validators = _validators2.default;
exports.Config = _Config2.default;
exports.State = _State2.default;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _metal = __webpack_require__(14);

var ERROR_ARRAY_OF_TYPE = 'Expected an array of single type.';
var ERROR_OBJECT_OF_TYPE = 'Expected object of one type.';
var ERROR_ONE_OF = 'Expected one of given values.';
var ERROR_ONE_OF_TYPE = 'Expected one of given types.';
var ERROR_SHAPE_OF = 'Expected object with a specific shape.';

/**
 * Provides access to various type validators that will return an
 * instance of Error when validation fails. Note that all type validators
 * will also accept null or undefined values. To not accept these you should
 * instead make your state property required.
 */
var validators = {
	any: function any() {
		return function () {
			return true;
		};
	},
	array: buildTypeValidator('array'),
	bool: buildTypeValidator('boolean'),
	func: buildTypeValidator('function'),
	number: buildTypeValidator('number'),
	object: buildTypeValidator('object'),
	string: buildTypeValidator('string'),

	/**
  * Creates a validator that checks that the value it receives is an array
  * of items, and that all of the items pass the given validator.
  * @param {!function()} validator Validator to check each item against.
  * @return {!function()}
  */
	arrayOf: function arrayOf(validator) {
		return maybe(function (value, name, context) {
			var result = validators.array(value, name, context);
			if (isInvalid(result)) {
				return result;
			}
			return validateArrayItems(validator, value, name, context);
		});
	},

	/**
  * Creates a validator that checks if a value is an instance of a given class.
  * @param {!function()} expectedClass Class to check value against.
  * @return {!function()}
  */
	instanceOf: function instanceOf(expectedClass) {
		return maybe(function (value, name, context) {
			if (value instanceof expectedClass) {
				return true;
			}
			var msg = 'Expected instance of ' + expectedClass;
			return composeError(msg, name, context);
		});
	},

	/**
  * Creates a validator that checks that the value it receives is an object,
  * and that all values within that object pass the given validator.
  * @param {!function()} validator Validator to check each object value against.
  * @return {!function()}
  */
	objectOf: function objectOf(validator) {
		return maybe(function (value, name, context) {
			for (var key in value) {
				if (isInvalid(validator(value[key]))) {
					return composeError(ERROR_OBJECT_OF_TYPE, name, context);
				}
			}
			return true;
		});
	},

	/**
  * Creates a validator that checks if the received value matches one of the
  * given values.
  * @param {!Array} arrayOfValues Array of values to check equality against.
  * @return {!function()}
  */
	oneOf: function oneOf(arrayOfValues) {
		return maybe(function (value, name, context) {
			var result = validators.array(arrayOfValues, name, context);
			if (isInvalid(result)) {
				return result;
			}
			return arrayOfValues.indexOf(value) === -1 ? composeError(ERROR_ONE_OF, name, context) : true;
		});
	},

	/**
  * Creates a validator that checks if the received value matches one of the
  * given types.
  * @param {!Array} arrayOfTypeValidators Array of validators to check value
  *     against.
  * @return {!function()}
  */
	oneOfType: function oneOfType(arrayOfTypeValidators) {
		return maybe(function (value, name, context) {
			var result = validators.array(arrayOfTypeValidators, name, context);
			if (isInvalid(result)) {
				return result;
			}

			for (var i = 0; i < arrayOfTypeValidators.length; i++) {
				if (!isInvalid(arrayOfTypeValidators[i](value, name, context))) {
					return true;
				}
			}
			return composeError(ERROR_ONE_OF_TYPE, name, context);
		});
	},

	/**
  * Creates a validator that checks if the received value is an object, and
  * that its contents match the given shape.
  * @param {!Object} shape An object containing validators for each key.
  * @return {!function()}
  */
	shapeOf: function shapeOf(shape) {
		return maybe(function (value, name, context) {
			var result = validators.object(shape, name, context);
			if (isInvalid(result)) {
				return result;
			}

			for (var key in shape) {
				var validator = shape[key];
				var required = false;
				if (validator.config) {
					required = validator.config.required;
					validator = validator.config.validator;
				}
				if (required && !(0, _metal.isDefAndNotNull)(value[key]) || isInvalid(validator(value[key]))) {
					return composeError(ERROR_SHAPE_OF, name, context);
				}
			}
			return true;
		});
	}
};

/**
 * Creates a validator that checks against a specific primitive type.
 * @param {string} expectedType Type to check against.
 * @return {!function()} Function that runs the validator if called with
 *     arguments, or just returns it otherwise. This means that when using a
 *     type validator in `State` it may be just passed directly (like
 *     `validators.bool`), or called with no args (like `validators.bool()`).
 *     That's done to allow all validators to be used consistently, since some
 *     (like `arrayOf`) always require that you call the function before
 *     receiving the actual validator. Type validators don't need the call, but
 *     work if it's made anyway.
 */
function buildTypeValidator(expectedType) {
	var validatorFn = maybe(validateType.bind(null, expectedType));
	return function () {
		if (arguments.length === 0) {
			return validatorFn;
		} else {
			return validatorFn.apply(undefined, arguments);
		}
	};
}

/**
 * Composes a warning a warning message.
 * @param {string} error Error message to display to console.
 * @param {?string} name Name of state property that is giving the error.
 * @param {Object} context The property's owner.
 * @return {!Error}
 */
function composeError(error, name, context) {
	var compName = context ? (0, _metal.getFunctionName)(context.constructor) : null;
	var renderer = context && context.getRenderer && context.getRenderer();
	var parent = renderer && renderer.getParent && renderer.getParent();
	var parentName = parent ? (0, _metal.getFunctionName)(parent.constructor) : null;
	var location = parentName ? 'Check render method of \'' + parentName + '\'.' : '';
	return new Error('Warning: Invalid state passed to \'' + name + '\'. ' + (error + ' Passed to \'' + compName + '\'. ' + location));
}

/**
 * Returns the type of the given value.
 * @param {*} value Any value.
 * @return {string} Type of value.
 */
function getType(value) {
	return Array.isArray(value) ? 'array' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
}

/**
 * Checks if the given validator result says that the value is invalid.
 * @param {boolean|!Error} result
 * @return {boolean}
 */
function isInvalid(result) {
	return result instanceof Error;
}

/**
 * Wraps the given validator so that it also accepts null/undefined values.
 *   a validator that checks a value against a single type, null, or
 * undefined.
 * @param {!function()} typeValidator Validator to wrap.
 * @return {!function()} Wrapped validator.
 */
function maybe(typeValidator) {
	return function (value, name, context) {
		return (0, _metal.isDefAndNotNull)(value) ? typeValidator(value, name, context) : true;
	};
}

/**
 * Checks if all the items of the given array pass the given validator.
 * @param {!function()} validator
 * @param {*} value The array to validate items for.
 * @param {string} name The name of the array property being checked.
 * @param {!Object} context Owner of the array property being checked.
 * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
 */
function validateArrayItems(validator, value, name, context) {
	for (var i = 0; i < value.length; i++) {
		if (isInvalid(validator(value[i], name, context))) {
			return composeError(ERROR_ARRAY_OF_TYPE, name, context);
		}
	}
	return true;
}

/**
 * Checks if the given value matches the expected type.
 * @param {string} expectedType String representing the expected type.
 * @param {*} value The value to match the type of.
 * @param {string} name The name of the property being checked.
 * @param {!Object} context Owner of the property being checked.
 * @return {!Error|boolean} `true` if the type matches, or an error otherwise.
 */
function validateType(expectedType, value, name, context) {
	var type = getType(value);
	if (type !== expectedType) {
		var msg = 'Expected type \'' + expectedType + '\', but received type \'' + type + '\'.';
		return composeError(msg, name, context);
	}
	return true;
}

exports.default = validators;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(76);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Base class that component renderers should extend from. It defines the
 * required methods all renderers should have.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ComponentRenderer = function () {
	function ComponentRenderer() {
		_classCallCheck(this, ComponentRenderer);
	}

	_createClass(ComponentRenderer, [{
		key: 'dispose',


		/**
   * Disposes of any data specific to the given component.
   * @param {!Component} component
   */
		value: function dispose() {}

		/**
   * Returns extra configuration for data that should be added to the manager.
   * Sub classes can override to return `State` config for properties that
   * should be added to the component.
   * @param {!Component} component
   * @return {Object}
   */

	}, {
		key: 'getExtraDataConfig',
		value: function getExtraDataConfig() {}

		/**
   * Renders the whole content (including its main element) and informs the
   * component about it. Should be overridden by sub classes.
   * @param {!Component} component
   */

	}, {
		key: 'render',
		value: function render(component) {
			if (!component.element) {
				component.element = document.createElement('div');
			}
			component.informRendered();
		}

		/**
   * Sets up this component to be used by this renderer. Sub classes should
   * override as needed for more behavior.
   * @param {!Component} component
   */

	}, {
		key: 'setUp',
		value: function setUp() {}

		/**
   * Updates the component's element html. This is automatically called when
   * the value of at least one of the component's state keys has changed.
   * Should be implemented by sub classes. Sub classes have to remember to call
   * "informRendered" on the component when any update rendering is done.
   * @param {!Component} component
   * @param {Object.<string, Object>} changes Object containing the names
   *     of all changed state keys, each mapped to an object with its new
   *     (newVal) and previous (prevVal) values.
   */

	}, {
		key: 'update',
		value: function update() {}
	}]);

	return ComponentRenderer;
}();

exports.default = new ComponentRenderer();

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

__webpack_require__(30);

var _changes = __webpack_require__(32);

var _data = __webpack_require__(9);

var _children = __webpack_require__(33);

var _patch2 = __webpack_require__(94);

var _render = __webpack_require__(35);

var _metalComponent = __webpack_require__(0);

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IncrementalDomRenderer = function (_ComponentRenderer$co) {
	_inherits(IncrementalDomRenderer, _ComponentRenderer$co);

	function IncrementalDomRenderer() {
		_classCallCheck(this, IncrementalDomRenderer);

		return _possibleConstructorReturn(this, (IncrementalDomRenderer.__proto__ || Object.getPrototypeOf(IncrementalDomRenderer)).apply(this, arguments));
	}

	_createClass(IncrementalDomRenderer, [{
		key: 'buildShouldUpdateArgs',

		/**
   * Returns an array with the args that should be passed to the component's
   * `shouldUpdate` method. This can be overridden by sub classes to change
   * what the method should receive.
   * @param {Object} changes
   * @return {!Array}
   */
		value: function buildShouldUpdateArgs(changes) {
			return [changes.props];
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'dispose',
		value: function dispose(component) {
			var data = (0, _data.getData)(component);
			var ref = data.config.ref;
			var owner = data.owner;
			if (owner && owner.components && owner.components[ref] === component) {
				delete owner.components[ref];
			}

			if (data.childComponents) {
				for (var i = 0; i < data.childComponents.length; i++) {
					var child = data.childComponents[i];
					if (!child.isDisposed()) {
						child.element = null;
						child.dispose();
					}
				}
			}

			(0, _data.clearData)(component);
		}

		/**
   * Generates a key for the element currently being rendered in the given
   * component. By default, just returns the original key. Sub classes can
   * override this to change the behavior.
   * @param {!Component} component
   * @param {string} key
   * @return {?string}
   */

	}, {
		key: 'generateKey',
		value: function generateKey(component, key) {
			return key;
		}

		/**
   * Get the component's config data.
   * @param {!Component} component
   * @return {!Object}
   */

	}, {
		key: 'getConfig',
		value: function getConfig(component) {
			return (0, _data.getData)(component).config;
		}

		/**
   * Get the component's incremental dom renderer data.
   * @param {!Component} component
   * @return {!Object}
   */

	}, {
		key: 'getData',
		value: function getData(component) {
			return (0, _data.getData)(component);
		}

		/**
   * Gets the component that triggered the current patch operation.
   * @return {Component}
   */

	}, {
		key: 'getPatchingComponent',
		value: function getPatchingComponent() {
			return (0, _patch2.getPatchingComponent)();
		}

		/**
   * Handles a node having just been rendered. Sub classes should override this
   * for custom behavior.
   */

	}, {
		key: 'handleNodeRendered',
		value: function handleNodeRendered() {}

		/**
   * Checks if the given object is an incremental dom node.
   * @param {!Object} node
   * @return {boolean}
   */

	}, {
		key: 'isIncDomNode',
		value: function isIncDomNode(node) {
			return !!(0, _children.getOwner)(node);
		}

		/**
   * Calls incremental dom's patch function to render the component.
   * @param {!Component} component
   */

	}, {
		key: 'patch',
		value: function patch(component) {
			(0, _patch2.patch)(component);
		}

		/**
   * Renders the renderer's component for the first time, patching its element
   * through incremental dom function calls. If the first arg is a function
   * instead of a component instance, creates and renders this function, which
   * can either be a simple incremental dom function or a component constructor.
   * @param {!Component} component
   * @param {!Component|function()} component Can be a component instance, a
   *     simple incremental dom function or a component constructor.
   * @param {Object|Element=} opt_dataOrElement Optional config data for the
   *     function, or parent for the rendered content.
   * @param {Element=} opt_parent Optional parent for the rendered content.
   * @return {!Component} The rendered component's instance.
   */

	}, {
		key: 'render',
		value: function render(component, opt_dataOrElement, opt_parent) {
			if (component instanceof _metalComponent.Component) {
				this.patch(component);
			} else {
				return (0, _render.renderFunction)(this, component, opt_dataOrElement, opt_parent);
			}
		}

		/**
   * Renders the given child node via its owner renderer.
   * @param {!Object} child
   */

	}, {
		key: 'renderChild',
		value: function renderChild(child) {
			(0, _render.renderChild)(child);
		}

		/**
   * Calls functions from `IncrementalDOM` to build the component element's
   * content. Can be overriden by subclasses (for integration with template
   * engines for example).
   * @param {!Component} component
   */

	}, {
		key: 'renderIncDom',
		value: function renderIncDom(component) {
			if (component.render) {
				component.render();
			} else {
				IncrementalDOM.elementVoid('div');
			}
		}

		/**
   * Runs the incremental dom functions for rendering this component, without
   * calling `patch`. This function needs to be called inside a `patch`.
   * @param {!Component} component
   */

	}, {
		key: 'renderInsidePatch',
		value: function renderInsidePatch(component) {
			var shouldRender = !component.wasRendered || this.shouldUpdate(component, (0, _changes.getChanges)(component)) || IncrementalDOM.currentPointer() !== component.element;
			if (shouldRender) {
				(0, _render.render)(component);
			} else if (component.element) {
				this.skipRender();
			}
		}

		/**
   * Sets up this component to be used by this renderer.
   * @param {!Component} component
   */

	}, {
		key: 'setUp',
		value: function setUp(component) {
			component.context = {};
			component.components = {};
			component.refs = {};

			var data = (0, _data.getData)(component);
			data.config = component.getInitialConfig();
			(0, _changes.trackChanges)(component);
		}

		/**
   * Checks if the component should be updated with the current state changes.
   * @param {!Component} component
   * @param {Object} changes
   * @return {boolean}
   */

	}, {
		key: 'shouldUpdate',
		value: function shouldUpdate(component, changes) {
			if (!changes) {
				return false;
			}
			if (component.shouldUpdate) {
				return component.shouldUpdate.apply(component, _toConsumableArray(this.buildShouldUpdateArgs(changes)));
			}
			return true;
		}

		/**
   * Skips the next disposal of children components, by clearing the array as
   * if there were no children rendered the last time. This can be useful for
   * allowing components to be reused by other parent components in separate
   * render update cycles.
   * @param {!Component} component
   */

	}, {
		key: 'skipNextChildrenDisposal',
		value: function skipNextChildrenDisposal(component) {
			(0, _data.getData)(component).childComponents = null;
		}

		/**
   * Skips rendering the current node.
   */

	}, {
		key: 'skipRender',
		value: function skipRender() {
			IncrementalDOM.skipNode();
		}

		/**
   * Updates the renderer's component when state changes, patching its element
   * through incremental dom function calls.
   * @param {!Component} component
   */

	}, {
		key: 'update',
		value: function update(component) {
			if (this.shouldUpdate(component, (0, _changes.getChanges)(component))) {
				this.patch(component);
			}
		}
	}]);

	return IncrementalDomRenderer;
}(_metalComponent.ComponentRenderer.constructor);

var renderer = new IncrementalDomRenderer();

// Name of this renderer. Renderers should provide this as a way to identify
// them via a simple string (when calling enableCompatibilityMode to add
// support to old features for specific renderers for example).
renderer.RENDERER_NAME = 'incremental-dom';

exports.default = renderer;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var _incrementalDom = __webpack_require__(86);

var IncrementalDOM = _interopRequireWildcard(_incrementalDom);

var _incrementalDomString = __webpack_require__(87);

var IncrementalDOMString = _interopRequireWildcard(_incrementalDomString);

var _metal = __webpack_require__(11);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

if ((0, _metal.isServerSide)()) {
	// Overrides global.IncrementalDOM virtual elements with incremental dom
	// string implementation for server side rendering. At the moment it does not
	// override for Node.js tests since tests are using jsdom to simulate the
	// browser.
	global.IncrementalDOM = IncrementalDOMString;
} else {
	var scope = typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window;

	scope.IncrementalDOM = IncrementalDOM;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(88);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.clearChanges = clearChanges;
exports.getChanges = getChanges;
exports.trackChanges = trackChanges;

var _data = __webpack_require__(9);

/**
 * Clears the changes tracked so far.
 * @param {!Object} data
 */
function clearChanges(data) {
  data.changes = null;
}

/**
 * Handles the `stateKeyChanged` event from a component. Stores change data.
 * @param {!Object} data
 * @param {!Object} eventData
 * @private
 */
function handleStateKeyChanged_(data, eventData) {
  data.changes = data.changes || {};
  var type = eventData.type || 'props';
  data.changes[type] = data.changes[type] || {};
  data.changes[type][eventData.key] = eventData;
}

/**
 * Returns an object with changes in the given component since the last time,
 * or null if there weren't any.
 * @param {!Component} component
 * @return {Object}
 */
function getChanges(component) {
  return (0, _data.getData)(component).changes;
}

/**
 * Starts tracking changes for the given component
 * @param {!Component} component
 */
function trackChanges(component) {
  var data = (0, _data.getData)(component);
  component.on('stateKeyChanged', handleStateKeyChanged_.bind(null, data));
}

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.CHILD_OWNER = undefined;
exports.captureChildren = captureChildren;
exports.isChildTag = isChildTag;
exports.getOwner = getOwner;
exports.renderChildTree = renderChildTree;

var _callArgs = __webpack_require__(34);

var _metal = __webpack_require__(11);

var _incrementalDomAop = __webpack_require__(15);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Property identifying a specific object as a Metal.js child node, and
 * pointing to the component instance that created it.
 * @type {string}
 */
var CHILD_OWNER = exports.CHILD_OWNER = '__metalChildOwner';

/**
 * Captures all child elements from incremental dom calls.
 * @param {!Component} component The component that is capturing children.
 * @param {!function()} callback Function to be called when children have all
 *     been captured.
 * @param {Object} data Data to pass to the callback function when calling it.
 */
function captureChildren(component, callback, data) {
	owner_ = component;
	callback_ = callback;
	callbackData_ = data;
	tree_ = {
		props: {
			children: []
		}
	};
	tree_.config = tree_.props;
	currentParent_ = tree_;
	isCapturing_ = true;
	(0, _incrementalDomAop.startInterception)({
		elementClose: handleInterceptedCloseCall_,
		elementOpen: handleInterceptedOpenCall_,
		text: handleInterceptedTextCall_
	});
}

/**
 * Checks if the given tag was built from a component's children.
 * @param {*} tag
 * @return {boolean}
 */
function isChildTag(tag) {
	return (0, _metal.isDef)(tag.tag);
}

/**
 * Gets the node's original owner.
 * @param {!Object} node
 * @return {Component}
 */
function getOwner(node) {
	return node[CHILD_OWNER];
}

/**
 * Renders a children tree through incremental dom.
 * @param {!{args: Array, children: !Array, isText: ?boolean}}
 * @param {function()=} opt_skipNode Optional function that is called for
 *     each node to be rendered. If it returns true, the node will be skipped.
 * @protected
 */
function renderChildTree(tree, opt_skipNode) {
	if (isCapturing_) {
		// If capturing, just add the node directly to the captured tree.
		addChildToTree(tree);
		return;
	}

	if (opt_skipNode && opt_skipNode.call(null, tree)) {
		return;
	}

	if ((0, _metal.isDef)(tree.text)) {
		var args = tree.args ? tree.args : [];
		args[0] = tree.text;
		IncrementalDOM.text.apply(null, args);
	} else {
		var _args = (0, _callArgs.buildCallFromConfig)(tree.tag, tree.props);
		_args[0] = {
			tag: _args[0],
			owner: getOwner(tree)
		};
		IncrementalDOM.elementOpen.apply(null, _args);
		if (tree.props.children) {
			for (var i = 0; i < tree.props.children.length; i++) {
				renderChildTree(tree.props.children[i], opt_skipNode);
			}
		}
		IncrementalDOM.elementClose(tree.tag);
	}
}

var callbackData_ = void 0;
var callback_ = void 0;
var currentParent_ = void 0;
var isCapturing_ = false;
var owner_ = void 0;
var tree_ = void 0;

/**
 * Adds a child element to the tree.
 * @param {!Array} args The arguments passed to the incremental dom call.
 * @param {boolean=} opt_isText Optional flag indicating if the child is a
 *     text element.
 * @protected
 */
function addChildCallToTree_(args, opt_isText) {
	var child = _defineProperty({
		parent: currentParent_
	}, CHILD_OWNER, owner_);

	if (opt_isText) {
		child.text = args[0];
		if (args.length > 1) {
			child.args = args;
		}
	} else {
		child.tag = args[0];
		child.props = (0, _callArgs.buildConfigFromCall)(args);
		child.props.children = [];
		child.config = child.props;
	}

	addChildToTree(child);
	return child;
}

function addChildToTree(child) {
	currentParent_.props.children.push(child);
}

/**
 * Handles an intercepted call to the `elementClose` function from incremental
 * dom.
 * @protected
 */
function handleInterceptedCloseCall_() {
	if (currentParent_ === tree_) {
		(0, _incrementalDomAop.stopInterception)();
		isCapturing_ = false;
		var node = callback_.call(owner_, tree_, callbackData_);
		callback_ = null;
		callbackData_ = null;
		currentParent_ = null;
		owner_ = null;
		tree_ = null;
		return node;
	} else {
		currentParent_ = currentParent_.parent;
		return true;
	}
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom.
 * @param {!function()} originalFn The original function before interception.
 * @protected
 */
function handleInterceptedOpenCall_() {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	currentParent_ = addChildCallToTree_(args);
}

/**
 * Handles an intercepted call to the `text` function from incremental dom.
 * @param {!function()} originalFn The original function before interception.
 * @protected
 */
function handleInterceptedTextCall_() {
	for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		args[_key2] = arguments[_key2];
	}

	addChildCallToTree_(args, true);
}

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Builds the component config object from its incremental dom call's
 * arguments.
 * @param {!Array} args
 * @return {!Object}
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.buildConfigFromCall = buildConfigFromCall;
exports.buildCallFromConfig = buildCallFromConfig;
function buildConfigFromCall(args) {
	var config = {};
	if (args[1]) {
		config.key = args[1];
	}
	var attrsArr = (args[2] || []).concat(args.slice(3));
	for (var i = 0; i < attrsArr.length; i += 2) {
		config[attrsArr[i]] = attrsArr[i + 1];
	}
	return config;
}

/**
 * Builds an incremental dom call array from the given tag and config object.
 * @param {string} tag
 * @param {!Object} config
 * @return {!Array}
 */
function buildCallFromConfig(tag, config) {
	var call = [tag, config.key, []];
	var keys = Object.keys(config);
	for (var i = 0; i < keys.length; i++) {
		if (keys[i] !== 'children' && keys[i] !== 'key') {
			call.push(keys[i], config[keys[i]]);
		}
	}
	return call;
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getComponentBeingRendered = getComponentBeingRendered;
exports.isComponentTag_ = isComponentTag_;
exports.render = render;
exports.renderChild = renderChild;
exports.renderFunction = renderFunction;

var _attributes = __webpack_require__(95);

var _callArgs = __webpack_require__(34);

var _children = __webpack_require__(33);

var _changes = __webpack_require__(32);

var _metalDom = __webpack_require__(6);

var _data = __webpack_require__(9);

var _metal = __webpack_require__(11);

var _unused = __webpack_require__(96);

var _incrementalDomAop = __webpack_require__(15);

var _metalComponent = __webpack_require__(0);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var renderingComponents_ = [];
var emptyChildren_ = [];

/**
 * Adds the given css classes to the specified arguments for an incremental
 * dom call, merging with the existing value if there is one.
 * @param {string} elementClasses
 * @param {!Object} config
 * @private
 */
function addElementClasses_(elementClasses, config) {
	if (config.class) {
		config.class += ' ' + elementClasses;
		config.class = removeDuplicateClasses_(config.class);
	} else {
		config.class = elementClasses;
	}
}

/**
 * Builds the "children" array to be passed to the current component.
 * @param {!Array<!Object>} children
 * @return {!Array<!Object>}
 * @private
 */
function buildChildren_(children) {
	return children.length === 0 ? emptyChildren_ : children;
}

/**
 * Finishes the render operation, doing some cleaups.
 * @param {!Component} component
 * @private
 */
function cleanUpRender_(component) {
	(0, _incrementalDomAop.stopInterception)();
	if (!(0, _data.getData)(component).rootElementReached) {
		component.element = null;
	}
	component.informRendered();
	finishedRenderingComponent_();
}

/**
 * Removes the most recent component from the queue of rendering components.
 * @private
 */
function finishedRenderingComponent_() {
	renderingComponents_.pop();
	if (renderingComponents_.length === 0) {
		(0, _unused.disposeUnused)();
	}
}

/**
 * Generates a key for the next element to be rendered.
 * @param {!Component} component
 * @param {?string} key The key originally passed to the element.
 * @return {?string}
 * @private
 */
function generateKey_(component, key) {
	var data = (0, _data.getData)(component);
	if (!data.rootElementReached && data.config.key) {
		key = data.config.key;
	}
	return component.getRenderer().generateKey(component, key);
}

/**
 * Gets the child components stored in the given object.
 * @param {!Object} data
 * @return {!Array<!Component>}
 * @private
 */
function getChildComponents_(data) {
	data.childComponents = data.childComponents || [];
	return data.childComponents;
}

/**
 * Gets the component being currently rendered.
 * @return {Component}
 */
function getComponentBeingRendered() {
	return renderingComponents_[renderingComponents_.length - 1];
}

/**
 * Gets the data object that should be currently used. This object will either
 * come from the current element being rendered by incremental dom or from
 * the component instance being rendered (only when the current element is the
 * component's direct parent).
 * @return {!Object}
 * @private
 */
function getCurrentData() {
	var element = IncrementalDOM.currentElement();
	var comp = getComponentBeingRendered();
	var obj = (0, _data.getData)(comp);
	if (obj.rootElementReached && element !== comp.element.parentNode) {
		obj = _metalDom.domData.get(element);
	}
	obj.icComponentsData = obj.icComponentsData || {};
	return obj.icComponentsData;
}

/**
 * Returns the "ref" to be used for a component. Uses "key" as "ref" when
 * compatibility mode is on for the current renderer.
 * @param {!Component} owner
 * @param {!Object} config
 * @return {?string}
 * @private
 */
function getRef_(owner, config) {
	var compatData = (0, _metal.getCompatibilityModeData)();
	if (compatData) {
		var ownerRenderer = owner.getRenderer();
		var renderers = compatData.renderers;
		var useKey = !renderers || renderers.indexOf(ownerRenderer) !== -1 || renderers.indexOf(ownerRenderer.RENDERER_NAME) !== -1;
		if (useKey && config.key && !config.ref) {
			return config.key;
		}
	}
	return config.ref;
}

/**
 * Gets the sub component referenced by the given tag and config data,
 * creating it if it doesn't yet exist.
 * @param {string|!Function} tagOrCtor The tag name.
 * @param {!Object} config The config object for the sub component.
 * @param {!Component} owner
 * @return {!Component} The sub component.
 * @protected
 */
function getSubComponent_(tagOrCtor, config, owner) {
	var Ctor = tagOrCtor;
	if ((0, _metal.isString)(Ctor)) {
		Ctor = _metalComponent.ComponentRegistry.getConstructor(tagOrCtor);
	}

	var ref = getRef_(owner, config);
	var comp = void 0;
	if ((0, _metal.isDef)(ref)) {
		comp = match_(owner.components[ref], Ctor, config, owner);
		owner.components[ref] = comp;
		owner.refs[ref] = comp;
	} else {
		var data = getCurrentData();
		var key = config.key;
		if (!(0, _metal.isDef)(key)) {
			var type = (0, _metal.getUid)(Ctor, true);
			data.currCount = data.currCount || {};
			data.currCount[type] = data.currCount[type] || 0;
			key = '__METAL_IC__' + type + '_' + data.currCount[type]++;
		}
		comp = match_(data.prevComps ? data.prevComps[key] : null, Ctor, config, owner);
		data.currComps = data.currComps || {};
		data.currComps[key] = comp;
	}

	return comp;
}

/**
 * Handles the event of children having finished being captured.
 * @param {!Object} tree The captured children in tree format.
 * @private
 */
function handleChildrenCaptured_(tree, _ref) {
	var props = _ref.props,
	    tag = _ref.tag;

	props.children = buildChildren_(tree.props.children);
	return renderFromTag_(tag, props);
}

/**
 * Handles a child being rendered via `IncrementalDomChildren.render`. Skips
 * component nodes so that they can be rendered the correct way without
 * having to recapture both them and their children via incremental dom.
 * @param {!Object} node
 * @return {boolean}
 * @private
 */
function handleChildRender_(node) {
	if (node.tag && isComponentTag_(node.tag)) {
		node.props.children = buildChildren_(node.props.children);
		renderFromTag_(node.tag, node.props, (0, _children.getOwner)(node));
		return true;
	}
}

/**
 * Handles an intercepted call to the attributes default handler from
 * incremental dom.
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 * @private
 */
function handleInterceptedAttributesCall_(element, name, value) {
	(0, _attributes.applyAttribute)(getComponentBeingRendered(), element, name, value);
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom.
 * @param {string} tag
 * @private
 */
function handleInterceptedOpenCall_(tag) {
	if (isComponentTag_(tag)) {
		return handleSubComponentCall_.apply(null, arguments);
	} else {
		return handleRegularCall_.apply(null, arguments);
	}
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom, done for a regular element. Among other things, adds any inline
 * listeners found on the first render and makes sure that component root
 * elements are always reused.
 * @param {!Component} owner
 * @param {!Array} args
 * @return {!Element} The rendered element.
 * @private
 */
function handleRegularCall_() {
	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	var config = (0, _callArgs.buildConfigFromCall)(args);
	var tag = args[0];

	var comp = getComponentBeingRendered();
	var owner = comp;
	if ((0, _children.isChildTag)(tag)) {
		owner = tag.owner;
		tag = tag.tag;
	}
	config.key = generateKey_(comp, config.key);

	if (!(0, _data.getData)(comp).rootElementReached) {
		var elementClasses = comp.getDataManager().get(comp, 'elementClasses');
		if (elementClasses) {
			addElementClasses_(elementClasses, config);
		}
	}
	(0, _attributes.convertListenerNamesToFns)(comp, config);

	var call = (0, _callArgs.buildCallFromConfig)(tag, config);
	var node = (0, _incrementalDomAop.getOriginalFn)('elementOpen').apply(null, call);
	resetNodeData_(node);
	updateElementIfNotReached_(comp, node);

	if ((0, _metal.isDefAndNotNull)(config.ref)) {
		owner.refs[config.ref] = node;
	}
	owner.getRenderer().handleNodeRendered(node);

	return node;
}

/**
 * Handles an intercepted call to the `elementOpen` function from incremental
 * dom, done for a sub component element. Creates and updates the appropriate
 * sub component.
 * @private
 */
function handleSubComponentCall_() {
	for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
		args[_key2] = arguments[_key2];
	}

	(0, _children.captureChildren)(getComponentBeingRendered(), handleChildrenCaptured_, {
		props: (0, _callArgs.buildConfigFromCall)(args),
		tag: args[0]
	});
}

/**
 * Passes down elementClasses to a child component if the parent component
 * returns another component at the top level (HOC).
 * @param {*} parent The parent component
 * @param {*} config The config of the subcomponent
 */
function inheritElementClasses_(parent, config) {
	var parentData = (0, _data.getData)(parent);
	var parentConfig = parentData.config;

	if (!parentData.rootElementReached && parentConfig && (0, _metal.isString)(parentConfig.elementClasses)) {
		var currentClasses = '';
		if ((0, _metal.isString)(config.elementClasses)) {
			currentClasses = config.elementClasses + ' ';
		}

		config.elementClasses = currentClasses + parentConfig.elementClasses;
	}
}

/**
 * Checks if the given tag represents a metal component.
 * @param {string} tag
 * @return {boolean}
 * @private
 */
function isComponentTag_(tag) {
	return (0, _metal.isFunction)(tag) || (0, _metal.isString)(tag) && tag[0] === tag[0].toUpperCase();
}

/**
 * Checks if the given component can be a match for a constructor.
 * @param {!Component} comp
 * @param {!function()} Ctor
 * @param {!Component} owner
 * @return {boolean}
 * @private
 */
function isMatch_(comp, Ctor, owner) {
	if (!comp || comp.constructor !== Ctor || comp.isDisposed()) {
		return false;
	}
	return (0, _data.getData)(comp).owner === owner;
}

/**
 * Returns the given component if it matches the specified constructor
 * function. Otherwise, returns a new instance of the given constructor. On
 * both cases the component's state and config will be updated.
 * @param {Component} comp
 * @param {!function()} Ctor
 * @param {!Object} config
 * @param {!Component} owner
 * @return {!Component}
 * @private
 */
function match_(comp, Ctor, config, owner) {
	if (isMatch_(comp, Ctor, owner)) {
		comp.startSkipUpdates();
		comp.getDataManager().replaceNonInternal(comp, config);
		comp.stopSkipUpdates();
	} else {
		comp = new Ctor(config, false);
	}
	(0, _data.getData)(comp).config = config;
	return comp;
}

/**
 * Prepares the render operation, resetting the component's data and starting
 * the incremental dom interception.
 * @param {!Component} component
 * @private
 */
function prepareRender_(component) {
	renderingComponents_.push(component);

	var data = (0, _data.getData)(component);
	resetComponentsData_(data.icComponentsData);
	(0, _changes.clearChanges)(data);
	data.rootElementReached = false;
	component.refs = {};

	if (data.childComponents) {
		(0, _unused.schedule)(data.childComponents);
		data.childComponents = null;
	}

	(0, _incrementalDomAop.startInterception)({
		attributes: handleInterceptedAttributesCall_,
		elementOpen: handleInterceptedOpenCall_
	});
}

/**
 * Removes duplicate css classes from the given string.
 * @param {string} classString
 * @return {string}
 * @private
 */
function removeDuplicateClasses_(classString) {
	var classes = [];
	var all = classString.split(/\s+/);
	var used = {};
	for (var i = 0; i < all.length; i++) {
		if (!used[all[i]]) {
			used[all[i]] = true;
			classes.push(all[i]);
		}
	}
	return classes.join(' ');
}

/**
 * Renders the component with incremental dom function calls. This assumes that
 * an incremental dom `patch` is already running, and that this function has
 * been called inside it.
 * @param {!Component} component
 */
function render(component) {
	prepareRender_(component);
	component.getRenderer().renderIncDom(component);
	cleanUpRender_(component);
}

/**
 * Renders the given child node.
 * @param {!Object} child
 */
function renderChild(child) {
	(0, _children.renderChildTree)(child, handleChildRender_);
}

/**
 * Renders the contents for the given tag.
 * @param {!function()|string} tag
 * @param {!Object} config
 * @param {Component=} opt_owner
 * @private
 */
function renderFromTag_(tag, config, opt_owner) {
	if ((0, _metal.isString)(tag) || tag.prototype.getRenderer) {
		var comp = renderSubComponent_(tag, config, opt_owner);
		updateElementIfNotReached_(getComponentBeingRendered(), comp.element);
		return comp.element;
	} else {
		return tag(config);
	}
}

/**
 * Creates and renders the given function, which can either be a simple
 * incremental dom function or a component constructor.
 * @param {!IncrementalDomRenderer} renderer
 * @param {!function()} fnOrCtor Either a simple incremental dom function or a
 *     component constructor.
 * @param {Object|Element=} opt_dataOrElement Optional config data for the
 *     function or parent for the rendered content.
 * @param {Element=} opt_parent Optional parent for the rendered content.
 * @return {!Component} The rendered component's instance.
 */
function renderFunction(renderer, fnOrCtor, opt_dataOrElement, opt_parent) {
	if (!_metalComponent.Component.isComponentCtor(fnOrCtor)) {
		var fn = fnOrCtor;

		var TempComponent = function (_Component) {
			_inherits(TempComponent, _Component);

			function TempComponent() {
				_classCallCheck(this, TempComponent);

				return _possibleConstructorReturn(this, (TempComponent.__proto__ || Object.getPrototypeOf(TempComponent)).apply(this, arguments));
			}

			_createClass(TempComponent, [{
				key: 'created',
				value: function created() {
					var parent = getComponentBeingRendered();
					if (parent) {
						updateContext_(this, parent);
					}
				}
			}, {
				key: 'render',
				value: function render() {
					fn(this.getInitialConfig());
				}
			}]);

			return TempComponent;
		}(_metalComponent.Component);

		TempComponent.RENDERER = renderer;
		fnOrCtor = TempComponent;
	}
	return _metalComponent.Component.render(fnOrCtor, opt_dataOrElement, opt_parent);
}

/**
 * This updates the sub component that is represented by the given data.
 * The sub component is created, added to its parent and rendered. If it
 * had already been rendered before though, it will only have its state
 * updated instead.
 * @param {string|!function()} tagOrCtor The tag name or constructor function.
 * @param {!Object} config The config object for the sub component.
 * @param {ComponentRenderer=} opt_owner
 * @return {!Component} The updated sub component.
 * @private
 */
function renderSubComponent_(tagOrCtor, config, opt_owner) {
	var parent = getComponentBeingRendered();
	var owner = opt_owner || parent;

	inheritElementClasses_(parent, config);

	var comp = getSubComponent_(tagOrCtor, config, owner);
	updateContext_(comp, parent);

	var data = (0, _data.getData)(comp);
	data.parent = parent;
	data.owner = owner;

	var parentData = (0, _data.getData)(parent);
	getChildComponents_(parentData).push(comp);
	if (!config.key && !parentData.rootElementReached) {
		config.key = parentData.config.key;
	}

	comp.getRenderer().renderInsidePatch(comp);
	if (!comp.wasRendered) {
		comp.renderComponent();
	}
	return comp;
}

/**
 * Resets the given incremental dom data object, preparing it for the next pass.
 * @param {Object} data
 * @private
 */
function resetComponentsData_(data) {
	if (data) {
		data.prevComps = data.currComps;
		data.currComps = null;
		data.currCount = null;
	}
}
/**
 * Resets all data stored in the given node.
 * @param {!Element} node
 * @private
 */
function resetNodeData_(node) {
	if (_metalDom.domData.has(node)) {
		resetComponentsData_(_metalDom.domData.get(node).icComponentsData);
	}
}

/**
 * Updates the given component's context according to the data from the
 * component that is currently being rendered.
 * @param {!Component} comp
 * @protected
 */
function updateContext_(comp, parent) {
	var context = comp.context;
	var childContext = parent.getChildContext ? parent.getChildContext() : null;
	_metal.object.mixin(context, parent.context, childContext);
	comp.context = context;
}

/**
 * Updates this renderer's component's element with the given values, unless
 * it has already been reached by an earlier call.
 * @param {!Component} component
 * @param {!Element} node
 * @private
 */
function updateElementIfNotReached_(component, node) {
	var data = (0, _data.getData)(component);
	if (!data.rootElementReached) {
		data.rootElementReached = true;
		if (component.element !== node) {
			component.element = node;
		}
	}
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// This file exists just for backwards compatibility, making sure that old
// default imports for this file still work. It's best to use the named exports
// for each function instead though, since that allows bundlers like Rollup to
// reduce the bundle size by removing unused code.

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.core = undefined;

var _coreNamed = __webpack_require__(98);

Object.keys(_coreNamed).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _coreNamed[key];
    }
  });
});

var core = _interopRequireWildcard(_coreNamed);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = core;
exports.core = core;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var core = function () {
	function core() {
		_classCallCheck(this, core);
	}

	/**
  * When defining a class Foo with an abstract method bar(), you can do:
  * Foo.prototype.bar = core.abstractMethod
  *
  * Now if a subclass of Foo fails to override bar(), an error will be thrown
  * when bar() is invoked.
  *
  * @type {!Function}
  * @throws {Error} when invoked to indicate the method should be overridden.
  */
	core.abstractMethod = function abstractMethod() {
		throw Error('Unimplemented abstract method');
	};

	/**
  * Loops constructor super classes collecting its properties values. If
  * property is not available on the super class `undefined` will be
  * collected as value for the class hierarchy position.
  * @param {!function()} constructor Class constructor.
  * @param {string} propertyName Property name to be collected.
  * @return {Array.<*>} Array of collected values.
  * TODO(*): Rethink superclass loop.
  */


	core.collectSuperClassesProperty = function collectSuperClassesProperty(constructor, propertyName) {
		var propertyValues = [constructor[propertyName]];
		while (constructor.__proto__ && !constructor.__proto__.isPrototypeOf(Function)) {
			constructor = constructor.__proto__;
			propertyValues.push(constructor[propertyName]);
		}
		return propertyValues;
	};

	/**
  * Gets the name of the given function. If the current browser doesn't
  * support the `name` property, this will calculate it from the function's
  * content string.
  * @param {!function()} fn
  * @return {string}
  */


	core.getFunctionName = function getFunctionName(fn) {
		if (!fn.name) {
			var str = fn.toString();
			fn.name = str.substring(9, str.indexOf('('));
		}
		return fn.name;
	};

	/**
  * Gets an unique id. If `opt_object` argument is passed, the object is
  * mutated with an unique id. Consecutive calls with the same object
  * reference won't mutate the object again, instead the current object uid
  * returns. See {@link core.UID_PROPERTY}.
  * @param {Object=} opt_object Optional object to be mutated with the uid. If
  *     not specified this method only returns the uid.
  * @param {boolean=} opt_noInheritance Optional flag indicating if this
  *     object's uid property can be inherited from parents or not.
  * @throws {Error} when invoked to indicate the method should be overridden.
  */


	core.getUid = function getUid(opt_object, opt_noInheritance) {
		if (opt_object) {
			var id = opt_object[core.UID_PROPERTY];
			if (opt_noInheritance && !opt_object.hasOwnProperty(core.UID_PROPERTY)) {
				id = null;
			}
			return id || (opt_object[core.UID_PROPERTY] = core.uniqueIdCounter_++);
		}
		return core.uniqueIdCounter_++;
	};

	/**
  * The identity function. Returns its first argument.
  * @param {*=} opt_returnValue The single value that will be returned.
  * @return {?} The first argument.
  */


	core.identityFunction = function identityFunction(opt_returnValue) {
		return opt_returnValue;
	};

	/**
  * Returns true if the specified value is a boolean.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is boolean.
  */


	core.isBoolean = function isBoolean(val) {
		return typeof val === 'boolean';
	};

	/**
  * Returns true if the specified value is not undefined.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is defined.
  */


	core.isDef = function isDef(val) {
		return val !== undefined;
	};

	/**
  * Returns true if value is not undefined or null.
  * @param {*} val
  * @return {Boolean}
  */


	core.isDefAndNotNull = function isDefAndNotNull(val) {
		return core.isDef(val) && !core.isNull(val);
	};

	/**
  * Returns true if value is a document.
  * @param {*} val
  * @return {Boolean}
  */


	core.isDocument = function isDocument(val) {
		return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
	};

	/**
  * Returns true if value is a dom element.
  * @param {*} val
  * @return {Boolean}
  */


	core.isElement = function isElement(val) {
		return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
	};

	/**
  * Returns true if the specified value is a function.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is a function.
  */


	core.isFunction = function isFunction(val) {
		return typeof val === 'function';
	};

	/**
  * Returns true if value is null.
  * @param {*} val
  * @return {Boolean}
  */


	core.isNull = function isNull(val) {
		return val === null;
	};

	/**
  * Returns true if the specified value is a number.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is a number.
  */


	core.isNumber = function isNumber(val) {
		return typeof val === 'number';
	};

	/**
  * Returns true if value is a window.
  * @param {*} val
  * @return {Boolean}
  */


	core.isWindow = function isWindow(val) {
		return val !== null && val === val.window;
	};

	/**
  * Returns true if the specified value is an object. This includes arrays
  * and functions.
  * @param {?} val Variable to test.
  * @return {boolean} Whether variable is an object.
  */


	core.isObject = function isObject(val) {
		var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
		return type === 'object' && val !== null || type === 'function';
	};

	/**
  * Returns true if value is a Promise.
  * @param {*} val
  * @return {Boolean}
  */


	core.isPromise = function isPromise(val) {
		return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
	};

	/**
  * Returns true if value is a string.
  * @param {*} val
  * @return {Boolean}
  */


	core.isString = function isString(val) {
		return typeof val === 'string';
	};

	/**
  * Merges the values of a static property a class with the values of that
  * property for all its super classes, and stores it as a new static
  * property of that class. If the static property already existed, it won't
  * be recalculated.
  * @param {!function()} constructor Class constructor.
  * @param {string} propertyName Property name to be collected.
  * @param {function(*, *):*=} opt_mergeFn Function that receives an array filled
  *   with the values of the property for the current class and all its super classes.
  *   Should return the merged value to be stored on the current class.
  * @return {boolean} Returns true if merge happens, false otherwise.
  */


	core.mergeSuperClassesProperty = function mergeSuperClassesProperty(constructor, propertyName, opt_mergeFn) {
		var mergedName = propertyName + '_MERGED';
		if (constructor.hasOwnProperty(mergedName)) {
			return false;
		}

		var merged = core.collectSuperClassesProperty(constructor, propertyName);
		if (opt_mergeFn) {
			merged = opt_mergeFn(merged);
		}
		constructor[mergedName] = merged;
		return true;
	};

	/**
  * Null function used for default values of callbacks, etc.
  * @return {void} Nothing.
  */


	core.nullFunction = function nullFunction() {};

	return core;
}();

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */


core.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
core.uniqueIdCounter_ = 1;

exports.default = core;

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scss_app_scss__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__scss_app_scss___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__scss_app_scss__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__components_MetalForm_MetalForm__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components_Dropdown_Dropdown__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_Calculator_Calculator__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__components_CalculatorButton_CalculatorButton__ = __webpack_require__(122);






new __WEBPACK_IMPORTED_MODULE_1__components_MetalForm_MetalForm__["a" /* default */]({
	endpoint: 'http://localhost:3100/calculator'
});




/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(40);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(42)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./app.scss", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/sass-loader/lib/loader.js!./app.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(41)(undefined);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/css?family=Open+Sans);", ""]);

// module
exports.push([module.i, "html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font-size: 100%;\n  font: inherit;\n  vertical-align: baseline; }\n\n/* HTML5 display-role reset for older browsers */\narticle, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section {\n  display: block; }\n\nbody {\n  line-height: 1; }\n\nol, ul {\n  list-style: none; }\n\nblockquote, q {\n  quotes: none; }\n\nblockquote:before, blockquote:after {\n  content: '';\n  content: none; }\n\nq:before, q:after {\n  content: '';\n  content: none; }\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0; }\n\n*, *:after, *:before {\n  box-sizing: border-box; }\n\nbody {\n  font-family: \"Open Sans\";\n  font-size: 13px;\n  background: #fafafa; }\n  body:before {\n    content: \"\";\n    position: absolute;\n    width: 100%;\n    height: 421px;\n    background: #3e9cfc;\n    left: 0;\n    top: 0; }\n\nhtml, body {\n  height: 100%; }\n\na {\n  text-decoration: none; }\n\n.wrapper {\n  padding-top: 56px;\n  min-height: calc(100% - 168px);\n  position: relative; }\n\n.container {\n  padding: 0 20px;\n  max-width: 1280px;\n  width: 100%;\n  margin: 0 auto; }\n  .container:after {\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: \" \";\n    clear: both;\n    height: 0; }\n\nform.loan-form fieldset .input-error {\n  color: #d0021b;\n  background: rgba(208, 1, 27, 0.2); }\n  form.loan-form fieldset .input-error::-webkit-input-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error:-moz-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error::-moz-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error:-ms-input-placeholder {\n    color: #d0021b; }\n  form.loan-form fieldset .input-error:active {\n    border-color: #d0021b; }\n\nbutton:hover, button:focus, button:active, a:hover, a:focus, a:active, input:hover, input:focus, input:active {\n  outline: none; }\n\nh1 {\n  font-size: 38px;\n  color: #fff;\n  font-weight: 400;\n  text-align: center;\n  margin-bottom: 46px; }\n  h1 small {\n    margin-top: 35px;\n    display: block;\n    font-size: 18px;\n    font-weight: 300; }\n\n.site-footer {\n  width: 100%;\n  height: 128px;\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flex;\n  display: -o-flex;\n  display: flex;\n  flex-direction: row;\n  align-items: center;\n  justify-content: flex-start;\n  line-height: 1.5;\n  color: #9b9b9b;\n  background: #ffffff;\n  width: 100%;\n  bottom: -168px;\n  position: absolute; }\n\n.dropdown {\n  position: relative;\n  font-size: 14px; }\n  .dropdown .dropdown-display {\n    position: relative; }\n  .dropdown .dropdown-list-wrapper {\n    display: none;\n    width: 100%;\n    top: 40px;\n    box-shadow: 0 2px 14px 0 rgba(97, 149, 237, 0.1);\n    border: solid 1px #e4e9ec;\n    position: absolute;\n    z-index: 5;\n    background: #fff; }\n    .dropdown .dropdown-list-wrapper input {\n      background: no-repeat 5px center transparent url(\"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHZlcnNpb249IjEuMSIgIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij4NCiAgIDxwYXRoIGZpbGw9IiMwMDAwMDAiIGQ9Ik05LjUsM0E2LjUsNi41IDAgMCwxIDE2LDkuNUMxNiwxMS4xMSAxNS40MSwxMi41OSAxNC40NCwxMy43M0wxNC43MSwxNEgxNS41TDIwLjUsMTlMMTksMjAuNUwxNCwxNS41VjE0LjcxTDEzLjczLDE0LjQ0QzEyLjU5LDE1LjQxIDExLjExLDE2IDkuNSwxNkE2LjUsNi41IDAgMCwxIDMsOS41QTYuNSw2LjUgMCAwLDEgOS41LDNNOS41LDVDNyw1IDUsNyA1LDkuNUM1LDEyIDcsMTQgOS41LDE0QzEyLDE0IDE0LDEyIDE0LDkuNUMxNCw3IDEyLDUgOS41LDVaIiAvPg0KPC9zdmc+\");\n      padding-left: 38px;\n      padding-top: 9px;\n      padding-bottom: 12px;\n      border-radius: 0; }\n      .dropdown .dropdown-list-wrapper input, .dropdown .dropdown-list-wrapper input:focus {\n        border-color: transparent;\n        border-bottom: 1px solid #e4e9ec; }\n  .dropdown .arrow_box {\n    position: relative;\n    background: #869cae;\n    position: absolute;\n    right: 12px;\n    z-index: 2;\n    height: 4px;\n    top: 19px; }\n    .dropdown .arrow_box:after {\n      bottom: 100%;\n      left: 50%;\n      border: solid transparent;\n      content: \" \";\n      height: 0;\n      width: 0;\n      position: absolute;\n      pointer-events: none;\n      border-bottom-color: #869cae;\n      border-width: 4px;\n      margin-left: -4px; }\n    .dropdown .arrow_box:before {\n      top: 100%;\n      left: 50%;\n      border: solid transparent;\n      content: \" \";\n      height: 0;\n      width: 0;\n      position: absolute;\n      pointer-events: none;\n      border-top-color: #869cae;\n      border-width: 4px;\n      margin-left: -4px; }\n\n.box-calculator {\n  position: relative;\n  flex: 1 0 202px;\n  margin: 0 65px 0 0; }\n  .box-calculator .calculator-display {\n    width: 202px;\n    height: 56px;\n    padding: 21px 16px 0;\n    font-size: 14px;\n    overflow: auto;\n    background: #eaf0f3; }\n  .box-calculator .calculator-buttons-wrapper {\n    display: -webkit-flex;\n    display: -moz-flex;\n    display: -ms-flex;\n    display: -o-flex;\n    display: flex;\n    flex-direction: row;\n    align-items: flex-start;\n    justify-content: space-between;\n    width: 202px;\n    margin-top: 10px; }\n  .box-calculator .calculator-digits {\n    width: 144px;\n    overflow: hidden;\n    border-radius: 5px; }\n  .box-calculator .calculator-operators {\n    overflow: hidden;\n    border-radius: 5px;\n    width: 47px; }\n    .box-calculator .calculator-operators .calculator-button, .box-calculator .calculator-operators .calculator-button--double-size {\n      margin-right: 0; }\n  .box-calculator .calculator-button, .box-calculator .calculator-button--double-size {\n    cursor: pointer;\n    width: 47px;\n    height: 47px;\n    float: left;\n    margin: 0 1px 1px 0;\n    border: 0;\n    background: rgba(62, 156, 252, 0.3);\n    color: #3e9cfc; }\n    .box-calculator .calculator-button:hover, .box-calculator .calculator-button--double-size:hover {\n      background: rgba(62, 156, 252, 0.45); }\n    .box-calculator .calculator-button:active, .box-calculator .calculator-button--double-size:active {\n      background: rgba(62, 156, 252, 0.55); }\n  .box-calculator .calculator-button--double-size {\n    width: 95px; }\n\n.loan-form {\n  background: #fff;\n  padding: 61px 65px;\n  border-radius: 6px;\n  box-shadow: 0 0 20px 0 rgba(0, 5, 61, 0.1);\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flex;\n  display: -o-flex;\n  display: flex;\n  flex-direction: row;\n  align-items: initial;\n  justify-content: stretch;\n  margin: 0 auto 122px;\n  width: 688px;\n  flex-wrap: wrap; }\n\n.box-loan-options {\n  display: -webkit-flex;\n  display: -moz-flex;\n  display: -ms-flex;\n  display: -o-flex;\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n  justify-content: flex-start;\n  flex: 1 0 290px;\n  position: relative; }\n  .box-loan-options input, .box-loan-options label, .box-loan-options button {\n    width: 100%; }\n  .box-loan-options .calculate-interest {\n    margin-bottom: 16px;\n    cursor: pointer;\n    margin-top: -3px;\n    transition: ease-out .3s all;\n    box-shadow: inset 0 0 0 #3e9cfc; }\n    .box-loan-options .calculate-interest:hover {\n      box-shadow: inset 0 50px 0 #3e9cfc;\n      color: #fff; }\n  .box-loan-options .get-quot {\n    cursor: pointer;\n    position: absolute;\n    max-width: 290px;\n    bottom: 0; }\n  .box-loan-options #input-total {\n    margin-bottom: 26px; }\n\ninput[type=\"text\"] {\n  font-size: 14px;\n  border-radius: 4px;\n  background: #eaf0f3;\n  padding: 11px 10px;\n  font-weight: 500;\n  color: #39536c;\n  border: 1px solid transparent; }\n  input[type=\"text\"]::-webkit-input-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]:-moz-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]::-moz-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]:-ms-input-placeholder {\n    color: rgba(134, 156, 173, 0.5); }\n  input[type=\"text\"]:focus {\n    border-color: #65b4f0; }\n\n.warning-label {\n  font-size: 12.5px;\n  margin-top: 6px;\n  line-height: 16px;\n  color: #d0021b;\n  display: none; }\n  .warning-label i {\n    cursor: pointer; }\n\n.dropdown .dropdown-list-wrapper.show, .warning-label.show {\n  display: block; }\n\nlabel {\n  margin-bottom: 27px; }\n  label:after {\n    visibility: hidden;\n    display: block;\n    font-size: 0;\n    content: \" \";\n    clear: both;\n    height: 0; }\n  label .caption {\n    color: #4a4a4a;\n    font-size: 18px;\n    margin-bottom: 6px;\n    display: block; }\n  label .mandatory-sign {\n    font-weight: bold;\n    color: #f5984c; }\n\n.button, .button--filled {\n  color: #308fff;\n  padding: 10px;\n  font-size: 16px;\n  background: #ffffff;\n  text-align: center;\n  font-weight: 500;\n  border: 1px solid #308fff;\n  border-radius: 4px; }\n  .button[disabled], [disabled].button--filled {\n    background-color: #728694;\n    border-color: transparent; }\n\n.button--filled {\n  background: #308fff;\n  color: #ffffff; }\n\n.dropdown-list-item, .dropdown-list-item:hover {\n  cursor: pointer;\n  padding: 10px; }\n  .dropdown-list-item:hover {\n    background: #f8fafa; }\n  .dropdown-list-item[data-selected] {\n    color: #329de6; }\n\n.submit-label {\n  position: absolute;\n  bottom: 45px;\n  width: 100%;\n  color: #fff;\n  background: #3e9cfc;\n  padding: 0.5rem;\n  border-radius: 4px;\n  opacity: 0;\n  visibility: hidden;\n  transform: translateY(10px);\n  z-index: 2;\n  transition: all .3s ease-in-out; }\n  .submit-label:before {\n    content: \"\";\n    display: block;\n    border: solid 7px transparent;\n    border-top-color: #3e9cfc;\n    width: 0;\n    height: 0;\n    position: absolute;\n    bottom: -11px;\n    left: 50%;\n    margin-left: -10px; }\n  .submit-label.danger {\n    background: #be0000; }\n    .submit-label.danger:before {\n      border-top-color: #be0000; }\n  .submit-label.show-message {\n    opacity: 1;\n    visibility: visible;\n    transform: translateY(0); }\n", ""]);

// exports


/***/ }),
/* 41 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(43);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 43 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MetalForm_soy_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_metal_soy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__ = __webpack_require__(16);








class MetalForm extends __WEBPACK_IMPORTED_MODULE_2_metal_component___default.a {
	/**
	 * MetalForm component
	 */
	created(){
		let instance = this;

		instance.ApplicationEmitter = new __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__["a" /* default */]();
		instance.ApplicationEmitter.on('LISTEN_DROPDOWN_EVENT', data => instance.dropdownData = data);
		instance.ApplicationEmitter.on('LISTEN_CALCULATOR_EVENT', data => instance.calculatorData = data);
	}
	
	/**
	 * Remove the form default behavior
	 * Set body event to verify the button show message
	 */
	attached(){
		let instance = this;
		
		instance.element.querySelector('form').addEventListener('submit', e => e.preventDefault());
		
		document.querySelector('body').addEventListener('click', (e)=> {
			if(e.target.classList.contains('get-quot')) return
			instance.element.querySelector('.submit-label').classList.remove('show-message');
		});
	}
	
	/**
	 * Check if has operators in the calculator display
	 * @param {Sring} text
	 * @returns {boolean}
	 */
	hasCalculatorOperators(text){
		return /[()+\-/*]/.test(text);
	}
	
	/**
	 * Check if has error in the form
	 * @returns {boolean || null}
	 */
	hasErrorInTheForm(){
		let instance = this,
				err;
		
		if(!instance.checkDropdownData()) err = true;
		if(!instance.checkCalculatorData()) err = true;
		
		return instance.error = err;
	}
	
	/**
	 * Calculate the form using the compound interest formula
	 * and show the result in the total input
	 */
	calculateForm(){
		let instance = this;

		if(instance.hasErrorInTheForm()) return;
		
		instance.debt = instance.calculateDebt({
			amount: instance.calculatorData,
			interest: instance.dropdownData.interest,
			months: instance.dropdownData.months
		});

		instance.element.querySelector('#input-total').placeholder = `R$: ${instance.debt}`;
		instance.element.querySelector('.get-quot').removeAttribute('disabled');
	}
	
	/**
	 * Calculate the debit using the compound interest formula
	 * @returns { string }
	 */
	calculateDebt({amount, interest, months}){
		let result;
		interest = interest / 100;
		result = (amount * Math.pow(1 + interest, months)).toLocaleString('pt-BR');
		
		if(result.split(',')[1].length > 2) result = result.substr(0, result.length-1);
		
		return result;
	}
	
	/**
	 * Check if the dropdown has item selected
	 * @returns {boolean}
	 */
	checkDropdownData(){
		let instance = this,
				isValid = true;
		
		if(!instance.dropdownData){
			instance.ApplicationEmitter.emit('LISTEN_DROPDOWN_ERROR', 'Please, select an item of the dropdown');
			isValid = false;
		}
		
		return isValid;
	}
	
	/**
	 * Check if the calculator has just numbers (integers or floats)
	 * @returns {boolean}
	 */
	checkCalculatorData(){
		let instance = this,
			data = instance.calculatorData,
			isValid = true;
		
		if(instance.hasCalculatorOperators(data) || !data || !parseFloat(data)){
			instance.ApplicationEmitter.emit('LISTEN_CALCULATOR_ERROR', "Please, type an exepression in your calculator and click in the button '='");
			isValid = false;
		}
		
		return isValid;
	}
	
	/**
	 * Send the count results to the server
	 */
	submitForm(){
		let instance = this;
		const	data = JSON.stringify({
			interest: instance.dropdownData.interest,
			loan: instance.calculatorData,
			numberOfMonths: instance.dropdownData.months,
			totalDebt: instance.debt
		});
		
		
		fetch(instance.endpoint, {
			method: "POST",
			headers: {
				'Accept': 'application/json, text/plain, */*',
				'Content-Type': 'application/json'
			},
			body: data
		}).then(resp => resp.json())
			.then(({status}) => instance.showFormMessage(status))
			.catch(err => instance.showFormMessage(`something wrong. Please contact the administrator.`, true))
	}
	
	/**
	 *  Show a vizual feedback in the form
	 * @param { String } text
	 * @param { Boolean } hasError
	 */
	showFormMessage(text, hasError){
		let instance = this;
		let element = instance.element.querySelector('.submit-label');
		
		element.textContent = text;
		element.classList.remove('danger');
		
		if(hasError) element.classList.add('danger');
		return element.classList.add('show-message');
	}
}

__WEBPACK_IMPORTED_MODULE_3_metal_soy___default.a.register(MetalForm, __WEBPACK_IMPORTED_MODULE_0__MetalForm_soy_js__["a" /* default */]);

/**
 * MetalForm State Definition
 */
MetalForm.STATE = {
	/**
	 * The emitter of the application
	 * to communicate with the other components
	 */
	ApplicationEmitter: {
		value: false
	},
	/**
	 * The user debit calculated in this component
	 */
	debt: {
		value: null
	},
	
	/**
	 * Expression that is in the calculator display
	 */
	calculatorData: {
		value: null
	},
	
	/**
	 * Item selected in the dropdown component
	 */
	dropdownData: {
		value: null
	},
	
	/**
	 * Url of the server, that will save the form data
	 */
	endpoint: {
		value: 'http://localhost:3100/calculator'
	}
};

/* harmony default export */ __webpack_exports__["a"] = (MetalForm);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export MetalForm */
/* unused harmony export templates */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
/* jshint ignore:start */


var templates;
goog.loadModule(function(exports) {

// This file was automatically generated from MetalForm.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace MetalForm.
 * @public
 */

goog.module('MetalForm.incrementaldom');

/** @suppress {extraRequire} */
var soy = goog.require('soy');
/** @suppress {extraRequire} */
var soydata = goog.require('soydata');
/** @suppress {extraRequire} */
goog.require('goog.i18n.bidi');
/** @suppress {extraRequire} */
goog.require('goog.asserts');
var IncrementalDom = goog.require('incrementaldom');
var ie_open = IncrementalDom.elementOpen;
var ie_close = IncrementalDom.elementClose;
var ie_void = IncrementalDom.elementVoid;
var ie_open_start = IncrementalDom.elementOpenStart;
var ie_open_end = IncrementalDom.elementOpenEnd;
var itext = IncrementalDom.text;
var iattr = IncrementalDom.attr;

var $templateAlias1 = __WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.getTemplate('Calculator.incrementaldom', 'render');

var $templateAlias2 = __WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.getTemplate('Dropdown.incrementaldom', 'render');


/**
 * @param {Object<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @param {Object<string, *>=} opt_ijData
 * @return {void}
 * @suppress {checkTypes}
 */
function $render(opt_data, opt_ignored, opt_ijData) {
  ie_open('main', null, null,
      'class', 'wrapper');
    ie_open('h1');
      ie_open('span');
        itext('Personal Loan');
      ie_close('span');
      ie_open('small');
        itext('Save and no red tape loan.');
      ie_close('small');
    ie_close('h1');
    ie_open('form', null, null,
        'method', 'post',
        'class', 'loan-form');
      ie_open('fieldset', null, null,
          'class', 'box-calculator');
        $templateAlias1({Listener: opt_data.ApplicationEmitter}, null, opt_ijData);
      ie_close('fieldset');
      ie_open('fieldset', null, null,
          'class', 'box-loan-options');
        ie_open('label', null, null,
            'for', 'select-months');
          ie_open('span', null, null,
              'class', 'caption');
            itext('Months ');
            ie_open('span', null, null,
                'class', 'mandatory-sign');
              itext('*');
            ie_close('span');
          ie_close('span');
          $templateAlias2({shown: '', Listener: opt_data.ApplicationEmitter}, null, opt_ijData);
        ie_close('label');
        ie_open('button', null, null,
            'class', 'button calculate-interest',
            'data-onclick', 'calculateForm');
          itext('Calculate');
        ie_close('button');
        ie_open('label', null, null,
            'for', 'input-total');
          ie_open('span', null, null,
              'class', 'caption');
            itext('Total');
          ie_close('span');
          ie_open('input', null, null,
              'type', 'text',
              'id', 'input-total',
              'disabled', '',
              'placeholder', 'R$: 0,00',
              'readonly', '');
          ie_close('input');
        ie_close('label');
        ie_void('span', null, null,
            'class', 'submit-label');
        ie_open('button', null, null,
            'class', 'get-quot button--filled',
            'data-onclick', 'submitForm',
            'disabled', '');
          itext('Get Quot');
        ie_close('button');
      ie_close('fieldset');
    ie_close('form');
    ie_open('footer', null, null,
        'class', 'site-footer');
      ie_open('div', null, null,
          'class', 'container');
        ie_open('p');
          itext(' Liferay Inc. ');
          ie_open('br');
          ie_close('br');
          itext(' Copyright \u00A9 2016 All Rights Reserved.');
        ie_close('p');
      ie_close('div');
    ie_close('footer');
  ie_close('main');
}
exports.render = $render;
if (goog.DEBUG) {
  $render.soyTemplateName = 'MetalForm.render';
}

exports.render.params = ["ApplicationEmitter"];
exports.render.types = {"ApplicationEmitter":"any"};
templates = exports;
return exports;

});

class MetalForm extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(MetalForm, templates);

/* harmony default export */ __webpack_exports__["a"] = (templates);
/* jshint ignore:end */


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(18);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12), __webpack_require__(2)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _events = __webpack_require__(17);

var _metal = __webpack_require__(5);

var _sync = __webpack_require__(54);

var _metalDom = __webpack_require__(6);

var _ComponentDataManager = __webpack_require__(24);

var _ComponentDataManager2 = _interopRequireDefault(_ComponentDataManager);

var _ComponentRenderer = __webpack_require__(28);

var _ComponentRenderer2 = _interopRequireDefault(_ComponentRenderer);

var _metalEvents = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Component collects common behaviors to be followed by UI components, such
 * as Lifecycle, CSS classes management, events encapsulation and support for
 * different types of rendering.
 * Rendering logic can be done by either:
 *     - Listening to the `render` event inside the `created` lifecycle function
 *       and adding the rendering logic to the listener.
 *     - Using an existing implementation of `ComponentRenderer` like `Soy`,
 *       and following its patterns.
 *     - Building your own implementation of a `ComponentRenderer`.
 * Specifying the renderer that will be used can be done by setting the RENDERER
 * static variable to the renderer's constructor function.
 *
 * Example:
 *
 * <code>
 * class CustomComponent extends Component {
 *   created() {
 *   }
 *
 *   rendered() {
 *   }
 *
 *   attached() {
 *   }
 *
 *   detached() {
 *   }
 *
 *   disposed() {
 *   }
 * }
 *
 * CustomComponent.RENDERER = MyRenderer;
 *
 * CustomComponent.STATE = {
 *   title: { value: 'Title' },
 *   fontSize: { value: '10px' }
 * };
 * </code>
 *
 * @extends {State}
 */
var Component = function (_EventEmitter) {
	_inherits(Component, _EventEmitter);

	/**
  * Constructor function for `Component`.
  * @param {Object=} opt_config An object with the initial values for this
  *     component's state.
  * @param {boolean|string|Element=} opt_parentElement The element where the
  *     component should be rendered. Can be given as a selector or an element.
  *     If `false` is passed, the component won't be rendered automatically
  *     after created.
  * @constructor
  */
	function Component(opt_config, opt_parentElement) {
		_classCallCheck(this, Component);

		/**
   * Instance of `DomEventEmitterProxy` which proxies events from the component's
   * element to the component itself.
   * @type {!DomEventEmitterProxy}
   * @protected
   */
		var _this = _possibleConstructorReturn(this, (Component.__proto__ || Object.getPrototypeOf(Component)).call(this));

		_this.elementEventProxy_ = new _metalDom.DomEventEmitterProxy(null, _this, proxyBlackList_);

		/**
   * The `EventHandler` instance for events attached from the `events` state key.
   * @type {EventHandler}
   * @protected
   */
		_this.eventsStateKeyHandler_ = null;

		/**
   * Whether the element is in document.
   * @type {boolean}
   */
		_this.inDocument = false;

		/**
   * The initial config option passed to this constructor.
   * @type {!Object}
   * @protected
   */
		_this.initialConfig_ = opt_config || {};

		/**
   * Whether the element was rendered.
   * @type {boolean}
   */
		_this.wasRendered = false;

		/**
   * The component's element will be appended to the element this variable is
   * set to, unless the user specifies another parent when calling `render` or
   * `attach`.
   * @type {!Element}
   */
		_this.DEFAULT_ELEMENT_PARENT = document.body;

		_this.setShouldUseFacade(true);
		_this.element = _this.initialConfig_.element;

		_this.setUpRenderer_();
		_this.setUpDataManager_();
		_this.setUpSyncUpdates_();

		_this.on('stateChanged', _this.handleComponentStateChanged_);
		_this.on('eventsChanged', _this.onEventsChanged_);
		_this.addListenersFromObj_(_this.dataManager_.get(_this, 'events'));

		_this.created();
		_this.componentCreated_ = true;
		if (opt_parentElement !== false) {
			_this.renderComponent(opt_parentElement);
		}
		return _this;
	}

	/**
  * Getter logic for the element property.
  * @return {Element}
  */


	_createClass(Component, [{
		key: 'addListenersFromObj_',


		/**
   * Adds the listeners specified in the given object.
   * @param {!Object} obj
   * @protected
   */
		value: function addListenersFromObj_(obj) {
			var _eventsStateKeyHandle;

			if (!this.eventsStateKeyHandler_) {
				this.eventsStateKeyHandler_ = new _metalEvents.EventHandler();
			}
			var handles = (0, _events.addListenersFromObj)(this, obj);
			(_eventsStateKeyHandle = this.eventsStateKeyHandler_).add.apply(_eventsStateKeyHandle, _toConsumableArray(handles));
		}

		/**
   * Invokes the attached Lifecycle. When attached, the component element is
   * appended to the DOM and any other action to be performed must be
   * implemented in this method, such as, binding DOM events. A component can
   * be re-attached multiple times.
   * @param {(string|Element)=} opt_parentElement Optional parent element
   *     to render the component.
   * @param {(string|Element)=} opt_siblingElement Optional sibling element
   *     to render the component before it. Relevant when the component needs
   *     to be rendered before an existing element in the DOM.
   * @protected
   * @chainable
   */

	}, {
		key: 'attach',
		value: function attach(opt_parentElement, opt_siblingElement) {
			if (!this.inDocument) {
				this.attachElement(opt_parentElement, opt_siblingElement);
				this.inDocument = true;
				this.attachData_ = {
					parent: opt_parentElement,
					sibling: opt_siblingElement
				};
				this.emit('attached', this.attachData_);
				this.attached();
			}
			return this;
		}

		/**
   * Lifecycle. When attached, the component element is appended to the DOM
   * and any other action to be performed must be implemented in this method,
   * such as, binding DOM events. A component can be re-attached multiple
   * times, therefore the undo behavior for any action performed in this phase
   * must be implemented on the detach phase.
   */

	}, {
		key: 'attached',
		value: function attached() {}

		/**
   * Attaches the component element into the DOM.
   * @param {(string|Element)=} opt_parentElement Optional parent element
   *     to render the component.
   * @param {(string|Element)=} opt_siblingElement Optional sibling element
   *     to render the component before it. Relevant when the component needs
   *     to be rendered before an existing element in the DOM, e.g.
   *     `component.attach(null, existingElement)`.
   */

	}, {
		key: 'attachElement',
		value: function attachElement(opt_parentElement, opt_siblingElement) {
			var element = this.element;
			if (element && (opt_siblingElement || !element.parentNode)) {
				var parent = (0, _metalDom.toElement)(opt_parentElement) || this.DEFAULT_ELEMENT_PARENT;
				parent.insertBefore(element, (0, _metalDom.toElement)(opt_siblingElement));
			}
		}

		/**
   * Lifecycle. This is called when the component has just been created, before
   * it's rendered.
   */

	}, {
		key: 'created',
		value: function created() {}

		/**
   * Listens to a delegate event on the component's element.
   * @param {string} eventName The name of the event to listen to.
   * @param {string} selector The selector that matches the child elements that
   *   the event should be triggered for.
   * @param {!function(!Object)} callback Function to be called when the event is
   *   triggered. It will receive the normalized event object.
   * @return {!EventHandle} Can be used to remove the listener.
   */

	}, {
		key: 'delegate',
		value: function delegate(eventName, selector, callback) {
			return this.on('delegate:' + eventName + ':' + selector, callback);
		}

		/**
   * Invokes the detached Lifecycle. When detached, the component element is
   * removed from the DOM and any other action to be performed must be
   * implemented in this method, such as, unbinding DOM events. A component
   * can be detached multiple times.
   * @chainable
   */

	}, {
		key: 'detach',
		value: function detach() {
			if (this.inDocument) {
				if (this.element && this.element.parentNode) {
					this.element.parentNode.removeChild(this.element);
				}
				this.inDocument = false;
				this.detached();
			}
			this.emit('detached');
			return this;
		}

		/**
   * Lifecycle. When detached, the component element is removed from the DOM
   * and any other action to be performed must be implemented in this method,
   * such as, unbinding DOM events. A component can be detached multiple
   * times, therefore the undo behavior for any action performed in this phase
   * must be implemented on the attach phase.
   */

	}, {
		key: 'detached',
		value: function detached() {}

		/**
   * Lifecycle. Called when the component is disposed. Should be overridden by
   * sub classes to dispose of any internal data or events.
   */

	}, {
		key: 'disposed',
		value: function disposed() {}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.detach();
			this.disposed();

			this.elementEventProxy_.dispose();
			this.elementEventProxy_ = null;

			this.dataManager_.dispose(this);
			this.dataManager_ = null;

			this.renderer_.dispose(this);
			this.renderer_ = null;

			_get(Component.prototype.__proto__ || Object.getPrototypeOf(Component.prototype), 'disposeInternal', this).call(this);
		}

		/**
   * Gets data about where this component was attached at.
   * @return {!Object}
   */

	}, {
		key: 'getAttachData',
		value: function getAttachData() {
			return this.attachData_;
		}

		/**
   * Gets the `ComponentDataManager` being used.
   * @return {!ComponentDataManager}
   */

	}, {
		key: 'getDataManager',
		value: function getDataManager() {
			return this.dataManager_;
		}

		/**
   * Gets the configuration object that was passed to this component's constructor.
   * @return {!Object}
   */

	}, {
		key: 'getInitialConfig',
		value: function getInitialConfig() {
			return this.initialConfig_;
		}

		/**
   * Gets state data for this component.
   * @return {!Object}
   */

	}, {
		key: 'getState',
		value: function getState() {
			return this.dataManager_.getState(this);
		}

		/**
   * Gets the keys for the state data.
   * @return {!Array<string>}
   */

	}, {
		key: 'getStateKeys',
		value: function getStateKeys() {
			return this.dataManager_.getStateKeys(this);
		}

		/**
   * Gets the `ComponentRenderer` instance being used.
   * @return {!ComponentRenderer}
   */

	}, {
		key: 'getRenderer',
		value: function getRenderer() {
			return this.renderer_;
		}

		/**
   * Handles a change in the component's element.
   * @param {Element} prevVal
   * @param {Element} newVal
   * @protected
   */

	}, {
		key: 'handleComponentElementChanged_',
		value: function handleComponentElementChanged_(prevVal, newVal) {
			this.elementEventProxy_.setOriginEmitter(newVal);
			if (this.componentCreated_) {
				this.emit('elementChanged', {
					prevVal: prevVal,
					newVal: newVal
				});
				if (newVal && this.wasRendered) {
					this.syncVisible(this.dataManager_.get(this, 'visible'));
				}
			}
		}

		/**
   * Handles state batch changes. Calls any existing `sync` functions that
   * match the changed state keys.
   * @param {Event} event
   * @protected
   */

	}, {
		key: 'handleComponentStateChanged_',
		value: function handleComponentStateChanged_(event) {
			if (!this.hasSyncUpdates()) {
				this.updateRenderer_(event);
			}
			(0, _sync.syncState)(this, event.changes);
			this.emit('stateSynced', event);
		}

		/**
   * Handles a `stateKeyChanged` event. This is only called for components that
   * have requested updates to happen synchronously.
   * @param {!{key: string, newVal: *, prevVal: *}} data
   * @protected
   */

	}, {
		key: 'handleComponentStateKeyChanged_',
		value: function handleComponentStateKeyChanged_(data) {
			this.updateRenderer_({
				changes: _defineProperty({}, data.key, data)
			});
		}

		/**
   * Checks if this component has sync updates enabled.
   * @return {boolean}
   */

	}, {
		key: 'hasSyncUpdates',
		value: function hasSyncUpdates() {
			return this.syncUpdates_;
		}

		/**
   * Informs that the component that the rendered has finished rendering it. The
   * renderer is the one responsible for calling this when appropriate. This
   * will emit events and run the appropriate lifecycle for the first render.
   */

	}, {
		key: 'informRendered',
		value: function informRendered() {
			var firstRender = !this.hasRendererRendered_;
			this.hasRendererRendered_ = true;
			this.rendered(firstRender);
			this.emit('rendered', firstRender);
		}

		/**
   * Checks if the given function is a component constructor.
   * @param {!function()} fn Any function
   * @return {boolean}
   */

	}, {
		key: 'mergeElementClasses_',


		/**
   * Merges two values for the ELEMENT_CLASSES property into a single one.
   * @param {string} class1
   * @param {string} class2
   * @return {string} The merged value.
   * @protected
   */
		value: function mergeElementClasses_(class1, class2) {
			return class1 ? class1 + ' ' + (class2 || '') : class2;
		}

		/**
   * Fired when the `events` state value is changed.
   * @param {!Object} event
   * @protected
   */

	}, {
		key: 'onEventsChanged_',
		value: function onEventsChanged_(event) {
			this.eventsStateKeyHandler_.removeAllListeners();
			this.addListenersFromObj_(event.newVal);
		}

		/**
   * Creates and renders a component for the given constructor function. This
   * will always make sure that the constructor runs without rendering the
   * component, having the `render` step happen only after it has finished.
   * @param {!function()} Ctor The component's constructor function.
   * @param {Object|Element=} opt_configOrElement Optional config data or parent
   *     for the component.
   * @param {Element=} opt_element Optional parent for the component.
   * @return {!Component} The rendered component's instance.
   */

	}, {
		key: 'renderComponent',


		/**
   * Renders the component into the DOM via its `ComponentRenderer`. Stores the
   * given parent element to be used when the renderer is done (`informRendered`).
   * @param {(string|Element|boolean)=} opt_parentElement Optional parent element
   *     to render the component. If set to `false`, the element won't be
   *     attached to any element after rendering. In this case, `attach` should
   *     be called manually later to actually attach it to the dom.
   */
		value: function renderComponent(opt_parentElement) {
			if (!this.hasRendererRendered_) {
				if (window.__METAL_DEV_TOOLS_HOOK__) {
					window.__METAL_DEV_TOOLS_HOOK__(this);
				}
				this.getRenderer().render(this);
			}
			this.emit('render');
			(0, _sync.syncState)(this);
			this.attach(opt_parentElement);
			this.wasRendered = true;
		}

		/**
   * Setter logic for the element property.
   * @param {?string|Element} val
   */

	}, {
		key: 'setState',


		/**
   * Sets the value of all the specified state keys.
   * @param {!Object.<string,*>} values A map of state keys to the values they
   *   should be set to.
   * @param {function()=} opt_callback An optional function that will be run
   *   after the next batched update is triggered.
   */
		value: function setState(state, opt_callback) {
			this.dataManager_.setState(this, state, opt_callback);
		}

		/**
   * Setter for the `elementClasses` data property. Appends given value with
   * the one specified in `ELEMENT_CLASSES`.
   * @param {string} val
   * @return {string}
   * @protected
   */

	}, {
		key: 'setterElementClassesFn_',
		value: function setterElementClassesFn_(val) {
			var elementClasses = (0, _metal.getStaticProperty)(this.constructor, 'ELEMENT_CLASSES', this.mergeElementClasses_);
			if (elementClasses) {
				val += ' ' + elementClasses;
			}
			return val.trim();
		}

		/**
   * Sets up the component's data manager.
   * @protected
   */

	}, {
		key: 'setUpDataManager_',
		value: function setUpDataManager_() {
			this.dataManager_ = (0, _metal.getStaticProperty)(this.constructor, 'DATA_MANAGER');
			this.dataManager_.setUp(this, _metal.object.mixin({}, this.renderer_.getExtraDataConfig(this), Component.DATA));
		}

		/**
   * Sets up the component's renderer.
   * @protected
   */

	}, {
		key: 'setUpRenderer_',
		value: function setUpRenderer_() {
			this.renderer_ = (0, _metal.getStaticProperty)(this.constructor, 'RENDERER');
			this.renderer_.setUp(this);
		}

		/**
   * Sets up the component to use sync updates when `SYNC_UPDATES` is `true`.
   * @protected
   */

	}, {
		key: 'setUpSyncUpdates_',
		value: function setUpSyncUpdates_() {
			this.syncUpdates_ = (0, _metal.getStaticProperty)(this.constructor, 'SYNC_UPDATES');
			if (this.hasSyncUpdates()) {
				this.on('stateKeyChanged', this.handleComponentStateKeyChanged_.bind(this));
			}
		}

		/**
   * Skips renderer updates until `stopSkipUpdates` is called.
   */

	}, {
		key: 'startSkipUpdates',
		value: function startSkipUpdates() {
			this.skipUpdates_ = true;
		}

		/**
   * Stops skipping renderer updates.
   */

	}, {
		key: 'stopSkipUpdates',
		value: function stopSkipUpdates() {
			this.skipUpdates_ = false;
		}

		/**
   * State synchronization logic for `visible` state key.
   * Updates the element's display value according to its visibility.
   * @param {boolean} newVal
   */

	}, {
		key: 'syncVisible',
		value: function syncVisible(newVal) {
			if (this.element) {
				this.element.style.display = newVal ? '' : 'none';
			}
		}

		/**
   * Lifecycle. Called whenever the component has just been rendered.
   * @param {boolean} firstRender Flag indicating if this was the component's
   *     first render.
   */

	}, {
		key: 'rendered',
		value: function rendered() {}

		/**
   * Calls "update" on the renderer, passing it the changed data.
   * @param {!{changes: !Object}} data
   * @protected
   */

	}, {
		key: 'updateRenderer_',
		value: function updateRenderer_(data) {
			if (!this.skipUpdates_ && this.hasRendererRendered_) {
				this.getRenderer().update(this, data);
			}
		}

		/**
   * Validator logic for the `events` state key.
   * @param {Object} val
   * @return {boolean}
   * @protected
   */

	}, {
		key: 'validatorEventsFn_',
		value: function validatorEventsFn_(val) {
			return !(0, _metal.isDefAndNotNull)(val) || (0, _metal.isObject)(val);
		}
	}, {
		key: 'element',
		get: function get() {
			return this.elementValue_;
		},
		set: function set(val) {
			if (!(0, _metal.isElement)(val) && !(0, _metal.isString)(val) && (0, _metal.isDefAndNotNull)(val)) {
				return;
			}

			if (val) {
				val = (0, _metalDom.toElement)(val) || this.elementValue_;
			}

			if (this.elementValue_ !== val) {
				var prev = this.elementValue_;
				this.elementValue_ = val;
				this.handleComponentElementChanged_(prev, val);
			}
		}
	}], [{
		key: 'isComponentCtor',
		value: function isComponentCtor(fn) {
			return fn.prototype && fn.prototype[Component.COMPONENT_FLAG];
		}
	}, {
		key: 'render',
		value: function render(Ctor, opt_configOrElement, opt_element) {
			var config = opt_configOrElement;
			var element = opt_element;
			if ((0, _metal.isElement)(opt_configOrElement)) {
				config = null;
				element = opt_configOrElement;
			}
			var instance = new Ctor(config, false);
			instance.renderComponent(element);
			return instance;
		}

		/**
   * Creates and renders a component for the given constructor function as
   * string. This will always make sure that the constructor runs without
   * rendering the component, having the `render` step happen only after it
   * has finished.
   * @param {!function()} Ctor The component's constructor function.
   * @param {Object|Element=} opt_configOrElement Optional config data or
   *     parent for the component.
   * @return {!String} The rendered component's content as string.
   */

	}, {
		key: 'renderToString',
		value: function renderToString(Ctor, opt_config) {
			var rendererName = Ctor.RENDERER && Ctor.RENDERER.RENDERER_NAME;
			switch (rendererName) {
				case 'jsx':
				case 'soy':
				case 'incremental-dom':
					{
						if (typeof IncrementalDOM === 'undefined') {
							throw new Error('Error. Trying to render incremental dom ' + 'based component to string requires IncrementalDOM ' + 'implementation to be loaded.');
						}
						// Incremental dom patches for components or nested components are
						// isolated inside the component element. The following code intercepts
						// incremental dom patches and collect results into temporary stack in
						// order to successfully collect the final string of the outermost
						// component after all nested components stack rendered.
						var interceptedComponentStrings = [];
						var patch = IncrementalDOM.patch;
						var patchInterceptor = function patchInterceptor() {
							var currentElement = patch.apply(null, arguments);
							interceptedComponentStrings.push(currentElement.innerHTML);
							IncrementalDOM.patch = patch;
						};
						IncrementalDOM.patch = patchInterceptor;
						Component.render(Ctor, opt_config).dispose();
						return interceptedComponentStrings[0];
					}
				default:
					throw new Error('Error. Trying to render non incremental dom ' + 'based component to string.');
			}
		}
	}]);

	return Component;
}(_metalEvents.EventEmitter);

/**
 * Component data definition.
 * @type {Object}
 * @static
 */


Component.DATA = {
	/**
  * Objects describing children elements that were passed to be rendered inside
  * this component.
  * @type {!Array<!Object>}
  */
	children: {
		validator: Array.isArray,
		value: []
	},

	/**
  * CSS classes to be applied to the element.
  * @type {string}
  */
	elementClasses: {
		setter: 'setterElementClassesFn_',
		validator: _metal.isString,
		value: ''
	},

	/**
  * Listeners that should be attached to this component. Should be provided as
  * an object, where the keys are event names and the values are the listener
  * functions (or function names).
  * @type {Object<string, (function()|string|{selector: string, fn: function()|string})>}
  */
	events: {
		validator: 'validatorEventsFn_',
		value: null
	},

	/**
  * Indicates if the component is visible or not.
  * @type {boolean}
  */
	visible: {
		validator: _metal.isBoolean,
		value: true
	}
};

/**
 * Name of the flag used to identify component constructors via their prototype.
 * @type {string}
 */
Component.COMPONENT_FLAG = '__metal_component__';

/**
 * The `ComponentDataManager` class that should be used. This class will be
 * responsible for handling the component's data. Each component may have its
 * own implementation.
 * @type {!ComponentDataManager}
 */
Component.DATA_MANAGER = _ComponentDataManager2.default;

/**
 * CSS classes to be applied to the element.
 * @type {string}
 */
Component.ELEMENT_CLASSES = '';

/**
 * The `ComponentRenderer` that should be used. Components need to set this
 * to a subclass of `ComponentRenderer` that has the rendering logic, like
 * `SoyRenderer`.
 * @type {!ComponentRenderer}
 */
Component.RENDERER = _ComponentRenderer2.default;

/**
 * Flag indicating if component updates will happen synchronously. Updates are
 * done asynchronously by default, which allows changes to be batched and
 * applied together.
 * @type {boolean}
 */
Component.SYNC_UPDATES = false;

/**
 * Sets a prototype flag to easily determine if a given constructor is for
 * a component or not.
 */
Component.prototype[Component.COMPONENT_FLAG] = true;

var proxyBlackList_ = {
	eventsChanged: true,
	stateChanged: true,
	stateKeyChanged: true
};

exports.default = Component;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.syncState = syncState;

var _metal = __webpack_require__(5);

var SYNC_FNS_KEY = '__METAL_SYNC_FNS__';

/**
 * Gets the `sync` methods for this component's state. Caches the results in
 * the component's constructor whenever possible, so that this doesn't need to
 * be calculated again. It's not possible to cache the results when at least
 * one sync method is defined in the instance itself instead of in its
 * prototype, as it may be bound to the instance (not reusable by others).
 * @param {!Component} component
 * @return {!Object}
 * @private
 */
function getSyncFns_(component) {
	var ctor = component.constructor;
	if (ctor.hasOwnProperty(SYNC_FNS_KEY)) {
		return ctor[SYNC_FNS_KEY];
	}

	var fns = {};
	var keys = component.getDataManager().getSyncKeys(component);
	var canCache = true;
	for (var i = 0; i < keys.length; i++) {
		var name = 'sync' + keys[i].charAt(0).toUpperCase() + keys[i].slice(1);
		var fn = component[name];
		if (fn) {
			fns[keys[i]] = fn;
			canCache = canCache && component.constructor.prototype[name];
		}
	}

	if (canCache) {
		ctor[SYNC_FNS_KEY] = fns;
	}
	return fns;
}

/**
 * Calls "sync" functions for the given component's state.
 * @param {!Component} component
 * @param {Object=} opt_changes When given, only the properties inside it will
 *     be synced. Otherwise all state properties will be synced.
 */
function syncState(component, opt_changes) {
	var syncFns = getSyncFns_(component);
	var keys = Object.keys(opt_changes || syncFns);
	for (var i = 0; i < keys.length; i++) {
		var fn = syncFns[keys[i]];
		if ((0, _metal.isFunction)(fn)) {
			var change = opt_changes && opt_changes[keys[i]];
			var manager = component.getDataManager();
			fn.call(component, change ? change.newVal : manager.get(component, keys[i]), change ? change.prevVal : undefined);
		}
	}
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.customEvents = undefined;
exports.addClasses = addClasses;
exports.closest = closest;
exports.append = append;
exports.buildFragment = buildFragment;
exports.contains = contains;
exports.delegate = delegate;
exports.enterDocument = enterDocument;
exports.exitDocument = exitDocument;
exports.hasClass = hasClass;
exports.isEmpty = isEmpty;
exports.match = match;
exports.next = next;
exports.on = on;
exports.once = once;
exports.parent = parent;
exports.registerCustomEvent = registerCustomEvent;
exports.removeChildren = removeChildren;
exports.removeClasses = removeClasses;
exports.replace = replace;
exports.supportsEvent = supportsEvent;
exports.toElement = toElement;
exports.toggleClasses = toggleClasses;
exports.triggerEvent = triggerEvent;

var _metal = __webpack_require__(7);

var _domData = __webpack_require__(13);

var _domData2 = _interopRequireDefault(_domData);

var _DomDelegatedEventHandle = __webpack_require__(62);

var _DomDelegatedEventHandle2 = _interopRequireDefault(_DomDelegatedEventHandle);

var _DomEventHandle = __webpack_require__(22);

var _DomEventHandle2 = _interopRequireDefault(_DomEventHandle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var elementsByTag_ = {};
var supportCache_ = {};
var customEvents = exports.customEvents = {};

var LAST_CONTAINER = '__metal_last_container__';
var USE_CAPTURE = {
	blur: true,
	error: true,
	focus: true,
	invalid: true,
	load: true,
	scroll: true
};

/**
 * Adds the requested CSS classes to an element.
 * @param {!Element|!Nodelist} elements The element or elements to add CSS classes to.
 * @param {string} classes CSS classes to add.
 */
function addClasses(elements, classes) {
	if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
		return;
	}

	if (!elements.length) {
		elements = [elements];
	}

	for (var i = 0; i < elements.length; i++) {
		if ('classList' in elements[i]) {
			addClassesWithNative_(elements[i], classes);
		} else {
			addClassesWithoutNative_(elements[i], classes);
		}
	}
}

/**
 * Adds the requested CSS classes to an element using classList.
 * @param {!Element} element The element to add CSS classes to.
 * @param {string} classes CSS classes to add.
 * @private
 */
function addClassesWithNative_(element, classes) {
	classes.split(' ').forEach(function (className) {
		if (className) {
			element.classList.add(className);
		}
	});
}

/**
 * Adds the requested CSS classes to an element without using classList.
 * @param {!Element} element The element to add CSS classes to.
 * @param {string} classes CSS classes to add.
 * @private
 */
function addClassesWithoutNative_(element, classes) {
	var elementClassName = ' ' + element.className + ' ';
	var classesToAppend = '';

	classes = classes.split(' ');

	for (var i = 0; i < classes.length; i++) {
		var className = classes[i];

		if (elementClassName.indexOf(' ' + className + ' ') === -1) {
			classesToAppend += ' ' + className;
		}
	}

	if (classesToAppend) {
		element.className = element.className + classesToAppend;
	}
}

/**
 * Adds an event listener to the given element, to be triggered via delegate.
 * @param {!Element} element
 * @param {string} eventName
 * @param {!function()} listener
 * @private
 */
function addElementListener_(element, eventName, listener) {
	addToArr_(_domData2.default.get(element, 'listeners', {}), eventName, listener);
}

/**
 * Adds an event listener to the given element, to be triggered via delegate
 * selectors.
 * @param {!Element} element
 * @param {string} eventName
 * @param {string} selector
 * @param {!function()} listener
 * @private
 */
function addSelectorListener_(element, eventName, selector, listener) {
	var delegatingData = _domData2.default.get(element, 'delegating', {});
	addToArr_(delegatingData[eventName].selectors, selector, listener);
}

/**
 * Adds a value to an array inside an object, creating it first if it doesn't
 * yet exist.
 * @param {!Array} arr
 * @param {string} key
 * @param {*} value
 * @private
 */
function addToArr_(arr, key, value) {
	if (!arr[key]) {
		arr[key] = [];
	}
	arr[key].push(value);
}

/**
 * Attaches a delegate listener, unless there's already one attached.
 * @param {!Element} element
 * @param {string} eventName
 * @private
 */
function attachDelegateEvent_(element, eventName) {
	var delegatingData = _domData2.default.get(element, 'delegating', {});
	if (!delegatingData[eventName]) {
		delegatingData[eventName] = {
			handle: on(element, eventName, handleDelegateEvent_, !!USE_CAPTURE[eventName]),
			selectors: {}
		};
	}
}

/**
 * Gets the closest element up the tree from the given element (including
 * itself) that matches the specified selector, or null if none match.
 * @param {Element} element
 * @param {string} selector
 * @return {Element}
 */
function closest(element, selector) {
	while (element && !match(element, selector)) {
		element = element.parentNode;
	}
	return element;
}

/**
 * Appends a child node with text or other nodes to a parent node. If
 * child is a HTML string it will be automatically converted to a document
 * fragment before appending it to the parent.
 * @param {!Element} parent The node to append nodes to.
 * @param {!(Element|NodeList|string)} child The thing to append to the parent.
 * @return {!Element} The appended child.
 */
function append(parent, child) {
	if ((0, _metal.isString)(child)) {
		child = buildFragment(child);
	}
	if (child instanceof NodeList) {
		var childArr = Array.prototype.slice.call(child);
		for (var i = 0; i < childArr.length; i++) {
			parent.appendChild(childArr[i]);
		}
	} else {
		parent.appendChild(child);
	}
	return child;
}

/**
 * Helper for converting a HTML string into a document fragment.
 * @param {string} htmlString The HTML string to convert.
 * @return {!Element} The resulting document fragment.
 */
function buildFragment(htmlString) {
	var tempDiv = document.createElement('div');
	tempDiv.innerHTML = '<br>' + htmlString;
	tempDiv.removeChild(tempDiv.firstChild);

	var fragment = document.createDocumentFragment();
	while (tempDiv.firstChild) {
		fragment.appendChild(tempDiv.firstChild);
	}
	return fragment;
}

/**
 * Checks if the first element contains the second one.
 * @param {!Element} element1
 * @param {!Element} element2
 * @return {boolean}
 */
function contains(element1, element2) {
	if ((0, _metal.isDocument)(element1)) {
		// document.contains is not defined on IE9, so call it on documentElement instead.
		return element1.documentElement.contains(element2);
	} else {
		return element1.contains(element2);
	}
}

/**
 * Listens to the specified event on the given DOM element, but only calls the
 * given callback listener when it's triggered by elements that match the
 * given selector or target element.
 * @param {!Element} element The DOM element the event should be listened on.
 * @param {string} eventName The name of the event to listen to.
 * @param {!Element|string} selectorOrTarget Either an element or css selector
 *     that should match the event for the listener to be triggered.
 * @param {!function(!Object)} callback Function to be called when the event
 *     is triggered. It will receive the normalized event object.
 * @param {boolean=} opt_default Optional flag indicating if this is a default
 *     listener. That means that it would only be executed after all non
 *     default listeners, and only if the event isn't prevented via
 *     `preventDefault`.
 * @return {!EventHandle} Can be used to remove the listener.
 */
function delegate(element, eventName, selectorOrTarget, callback, opt_default) {
	var customConfig = customEvents[eventName];
	if (customConfig && customConfig.delegate) {
		eventName = customConfig.originalEvent;
		callback = customConfig.handler.bind(customConfig, callback);
	}

	if (opt_default) {
		// Wrap callback so we don't set property directly on it.
		callback = callback.bind();
		callback.defaultListener_ = true;
	}

	attachDelegateEvent_(element, eventName);
	if ((0, _metal.isString)(selectorOrTarget)) {
		addSelectorListener_(element, eventName, selectorOrTarget, callback);
	} else {
		addElementListener_(selectorOrTarget, eventName, callback);
	}

	return new _DomDelegatedEventHandle2.default((0, _metal.isString)(selectorOrTarget) ? element : selectorOrTarget, eventName, callback, (0, _metal.isString)(selectorOrTarget) ? selectorOrTarget : null);
}

/**
 * Verifies if the element is able to trigger the Click event,
 * simulating browsers behaviour, avoiding event listeners to be called by triggerEvent method.
 * @param {Element} node Element to be checked.
 * @param {string} eventName The event name.
 * @private
 */
function isAbleToInteractWith_(node, eventName, opt_eventObj) {
	if (opt_eventObj && eventName === 'click' && opt_eventObj.button === 2) {
		// Firefox triggers "click" events on the document for right clicks. This
		// causes our delegate logic to trigger it for regular elements too, which
		// shouldn't happen. Ignoring them here.
		return false;
	}

	var matchesSelector = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'FIELDSET'];
	if (eventName === 'click' && matchesSelector.indexOf(node.tagName) > -1) {
		return !(node.disabled || parent(node, 'fieldset[disabled]'));
	}
	return true;
}

/**
 * Inserts node in document as last element.
 * @param {Element} node Element to remove children from.
 */
function enterDocument(node) {
	node && append(document.body, node);
}

/**
 * Removes node from document.
 * @param {Element} node Element to remove children from.
 */
function exitDocument(node) {
	if (node && node.parentNode) {
		node.parentNode.removeChild(node);
	}
}

/**
 * This is called when an event is triggered by a delegate listener. All
 * matching listeners of this event type from `target` to `currentTarget` will
 * be triggered.
 * @param {!Event} event The event payload.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function handleDelegateEvent_(event) {
	normalizeDelegateEvent_(event);
	var ret = true;
	var container = event.currentTarget;
	var defFns = [];

	ret &= triggerDelegatedListeners_(container, event, defFns);
	ret &= triggerDefaultDelegatedListeners_(defFns, event);

	event.delegateTarget = null;
	event[LAST_CONTAINER] = container;
	return ret;
}

/**
 * Checks if the given element has the requested css class.
 * @param {!Element} element
 * @param {string} className
 * @return {boolean}
 */
function hasClass(element, className) {
	if ('classList' in element) {
		return hasClassWithNative_(element, className);
	} else {
		return hasClassWithoutNative_(element, className);
	}
}

/**
 * Checks if the given element has the requested css class using classList.
 * @param {!Element} element
 * @param {string} className
 * @return {boolean}
 * @private
 */
function hasClassWithNative_(element, className) {
	return element.classList.contains(className);
}

/**
 * Checks if the given element has the requested css class without using classList.
 * @param {!Element} element
 * @param {string} className
 * @return {boolean}
 * @private
 */
function hasClassWithoutNative_(element, className) {
	return (' ' + element.className + ' ').indexOf(' ' + className + ' ') >= 0;
}

/**
 * Checks if the given element is empty or not.
 * @param {!Element} element
 * @return {boolean}
 */
function isEmpty(element) {
	return element.childNodes.length === 0;
}

/**
 * Check if an element matches a given selector.
 * @param {Element} element
 * @param {string} selector
 * @return {boolean}
 */
function match(element, selector) {
	if (!element || element.nodeType !== 1) {
		return false;
	}

	var p = Element.prototype;
	var m = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector;
	if (m) {
		return m.call(element, selector);
	}

	return matchFallback_(element, selector);
}

/**
 * Check if an element matches a given selector, using an internal implementation
 * instead of calling existing javascript functions.
 * @param {Element} element
 * @param {string} selector
 * @return {boolean}
 * @private
 */
function matchFallback_(element, selector) {
	var nodes = document.querySelectorAll(selector, element.parentNode);
	for (var i = 0; i < nodes.length; ++i) {
		if (nodes[i] === element) {
			return true;
		}
	}
	return false;
}

/**
 * Returns the next sibling of the given element that matches the specified
 * selector, or null if there is none.
 * @param {!Element} element
 * @param {?string} selector
 */
function next(element, selector) {
	do {
		element = element.nextSibling;
		if (element && match(element, selector)) {
			return element;
		}
	} while (element);
	return null;
}

/**
 * Normalizes the event payload for delegate listeners.
 * @param {!Event} event
 * @private
 */
function normalizeDelegateEvent_(event) {
	event.stopPropagation = stopPropagation_;
	event.stopImmediatePropagation = stopImmediatePropagation_;
}

/**
 * Listens to the specified event on the given DOM element. This function normalizes
 * DOM event payloads and functions so they'll work the same way on all supported
 * browsers.
 * @param {!Element|string} element The DOM element to listen to the event on, or
 *   a selector that should be delegated on the entire document.
 * @param {string} eventName The name of the event to listen to.
 * @param {!function(!Object)} callback Function to be called when the event is
 *   triggered. It will receive the normalized event object.
 * @param {boolean} opt_capture Flag indicating if listener should be triggered
 *   during capture phase, instead of during the bubbling phase. Defaults to false.
 * @return {!DomEventHandle} Can be used to remove the listener.
 */
function on(element, eventName, callback, opt_capture) {
	if ((0, _metal.isString)(element)) {
		return delegate(document, eventName, element, callback);
	}
	var customConfig = customEvents[eventName];
	if (customConfig && customConfig.event) {
		eventName = customConfig.originalEvent;
		callback = customConfig.handler.bind(customConfig, callback);
	}
	element.addEventListener(eventName, callback, opt_capture);
	return new _DomEventHandle2.default(element, eventName, callback, opt_capture);
}

/**
 * Listens to the specified event on the given DOM element once. This
 * function normalizes DOM event payloads and functions so they'll work the
 * same way on all supported browsers.
 * @param {!Element} element The DOM element to listen to the event on.
 * @param {string} eventName The name of the event to listen to.
 * @param {!function(!Object)} callback Function to be called when the event
 *   is triggered. It will receive the normalized event object.
 * @return {!DomEventHandle} Can be used to remove the listener.
 */
function once(element, eventName, callback) {
	var domEventHandle = on(element, eventName, function () {
		domEventHandle.removeListener();
		return callback.apply(this, arguments);
	});
	return domEventHandle;
}

/**
 * Gets the first parent from the given element that matches the specified
 * selector, or null if none match.
 * @param {!Element} element
 * @param {string} selector
 * @return {Element}
 */
function parent(element, selector) {
	return closest(element.parentNode, selector);
}

/**
 * Registers a custom event.
 * @param {string} eventName The name of the custom event.
 * @param {!Object} customConfig An object with information about how the event
 *   should be handled.
 */
function registerCustomEvent(eventName, customConfig) {
	customEvents[eventName] = customConfig;
}

/**
 * Removes all the child nodes on a DOM node.
 * @param {Element} node Element to remove children from.
 */
function removeChildren(node) {
	var child = void 0;
	while (child = node.firstChild) {
		node.removeChild(child);
	}
}

/**
 * Removes the requested CSS classes from an element.
 * @param {!Element|!NodeList} elements The element or elements to remove CSS classes from.
 * @param {string} classes CSS classes to remove.
 */
function removeClasses(elements, classes) {
	if (!(0, _metal.isObject)(elements) || !(0, _metal.isString)(classes)) {
		return;
	}

	if (!elements.length) {
		elements = [elements];
	}

	for (var i = 0; i < elements.length; i++) {
		if ('classList' in elements[i]) {
			removeClassesWithNative_(elements[i], classes);
		} else {
			removeClassesWithoutNative_(elements[i], classes);
		}
	}
}

/**
 * Removes the requested CSS classes from an element using classList.
 * @param {!Element} element The element to remove CSS classes from.
 * @param {string} classes CSS classes to remove.
 * @private
 */
function removeClassesWithNative_(element, classes) {
	classes.split(' ').forEach(function (className) {
		if (className) {
			element.classList.remove(className);
		}
	});
}

/**
 * Removes the requested CSS classes from an element without using classList.
 * @param {!Element} element The element to remove CSS classes from.
 * @param {string} classes CSS classes to remove.
 * @private
 */
function removeClassesWithoutNative_(element, classes) {
	var elementClassName = ' ' + element.className + ' ';

	classes = classes.split(' ');

	for (var i = 0; i < classes.length; i++) {
		elementClassName = elementClassName.replace(' ' + classes[i] + ' ', ' ');
	}

	element.className = elementClassName.trim();
}

/**
 * Replaces the first element with the second.
 * @param {Element} element1
 * @param {Element} element2
 */
function replace(element1, element2) {
	if (element1 && element2 && element1 !== element2 && element1.parentNode) {
		element1.parentNode.insertBefore(element2, element1);
		element1.parentNode.removeChild(element1);
	}
}

/**
 * The function that replaces `stopImmediatePropagation_` for events.
 * @private
 */
function stopImmediatePropagation_() {
	var event = this; // eslint-disable-line
	event.stopped = true;
	event.stoppedImmediate = true;
	Event.prototype.stopImmediatePropagation.call(event);
}

/**
 * The function that replaces `stopPropagation` for events.
 * @private
 */
function stopPropagation_() {
	var event = this; // eslint-disable-line
	event.stopped = true;
	Event.prototype.stopPropagation.call(event);
}

/**
 * Checks if the given element supports the given event type.
 * @param {!Element|string} element The DOM element or element tag name to check.
 * @param {string} eventName The name of the event to check.
 * @return {boolean}
 */
function supportsEvent(element, eventName) {
	if (customEvents[eventName]) {
		return true;
	}

	if ((0, _metal.isString)(element)) {
		if (!elementsByTag_[element]) {
			elementsByTag_[element] = document.createElement(element);
		}
		element = elementsByTag_[element];
	}

	var tag = element.tagName;
	if (!supportCache_[tag] || !supportCache_[tag].hasOwnProperty(eventName)) {
		supportCache_[tag] = supportCache_[tag] || {};
		supportCache_[tag][eventName] = 'on' + eventName in element;
	}
	return supportCache_[tag][eventName];
}

/**
 * This triggers all default matched delegated listeners of a given event type.
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 * @param {!Event} event
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerDefaultDelegatedListeners_(defFns, event) {
	var ret = true;

	for (var i = 0; i < defFns.length && !event.defaultPrevented; i++) {
		event.delegateTarget = defFns[i].element;
		ret &= defFns[i].fn(event);
	}

	return ret;
}

/**
 * This triggers all matched delegated listeners of a given event type when its
 * delegated target is able to interact.
 * @param {!Element} container
 * @param {!Event} event
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerDelegatedListeners_(container, event, defaultFns) {
	var ret = true;
	var currElement = event.target;
	var limit = container.parentNode;

	while (currElement && currElement !== limit && !event.stopped) {
		if (isAbleToInteractWith_(currElement, event.type, event)) {
			event.delegateTarget = currElement;
			ret &= triggerElementListeners_(currElement, event, defaultFns);
			ret &= triggerSelectorListeners_(container, currElement, event, defaultFns);
		}
		currElement = currElement.parentNode;
	}

	return ret;
}

/**
 * Converts the given argument to a DOM element. Strings are assumed to
 * be selectors, and so a matched element will be returned. If the arg
 * is already a DOM element it will be the return value.
 * @param {string|Element|Document} selectorOrElement
 * @return {Element} The converted element, or null if none was found.
 */
function toElement(selectorOrElement) {
	if ((0, _metal.isElement)(selectorOrElement) || (0, _metal.isDocument)(selectorOrElement) || (0, _metal.isDocumentFragment)(selectorOrElement)) {
		return selectorOrElement;
	} else if ((0, _metal.isString)(selectorOrElement)) {
		if (selectorOrElement[0] === '#' && selectorOrElement.indexOf(' ') === -1) {
			return document.getElementById(selectorOrElement.substr(1));
		} else {
			return document.querySelector(selectorOrElement);
		}
	} else {
		return null;
	}
}

/**
 * Adds or removes one or more classes from an element. If any of the classes
 * is present, it will be removed from the element, or added otherwise.
 * @param {!Element} element The element which classes will be toggled.
 * @param {string} classes The classes which have to added or removed from the element.
 */
function toggleClasses(element, classes) {
	if (!(0, _metal.isObject)(element) || !(0, _metal.isString)(classes)) {
		return;
	}

	if ('classList' in element) {
		toggleClassesWithNative_(element, classes);
	} else {
		toggleClassesWithoutNative_(element, classes);
	}
}

/**
 * Adds or removes one or more classes from an element using classList.
 * If any of the classes is present, it will be removed from the element,
 * or added otherwise.
 * @param {!Element} element The element which classes will be toggled.
 * @param {string} classes The classes which have to added or removed from the element.
 * @private
 */
function toggleClassesWithNative_(element, classes) {
	classes.split(' ').forEach(function (className) {
		element.classList.toggle(className);
	});
}

/**
 * Adds or removes one or more classes from an element without using classList.
 * If any of the classes is present, it will be removed from the element,
 * or added otherwise.
 * @param {!Element} element The element which classes will be toggled.
 * @param {string} classes The classes which have to added or removed from the element.
 * @private
 */
function toggleClassesWithoutNative_(element, classes) {
	var elementClassName = ' ' + element.className + ' ';

	classes = classes.split(' ');

	for (var i = 0; i < classes.length; i++) {
		var className = ' ' + classes[i] + ' ';
		var classIndex = elementClassName.indexOf(className);

		if (classIndex === -1) {
			elementClassName = '' + elementClassName + classes[i] + ' ';
		} else {
			var before = elementClassName.substring(0, classIndex);
			var after = elementClassName.substring(classIndex + className.length);
			elementClassName = before + ' ' + after;
		}
	}

	element.className = elementClassName.trim();
}

/**
 * Triggers all listeners for the given event type that are stored in the
 * specified element.
 * @param {!Element} element
 * @param {!Event} event
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerElementListeners_(element, event, defaultFns) {
	var lastContainer = event[LAST_CONTAINER];
	if (!(0, _metal.isDef)(lastContainer) || !contains(lastContainer, element)) {
		var listeners = _domData2.default.get(element, 'listeners', {})[event.type];
		return triggerListeners_(listeners, event, element, defaultFns);
	}
	return true;
}

/**
 * Triggers the specified event on the given element.
 * NOTE: This should mostly be used for testing, not on real code.
 * @param {!Element} element The node that should trigger the event.
 * @param {string} eventName The name of the event to be triggred.
 * @param {Object=} opt_eventObj An object with data that should be on the
 *   triggered event's payload.
 */
function triggerEvent(element, eventName, opt_eventObj) {
	if (isAbleToInteractWith_(element, eventName, opt_eventObj)) {
		var eventObj = document.createEvent('HTMLEvents');
		eventObj.initEvent(eventName, true, true);
		_metal.object.mixin(eventObj, opt_eventObj);
		element.dispatchEvent(eventObj);
	}
}

/**
 * Triggers the given listeners array.
 * @param {Array<!function()>} listeners
 * @param {!Event} event
 * @param {!Element} element
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerListeners_(listeners, event, element, defaultFns) {
	var ret = true;
	listeners = listeners || [];
	for (var i = 0; i < listeners.length && !event.stoppedImmediate; i++) {
		if (listeners[i].defaultListener_) {
			defaultFns.push({
				element: element,
				fn: listeners[i]
			});
		} else {
			ret &= listeners[i](event);
		}
	}
	return ret;
}

/**
 * Triggers all selector listeners for the given event.
 * @param {!Element} container
 * @param {!Element} element
 * @param {!Event} event
 * @param {!Array} defaultFns Array to collect default listeners in, instead
 *     of running them.
 * @return {boolean} False if at least one of the triggered callbacks returns
 *     false, or true otherwise.
 * @private
 */
function triggerSelectorListeners_(container, element, event, defaultFns) {
	var ret = true;
	var data = _domData2.default.get(container, 'delegating', {});
	var map = data[event.type].selectors;
	var selectors = Object.keys(map);
	for (var i = 0; i < selectors.length && !event.stoppedImmediate; i++) {
		if (match(element, selectors[i])) {
			var listeners = map[selectors[i]];
			ret &= triggerListeners_(listeners, event, element, defaultFns);
		}
	}
	return ret;
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(19);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(7);

var _domData = __webpack_require__(13);

var _domData2 = _interopRequireDefault(_domData);

var _metalEvents = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This is a special EventHandle, that is responsible for dom delegated events
 * (only the ones that receive a target element, not a selector string).
 * @extends {EventHandle}
 */
var DomDelegatedEventHandle = function (_EventHandle) {
	_inherits(DomDelegatedEventHandle, _EventHandle);

	/**
  * The constructor for `DomDelegatedEventHandle`.
  * @param {!Event} emitter Element the event was subscribed to.
  * @param {string} event The name of the event that was subscribed to.
  * @param {!Function} listener The listener subscribed to the event.
  * @param {string=} opt_selector An optional selector used when delegating
  *     the event.
  * @constructor
  */
	function DomDelegatedEventHandle(emitter, event, listener, opt_selector) {
		_classCallCheck(this, DomDelegatedEventHandle);

		var _this = _possibleConstructorReturn(this, (DomDelegatedEventHandle.__proto__ || Object.getPrototypeOf(DomDelegatedEventHandle)).call(this, emitter, event, listener));

		_this.selector_ = opt_selector;
		return _this;
	}

	/**
  * @inheritDoc
  */


	_createClass(DomDelegatedEventHandle, [{
		key: 'removeListener',
		value: function removeListener() {
			var delegating = _domData2.default.get(this.emitter_, 'delegating', {});
			var listeners = _domData2.default.get(this.emitter_, 'listeners', {});
			var selector = this.selector_;
			var arr = (0, _metal.isString)(selector) ? delegating[this.event_].selectors : listeners;
			var key = (0, _metal.isString)(selector) ? selector : this.event_;

			_metal.array.remove(arr[key] || [], this.listener_);
			if (arr[key] && arr[key].length === 0) {
				delete arr[key];
			}
		}
	}]);

	return DomDelegatedEventHandle;
}(_metalEvents.EventHandle);

exports.default = DomDelegatedEventHandle;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(10);

var _EventHandle = __webpack_require__(21);

var _EventHandle2 = _interopRequireDefault(_EventHandle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var singleArray_ = [0];

/**
 * EventEmitter utility.
 * @constructor
 * @extends {Disposable}
 */

var EventEmitter = function (_Disposable) {
	_inherits(EventEmitter, _Disposable);

	function EventEmitter() {
		_classCallCheck(this, EventEmitter);

		/**
   * Holds event listeners scoped by event type.
   * @type {Object<string, !Array<!function()>>}
   * @protected
   */
		var _this = _possibleConstructorReturn(this, (EventEmitter.__proto__ || Object.getPrototypeOf(EventEmitter)).call(this));

		_this.events_ = null;

		/**
   * Handlers that are triggered when an event is listened to.
   * @type {Array}
   */
		_this.listenerHandlers_ = null;

		/**
   * Configuration option which determines if an event facade should be sent
   * as a param of listeners when emitting events. If set to true, the facade
   * will be passed as the first argument of the listener.
   * @type {boolean}
   * @protected
   */
		_this.shouldUseFacade_ = false;
		return _this;
	}

	/**
  * Adds a handler to given holder variable. If the holder doesn't have a
  * value yet, it will receive the handler directly. If the holder is an array,
  * the value will just be added to it. Otherwise, the holder will be set to a
  * new array containing its previous value plus the new handler.
  * @param {*} holder
  * @param {!function()|Object} handler
  * @return {*} The holder's new value.
  * @protected
  */


	_createClass(EventEmitter, [{
		key: 'addHandler_',
		value: function addHandler_(holder, handler) {
			if (!holder) {
				holder = handler;
			} else {
				if (!Array.isArray(holder)) {
					holder = [holder];
				}
				holder.push(handler);
			}
			return holder;
		}

		/**
   * Adds a listener to the end of the listeners array for the specified events.
   * @param {!(Array|string)} event
   * @param {!Function} listener
   * @param {boolean} opt_default Flag indicating if this listener is a default
   *   action for this event. Default actions are run last, and only if no previous
   *   listener call `preventDefault()` on the received event facade.
   * @return {!EventHandle} Can be used to remove the listener.
   */

	}, {
		key: 'addListener',
		value: function addListener(event, listener, opt_default) {
			this.validateListener_(listener);

			var events = this.toEventsArray_(event);
			for (var i = 0; i < events.length; i++) {
				this.addSingleListener_(events[i], listener, opt_default);
			}

			return new _EventHandle2.default(this, event, listener);
		}

		/**
   * Adds a listener to the end of the listeners array for a single event.
   * @param {string} event
   * @param {!Function} listener
   * @param {boolean} opt_default Flag indicating if this listener is a default
   *   action for this event. Default actions are run last, and only if no previous
   *   listener call `preventDefault()` on the received event facade.
   * @return {!EventHandle} Can be used to remove the listener.
   * @param {Function=} opt_origin The original function that was added as a
   *   listener, if there is any.
   * @protected
   */

	}, {
		key: 'addSingleListener_',
		value: function addSingleListener_(event, listener, opt_default, opt_origin) {
			this.runListenerHandlers_(event);
			if (opt_default || opt_origin) {
				listener = {
					default: opt_default,
					fn: listener,
					origin: opt_origin
				};
			}
			this.events_ = this.events_ || {};
			this.events_[event] = this.addHandler_(this.events_[event], listener);
		}

		/**
   * Builds facade for the given event.
   * @param {string} event
   * @return {Object}
   * @protected
   */

	}, {
		key: 'buildFacade_',
		value: function buildFacade_(event) {
			if (this.getShouldUseFacade()) {
				var facade = {
					preventDefault: function preventDefault() {
						facade.preventedDefault = true;
					},
					target: this,
					type: event
				};
				return facade;
			}
		}

		/**
   * Disposes of this instance's object references.
   * @override
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.events_ = null;
		}

		/**
   * Execute each of the listeners in order with the supplied arguments.
   * @param {string} event
   * @param {*} opt_args [arg1], [arg2], [...]
   * @return {boolean} Returns true if event had listeners, false otherwise.
   */

	}, {
		key: 'emit',
		value: function emit(event) {
			var listeners = this.getRawListeners_(event);
			if (listeners.length === 0) {
				return false;
			}

			var args = _metal.array.slice(arguments, 1);
			this.runListeners_(listeners, args, this.buildFacade_(event));
			return true;
		}

		/**
   * Gets the listener objects for the given event, if there are any.
   * @param {string} event
   * @return {!Array}
   * @protected
   */

	}, {
		key: 'getRawListeners_',
		value: function getRawListeners_(event) {
			var directListeners = toArray(this.events_ && this.events_[event]);
			return directListeners.concat(toArray(this.events_ && this.events_['*']));
		}

		/**
   * Gets the configuration option which determines if an event facade should
   * be sent as a param of listeners when emitting events. If set to true, the
   * facade will be passed as the first argument of the listener.
   * @return {boolean}
   */

	}, {
		key: 'getShouldUseFacade',
		value: function getShouldUseFacade() {
			return this.shouldUseFacade_;
		}

		/**
   * Returns an array of listeners for the specified event.
   * @param {string} event
   * @return {Array} Array of listeners.
   */

	}, {
		key: 'listeners',
		value: function listeners(event) {
			return this.getRawListeners_(event).map(function (listener) {
				return listener.fn ? listener.fn : listener;
			});
		}

		/**
   * Adds a listener that will be invoked a fixed number of times for the
   * events. After each event is triggered the specified amount of times, the
   * listener is removed for it.
   * @param {!(Array|string)} event
   * @param {number} amount The amount of times this event should be listened
   * to.
   * @param {!Function} listener
   * @return {!EventHandle} Can be used to remove the listener.
   */

	}, {
		key: 'many',
		value: function many(event, amount, listener) {
			var events = this.toEventsArray_(event);
			for (var i = 0; i < events.length; i++) {
				this.many_(events[i], amount, listener);
			}

			return new _EventHandle2.default(this, event, listener);
		}

		/**
   * Adds a listener that will be invoked a fixed number of times for a single
   * event. After the event is triggered the specified amount of times, the
   * listener is removed.
   * @param {string} event
   * @param {number} amount The amount of times this event should be listened
   * to.
   * @param {!Function} listener
   * @protected
   */

	}, {
		key: 'many_',
		value: function many_(event, amount, listener) {
			var self = this;

			if (amount <= 0) {
				return;
			}

			function handlerInternal() {
				if (--amount === 0) {
					self.removeListener(event, handlerInternal);
				}
				listener.apply(self, arguments);
			}

			self.addSingleListener_(event, handlerInternal, false, listener);
		}

		/**
   * Checks if a listener object matches the given listener function. To match,
   * it needs to either point to that listener or have it as its origin.
   * @param {!Object} listenerObj
   * @param {!Function} listener
   * @return {boolean}
   * @protected
   */

	}, {
		key: 'matchesListener_',
		value: function matchesListener_(listenerObj, listener) {
			var fn = listenerObj.fn || listenerObj;
			return fn === listener || listenerObj.origin && listenerObj.origin === listener;
		}

		/**
   * Removes a listener for the specified events.
   * Caution: changes array indices in the listener array behind the listener.
   * @param {!(Array|string)} events
   * @param {!Function} listener
   * @return {!Object} Returns emitter, so calls can be chained.
   */

	}, {
		key: 'off',
		value: function off(event, listener) {
			this.validateListener_(listener);
			if (!this.events_) {
				return this;
			}

			var events = this.toEventsArray_(event);
			for (var i = 0; i < events.length; i++) {
				this.events_[events[i]] = this.removeMatchingListenerObjs_(toArray(this.events_[events[i]]), listener);
			}

			return this;
		}

		/**
   * Adds a listener to the end of the listeners array for the specified events.
   * @param {!(Array|string)} events
   * @param {!Function} listener
   * @return {!EventHandle} Can be used to remove the listener.
   */

	}, {
		key: 'on',
		value: function on() {
			return this.addListener.apply(this, arguments);
		}

		/**
   * Adds handler that gets triggered when an event is listened to on this
   * instance.
   * @param {!function()}
   */

	}, {
		key: 'onListener',
		value: function onListener(handler) {
			this.listenerHandlers_ = this.addHandler_(this.listenerHandlers_, handler);
		}

		/**
   * Adds a one time listener for the events. This listener is invoked only the
   * next time each event is fired, after which it is removed.
   * @param {!(Array|string)} events
   * @param {!Function} listener
   * @return {!EventHandle} Can be used to remove the listener.
   */

	}, {
		key: 'once',
		value: function once(events, listener) {
			return this.many(events, 1, listener);
		}

		/**
   * Removes all listeners, or those of the specified events. It's not a good
   * idea to remove listeners that were added elsewhere in the code,
   * especially when it's on an emitter that you didn't create.
   * @param {(Array|string)=} opt_events
   * @return {!Object} Returns emitter, so calls can be chained.
   */

	}, {
		key: 'removeAllListeners',
		value: function removeAllListeners(opt_events) {
			if (this.events_) {
				if (opt_events) {
					var events = this.toEventsArray_(opt_events);
					for (var i = 0; i < events.length; i++) {
						this.events_[events[i]] = null;
					}
				} else {
					this.events_ = null;
				}
			}
			return this;
		}

		/**
   * Removes all listener objects from the given array that match the given
   * listener function.
   * @param {Array.<Object>} listenerObjs
   * @param {!Function} listener
   * @return {Array.<Object>|Object} The new listeners array for this event.
   * @protected
   */

	}, {
		key: 'removeMatchingListenerObjs_',
		value: function removeMatchingListenerObjs_(listenerObjs, listener) {
			var finalListeners = [];
			for (var i = 0; i < listenerObjs.length; i++) {
				if (!this.matchesListener_(listenerObjs[i], listener)) {
					finalListeners.push(listenerObjs[i]);
				}
			}
			return finalListeners.length > 0 ? finalListeners : null;
		}

		/**
   * Removes a listener for the specified events.
   * Caution: changes array indices in the listener array behind the listener.
   * @param {!(Array|string)} events
   * @param {!Function} listener
   * @return {!Object} Returns emitter, so calls can be chained.
   */

	}, {
		key: 'removeListener',
		value: function removeListener() {
			return this.off.apply(this, arguments);
		}

		/**
   * Runs the handlers when an event is listened to.
   * @param {string} event
   * @protected
   */

	}, {
		key: 'runListenerHandlers_',
		value: function runListenerHandlers_(event) {
			var handlers = this.listenerHandlers_;
			if (handlers) {
				handlers = toArray(handlers);
				for (var i = 0; i < handlers.length; i++) {
					handlers[i](event);
				}
			}
		}

		/**
   * Runs the given listeners.
   * @param {!Array} listeners
   * @param {!Array} args
   * @param (Object) facade
   * @protected
   */

	}, {
		key: 'runListeners_',
		value: function runListeners_(listeners, args, facade) {
			if (facade) {
				args.push(facade);
			}

			var defaultListeners = [];
			for (var i = 0; i < listeners.length; i++) {
				var listener = listeners[i].fn || listeners[i];
				if (listeners[i].default) {
					defaultListeners.push(listener);
				} else {
					listener.apply(this, args);
				}
			}
			if (!facade || !facade.preventedDefault) {
				for (var j = 0; j < defaultListeners.length; j++) {
					defaultListeners[j].apply(this, args);
				}
			}
		}

		/**
   * Sets the configuration option which determines if an event facade should
   * be sent as a param of listeners when emitting events. If set to true, the
   * facade will be passed as the first argument of the listener.
   * @param {boolean} shouldUseFacade
   * @return {!Object} Returns emitter, so calls can be chained.
   */

	}, {
		key: 'setShouldUseFacade',
		value: function setShouldUseFacade(shouldUseFacade) {
			this.shouldUseFacade_ = shouldUseFacade;
			return this;
		}

		/**
   * Converts the parameter to an array if only one event is given. Reuses the
   * same array each time this conversion is done, to avoid using more memory
   * than necessary.
   * @param  {!(Array|string)} events
   * @return {!Array}
   * @protected
   */

	}, {
		key: 'toEventsArray_',
		value: function toEventsArray_(events) {
			if ((0, _metal.isString)(events)) {
				singleArray_[0] = events;
				events = singleArray_;
			}
			return events;
		}

		/**
   * Checks if the given listener is valid, throwing an exception when it's not.
   * @param  {*} listener
   * @protected
   */

	}, {
		key: 'validateListener_',
		value: function validateListener_(listener) {
			if (!(0, _metal.isFunction)(listener)) {
				throw new TypeError('Listener must be a function');
			}
		}
	}]);

	return EventEmitter;
}(_metal.Disposable);

function toArray(val) {
	val = val || [];
	return Array.isArray(val) ? val : [val];
}

exports.default = EventEmitter;

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(20);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventEmitterProxy utility. It's responsible for linking two EventEmitter
 * instances together, emitting events from the first emitter through the
 * second one. That means that listening to a supported event on the target
 * emitter will mean listening to it on the origin emitter as well.
 * @param {EventEmitter} originEmitter Events originated on this emitter
 *   will be fired for the target emitter's listeners as well.
 * @param {EventEmitter} targetEmitter Event listeners attached to this emitter
 *   will also be triggered when the event is fired by the origin emitter.
 * @param {Object} opt_blacklist Optional blacklist of events that should not be
 *   proxied.
 * @constructor
 * @extends {Disposable}
 */
var EventEmitterProxy = function (_Disposable) {
	_inherits(EventEmitterProxy, _Disposable);

	function EventEmitterProxy(originEmitter, targetEmitter, opt_blacklist, opt_whitelist) {
		_classCallCheck(this, EventEmitterProxy);

		/**
   * Map of events that should not be proxied.
   * @type {Object}
   * @protected
   */
		var _this = _possibleConstructorReturn(this, (EventEmitterProxy.__proto__ || Object.getPrototypeOf(EventEmitterProxy)).call(this));

		_this.blacklist_ = opt_blacklist;

		/**
   * The origin emitter. This emitter's events will be proxied through the
   * target emitter.
   * @type {EventEmitter}
   * @protected
   */
		_this.originEmitter_ = originEmitter;

		/**
   * A list of events that are pending to be listened by an actual origin
   * emitter. Events are stored here when the origin doesn't exist, so they
   * can be set on a new origin when one is set.
   * @type {Array}
   * @protected
   */
		_this.pendingEvents_ = null;

		/**
   * Holds a map of events from the origin emitter that are already being proxied.
   * @type {Object<string, !EventHandle>}
   * @protected
   */
		_this.proxiedEvents_ = null;

		/**
   * The target emitter. This emitter will emit all events that come from
   * the origin emitter.
   * @type {EventEmitter}
   * @protected
   */
		_this.targetEmitter_ = targetEmitter;

		/**
   * Map of events that should be proxied. If whitelist is set blacklist is ignored.
   * @type {Object}
   * @protected
   */
		_this.whitelist_ = opt_whitelist;

		_this.startProxy_();
		return _this;
	}

	/**
  * Adds the given listener for the given event.
  * @param {string} event
  * @param {!function()} listener
  * @return {!EventHandle} The listened event's handle.
  * @protected
  */


	_createClass(EventEmitterProxy, [{
		key: 'addListener_',
		value: function addListener_(event, listener) {
			return this.originEmitter_.on(event, listener);
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.removeListeners_();
			this.proxiedEvents_ = null;
			this.originEmitter_ = null;
			this.targetEmitter_ = null;
		}

		/**
   * Emits the specified event type on the target emitter.
   * @protected
   */

	}, {
		key: 'emitOnTarget_',
		value: function emitOnTarget_() {
			this.targetEmitter_.emit.apply(this.targetEmitter_, arguments);
		}

		/**
   * Proxies the given event from the origin to the target emitter.
   * @param {string} event
   */

	}, {
		key: 'proxyEvent',
		value: function proxyEvent(event) {
			if (this.shouldProxyEvent_(event)) {
				this.tryToAddListener_(event);
			}
		}

		/**
   * Removes the proxy listener for all events.
   * @protected
   */

	}, {
		key: 'removeListeners_',
		value: function removeListeners_() {
			if (this.proxiedEvents_) {
				var events = Object.keys(this.proxiedEvents_);
				for (var i = 0; i < events.length; i++) {
					this.proxiedEvents_[events[i]].removeListener();
				}
				this.proxiedEvents_ = null;
			}
			this.pendingEvents_ = null;
		}

		/**
   * Changes the origin emitter. This automatically detaches any events that
   * were already being proxied from the previous emitter, and starts proxying
   * them on the new emitter instead.
   * @param {!EventEmitter} originEmitter
   */

	}, {
		key: 'setOriginEmitter',
		value: function setOriginEmitter(originEmitter) {
			var _this2 = this;

			var events = this.originEmitter_ && this.proxiedEvents_ ? Object.keys(this.proxiedEvents_) : this.pendingEvents_;
			this.originEmitter_ = originEmitter;
			if (events) {
				this.removeListeners_();
				events.forEach(function (event) {
					return _this2.proxyEvent(event);
				});
			}
		}

		/**
   * Checks if the given event should be proxied.
   * @param {string} event
   * @return {boolean}
   * @protected
   */

	}, {
		key: 'shouldProxyEvent_',
		value: function shouldProxyEvent_(event) {
			if (this.whitelist_ && !this.whitelist_[event]) {
				return false;
			}
			if (this.blacklist_ && this.blacklist_[event]) {
				return false;
			}
			return !this.proxiedEvents_ || !this.proxiedEvents_[event];
		}

		/**
   * Starts proxying all events from the origin to the target emitter.
   * @protected
   */

	}, {
		key: 'startProxy_',
		value: function startProxy_() {
			this.targetEmitter_.onListener(this.proxyEvent.bind(this));
		}

		/**
   * Adds a listener to the origin emitter, if it exists. Otherwise, stores
   * the pending listener so it can be used on a future origin emitter.
   * @param {string} event
   * @protected
   */

	}, {
		key: 'tryToAddListener_',
		value: function tryToAddListener_(event) {
			if (this.originEmitter_) {
				this.proxiedEvents_ = this.proxiedEvents_ || {};
				this.proxiedEvents_[event] = this.addListener_(event, this.emitOnTarget_.bind(this, event));
			} else {
				this.pendingEvents_ = this.pendingEvents_ || [];
				this.pendingEvents_.push(event);
			}
		}
	}]);

	return EventEmitterProxy;
}(_metal.Disposable);

exports.default = EventEmitterProxy;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(10);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * EventHandler utility. It's useful for easily removing a group of
 * listeners from different EventEmitter instances.
 * @constructor
 * @extends {Disposable}
 */
var EventHandler = function (_Disposable) {
	_inherits(EventHandler, _Disposable);

	function EventHandler() {
		_classCallCheck(this, EventHandler);

		/**
   * An array that holds the added event handles, so the listeners can be
   * removed later.
   * @type {Array.<EventHandle>}
   * @protected
   */
		var _this = _possibleConstructorReturn(this, (EventHandler.__proto__ || Object.getPrototypeOf(EventHandler)).call(this));

		_this.eventHandles_ = [];
		return _this;
	}

	/**
  * Adds event handles to be removed later through the `removeAllListeners`
  * method.
  * @param {...(!EventHandle)} var_args
  */


	_createClass(EventHandler, [{
		key: 'add',
		value: function add() {
			for (var i = 0; i < arguments.length; i++) {
				this.eventHandles_.push(arguments[i]);
			}
		}

		/**
   * Disposes of this instance's object references.
   * @override
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			this.eventHandles_ = null;
		}

		/**
   * Removes all listeners that have been added through the `add` method.
   */

	}, {
		key: 'removeAllListeners',
		value: function removeAllListeners() {
			for (var i = 0; i < this.eventHandles_.length; i++) {
				this.eventHandles_[i].removeListener();
			}

			this.eventHandles_ = [];
		}
	}]);

	return EventHandler;
}(_metal.Disposable);

exports.default = EventHandler;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _dom = __webpack_require__(4);

var _metalEvents = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * DomEventEmitterProxy utility. It extends `EventEmitterProxy` to also accept
 * dom elements as origin emitters.
 * @extends {EventEmitterProxy}
 */
var DomEventEmitterProxy = function (_EventEmitterProxy) {
	_inherits(DomEventEmitterProxy, _EventEmitterProxy);

	function DomEventEmitterProxy() {
		_classCallCheck(this, DomEventEmitterProxy);

		return _possibleConstructorReturn(this, (DomEventEmitterProxy.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy)).apply(this, arguments));
	}

	_createClass(DomEventEmitterProxy, [{
		key: 'addListener_',

		/**
   * Adds the given listener for the given event.
   * @param {string} event
   * @param {!function()} listener
   * @return {!EventHandle} The listened event's handle.
   * @protected
   * @override
   */
		value: function addListener_(event, listener) {
			if (this.originEmitter_.addEventListener) {
				if (this.isDelegateEvent_(event)) {
					var index = event.indexOf(':', 9);
					var eventName = event.substring(9, index);
					var selector = event.substring(index + 1);
					return (0, _dom.delegate)(this.originEmitter_, eventName, selector, listener);
				} else {
					return (0, _dom.on)(this.originEmitter_, event, listener);
				}
			} else {
				return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'addListener_', this).call(this, event, listener);
			}
		}

		/**
   * Checks if the given event is of the delegate type.
   * @param {string} event
   * @return {boolean}
   * @protected
   */

	}, {
		key: 'isDelegateEvent_',
		value: function isDelegateEvent_(event) {
			return event.substr(0, 9) === 'delegate:';
		}

		/**
   * Checks if the given event is supported by the origin element.
   * @param {string} event
   * @protected
   */

	}, {
		key: 'isSupportedDomEvent_',
		value: function isSupportedDomEvent_(event) {
			if (!this.originEmitter_ || !this.originEmitter_.addEventListener) {
				return true;
			}
			return this.isDelegateEvent_(event) && event.indexOf(':', 9) !== -1 || (0, _dom.supportsEvent)(this.originEmitter_, event);
		}

		/**
   * Checks if the given event should be proxied.
   * @param {string} event
   * @return {boolean}
   * @protected
   * @override
   */

	}, {
		key: 'shouldProxyEvent_',
		value: function shouldProxyEvent_(event) {
			return _get(DomEventEmitterProxy.prototype.__proto__ || Object.getPrototypeOf(DomEventEmitterProxy.prototype), 'shouldProxyEvent_', this).call(this, event) && this.isSupportedDomEvent_(event);
		}
	}]);

	return DomEventEmitterProxy;
}(_metalEvents.EventEmitterProxy);

exports.default = DomEventEmitterProxy;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(7);

var _dom = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility functions for running javascript code in the global scope.
 */
var globalEval = function () {
	function globalEval() {
		_classCallCheck(this, globalEval);
	}

	_createClass(globalEval, null, [{
		key: 'run',

		/**
   * Evaluates the given string in the global scope.
   * @param {string} text
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   * @return {Element} script
   */
		value: function run(text, opt_appendFn) {
			var script = document.createElement('script');
			script.text = text;
			if (opt_appendFn) {
				opt_appendFn(script);
			} else {
				document.head.appendChild(script);
			}
			(0, _dom.exitDocument)(script);
			return script;
		}

		/**
   * Evaluates the given javascript file in the global scope.
   * @param {string} src The file's path.
   * @param {function()=} opt_callback Optional function to be called
   *   when the script has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   * @return {Element} script
   */

	}, {
		key: 'runFile',
		value: function runFile(src, opt_callback, opt_appendFn) {
			var script = document.createElement('script');
			script.src = src;

			var callback = function callback() {
				(0, _dom.exitDocument)(script);
				opt_callback && opt_callback();
			};
			(0, _dom.once)(script, 'load', callback);
			(0, _dom.once)(script, 'error', callback);

			if (opt_appendFn) {
				opt_appendFn(script);
			} else {
				document.head.appendChild(script);
			}

			return script;
		}

		/**
   * Evaluates the code referenced by the given script element.
   * @param {!Element} script
   * @param {function()=} opt_callback Optional function to be called
   *   when the script has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   * @return {Element} script
   */

	}, {
		key: 'runScript',
		value: function runScript(script, opt_callback, opt_appendFn) {
			var callback = function callback() {
				opt_callback && opt_callback();
			};
			if (script.type && script.type !== 'text/javascript') {
				_metal.async.nextTick(callback);
				return;
			}
			(0, _dom.exitDocument)(script);
			if (script.src) {
				return globalEval.runFile(script.src, opt_callback, opt_appendFn);
			} else {
				_metal.async.nextTick(callback);
				return globalEval.run(script.text, opt_appendFn);
			}
		}

		/**
   * Evaluates any script tags present in the given element.
   * @param {!Element} element
   * @param {function()=} opt_callback Optional function to be called
   *   when the script has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   */

	}, {
		key: 'runScriptsInElement',
		value: function runScriptsInElement(element, opt_callback, opt_appendFn) {
			var scripts = element.querySelectorAll('script');
			if (scripts.length) {
				globalEval.runScriptsInOrder(scripts, 0, opt_callback, opt_appendFn);
			} else if (opt_callback) {
				_metal.async.nextTick(opt_callback);
			}
		}

		/**
   * Runs the given scripts elements in the order that they appear.
   * @param {!NodeList} scripts
   * @param {number} index
   * @param {function()=} opt_callback Optional function to be called
   *   when the script has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   */

	}, {
		key: 'runScriptsInOrder',
		value: function runScriptsInOrder(scripts, index, opt_callback, opt_appendFn) {
			globalEval.runScript(scripts.item(index), function () {
				if (index < scripts.length - 1) {
					globalEval.runScriptsInOrder(scripts, index + 1, opt_callback, opt_appendFn);
				} else if (opt_callback) {
					_metal.async.nextTick(opt_callback);
				}
			}, opt_appendFn);
		}
	}]);

	return globalEval;
}();

exports.default = globalEval;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(7);

var _dom = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Utility functions for running styles.
 */
var globalEvalStyles = function () {
	function globalEvalStyles() {
		_classCallCheck(this, globalEvalStyles);
	}

	_createClass(globalEvalStyles, null, [{
		key: 'run',

		/**
   * Evaluates the given style.
   * @param {string} text
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   * @return {Element} style
   */
		value: function run(text, opt_appendFn) {
			var style = document.createElement('style');
			style.innerHTML = text;
			if (opt_appendFn) {
				opt_appendFn(style);
			} else {
				document.head.appendChild(style);
			}
			return style;
		}

		/**
   * Evaluates the given style file.
   * @param {string} href The file's path.
   * @param {function()=} opt_callback Optional function to be called
   *   when the styles has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   * @return {Element} style
   */

	}, {
		key: 'runFile',
		value: function runFile(href, opt_callback, opt_appendFn) {
			var link = document.createElement('link');
			link.rel = 'stylesheet';
			link.href = href;
			globalEvalStyles.runStyle(link, opt_callback, opt_appendFn);
			return link;
		}

		/**
   * Evaluates the code referenced by the given style/link element.
   * @param {!Element} style
   * @param {function()=} opt_callback Optional function to be called
   *   when the script has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   *  @return {Element} style
   */

	}, {
		key: 'runStyle',
		value: function runStyle(style, opt_callback, opt_appendFn) {
			var callback = function callback() {
				opt_callback && opt_callback();
			};
			if (style.rel && style.rel !== 'stylesheet') {
				_metal.async.nextTick(callback);
				return;
			}

			if (style.tagName === 'STYLE') {
				_metal.async.nextTick(callback);
			} else {
				(0, _dom.once)(style, 'load', callback);
				(0, _dom.once)(style, 'error', callback);
			}

			if (opt_appendFn) {
				opt_appendFn(style);
			} else {
				document.head.appendChild(style);
			}

			return style;
		}

		/**
   * Evaluates any style present in the given element.
   * @param {!Element} element
   * @param {function()=} opt_callback Optional function to be called when the
   *   style has been run.
   * @param {function()=} opt_appendFn Optional function to append the node
   *   into document.
   */

	}, {
		key: 'runStylesInElement',
		value: function runStylesInElement(element, opt_callback, opt_appendFn) {
			var styles = element.querySelectorAll('style,link');
			if (styles.length === 0 && opt_callback) {
				_metal.async.nextTick(opt_callback);
				return;
			}

			var loadCount = 0;
			var callback = function callback() {
				if (opt_callback && ++loadCount === styles.length) {
					_metal.async.nextTick(opt_callback);
				}
			};
			for (var i = 0; i < styles.length; i++) {
				globalEvalStyles.runStyle(styles[i], callback, opt_appendFn);
			}
		}
	}]);

	return globalEvalStyles;
}();

exports.default = globalEvalStyles;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _dom = __webpack_require__(4);

var _features = __webpack_require__(23);

var _features2 = _interopRequireDefault(_features);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mouseEventMap = {
	mouseenter: 'mouseover',
	mouseleave: 'mouseout',
	pointerenter: 'pointerover',
	pointerleave: 'pointerout'
};
Object.keys(mouseEventMap).forEach(function (eventName) {
	(0, _dom.registerCustomEvent)(eventName, {
		delegate: true,
		handler: function handler(callback, event) {
			var related = event.relatedTarget;
			var target = event.delegateTarget;
			if (!related || related !== target && !(0, _dom.contains)(target, related)) {
				event.customType = eventName;
				return callback(event);
			}
		},
		originalEvent: mouseEventMap[eventName]
	});
});

var animationEventMap = {
	animation: 'animationend',
	transition: 'transitionend'
};
Object.keys(animationEventMap).forEach(function (eventType) {
	var eventName = animationEventMap[eventType];
	(0, _dom.registerCustomEvent)(eventName, {
		event: true,
		delegate: true,
		handler: function handler(callback, event) {
			event.customType = eventName;
			return callback(event);
		},
		originalEvent: _features2.default.checkAnimationEventName()[eventType]
	});
});

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(27);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _metal = __webpack_require__(14);

var _validators = __webpack_require__(26);

var _validators2 = _interopRequireDefault(_validators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sugar api that can be used as an alternative for manually building `State`
 * configuration in the expected format. For example, instead of having
 * something like this:
 *
 * ```js
 * MyClass.STATE = {
 *   foo: {
 *     required: true,
 *     validator: validators.number,
 *     value: 13
 *   }
 * };
 * ```
 *
 * You could instead do:
 *
 * ```js
 * MyClass.STATE = {
 *   foo: Config.required().number().value(13)
 * };
 * ```
 */
var Config = {
	/**
 * An object that contains a validator function.
 * @typedef {!Object} ConfigWithValidator
 */

	/**
  * Function that creates `State` object with an `any` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	any: setPrimitiveValidators('any'),

	/**
  * Function that creates `State` object with an `array` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	array: setPrimitiveValidators('array'),

	/**
  * Function that creates `State` object with an `arrayOf` validator.
  * @param {ConfigWithValidator} stateConfig `State` configuration object
  * @return {ConfigWithValidator} `State` configuration object.
  */
	arrayOf: setNestedValidators('arrayOf'),

	/**
  * Function that creates `State` object with a `bool` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	bool: setPrimitiveValidators('bool'),

	/**
  * Function that creates `State` object with a `func` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	func: setPrimitiveValidators('func'),

	/**
  * Function that creates `State` object with an `instanceOf` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	instanceOf: setExplicitValueValidators('instanceOf'),

	/**
  * Function that creates `State` object with a `number` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	number: setPrimitiveValidators('number'),

	/**
  * Function that creates `State` object with an `object` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	object: setPrimitiveValidators('object'),

	/**
  * Function that creates `State` object with an `objectOf` validator.
  * @param {ConfigWithValidator} stateConfig `State` configuration object
  * @return {ConfigWithValidator} `State` configuration object.
  */
	objectOf: setNestedValidators('objectOf'),

	/**
  * Function that creates `State` object with an `oneOf` validator.
  * @param {!Array} values `State` configuration object
  * @return {ConfigWithValidator} `State` configuration object.
  */
	oneOf: setExplicitValueValidators('oneOf'),

	/**
  * Creates `State` configuration object with an `oneOfType` validator.
  * @param {ConfigWithValidator[]} validatorArray Array of `State` configuration objects.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	oneOfType: function oneOfType(validatorArray) {
		validatorArray = validatorArray.map(function (configObj) {
			return configObj.config.validator;
		});

		return this.validator(_validators2.default.oneOfType(validatorArray));
	},


	/**
  * Creates `State` configuration object with a `shapeOf` validator.
  * @param {!Object.<string, ConfigWithValidator>} shapeObj Values being `State` configuration objects.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	shapeOf: function shapeOf(shapeObj) {
		shapeObj = destructShapeOfConfigs(shapeObj);

		return this.validator(_validators2.default.shapeOf(shapeObj));
	},


	/**
  * Function that creates `State` object with an `string` validator.
  * @return {ConfigWithValidator} `State` configuration object.
  */
	string: setPrimitiveValidators('string'),

	/**
  * Adds the `internal` flag to the `State` configuration.
  * @param {boolean} required Flag to set "internal" to. True by default.
  * @return {!Object} `State` configuration object.
  */
	internal: function internal() {
		var _internal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

		return mergeConfig(this, {
			internal: _internal
		});
	},


	/**
  * Adds the `required` flag to the `State` configuration.
  * @param {boolean} required Flag to set "required" to. True by default.
  * @return {!Object} `State` configuration object.
  */
	required: function required() {
		var _required = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

		return mergeConfig(this, {
			required: _required
		});
	},


	/**
  * Adds a setter to the `State` configuration.
  * @param {!function()} setter
  * @return {!Object} `State` configuration object.
  */
	setter: function setter(_setter) {
		return mergeConfig(this, {
			setter: _setter
		});
	},


	/**
  * Adds a validator to the `State` configuration.
  * @param {!function()} validator
  * @return {!Object} `State` configuration object.
  */
	validator: function validator(_validator) {
		return mergeConfig(this, {
			validator: _validator
		});
	},


	/**
  * Adds a default value to the `State` configuration.
  * @param {*} value
  * @return {!Object} `State` configuration object.
  */
	value: function value(_value) {
		return mergeConfig(this, {
			value: _value
		});
	},


	/**
  * Adds a valueFn that will return a default value for the `State` configuration.
  * @param {!function()} valueFn
  * @return {!Object} `State` configuration object.
  */
	valueFn: function valueFn(_valueFn) {
		return mergeConfig(this, {
			valueFn: _valueFn
		});
	}
};

/**
 * Recursively sets validators for shapeOf.
 * @param {!Object} shape The shape of specific types.
 * @return {!Object} Shape object with validators as values.
 */
function destructShapeOfConfigs(shape) {
	var keys = Object.keys(shape);

	var retShape = {};

	keys.forEach(function (key) {
		var value = shape[key];

		retShape[key] = value.config && value.config.validator ? value.config.validator : destructShapeOfConfigs(value);
	});

	return retShape;
}

/**
 * Merges the given config object into the one that has been built so far.
 * @param {!Object} context The object calling this function.
 * @param {!Object} config The object to merge to the built config.
 * @return {!Object} The final object containing the built config.
 */
function mergeConfig(context, config) {
	var obj = context;
	if (obj === Config) {
		obj = Object.create(Config);
		obj.config = {};
	}
	_metal.object.mixin(obj.config, config);
	return obj;
}

/**
* Calls validators with provided argument.
* @param {string} name The name of the validator.
* @param {!function()}
*/
function setExplicitValueValidators(name) {
	return function (arg) {
		return this.validator(_validators2.default[name](arg));
	};
}

/**
* Calls validators with a single nested config.
* @param {string} name The name of the validator.
* @return {!function()}
*/
function setNestedValidators(name) {
	return function (arg) {
		return this.validator(_validators2.default[name](arg.config.validator));
	};
}

/**
* Adds primitive type validators to the config object.
* @param {string} name The name of the validator.
* @return {!function()}
*/
function setPrimitiveValidators(name) {
	return function () {
		return this.validator(_validators2.default[name]);
	};
}

exports.default = Config;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _metal = __webpack_require__(14);

var _metalEvents = __webpack_require__(8);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * State adds support for having object properties that can be watched for
 * changes, as well as configured with validators, setters and other options.
 * See the `configState` method for a complete list of available configuration
 * options for each state key.
 * @extends {EventEmitter}
 */
var State = function (_EventEmitter) {
	_inherits(State, _EventEmitter);

	/**
  * Constructor function for `State`.
  * @param {Object=} opt_config Optional config object with initial values to
  *     set state properties to.
  * @param {Object=} opt_obj Optional object that should hold the state
  *     properties. If none is given, they will be added directly to `this`
  *     instead.
  * @param {Object=} opt_context Optional context to call functions (like
  *     validators and setters) on. Defaults to `this`.
  */
	function State(opt_config, opt_obj, opt_context) {
		_classCallCheck(this, State);

		/**
   * Context to call functions (like validators and setters) on.
   * @type {!Object}
   * @protected
   */
		var _this = _possibleConstructorReturn(this, (State.__proto__ || Object.getPrototypeOf(State)).call(this));

		_this.context_ = opt_context || _this;

		/**
   * Map of keys that can not be used as state keys.
   * @type {Object<string, boolean>}
   * @protected
   */
		_this.keysBlacklist_ = null;

		/**
   * Object that should hold the state properties.
   * @type {!Object}
   * @protected
   */
		_this.obj_ = opt_obj || _this;

		_this.eventData_ = null;

		/**
   * Object with information about the batch event that is currently
   * scheduled, or null if none is.
   * @type {Object}
   * @protected
   */
		_this.scheduledBatchData_ = null;

		/**
   * Object that contains information about all this instance's state keys.
   * @type {!Object<string, !Object>}
   * @protected
   */
		_this.stateInfo_ = {};

		_this.stateConfigs_ = {};

		_this.initialValues_ = _metal.object.mixin({}, opt_config);

		_this.setShouldUseFacade(true);
		_this.configStateFromStaticHint_();

		Object.defineProperty(_this.obj_, State.STATE_REF_KEY, {
			configurable: true,
			enumerable: false,
			value: _this
		});
		return _this;
	}

	/**
  * Logs an error if the given property is required but wasn't given.
  * @param {string} name
  * @protected
  */


	_createClass(State, [{
		key: 'assertGivenIfRequired_',
		value: function assertGivenIfRequired_(name) {
			var config = this.stateConfigs_[name];
			if (config.required) {
				var info = this.getStateInfo(name);
				var value = info.state === State.KeyStates.INITIALIZED ? this.get(name) : this.initialValues_[name];
				if (!(0, _metal.isDefAndNotNull)(value)) {
					var errorMessage = 'The property called "' + name + '" is required but didn\'t receive a value.';
					if (this.shouldThrowValidationError()) {
						throw new Error(errorMessage);
					} else {
						console.error(errorMessage);
					}
				}
			}
		}

		/**
   * Logs an error if the `validatorReturn` is instance of `Error`.
   * @param {*} validatorReturn
   * @protected
   */

	}, {
		key: 'assertValidatorReturnInstanceOfError_',
		value: function assertValidatorReturnInstanceOfError_(validatorReturn) {
			if (validatorReturn instanceof Error) {
				if (this.shouldThrowValidationError()) {
					throw validatorReturn;
				} else {
					console.error('Warning: ' + validatorReturn);
				}
			}
		}

		/**
   * Checks that the given name is a valid state key name. If it's not, an error
   * will be thrown.
   * @param {string} name The name to be validated.
   * @throws {Error}
   * @protected
   */

	}, {
		key: 'assertValidStateKeyName_',
		value: function assertValidStateKeyName_(name) {
			if (this.keysBlacklist_ && this.keysBlacklist_[name]) {
				throw new Error('It\'s not allowed to create a state key with the name "' + name + '".');
			}
		}

		/**
   * Builds the property definition object for the specified state key.
   * @param {string} name The name of the key.
   * @return {!Object}
   * @protected
   */

	}, {
		key: 'buildKeyPropertyDef_',
		value: function buildKeyPropertyDef_(name) {
			return {
				configurable: true,
				enumerable: true,
				get: function get() {
					return this[State.STATE_REF_KEY].getStateKeyValue_(name);
				},
				set: function set(val) {
					this[State.STATE_REF_KEY].setStateKeyValue_(name, val);
				}
			};
		}

		/**
   * Calls the requested function, running the appropriate code for when it's
   * passed as an actual function object or just the function's name.
   * @param {!Function|string} fn Function, or name of the function to run.
   * @param {!Array} An optional array of parameters to be passed to the
   *   function that will be called.
   * @return {*} The return value of the called function.
   * @protected
   */

	}, {
		key: 'callFunction_',
		value: function callFunction_(fn, args) {
			if ((0, _metal.isString)(fn)) {
				return this.context_[fn].apply(this.context_, args);
			} else if ((0, _metal.isFunction)(fn)) {
				return fn.apply(this.context_, args);
			}
		}

		/**
   * Calls the state key's setter, if there is one.
   * @param {string} name The name of the key.
   * @param {*} value The value to be set.
   * @param {*} currentValue The current value.
   * @return {*} The final value to be set.
   * @protected
   */

	}, {
		key: 'callSetter_',
		value: function callSetter_(name, value, currentValue) {
			var config = this.stateConfigs_[name];
			if (config.setter) {
				value = this.callFunction_(config.setter, [value, currentValue]);
			}
			return value;
		}

		/**
   * Calls the state key's validator, if there is one. Emits console
   * warning if validator returns a string.
   * @param {string} name The name of the key.
   * @param {*} value The value to be validated.
   * @return {boolean} Flag indicating if value is valid or not.
   * @protected
   */

	}, {
		key: 'callValidator_',
		value: function callValidator_(name, value) {
			var config = this.stateConfigs_[name];
			if (config.validator) {
				var validatorReturn = this.callFunction_(config.validator, [value, name, this.context_]);
				this.assertValidatorReturnInstanceOfError_(validatorReturn);
				return validatorReturn;
			}
			return true;
		}

		/**
   * Checks if the it's allowed to write on the requested state key.
   * @param {string} name The name of the key.
   * @return {boolean}
   */

	}, {
		key: 'canSetState',
		value: function canSetState(name) {
			var info = this.getStateInfo(name);
			return !this.stateConfigs_[name].writeOnce || !info.written;
		}

		/**
   * Adds the given key(s) to the state, together with its(their) configs.
   * Config objects support the given settings:
   *     required - When set to `true`, causes errors to be printed (via
   *     `console.error`) if no value is given for the property.
   *
   *     setter - Function for normalizing state key values. It receives the new
   *     value that was set, and returns the value that should be stored.
   *
   *     validator - Function that validates state key values. When it returns
   *     false, the new value is ignored. When it returns an instance of Error,
   *     it will emit the error to the console.
   *
   *     value - The default value for the state key. Note that setting this to
   *     an object will cause all class instances to use the same reference to
   *     the object. To have each instance use a different reference for objects,
   *     use the `valueFn` option instead.
   *
   *     valueFn - A function that returns the default value for a state key.
   *
   *     writeOnce - Ignores writes to the state key after it's been first
   *     written to. That is, allows writes only when setting the value for the
   *     first time.
   * @param {!Object.<string, !Object>|string} configs An object that maps
   *     configuration options for keys to be added to the state.
   * @param {boolean|Object|*=} opt_context The context where the added state
   *     keys will be defined (defaults to `this`), or false if they shouldn't
   *     be defined at all.
   */

	}, {
		key: 'configState',
		value: function configState(configs, opt_context) {
			var names = Object.keys(configs);
			if (names.length === 0) {
				return;
			}

			if (opt_context !== false) {
				var props = {};
				for (var i = 0; i < names.length; i++) {
					var name = names[i];
					this.assertValidStateKeyName_(name);
					props[name] = this.buildKeyPropertyDef_(name);
				}
				Object.defineProperties(opt_context || this.obj_, props);
			}

			this.stateConfigs_ = configs;
			for (var _i = 0; _i < names.length; _i++) {
				var _name = names[_i];
				configs[_name] = configs[_name].config ? configs[_name].config : configs[_name];
				this.assertGivenIfRequired_(names[_i]);
				this.validateInitialValue_(names[_i]);
			}
		}

		/**
   * Adds state keys from super classes static hint `MyClass.STATE = {};`.
   * @param {Object.<string, !Object>=} opt_config An object that maps all the
   *     configurations for state keys.
   * @protected
   */

	}, {
		key: 'configStateFromStaticHint_',
		value: function configStateFromStaticHint_() {
			var ctor = this.constructor;
			if (ctor !== State) {
				var defineContext = void 0;
				if (this.obj_ === this) {
					defineContext = ctor.hasConfiguredState_ ? false : ctor.prototype;
					ctor.hasConfiguredState_ = true;
				}
				this.configState(State.getStateStatic(ctor), defineContext);
			}
		}

		/**
   * @inheritDoc
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {
			_get(State.prototype.__proto__ || Object.getPrototypeOf(State.prototype), 'disposeInternal', this).call(this);
			this.initialValues_ = null;
			this.stateInfo_ = null;
			this.stateConfigs_ = null;
			this.scheduledBatchData_ = null;
		}

		/**
   * Emits the state change batch event.
   * @protected
   */

	}, {
		key: 'emitBatchEvent_',
		value: function emitBatchEvent_() {
			if (!this.isDisposed()) {
				var data = this.scheduledBatchData_;
				this.scheduledBatchData_ = null;
				this.context_.emit('stateChanged', data);
			}
		}

		/**
   * Returns the value of the requested state key.
   * Note: this can and should be accomplished by accessing the value as a
   * regular property. This should only be used in cases where a function is
   * actually needed.
   * @param {string} name
   * @return {*}
   */

	}, {
		key: 'get',
		value: function get(name) {
			return this.obj_[name];
		}

		/**
   * Returns an object that maps state keys to their values.
   * @param {Array<string>=} opt_names A list of names of the keys that should
   *   be returned. If none is given, the whole state will be returned.
   * @return {Object.<string, *>}
   */

	}, {
		key: 'getState',
		value: function getState(opt_names) {
			var state = {};
			var names = opt_names || this.getStateKeys();

			for (var i = 0; i < names.length; i++) {
				state[names[i]] = this.get(names[i]);
			}

			return state;
		}

		/**
   * Gets information about the specified state property.
   * @param {string} name
   * @return {!Object}
   */

	}, {
		key: 'getStateInfo',
		value: function getStateInfo(name) {
			if (!this.stateInfo_[name]) {
				this.stateInfo_[name] = {};
			}
			return this.stateInfo_[name];
		}

		/**
   * Gets the config object for the requested state key.
   * @param {string} name The key's name.
   * @return {Object}
   * @protected
   */

	}, {
		key: 'getStateKeyConfig',
		value: function getStateKeyConfig(name) {
			return this.stateConfigs_ ? this.stateConfigs_[name] : null;
		}

		/**
   * Returns an array with all state keys.
   * @return {!Array.<string>}
   */

	}, {
		key: 'getStateKeys',
		value: function getStateKeys() {
			return this.stateConfigs_ ? Object.keys(this.stateConfigs_) : [];
		}

		/**
   * Gets the value of the specified state key. This is passed as that key's
   * getter to the `Object.defineProperty` call inside the `addKeyToState` method.
   * @param {string} name The name of the key.
   * @return {*}
   * @protected
   */

	}, {
		key: 'getStateKeyValue_',
		value: function getStateKeyValue_(name) {
			if (!this.warnIfDisposed_(name)) {
				this.initStateKey_(name);
				return this.getStateInfo(name).value;
			}
		}

		/**
   * Merges the STATE static variable for the given constructor function.
   * @param  {!Function} ctor Constructor function.
   * @return {boolean} Returns true if merge happens, false otherwise.
   * @static
   */

	}, {
		key: 'hasBeenSet',


		/**
   * Checks if the value of the state key with the given name has already been
   * set. Note that this doesn't run the key's getter.
   * @param {string} name The name of the key.
   * @return {boolean}
   */
		value: function hasBeenSet(name) {
			var info = this.getStateInfo(name);
			return info.state === State.KeyStates.INITIALIZED || this.hasInitialValue_(name);
		}

		/**
   * Checks if an initial value was given to the specified state property.
   * @param {string} name The name of the key.
   * @return {boolean}
   * @protected
   */

	}, {
		key: 'hasInitialValue_',
		value: function hasInitialValue_(name) {
			return this.initialValues_.hasOwnProperty(name);
		}

		/**
   * Checks if the given key is present in this instance's state.
   * @param {string} key
   * @return {boolean}
   */

	}, {
		key: 'hasStateKey',
		value: function hasStateKey(key) {
			if (!this.warnIfDisposed_(key)) {
				return !!this.stateConfigs_[key];
			}
		}

		/**
   * Informs of changes to a state key's value through an event. Won't trigger
   * the event if the value hasn't changed or if it's being initialized.
   * @param {string} name The name of the key.
   * @param {*} prevVal The previous value of the key.
   * @protected
   */

	}, {
		key: 'informChange_',
		value: function informChange_(name, prevVal) {
			if (this.shouldInformChange_(name, prevVal)) {
				var data = _metal.object.mixin({
					key: name,
					newVal: this.get(name),
					prevVal: prevVal
				}, this.eventData_);
				this.context_.emit(name + 'Changed', data);
				this.context_.emit('stateKeyChanged', data);
				this.scheduleBatchEvent_(data);
			}
		}

		/**
   * Initializes the specified state key, giving it a first value.
   * @param {string} name The name of the key.
   * @protected
   */

	}, {
		key: 'initStateKey_',
		value: function initStateKey_(name) {
			var info = this.getStateInfo(name);
			if (info.state !== State.KeyStates.UNINITIALIZED) {
				return;
			}

			info.state = State.KeyStates.INITIALIZING;
			this.setInitialValue_(name);
			if (!info.written) {
				this.setDefaultValue(name);
			}
			info.state = State.KeyStates.INITIALIZED;
		}

		/**
   * Merges two values for the STATE property into a single object.
   * @param {Object} mergedVal
   * @param {Object} currVal
   * @return {!Object} The merged value.
   * @static
   */

	}, {
		key: 'removeStateKey',


		/**
   * Removes the requested state key.
   * @param {string} name The name of the key.
   */
		value: function removeStateKey(name) {
			this.stateInfo_[name] = null;
			this.stateConfigs_[name] = null;
			delete this.obj_[name];
		}

		/**
   * Schedules a state change batch event to be emitted asynchronously.
   * @param {!Object} changeData Information about a state key's update.
   * @protected
   */

	}, {
		key: 'scheduleBatchEvent_',
		value: function scheduleBatchEvent_(changeData) {
			if (!this.scheduledBatchData_) {
				_metal.async.nextTick(this.emitBatchEvent_, this);
				this.scheduledBatchData_ = _metal.object.mixin({
					changes: {}
				}, this.eventData_);
			}

			var name = changeData.key;
			var changes = this.scheduledBatchData_.changes;
			if (changes[name]) {
				changes[name].newVal = changeData.newVal;
			} else {
				changes[name] = changeData;
			}
		}

		/**
   * Sets the value of the requested state key.
   * Note: this can and should be accomplished by setting the state key as a
   * regular property. This should only be used in cases where a function is
   * actually needed.
   * @param {string} name
   * @param {*} value
   * @return {*}
   */

	}, {
		key: 'set',
		value: function set(name, value) {
			if (this.hasStateKey(name)) {
				this.obj_[name] = value;
			}
		}

		/**
   * Sets the default value of the requested state key.
   * @param {string} name The name of the key.
   * @return {*}
   */

	}, {
		key: 'setDefaultValue',
		value: function setDefaultValue(name) {
			var config = this.stateConfigs_[name];

			if (config.value !== undefined) {
				this.set(name, config.value);
			} else {
				this.set(name, this.callFunction_(config.valueFn));
			}
		}

		/**
   * Sets data to be sent with all events emitted from this instance.
   * @param {Object}
   */

	}, {
		key: 'setEventData',
		value: function setEventData(data) {
			this.eventData_ = data;
		}

		/**
   * Sets the initial value of the requested state key.
   * @param {string} name The name of the key.
   * @return {*}
   * @protected
   */

	}, {
		key: 'setInitialValue_',
		value: function setInitialValue_(name) {
			if (this.hasInitialValue_(name)) {
				this.set(name, this.initialValues_[name]);
				this.initialValues_[name] = undefined;
			}
		}

		/**
   * Sets a map of keys that are not valid state keys.
   * @param {!Object<string, boolean>}
   */

	}, {
		key: 'setKeysBlacklist',
		value: function setKeysBlacklist(blacklist) {
			this.keysBlacklist_ = blacklist;
		}

		/**
   * Sets the value of all the specified state keys.
   * @param {!Object.<string,*>} values A map of state keys to the values they
   *   should be set to.
   * @param {function()=} opt_callback An optional function that will be run
   *   after the next batched update is triggered.
   */

	}, {
		key: 'setState',
		value: function setState(values, opt_callback) {
			var _this2 = this;

			Object.keys(values).forEach(function (name) {
				return _this2.set(name, values[name]);
			});
			if (opt_callback && this.scheduledBatchData_) {
				this.context_.once('stateChanged', opt_callback);
			}
		}

		/**
   * Sets the value of the specified state key. This is passed as that key's
   * setter to the `Object.defineProperty` call inside the `addKeyToState`
   * method.
   * @param {string} name The name of the key.
   * @param {*} value The new value of the key.
   * @protected
   */

	}, {
		key: 'setStateKeyValue_',
		value: function setStateKeyValue_(name, value) {
			if (this.warnIfDisposed_(name) || !this.canSetState(name) || !this.validateKeyValue_(name, value)) {
				return;
			}

			var prevVal = this.get(name);
			var info = this.getStateInfo(name);
			info.value = this.callSetter_(name, value, prevVal);
			this.assertGivenIfRequired_(name);
			info.written = true;
			this.informChange_(name, prevVal);
		}

		/**
   * Checks if we should inform about a state update. Updates are ignored during
   * state initialization. Otherwise, updates to primitive values are only
   * informed when the new value is different from the previous one. Updates to
   * objects (which includes functions and arrays) are always informed outside
   * initialization though, since we can't be sure if all of the internal data
   * has stayed the same.
   * @param {string} name The name of the key.
   * @param {*} prevVal The previous value of the key.
   * @return {boolean}
   * @protected
   */

	}, {
		key: 'shouldInformChange_',
		value: function shouldInformChange_(name, prevVal) {
			var info = this.getStateInfo(name);
			return info.state === State.KeyStates.INITIALIZED && ((0, _metal.isObject)(prevVal) || prevVal !== this.get(name));
		}

		/**
   * Returns a boolean that determines whether or not should throw error when
   * vaildator functions returns an `Error` instance.
   * @return {boolean} By default returns false.
   */

	}, {
		key: 'shouldThrowValidationError',
		value: function shouldThrowValidationError() {
			return false;
		}

		/**
   * Validates the initial value for the state property with the given name.
   * @param {string} name
   * @protected
   */

	}, {
		key: 'validateInitialValue_',
		value: function validateInitialValue_(name) {
			if (this.hasInitialValue_(name) && !this.callValidator_(name, this.initialValues_[name])) {
				delete this.initialValues_[name];
			}
		}

		/**
   * Validates the state key's value, which includes calling the validator
   * defined in the key's configuration object, if there is one.
   * @param {string} name The name of the key.
   * @param {*} value The value to be validated.
   * @return {boolean} Flag indicating if value is valid or not.
   * @protected
   */

	}, {
		key: 'validateKeyValue_',
		value: function validateKeyValue_(name, value) {
			var info = this.getStateInfo(name);
			return info.state === State.KeyStates.INITIALIZING || this.callValidator_(name, value);
		}

		/**
   * Warns if this instance has already been disposed.
   * @param {string} name Name of the property to be accessed if not disposed.
   * @return {boolean} True if disposed, or false otherwise.
   * @protected
   */

	}, {
		key: 'warnIfDisposed_',
		value: function warnIfDisposed_(name) {
			var disposed = this.isDisposed();
			if (disposed) {
				console.warn('Error. Trying to access property "' + name + '" on disposed instance');
			}
			return disposed;
		}
	}], [{
		key: 'getStateStatic',
		value: function getStateStatic(ctor) {
			return (0, _metal.getStaticProperty)(ctor, 'STATE', State.mergeState);
		}
	}, {
		key: 'mergeState',
		value: function mergeState(mergedVal, currVal) {
			return _metal.object.mixin({}, currVal, mergedVal);
		}
	}]);

	return State;
}(_metalEvents.EventEmitter);

State.STATE_REF_KEY = '__METAL_STATE_REF_KEY__';

/**
 * Constants that represent the states that a state key can be in.
 * @type {!Object}
 */
State.KeyStates = {
	UNINITIALIZED: undefined,
	INITIALIZING: 1,
	INITIALIZED: 2
};

exports.default = State;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _metal = __webpack_require__(5);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The component registry is used to register components, so they can
 * be accessible by name.
 * @type {Object}
 */
var ComponentRegistry = function () {
	function ComponentRegistry() {
		_classCallCheck(this, ComponentRegistry);
	}

	_createClass(ComponentRegistry, null, [{
		key: 'getConstructor',

		/**
   * Gets the constructor function for the given component name, or
   * undefined if it hasn't been registered yet.
   * @param {string} name The component's name.
   * @return {?function()}
   * @static
   */
		value: function getConstructor(name) {
			var constructorFn = ComponentRegistry.components_[name];
			if (!constructorFn) {
				console.error('There\'s no constructor registered for the component named ' + name + '.\n\t\t\t\tComponents need to be registered via ComponentRegistry.register.');
			}
			return constructorFn;
		}

		/**
   * Registers a component, so it can be found by its name.
   * @param {!Function} constructorFn The component's constructor function.
   * @param {string=} opt_name Name of the registered component. If none is given
   *   the name defined by the NAME static variable will be used instead. If that
   *   isn't set as well, the name of the constructor function will be used.
   * @static
   */

	}, {
		key: 'register',
		value: function register(constructorFn, opt_name) {
			var name = opt_name;
			if (!name) {
				if (constructorFn.hasOwnProperty('NAME')) {
					name = constructorFn.NAME;
				} else {
					name = (0, _metal.getFunctionName)(constructorFn);
				}
			}
			constructorFn.NAME = name;
			ComponentRegistry.components_[name] = constructorFn;
		}
	}]);

	return ComponentRegistry;
}();

/**
 * Holds all registered components, indexed by their names.
 * @type {!Object<string, function()>}
 * @protected
 * @static
 */


ComponentRegistry.components_ = {};

exports.default = ComponentRegistry;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var require;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

__webpack_require__(29);

(function () {
  this.CLOSURE_NO_DEPS = true;
  this.goog = this.goog || {};

  // Copyright 2006 The Closure Library Authors. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS-IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  /**
   * @fileoverview Bootstrap for the Google JS Library (Closure).
   *
   * In uncompiled mode base.js will write out Closure's deps file, unless the
   * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
   * include their own deps file(s) from different locations.
   *
   * @author arv@google.com (Erik Arvidsson)
   *
   * @provideGoog
   */

  /**
   * @define {boolean} Overridden to true by the compiler when
   *     --process_closure_primitives is specified.
   */
  var COMPILED = false;

  /**
   * Base namespace for the Closure library.  Checks to see goog is already
   * defined in the current scope before assigning to prevent clobbering if
   * base.js is loaded more than once.
   *
   * @const
   */
  var goog = this.goog || {};

  /**
   * Reference to the global context.  In most cases this will be 'window'.
   */
  goog.global = this;

  /**
   * A hook for overriding the define values in uncompiled mode.
   *
   * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
   * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
   * {@code goog.define} will use the value instead of the default value.  This
   * allows flags to be overwritten without compilation (this is normally
   * accomplished with the compiler's "define" flag).
   *
   * Example:
   * <pre>
   *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
   * </pre>
   *
   * @type {Object<string, (string|number|boolean)>|undefined}
   */
  goog.global.CLOSURE_UNCOMPILED_DEFINES;

  /**
   * A hook for overriding the define values in uncompiled or compiled mode,
   * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
   * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
   *
   * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
   * string literals or the compiler will emit an error.
   *
   * While any @define value may be set, only those set with goog.define will be
   * effective for uncompiled code.
   *
   * Example:
   * <pre>
   *   var CLOSURE_DEFINES = {'goog.DEBUG': false} ;
   * </pre>
   *
   * @type {Object<string, (string|number|boolean)>|undefined}
   */
  goog.global.CLOSURE_DEFINES;

  /**
   * Returns true if the specified value is not undefined.
   * WARNING: Do not use this to test if an object has a property. Use the in
   * operator instead.
   *
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is defined.
   */
  goog.isDef = function (val) {
    // void 0 always evaluates to undefined and hence we do not need to depend on
    // the definition of the global variable named 'undefined'.
    return val !== void 0;
  };

  /**
   * Builds an object structure for the provided namespace path, ensuring that
   * names that already exist are not overwritten. For example:
   * "a.b.c" -> a = {};a.b={};a.b.c={};
   * Used by goog.provide and goog.exportSymbol.
   * @param {string} name name of the object that this file defines.
   * @param {*=} opt_object the object to expose at the end of the path.
   * @param {Object=} opt_objectToExportTo The object to add the path to; default
   *     is |goog.global|.
   * @private
   */
  goog.exportPath_ = function (name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || goog.global;

    // Internet Explorer exhibits strange behavior when throwing errors from
    // methods externed in this manner.  See the testExportSymbolExceptions in
    // base_test.html for an example.
    if (!(parts[0] in cur) && cur.execScript) {
      cur.execScript('var ' + parts[0]);
    }

    // Certain browsers cannot parse code in the form for((a in b); c;);
    // This pattern is produced by the JSCompiler when it collapses the
    // statement above into the conditional loop below. To prevent this from
    // happening, use a for-loop and reserve the init logic as below.

    // Parentheses added to eliminate strict JS warning in Firefox.
    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length && goog.isDef(opt_object)) {
        // last part and we have an object; use it
        cur[part] = opt_object;
      } else if (cur[part]) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
  };

  /**
   * Defines a named value. In uncompiled mode, the value is retrieved from
   * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
   * has the property specified, and otherwise used the defined defaultValue.
   * When compiled the default can be overridden using the compiler
   * options or the value set in the CLOSURE_DEFINES object.
   *
   * @param {string} name The distinguished name to provide.
   * @param {string|number|boolean} defaultValue
   */
  goog.define = function (name, defaultValue) {
    var value = defaultValue;
    if (!COMPILED) {
      if (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
        value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
      } else if (goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, name)) {
        value = goog.global.CLOSURE_DEFINES[name];
      }
    }
    goog.exportPath_(name, value);
  };

  /**
   * @define {boolean} DEBUG is provided as a convenience so that debugging code
   * that should not be included in a production js_binary can be easily stripped
   * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
   * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
   * because they are generally used for debugging purposes and it is difficult
   * for the JSCompiler to statically determine whether they are used.
   */
  goog.define('goog.DEBUG', true);

  /**
   * @define {string} LOCALE defines the locale being used for compilation. It is
   * used to select locale specific data to be compiled in js binary. BUILD rule
   * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
   * option.
   *
   * Take into account that the locale code format is important. You should use
   * the canonical Unicode format with hyphen as a delimiter. Language must be
   * lowercase, Language Script - Capitalized, Region - UPPERCASE.
   * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
   *
   * See more info about locale codes here:
   * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
   *
   * For language codes you should use values defined by ISO 693-1. See it here
   * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
   * this rule: the Hebrew language. For legacy reasons the old code (iw) should
   * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
   */
  goog.define('goog.LOCALE', 'en'); // default to en


  /**
   * @define {boolean} Whether this code is running on trusted sites.
   *
   * On untrusted sites, several native functions can be defined or overridden by
   * external libraries like Prototype, Datejs, and JQuery and setting this flag
   * to false forces closure to use its own implementations when possible.
   *
   * If your JavaScript can be loaded by a third party site and you are wary about
   * relying on non-standard implementations, specify
   * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
   */
  goog.define('goog.TRUSTED_SITE', true);

  /**
   * @define {boolean} Whether a project is expected to be running in strict mode.
   *
   * This define can be used to trigger alternate implementations compatible with
   * running in EcmaScript Strict mode or warn about unavailable functionality.
   * @see https://goo.gl/g5EoHI
   *
   */
  goog.define('goog.STRICT_MODE_COMPATIBLE', false);

  /**
   * @define {boolean} Whether code that calls {@link goog.setTestOnly} should
   *     be disallowed in the compilation unit.
   */
  goog.define('goog.DISALLOW_TEST_ONLY_CODE', COMPILED && !goog.DEBUG);

  /**
   * @define {boolean} Whether to use a Chrome app CSP-compliant method for
   *     loading scripts via goog.require. @see appendScriptSrcNode_.
   */
  goog.define('goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING', false);

  /**
   * Defines a namespace in Closure.
   *
   * A namespace may only be defined once in a codebase. It may be defined using
   * goog.provide() or goog.module().
   *
   * The presence of one or more goog.provide() calls in a file indicates
   * that the file defines the given objects/namespaces.
   * Provided symbols must not be null or undefined.
   *
   * In addition, goog.provide() creates the object stubs for a namespace
   * (for example, goog.provide("goog.foo.bar") will create the object
   * goog.foo.bar if it does not already exist).
   *
   * Build tools also scan for provide/require/module statements
   * to discern dependencies, build dependency files (see deps.js), etc.
   *
   * @see goog.require
   * @see goog.module
   * @param {string} name Namespace provided by this file in the form
   *     "goog.package.part".
   */
  goog.provide = function (name) {
    if (!COMPILED) {
      // Ensure that the same namespace isn't provided twice.
      // A goog.module/goog.provide maps a goog.require to a specific file
      if (goog.isProvided_(name)) {
        throw Error('Namespace "' + name + '" already declared.');
      }
    }

    goog.constructNamespace_(name);
  };

  /**
   * @param {string} name Namespace provided by this file in the form
   *     "goog.package.part".
   * @param {Object=} opt_obj The object to embed in the namespace.
   * @private
   */
  goog.constructNamespace_ = function (name, opt_obj) {
    if (!COMPILED) {
      delete goog.implicitNamespaces_[name];

      var namespace = name;
      while (namespace = namespace.substring(0, namespace.lastIndexOf('.'))) {
        if (goog.getObjectByName(namespace)) {
          break;
        }
        goog.implicitNamespaces_[namespace] = true;
      }
    }

    goog.exportPath_(name, opt_obj);
  };

  /**
   * Module identifier validation regexp.
   * Note: This is a conservative check, it is very possible to be more lenient,
   *   the primary exclusion here is "/" and "\" and a leading ".", these
   *   restrictions are intended to leave the door open for using goog.require
   *   with relative file paths rather than module identifiers.
   * @private
   */
  goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;

  /**
   * Defines a module in Closure.
   *
   * Marks that this file must be loaded as a module and claims the namespace.
   *
   * A namespace may only be defined once in a codebase. It may be defined using
   * goog.provide() or goog.module().
   *
   * goog.module() has three requirements:
   * - goog.module may not be used in the same file as goog.provide.
   * - goog.module must be the first statement in the file.
   * - only one goog.module is allowed per file.
   *
   * When a goog.module annotated file is loaded, it is enclosed in
   * a strict function closure. This means that:
   * - any variables declared in a goog.module file are private to the file
   * (not global), though the compiler is expected to inline the module.
   * - The code must obey all the rules of "strict" JavaScript.
   * - the file will be marked as "use strict"
   *
   * NOTE: unlike goog.provide, goog.module does not declare any symbols by
   * itself. If declared symbols are desired, use
   * goog.module.declareLegacyNamespace().
   *
   *
   * See the public goog.module proposal: http://goo.gl/Va1hin
   *
   * @param {string} name Namespace provided by this file in the form
   *     "goog.package.part", is expected but not required.
   */
  goog.module = function (name) {
    if (!goog.isString(name) || !name || name.search(goog.VALID_MODULE_RE_) == -1) {
      throw Error('Invalid module identifier');
    }
    if (!goog.isInModuleLoader_()) {
      throw Error('Module ' + name + ' has been loaded incorrectly.');
    }
    if (goog.moduleLoaderState_.moduleName) {
      throw Error('goog.module may only be called once per module.');
    }

    // Store the module name for the loader.
    goog.moduleLoaderState_.moduleName = name;
    if (!COMPILED) {
      // Ensure that the same namespace isn't provided twice.
      // A goog.module/goog.provide maps a goog.require to a specific file
      if (goog.isProvided_(name)) {
        throw Error('Namespace "' + name + '" already declared.');
      }
      delete goog.implicitNamespaces_[name];
    }
  };

  /**
   * @param {string} name The module identifier.
   * @return {?} The module exports for an already loaded module or null.
   *
   * Note: This is not an alternative to goog.require, it does not
   * indicate a hard dependency, instead it is used to indicate
   * an optional dependency or to access the exports of a module
   * that has already been loaded.
   * @suppress {missingProvide}
   */
  goog.module.get = function (name) {
    return goog.module.getInternal_(name);
  };

  /**
   * @param {string} name The module identifier.
   * @return {?} The module exports for an already loaded module or null.
   * @private
   */
  goog.module.getInternal_ = function (name) {
    if (!COMPILED) {
      if (goog.isProvided_(name)) {
        // goog.require only return a value with-in goog.module files.
        return name in goog.loadedModules_ ? goog.loadedModules_[name] : goog.getObjectByName(name);
      } else {
        return null;
      }
    }
  };

  /**
   * @private {?{moduleName: (string|undefined), declareLegacyNamespace:boolean}}
   */
  goog.moduleLoaderState_ = null;

  /**
   * @private
   * @return {boolean} Whether a goog.module is currently being initialized.
   */
  goog.isInModuleLoader_ = function () {
    return goog.moduleLoaderState_ != null;
  };

  /**
   * Provide the module's exports as a globally accessible object under the
   * module's declared name.  This is intended to ease migration to goog.module
   * for files that have existing usages.
   * @suppress {missingProvide}
   */
  goog.module.declareLegacyNamespace = function () {
    if (!COMPILED && !goog.isInModuleLoader_()) {
      throw new Error('goog.module.declareLegacyNamespace must be called from ' + 'within a goog.module');
    }
    if (!COMPILED && !goog.moduleLoaderState_.moduleName) {
      throw Error('goog.module must be called prior to ' + 'goog.module.declareLegacyNamespace.');
    }
    goog.moduleLoaderState_.declareLegacyNamespace = true;
  };

  /**
   * Marks that the current file should only be used for testing, and never for
   * live code in production.
   *
   * In the case of unit tests, the message may optionally be an exact namespace
   * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
   * provide (if not explicitly defined in the code).
   *
   * @param {string=} opt_message Optional message to add to the error that's
   *     raised when used in production code.
   */
  goog.setTestOnly = function (opt_message) {
    if (goog.DISALLOW_TEST_ONLY_CODE) {
      opt_message = opt_message || '';
      throw Error('Importing test-only code into non-debug environment' + (opt_message ? ': ' + opt_message : '.'));
    }
  };

  if (!COMPILED) {
    /**
     * Check if the given name has been goog.provided. This will return false for
     * names that are available only as implicit namespaces.
     * @param {string} name name of the object to look for.
     * @return {boolean} Whether the name has been provided.
     * @private
     */
    goog.isProvided_ = function (name) {
      return name in goog.loadedModules_ || !goog.implicitNamespaces_[name] && goog.isDefAndNotNull(goog.getObjectByName(name));
    };

    /**
     * Namespaces implicitly defined by goog.provide. For example,
     * goog.provide('goog.events.Event') implicitly declares that 'goog' and
     * 'goog.events' must be namespaces.
     *
     * @type {!Object<string, (boolean|undefined)>}
     * @private
     */
    goog.implicitNamespaces_ = { 'goog.module': true };

    // NOTE: We add goog.module as an implicit namespace as goog.module is defined
    // here and because the existing module package has not been moved yet out of
    // the goog.module namespace. This satisifies both the debug loader and
    // ahead-of-time dependency management.
  }

  /**
   * Returns an object based on its fully qualified external name.  The object
   * is not found if null or undefined.  If you are using a compilation pass that
   * renames property names beware that using this function will not find renamed
   * properties.
   *
   * @param {string} name The fully qualified name.
   * @param {Object=} opt_obj The object within which to look; default is
   *     |goog.global|.
   * @return {?} The value (object or primitive) or, if not found, null.
   */
  goog.getObjectByName = function (name, opt_obj) {
    var parts = name.split('.');
    var cur = opt_obj || goog.global;
    for (var part; part = parts.shift();) {
      if (goog.isDefAndNotNull(cur[part])) {
        cur = cur[part];
      } else {
        return null;
      }
    }
    return cur;
  };

  /**
   * Globalizes a whole namespace, such as goog or goog.lang.
   *
   * @param {!Object} obj The namespace to globalize.
   * @param {Object=} opt_global The object to add the properties to.
   * @deprecated Properties may be explicitly exported to the global scope, but
   *     this should no longer be done in bulk.
   */
  goog.globalize = function (obj, opt_global) {
    var global = opt_global || goog.global;
    for (var x in obj) {
      global[x] = obj[x];
    }
  };

  /**
   * Adds a dependency from a file to the files it requires.
   * @param {string} relPath The path to the js file.
   * @param {!Array<string>} provides An array of strings with
   *     the names of the objects this file provides.
   * @param {!Array<string>} requires An array of strings with
   *     the names of the objects this file requires.
   * @param {boolean|!Object<string>=} opt_loadFlags Parameters indicating
   *     how the file must be loaded.  The boolean 'true' is equivalent
   *     to {'module': 'goog'} for backwards-compatibility.  Valid properties
   *     and values include {'module': 'goog'} and {'lang': 'es6'}.
   */
  goog.addDependency = function (relPath, provides, requires, opt_loadFlags) {
    if (goog.DEPENDENCIES_ENABLED) {
      var provide, require;
      var path = relPath.replace(/\\/g, '/');
      var deps = goog.dependencies_;
      if (!opt_loadFlags || typeof opt_loadFlags === 'boolean') {
        opt_loadFlags = opt_loadFlags ? { 'module': 'goog' } : {};
      }
      for (var i = 0; provide = provides[i]; i++) {
        deps.nameToPath[provide] = path;
        deps.pathIsModule[path] = opt_loadFlags['module'] == 'goog';
      }
      for (var j = 0; require = requires[j]; j++) {
        if (!(path in deps.requires)) {
          deps.requires[path] = {};
        }
        deps.requires[path][require] = true;
      }
    }
  };

  // NOTE(nnaze): The debug DOM loader was included in base.js as an original way
  // to do "debug-mode" development.  The dependency system can sometimes be
  // confusing, as can the debug DOM loader's asynchronous nature.
  //
  // With the DOM loader, a call to goog.require() is not blocking -- the script
  // will not load until some point after the current script.  If a namespace is
  // needed at runtime, it needs to be defined in a previous script, or loaded via
  // require() with its registered dependencies.
  //
  // User-defined namespaces may need their own deps file. For a reference on
  // creating a deps file, see:
  // Externally: https://developers.google.com/closure/library/docs/depswriter
  //
  // Because of legacy clients, the DOM loader can't be easily removed from
  // base.js.  Work is being done to make it disableable or replaceable for
  // different environments (DOM-less JavaScript interpreters like Rhino or V8,
  // for example). See bootstrap/ for more information.


  /**
   * @define {boolean} Whether to enable the debug loader.
   *
   * If enabled, a call to goog.require() will attempt to load the namespace by
   * appending a script tag to the DOM (if the namespace has been registered).
   *
   * If disabled, goog.require() will simply assert that the namespace has been
   * provided (and depend on the fact that some outside tool correctly ordered
   * the script).
   */
  goog.define('goog.ENABLE_DEBUG_LOADER', true);

  /**
   * @param {string} msg
   * @private
   */
  goog.logToConsole_ = function (msg) {
    if (goog.global.console) {
      goog.global.console['error'](msg);
    }
  };

  /**
   * Implements a system for the dynamic resolution of dependencies that works in
   * parallel with the BUILD system. Note that all calls to goog.require will be
   * stripped by the JSCompiler when the --process_closure_primitives option is
   * used.
   * @see goog.provide
   * @param {string} name Namespace to include (as was given in goog.provide()) in
   *     the form "goog.package.part".
   * @return {?} If called within a goog.module file, the associated namespace or
   *     module otherwise null.
   */
  goog.require = function (name) {
    // If the object already exists we do not need do do anything.
    if (!COMPILED) {
      if (goog.ENABLE_DEBUG_LOADER && goog.IS_OLD_IE_) {
        goog.maybeProcessDeferredDep_(name);
      }

      if (goog.isProvided_(name)) {
        if (goog.isInModuleLoader_()) {
          return goog.module.getInternal_(name);
        } else {
          return null;
        }
      }

      if (goog.ENABLE_DEBUG_LOADER) {
        var path = goog.getPathFromDeps_(name);
        if (path) {
          goog.writeScripts_(path);
          return null;
        }
      }

      var errorMessage = 'goog.require could not find: ' + name;
      goog.logToConsole_(errorMessage);

      throw Error(errorMessage);
    }
  };

  /**
   * Path for included scripts.
   * @type {string}
   */
  goog.basePath = '';

  /**
   * A hook for overriding the base path.
   * @type {string|undefined}
   */
  goog.global.CLOSURE_BASE_PATH;

  /**
   * Whether to write out Closure's deps file. By default, the deps are written.
   * @type {boolean|undefined}
   */
  goog.global.CLOSURE_NO_DEPS;

  /**
   * A function to import a single script. This is meant to be overridden when
   * Closure is being run in non-HTML contexts, such as web workers. It's defined
   * in the global scope so that it can be set before base.js is loaded, which
   * allows deps.js to be imported properly.
   *
   * The function is passed the script source, which is a relative URI. It should
   * return true if the script was imported, false otherwise.
   * @type {(function(string): boolean)|undefined}
   */
  goog.global.CLOSURE_IMPORT_SCRIPT;

  /**
   * Null function used for default values of callbacks, etc.
   * @return {void} Nothing.
   */
  goog.nullFunction = function () {};

  /**
   * When defining a class Foo with an abstract method bar(), you can do:
   * Foo.prototype.bar = goog.abstractMethod
   *
   * Now if a subclass of Foo fails to override bar(), an error will be thrown
   * when bar() is invoked.
   *
   * Note: This does not take the name of the function to override as an argument
   * because that would make it more difficult to obfuscate our JavaScript code.
   *
   * @type {!Function}
   * @throws {Error} when invoked to indicate the method should be overridden.
   */
  goog.abstractMethod = function () {
    throw Error('unimplemented abstract method');
  };

  /**
   * Adds a {@code getInstance} static method that always returns the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  goog.addSingletonGetter = function (ctor) {
    ctor.getInstance = function () {
      if (ctor.instance_) {
        return ctor.instance_;
      }
      if (goog.DEBUG) {
        // NOTE: JSCompiler can't optimize away Array#push.
        goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
      }
      return ctor.instance_ = new ctor();
    };
  };

  /**
   * All singleton classes that have been instantiated, for testing. Don't read
   * it directly, use the {@code goog.testing.singleton} module. The compiler
   * removes this variable if unused.
   * @type {!Array<!Function>}
   * @private
   */
  goog.instantiatedSingletons_ = [];

  /**
   * @define {boolean} Whether to load goog.modules using {@code eval} when using
   * the debug loader.  This provides a better debugging experience as the
   * source is unmodified and can be edited using Chrome Workspaces or similar.
   * However in some environments the use of {@code eval} is banned
   * so we provide an alternative.
   */
  goog.define('goog.LOAD_MODULE_USING_EVAL', true);

  /**
   * @define {boolean} Whether the exports of goog.modules should be sealed when
   * possible.
   */
  goog.define('goog.SEAL_MODULE_EXPORTS', goog.DEBUG);

  /**
   * The registry of initialized modules:
   * the module identifier to module exports map.
   * @private @const {!Object<string, ?>}
   */
  goog.loadedModules_ = {};

  /**
   * True if goog.dependencies_ is available.
   * @const {boolean}
   */
  goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;

  if (goog.DEPENDENCIES_ENABLED) {
    /**
     * This object is used to keep track of dependencies and other data that is
     * used for loading scripts.
     * @private
     * @type {{
     *   pathIsModule: !Object<string, boolean>,
     *   nameToPath: !Object<string, string>,
     *   requires: !Object<string, !Object<string, boolean>>,
     *   visited: !Object<string, boolean>,
     *   written: !Object<string, boolean>,
     *   deferred: !Object<string, string>
     * }}
     */
    goog.dependencies_ = {
      pathIsModule: {}, // 1 to 1

      nameToPath: {}, // 1 to 1

      requires: {}, // 1 to many

      // Used when resolving dependencies to prevent us from visiting file twice.
      visited: {},

      written: {}, // Used to keep track of script files we have written.

      deferred: {} // Used to track deferred module evaluations in old IEs
    };

    /**
     * Tries to detect whether is in the context of an HTML document.
     * @return {boolean} True if it looks like HTML document.
     * @private
     */
    goog.inHtmlDocument_ = function () {
      /** @type {Document} */
      var doc = goog.global.document;
      return doc != null && 'write' in doc; // XULDocument misses write.
    };

    /**
     * Tries to detect the base path of base.js script that bootstraps Closure.
     * @private
     */
    goog.findBasePath_ = function () {
      if (goog.isDef(goog.global.CLOSURE_BASE_PATH)) {
        goog.basePath = goog.global.CLOSURE_BASE_PATH;
        return;
      } else if (!goog.inHtmlDocument_()) {
        return;
      }
      /** @type {Document} */
      var doc = goog.global.document;
      var scripts = doc.getElementsByTagName('SCRIPT');
      // Search backwards since the current script is in almost all cases the one
      // that has base.js.
      for (var i = scripts.length - 1; i >= 0; --i) {
        var script = /** @type {!HTMLScriptElement} */scripts[i];
        var src = script.src;
        var qmark = src.lastIndexOf('?');
        var l = qmark == -1 ? src.length : qmark;
        if (src.substr(l - 7, 7) == 'base.js') {
          goog.basePath = src.substr(0, l - 7);
          return;
        }
      }
    };

    /**
     * Imports a script if, and only if, that script hasn't already been imported.
     * (Must be called at execution time)
     * @param {string} src Script source.
     * @param {string=} opt_sourceText The optionally source text to evaluate
     * @private
     */
    goog.importScript_ = function (src, opt_sourceText) {
      var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;
      if (importScript(src, opt_sourceText)) {
        goog.dependencies_.written[src] = true;
      }
    };

    /** @const @private {boolean} */
    goog.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document && goog.global.document.all);

    /**
     * Given a URL initiate retrieval and execution of the module.
     * @param {string} src Script source URL.
     * @private
     */
    goog.importModule_ = function (src) {
      // In an attempt to keep browsers from timing out loading scripts using
      // synchronous XHRs, put each load in its own script block.
      var bootstrap = 'goog.retrieveAndExecModule_("' + src + '");';

      if (goog.importScript_('', bootstrap)) {
        goog.dependencies_.written[src] = true;
      }
    };

    /** @private {!Array<string>} */
    goog.queuedModules_ = [];

    /**
     * Return an appropriate module text. Suitable to insert into
     * a script tag (that is unescaped).
     * @param {string} srcUrl
     * @param {string} scriptText
     * @return {string}
     * @private
     */
    goog.wrapModule_ = function (srcUrl, scriptText) {
      if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) {
        return '' + 'goog.loadModule(function(exports) {' + '"use strict";' + scriptText + '\n' + // terminate any trailing single line comment.
        ';return exports' + '});' + '\n//# sourceURL=' + srcUrl + '\n';
      } else {
        return '' + 'goog.loadModule(' + goog.global.JSON.stringify(scriptText + '\n//# sourceURL=' + srcUrl + '\n') + ');';
      }
    };

    // On IE9 and earlier, it is necessary to handle
    // deferred module loads. In later browsers, the
    // code to be evaluated is simply inserted as a script
    // block in the correct order. To eval deferred
    // code at the right time, we piggy back on goog.require to call
    // goog.maybeProcessDeferredDep_.
    //
    // The goog.requires are used both to bootstrap
    // the loading process (when no deps are available) and
    // declare that they should be available.
    //
    // Here we eval the sources, if all the deps are available
    // either already eval'd or goog.require'd.  This will
    // be the case when all the dependencies have already
    // been loaded, and the dependent module is loaded.
    //
    // But this alone isn't sufficient because it is also
    // necessary to handle the case where there is no root
    // that is not deferred.  For that there we register for an event
    // and trigger goog.loadQueuedModules_ handle any remaining deferred
    // evaluations.

    /**
     * Handle any remaining deferred goog.module evals.
     * @private
     */
    goog.loadQueuedModules_ = function () {
      var count = goog.queuedModules_.length;
      if (count > 0) {
        var queue = goog.queuedModules_;
        goog.queuedModules_ = [];
        for (var i = 0; i < count; i++) {
          var path = queue[i];
          goog.maybeProcessDeferredPath_(path);
        }
      }
    };

    /**
     * Eval the named module if its dependencies are
     * available.
     * @param {string} name The module to load.
     * @private
     */
    goog.maybeProcessDeferredDep_ = function (name) {
      if (goog.isDeferredModule_(name) && goog.allDepsAreAvailable_(name)) {
        var path = goog.getPathFromDeps_(name);
        goog.maybeProcessDeferredPath_(goog.basePath + path);
      }
    };

    /**
     * @param {string} name The module to check.
     * @return {boolean} Whether the name represents a
     *     module whose evaluation has been deferred.
     * @private
     */
    goog.isDeferredModule_ = function (name) {
      var path = goog.getPathFromDeps_(name);
      if (path && goog.dependencies_.pathIsModule[path]) {
        var abspath = goog.basePath + path;
        return abspath in goog.dependencies_.deferred;
      }
      return false;
    };

    /**
     * @param {string} name The module to check.
     * @return {boolean} Whether the name represents a
     *     module whose declared dependencies have all been loaded
     *     (eval'd or a deferred module load)
     * @private
     */
    goog.allDepsAreAvailable_ = function (name) {
      var path = goog.getPathFromDeps_(name);
      if (path && path in goog.dependencies_.requires) {
        for (var requireName in goog.dependencies_.requires[path]) {
          if (!goog.isProvided_(requireName) && !goog.isDeferredModule_(requireName)) {
            return false;
          }
        }
      }
      return true;
    };

    /**
     * @param {string} abspath
     * @private
     */
    goog.maybeProcessDeferredPath_ = function (abspath) {
      if (abspath in goog.dependencies_.deferred) {
        var src = goog.dependencies_.deferred[abspath];
        delete goog.dependencies_.deferred[abspath];
        goog.globalEval(src);
      }
    };

    /**
     * Load a goog.module from the provided URL.  This is not a general purpose
     * code loader and does not support late loading code, that is it should only
     * be used during page load. This method exists to support unit tests and
     * "debug" loaders that would otherwise have inserted script tags. Under the
     * hood this needs to use a synchronous XHR and is not recommeneded for
     * production code.
     *
     * The module's goog.requires must have already been satisified; an exception
     * will be thrown if this is not the case. This assumption is that no
     * "deps.js" file exists, so there is no way to discover and locate the
     * module-to-be-loaded's dependencies and no attempt is made to do so.
     *
     * There should only be one attempt to load a module.  If
     * "goog.loadModuleFromUrl" is called for an already loaded module, an
     * exception will be throw.
     *
     * @param {string} url The URL from which to attempt to load the goog.module.
     */
    goog.loadModuleFromUrl = function (url) {
      // Because this executes synchronously, we don't need to do any additional
      // bookkeeping. When "goog.loadModule" the namespace will be marked as
      // having been provided which is sufficient.
      goog.retrieveAndExecModule_(url);
    };

    /**
     * @param {function(?):?|string} moduleDef The module definition.
     */
    goog.loadModule = function (moduleDef) {
      // NOTE: we allow function definitions to be either in the from
      // of a string to eval (which keeps the original source intact) or
      // in a eval forbidden environment (CSP) we allow a function definition
      // which in its body must call {@code goog.module}, and return the exports
      // of the module.
      var previousState = goog.moduleLoaderState_;
      try {
        goog.moduleLoaderState_ = {
          moduleName: undefined,
          declareLegacyNamespace: false
        };
        var exports;
        if (goog.isFunction(moduleDef)) {
          exports = moduleDef.call(goog.global, {});
        } else if (goog.isString(moduleDef)) {
          exports = goog.loadModuleFromSource_.call(goog.global, moduleDef);
        } else {
          throw Error('Invalid module definition');
        }

        var moduleName = goog.moduleLoaderState_.moduleName;
        if (!goog.isString(moduleName) || !moduleName) {
          throw Error('Invalid module name \"' + moduleName + '\"');
        }

        // Don't seal legacy namespaces as they may be uses as a parent of
        // another namespace
        if (goog.moduleLoaderState_.declareLegacyNamespace) {
          goog.constructNamespace_(moduleName, exports);
        } else if (goog.SEAL_MODULE_EXPORTS && Object.seal) {
          Object.seal(exports);
        }

        goog.loadedModules_[moduleName] = exports;
      } finally {
        goog.moduleLoaderState_ = previousState;
      }
    };

    /**
     * @private @const {function(string):?}
     *
     * The new type inference warns because this function has no formal
     * parameters, but its jsdoc says that it takes one argument.
     * (The argument is used via arguments[0], but NTI does not detect this.)
     * @suppress {newCheckTypes}
     */
    goog.loadModuleFromSource_ = function () {
      // NOTE: we avoid declaring parameters or local variables here to avoid
      // masking globals or leaking values into the module definition.
      'use strict';

      var exports = {};
      eval(arguments[0]);
      return exports;
    };

    /**
     * Writes a new script pointing to {@code src} directly into the DOM.
     *
     * NOTE: This method is not CSP-compliant. @see goog.appendScriptSrcNode_ for
     * the fallback mechanism.
     *
     * @param {string} src The script URL.
     * @private
     */
    goog.writeScriptSrcNode_ = function (src) {
      goog.global.document.write('<script type="text/javascript" src="' + src + '"></' + 'script>');
    };

    /**
     * Appends a new script node to the DOM using a CSP-compliant mechanism. This
     * method exists as a fallback for document.write (which is not allowed in a
     * strict CSP context, e.g., Chrome apps).
     *
     * NOTE: This method is not analogous to using document.write to insert a
     * <script> tag; specifically, the user agent will execute a script added by
     * document.write immediately after the current script block finishes
     * executing, whereas the DOM-appended script node will not be executed until
     * the entire document is parsed and executed. That is to say, this script is
     * added to the end of the script execution queue.
     *
     * The page must not attempt to call goog.required entities until after the
     * document has loaded, e.g., in or after the window.onload callback.
     *
     * @param {string} src The script URL.
     * @private
     */
    goog.appendScriptSrcNode_ = function (src) {
      /** @type {Document} */
      var doc = goog.global.document;
      var scriptEl =
      /** @type {HTMLScriptElement} */doc.createElement('script');
      scriptEl.type = 'text/javascript';
      scriptEl.src = src;
      scriptEl.defer = false;
      scriptEl.async = false;
      doc.head.appendChild(scriptEl);
    };

    /**
     * The default implementation of the import function. Writes a script tag to
     * import the script.
     *
     * @param {string} src The script url.
     * @param {string=} opt_sourceText The optionally source text to evaluate
     * @return {boolean} True if the script was imported, false otherwise.
     * @private
     */
    goog.writeScriptTag_ = function (src, opt_sourceText) {
      if (goog.inHtmlDocument_()) {
        /** @type {!HTMLDocument} */
        var doc = goog.global.document;

        // If the user tries to require a new symbol after document load,
        // something has gone terribly wrong. Doing a document.write would
        // wipe out the page. This does not apply to the CSP-compliant method
        // of writing script tags.
        if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && doc.readyState == 'complete') {
          // Certain test frameworks load base.js multiple times, which tries
          // to write deps.js each time. If that happens, just fail silently.
          // These frameworks wipe the page between each load of base.js, so this
          // is OK.
          var isDeps = /\bdeps.js$/.test(src);
          if (isDeps) {
            return false;
          } else {
            throw Error('Cannot write "' + src + '" after document load');
          }
        }

        var isOldIE = goog.IS_OLD_IE_;

        if (opt_sourceText === undefined) {
          if (!isOldIE) {
            if (goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
              goog.appendScriptSrcNode_(src);
            } else {
              goog.writeScriptSrcNode_(src);
            }
          } else {
            var state = " onreadystatechange='goog.onScriptLoad_(this, " + ++goog.lastNonModuleScriptIndex_ + ")' ";
            doc.write('<script type="text/javascript" src="' + src + '"' + state + '></' + 'script>');
          }
        } else {
          doc.write('<script type="text/javascript">' + opt_sourceText + '</' + 'script>');
        }
        return true;
      } else {
        return false;
      }
    };

    /** @private {number} */
    goog.lastNonModuleScriptIndex_ = 0;

    /**
     * A readystatechange handler for legacy IE
     * @param {!HTMLScriptElement} script
     * @param {number} scriptIndex
     * @return {boolean}
     * @private
     */
    goog.onScriptLoad_ = function (script, scriptIndex) {
      // for now load the modules when we reach the last script,
      // later allow more inter-mingling.
      if (script.readyState == 'complete' && goog.lastNonModuleScriptIndex_ == scriptIndex) {
        goog.loadQueuedModules_();
      }
      return true;
    };

    /**
     * Resolves dependencies based on the dependencies added using addDependency
     * and calls importScript_ in the correct order.
     * @param {string} pathToLoad The path from which to start discovering
     *     dependencies.
     * @private
     */
    goog.writeScripts_ = function (pathToLoad) {
      /** @type {!Array<string>} The scripts we need to write this time. */
      var scripts = [];
      var seenScript = {};
      var deps = goog.dependencies_;

      /** @param {string} path */
      function visitNode(path) {
        if (path in deps.written) {
          return;
        }

        // We have already visited this one. We can get here if we have cyclic
        // dependencies.
        if (path in deps.visited) {
          return;
        }

        deps.visited[path] = true;

        if (path in deps.requires) {
          for (var requireName in deps.requires[path]) {
            // If the required name is defined, we assume that it was already
            // bootstrapped by other means.
            if (!goog.isProvided_(requireName)) {
              if (requireName in deps.nameToPath) {
                visitNode(deps.nameToPath[requireName]);
              } else {
                throw Error('Undefined nameToPath for ' + requireName);
              }
            }
          }
        }

        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
      }

      visitNode(pathToLoad);

      // record that we are going to load all these scripts.
      for (var i = 0; i < scripts.length; i++) {
        var path = scripts[i];
        goog.dependencies_.written[path] = true;
      }

      // If a module is loaded synchronously then we need to
      // clear the current inModuleLoader value, and restore it when we are
      // done loading the current "requires".
      var moduleState = goog.moduleLoaderState_;
      goog.moduleLoaderState_ = null;

      for (var i = 0; i < scripts.length; i++) {
        var path = scripts[i];
        if (path) {
          if (!deps.pathIsModule[path]) {
            goog.importScript_(goog.basePath + path);
          } else {
            goog.importModule_(goog.basePath + path);
          }
        } else {
          goog.moduleLoaderState_ = moduleState;
          throw Error('Undefined script input');
        }
      }

      // restore the current "module loading state"
      goog.moduleLoaderState_ = moduleState;
    };

    /**
     * Looks at the dependency rules and tries to determine the script file that
     * fulfills a particular rule.
     * @param {string} rule In the form goog.namespace.Class or project.script.
     * @return {?string} Url corresponding to the rule, or null.
     * @private
     */
    goog.getPathFromDeps_ = function (rule) {
      if (rule in goog.dependencies_.nameToPath) {
        return goog.dependencies_.nameToPath[rule];
      } else {
        return null;
      }
    };

    goog.findBasePath_();

    // Allow projects to manage the deps files themselves.
    if (!goog.global.CLOSURE_NO_DEPS) {
      goog.importScript_(goog.basePath + 'deps.js');
    }
  }

  /**
   * Normalize a file path by removing redundant ".." and extraneous "." file
   * path components.
   * @param {string} path
   * @return {string}
   * @private
   */
  goog.normalizePath_ = function (path) {
    var components = path.split('/');
    var i = 0;
    while (i < components.length) {
      if (components[i] == '.') {
        components.splice(i, 1);
      } else if (i && components[i] == '..' && components[i - 1] && components[i - 1] != '..') {
        components.splice(--i, 2);
      } else {
        i++;
      }
    }
    return components.join('/');
  };

  /**
   * Loads file by synchronous XHR. Should not be used in production environments.
   * @param {string} src Source URL.
   * @return {string} File contents.
   * @private
   */
  goog.loadFileSync_ = function (src) {
    if (goog.global.CLOSURE_LOAD_FILE_SYNC) {
      return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
    } else {
      /** @type {XMLHttpRequest} */
      var xhr = new goog.global['XMLHttpRequest']();
      xhr.open('get', src, false);
      xhr.send();
      return xhr.responseText;
    }
  };

  /**
   * Retrieve and execute a module.
   * @param {string} src Script source URL.
   * @private
   */
  goog.retrieveAndExecModule_ = function (src) {
    if (!COMPILED) {
      // The full but non-canonicalized URL for later use.
      var originalPath = src;
      // Canonicalize the path, removing any /./ or /../ since Chrome's debugging
      // console doesn't auto-canonicalize XHR loads as it does <script> srcs.
      src = goog.normalizePath_(src);

      var importScript = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;

      var scriptText = goog.loadFileSync_(src);

      if (scriptText != null) {
        var execModuleScript = goog.wrapModule_(src, scriptText);
        var isOldIE = goog.IS_OLD_IE_;
        if (isOldIE) {
          goog.dependencies_.deferred[originalPath] = execModuleScript;
          goog.queuedModules_.push(originalPath);
        } else {
          importScript(src, execModuleScript);
        }
      } else {
        throw new Error('load of ' + src + 'failed');
      }
    }
  };

  //==============================================================================
  // Language Enhancements
  //==============================================================================


  /**
   * This is a "fixed" version of the typeof operator.  It differs from the typeof
   * operator in such a way that null returns 'null' and arrays return 'array'.
   * @param {?} value The value to get the type of.
   * @return {string} The name of the type.
   */
  goog.typeOf = function (value) {
    var s = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    if (s == 'object') {
      if (value) {
        // Check these first, so we can avoid calling Object.prototype.toString if
        // possible.
        //
        // IE improperly marshals typeof across execution contexts, but a
        // cross-context object will still return false for "instanceof Object".
        if (value instanceof Array) {
          return 'array';
        } else if (value instanceof Object) {
          return s;
        }

        // HACK: In order to use an Object prototype method on the arbitrary
        //   value, the compiler requires the value be cast to type Object,
        //   even though the ECMA spec explicitly allows it.
        var className = Object.prototype.toString.call(
        /** @type {!Object} */value);
        // In Firefox 3.6, attempting to access iframe window objects' length
        // property throws an NS_ERROR_FAILURE, so we need to special-case it
        // here.
        if (className == '[object Window]') {
          return 'object';
        }

        // We cannot always use constructor == Array or instanceof Array because
        // different frames have different Array objects. In IE6, if the iframe
        // where the array was created is destroyed, the array loses its
        // prototype. Then dereferencing val.splice here throws an exception, so
        // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
        // so that will work. In this case, this function will return false and
        // most array functions will still work because the array is still
        // array-like (supports length and []) even though it has lost its
        // prototype.
        // Mark Miller noticed that Object.prototype.toString
        // allows access to the unforgeable [[Class]] property.
        //  15.2.4.2 Object.prototype.toString ( )
        //  When the toString method is called, the following steps are taken:
        //      1. Get the [[Class]] property of this object.
        //      2. Compute a string value by concatenating the three strings
        //         "[object ", Result(1), and "]".
        //      3. Return Result(2).
        // and this behavior survives the destruction of the execution context.
        if (className == '[object Array]' ||
        // In IE all non value types are wrapped as objects across window
        // boundaries (not iframe though) so we have to do object detection
        // for this edge case.
        typeof value.length == 'number' && typeof value.splice != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('splice')) {
          return 'array';
        }
        // HACK: There is still an array case that fails.
        //     function ArrayImpostor() {}
        //     ArrayImpostor.prototype = [];
        //     var impostor = new ArrayImpostor;
        // this can be fixed by getting rid of the fast path
        // (value instanceof Array) and solely relying on
        // (value && Object.prototype.toString.vall(value) === '[object Array]')
        // but that would require many more function calls and is not warranted
        // unless closure code is receiving objects from untrusted sources.

        // IE in cross-window calls does not correctly marshal the function type
        // (it appears just as an object) so we cannot use just typeof val ==
        // 'function'. However, if the object has a call property, it is a
        // function.
        if (className == '[object Function]' || typeof value.call != 'undefined' && typeof value.propertyIsEnumerable != 'undefined' && !value.propertyIsEnumerable('call')) {
          return 'function';
        }
      } else {
        return 'null';
      }
    } else if (s == 'function' && typeof value.call == 'undefined') {
      // In Safari typeof nodeList returns 'function', and on Firefox typeof
      // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
      // would like to return object for those and we can detect an invalid
      // function by making sure that the function object has a call method.
      return 'object';
    }
    return s;
  };

  /**
   * Returns true if the specified value is null.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is null.
   */
  goog.isNull = function (val) {
    return val === null;
  };

  /**
   * Returns true if the specified value is defined and not null.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is defined and not null.
   */
  goog.isDefAndNotNull = function (val) {
    // Note that undefined == null.
    return val != null;
  };

  /**
   * Returns true if the specified value is an array.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is an array.
   */
  goog.isArray = function (val) {
    return goog.typeOf(val) == 'array';
  };

  /**
   * Returns true if the object looks like an array. To qualify as array like
   * the value needs to be either a NodeList or an object with a Number length
   * property. As a special case, a function value is not array like, because its
   * length property is fixed to correspond to the number of expected arguments.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is an array.
   */
  goog.isArrayLike = function (val) {
    var type = goog.typeOf(val);
    // We do not use goog.isObject here in order to exclude function values.
    return type == 'array' || type == 'object' && typeof val.length == 'number';
  };

  /**
   * Returns true if the object looks like a Date. To qualify as Date-like the
   * value needs to be an object and have a getFullYear() function.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is a like a Date.
   */
  goog.isDateLike = function (val) {
    return goog.isObject(val) && typeof val.getFullYear == 'function';
  };

  /**
   * Returns true if the specified value is a string.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is a string.
   */
  goog.isString = function (val) {
    return typeof val == 'string';
  };

  /**
   * Returns true if the specified value is a boolean.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is boolean.
   */
  goog.isBoolean = function (val) {
    return typeof val == 'boolean';
  };

  /**
   * Returns true if the specified value is a number.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is a number.
   */
  goog.isNumber = function (val) {
    return typeof val == 'number';
  };

  /**
   * Returns true if the specified value is a function.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is a function.
   */
  goog.isFunction = function (val) {
    return goog.typeOf(val) == 'function';
  };

  /**
   * Returns true if the specified value is an object.  This includes arrays and
   * functions.
   * @param {?} val Variable to test.
   * @return {boolean} Whether variable is an object.
   */
  goog.isObject = function (val) {
    var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
    return type == 'object' && val != null || type == 'function';
    // return Object(val) === val also works, but is slower, especially if val is
    // not an object.
  };

  /**
   * Gets a unique ID for an object. This mutates the object so that further calls
   * with the same object as a parameter returns the same value. The unique ID is
   * guaranteed to be unique across the current session amongst objects that are
   * passed into {@code getUid}. There is no guarantee that the ID is unique or
   * consistent across sessions. It is unsafe to generate unique ID for function
   * prototypes.
   *
   * @param {Object} obj The object to get the unique ID for.
   * @return {number} The unique ID for the object.
   */
  goog.getUid = function (obj) {
    // TODO(arv): Make the type stricter, do not accept null.

    // In Opera window.hasOwnProperty exists but always returns false so we avoid
    // using it. As a consequence the unique ID generated for BaseClass.prototype
    // and SubClass.prototype will be the same.
    return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
  };

  /**
   * Whether the given object is already assigned a unique ID.
   *
   * This does not modify the object.
   *
   * @param {!Object} obj The object to check.
   * @return {boolean} Whether there is an assigned unique id for the object.
   */
  goog.hasUid = function (obj) {
    return !!obj[goog.UID_PROPERTY_];
  };

  /**
   * Removes the unique ID from an object. This is useful if the object was
   * previously mutated using {@code goog.getUid} in which case the mutation is
   * undone.
   * @param {Object} obj The object to remove the unique ID field from.
   */
  goog.removeUid = function (obj) {
    // TODO(arv): Make the type stricter, do not accept null.

    // In IE, DOM nodes are not instances of Object and throw an exception if we
    // try to delete.  Instead we try to use removeAttribute.
    if (obj !== null && 'removeAttribute' in obj) {
      obj.removeAttribute(goog.UID_PROPERTY_);
    }
    /** @preserveTry */
    try {
      delete obj[goog.UID_PROPERTY_];
    } catch (ex) {}
  };

  /**
   * Name for unique ID property. Initialized in a way to help avoid collisions
   * with other closure JavaScript on the same page.
   * @type {string}
   * @private
   */
  goog.UID_PROPERTY_ = 'closure_uid_' + (Math.random() * 1e9 >>> 0);

  /**
   * Counter for UID.
   * @type {number}
   * @private
   */
  goog.uidCounter_ = 0;

  /**
   * Adds a hash code field to an object. The hash code is unique for the
   * given object.
   * @param {Object} obj The object to get the hash code for.
   * @return {number} The hash code for the object.
   * @deprecated Use goog.getUid instead.
   */
  goog.getHashCode = goog.getUid;

  /**
   * Removes the hash code field from an object.
   * @param {Object} obj The object to remove the field from.
   * @deprecated Use goog.removeUid instead.
   */
  goog.removeHashCode = goog.removeUid;

  /**
   * Clones a value. The input may be an Object, Array, or basic type. Objects and
   * arrays will be cloned recursively.
   *
   * WARNINGS:
   * <code>goog.cloneObject</code> does not detect reference loops. Objects that
   * refer to themselves will cause infinite recursion.
   *
   * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
   * UIDs created by <code>getUid</code> into cloned results.
   *
   * @param {*} obj The value to clone.
   * @return {*} A clone of the input value.
   * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
   */
  goog.cloneObject = function (obj) {
    var type = goog.typeOf(obj);
    if (type == 'object' || type == 'array') {
      if (obj.clone) {
        return obj.clone();
      }
      var clone = type == 'array' ? [] : {};
      for (var key in obj) {
        clone[key] = goog.cloneObject(obj[key]);
      }
      return clone;
    }

    return obj;
  };

  /**
   * A native implementation of goog.bind.
   * @param {Function} fn A function to partially apply.
   * @param {Object|undefined} selfObj Specifies the object which this should
   *     point to when the function is run.
   * @param {...*} var_args Additional arguments that are partially applied to the
   *     function.
   * @return {!Function} A partially-applied form of the function bind() was
   *     invoked as a method of.
   * @private
   * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
   *     deprecated because some people have declared a pure-JS version.
   *     Only the pure-JS version is truly deprecated.
   */
  goog.bindNative_ = function (fn, selfObj, var_args) {
    return (/** @type {!Function} */fn.call.apply(fn.bind, arguments)
    );
  };

  /**
   * A pure-JS implementation of goog.bind.
   * @param {Function} fn A function to partially apply.
   * @param {Object|undefined} selfObj Specifies the object which this should
   *     point to when the function is run.
   * @param {...*} var_args Additional arguments that are partially applied to the
   *     function.
   * @return {!Function} A partially-applied form of the function bind() was
   *     invoked as a method of.
   * @private
   */
  goog.bindJs_ = function (fn, selfObj, var_args) {
    if (!fn) {
      throw new Error();
    }

    if (arguments.length > 2) {
      var boundArgs = Array.prototype.slice.call(arguments, 2);
      return function () {
        // Prepend the bound arguments to the current arguments.
        var newArgs = Array.prototype.slice.call(arguments);
        Array.prototype.unshift.apply(newArgs, boundArgs);
        return fn.apply(selfObj, newArgs);
      };
    } else {
      return function () {
        return fn.apply(selfObj, arguments);
      };
    }
  };

  /**
   * Partially applies this function to a particular 'this object' and zero or
   * more arguments. The result is a new function with some arguments of the first
   * function pre-filled and the value of this 'pre-specified'.
   *
   * Remaining arguments specified at call-time are appended to the pre-specified
   * ones.
   *
   * Also see: {@link #partial}.
   *
   * Usage:
   * <pre>var barMethBound = goog.bind(myFunction, myObj, 'arg1', 'arg2');
   * barMethBound('arg3', 'arg4');</pre>
   *
   * @param {?function(this:T, ...)} fn A function to partially apply.
   * @param {T} selfObj Specifies the object which this should point to when the
   *     function is run.
   * @param {...*} var_args Additional arguments that are partially applied to the
   *     function.
   * @return {!Function} A partially-applied form of the function goog.bind() was
   *     invoked as a method of.
   * @template T
   * @suppress {deprecated} See above.
   */
  goog.bind = function (fn, selfObj, var_args) {
    // TODO(nicksantos): narrow the type signature.
    if (Function.prototype.bind &&
    // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
    // extension environment. This means that for Chrome extensions, they get
    // the implementation of Function.prototype.bind that calls goog.bind
    // instead of the native one. Even worse, we don't want to introduce a
    // circular dependency between goog.bind and Function.prototype.bind, so
    // we have to hack this to make sure it works correctly.
    Function.prototype.bind.toString().indexOf('native code') != -1) {
      goog.bind = goog.bindNative_;
    } else {
      goog.bind = goog.bindJs_;
    }
    return goog.bind.apply(null, arguments);
  };

  /**
   * Like goog.bind(), except that a 'this object' is not required. Useful when
   * the target function is already bound.
   *
   * Usage:
   * var g = goog.partial(f, arg1, arg2);
   * g(arg3, arg4);
   *
   * @param {Function} fn A function to partially apply.
   * @param {...*} var_args Additional arguments that are partially applied to fn.
   * @return {!Function} A partially-applied form of the function goog.partial()
   *     was invoked as a method of.
   */
  goog.partial = function (fn, var_args) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function () {
      // Clone the array (with slice()) and append additional arguments
      // to the existing arguments.
      var newArgs = args.slice();
      newArgs.push.apply(newArgs, arguments);
      return fn.apply(this, newArgs);
    };
  };

  /**
   * Copies all the members of a source object to a target object. This method
   * does not work on all browsers for all objects that contain keys such as
   * toString or hasOwnProperty. Use goog.object.extend for this purpose.
   * @param {Object} target Target.
   * @param {Object} source Source.
   */
  goog.mixin = function (target, source) {
    for (var x in source) {
      target[x] = source[x];
    }

    // For IE7 or lower, the for-in-loop does not contain any properties that are
    // not enumerable on the prototype object (for example, isPrototypeOf from
    // Object.prototype) but also it will not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).
  };

  /**
   * @return {number} An integer value representing the number of milliseconds
   *     between midnight, January 1, 1970 and the current time.
   */
  goog.now = goog.TRUSTED_SITE && Date.now || function () {
    // Unary plus operator converts its operand to a number which in
    // the case of
    // a date is done by calling getTime().
    return +new Date();
  };

  /**
   * Evals JavaScript in the global scope.  In IE this uses execScript, other
   * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
   * global scope (for example, in Safari), appends a script tag instead.
   * Throws an exception if neither execScript or eval is defined.
   * @param {string} script JavaScript string.
   */
  goog.globalEval = function (script) {
    if (goog.global.execScript) {
      goog.global.execScript(script, 'JavaScript');
    } else if (goog.global.eval) {
      // Test to see if eval works
      if (goog.evalWorksForGlobals_ == null) {
        goog.global.eval('var _evalTest_ = 1;');
        if (typeof goog.global['_evalTest_'] != 'undefined') {
          try {
            delete goog.global['_evalTest_'];
          } catch (ignore) {
            // Microsoft edge fails the deletion above in strict mode.
          }
          goog.evalWorksForGlobals_ = true;
        } else {
          goog.evalWorksForGlobals_ = false;
        }
      }

      if (goog.evalWorksForGlobals_) {
        goog.global.eval(script);
      } else {
        /** @type {Document} */
        var doc = goog.global.document;
        var scriptElt =
        /** @type {!HTMLScriptElement} */doc.createElement('SCRIPT');
        scriptElt.type = 'text/javascript';
        scriptElt.defer = false;
        // Note(user): can't use .innerHTML since "t('<test>')" will fail and
        // .text doesn't work in Safari 2.  Therefore we append a text node.
        scriptElt.appendChild(doc.createTextNode(script));
        doc.body.appendChild(scriptElt);
        doc.body.removeChild(scriptElt);
      }
    } else {
      throw Error('goog.globalEval not available');
    }
  };

  /**
   * Indicates whether or not we can call 'eval' directly to eval code in the
   * global scope. Set to a Boolean by the first call to goog.globalEval (which
   * empirically tests whether eval works for globals). @see goog.globalEval
   * @type {?boolean}
   * @private
   */
  goog.evalWorksForGlobals_ = null;

  /**
   * Optional map of CSS class names to obfuscated names used with
   * goog.getCssName().
   * @private {!Object<string, string>|undefined}
   * @see goog.setCssNameMapping
   */
  goog.cssNameMapping_;

  /**
   * Optional obfuscation style for CSS class names. Should be set to either
   * 'BY_WHOLE' or 'BY_PART' if defined.
   * @type {string|undefined}
   * @private
   * @see goog.setCssNameMapping
   */
  goog.cssNameMappingStyle_;

  /**
   * Handles strings that are intended to be used as CSS class names.
   *
   * This function works in tandem with @see goog.setCssNameMapping.
   *
   * Without any mapping set, the arguments are simple joined with a hyphen and
   * passed through unaltered.
   *
   * When there is a mapping, there are two possible styles in which these
   * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
   * of the passed in css name is rewritten according to the map. In the BY_WHOLE
   * style, the full css name is looked up in the map directly. If a rewrite is
   * not specified by the map, the compiler will output a warning.
   *
   * When the mapping is passed to the compiler, it will replace calls to
   * goog.getCssName with the strings from the mapping, e.g.
   *     var x = goog.getCssName('foo');
   *     var y = goog.getCssName(this.baseClass, 'active');
   *  becomes:
   *     var x = 'foo';
   *     var y = this.baseClass + '-active';
   *
   * If one argument is passed it will be processed, if two are passed only the
   * modifier will be processed, as it is assumed the first argument was generated
   * as a result of calling goog.getCssName.
   *
   * @param {string} className The class name.
   * @param {string=} opt_modifier A modifier to be appended to the class name.
   * @return {string} The class name or the concatenation of the class name and
   *     the modifier.
   */
  goog.getCssName = function (className, opt_modifier) {
    var getMapping = function getMapping(cssName) {
      return goog.cssNameMapping_[cssName] || cssName;
    };

    var renameByParts = function renameByParts(cssName) {
      // Remap all the parts individually.
      var parts = cssName.split('-');
      var mapped = [];
      for (var i = 0; i < parts.length; i++) {
        mapped.push(getMapping(parts[i]));
      }
      return mapped.join('-');
    };

    var rename;
    if (goog.cssNameMapping_) {
      rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ? getMapping : renameByParts;
    } else {
      rename = function rename(a) {
        return a;
      };
    }

    if (opt_modifier) {
      return className + '-' + rename(opt_modifier);
    } else {
      return rename(className);
    }
  };

  /**
   * Sets the map to check when returning a value from goog.getCssName(). Example:
   * <pre>
   * goog.setCssNameMapping({
   *   "goog": "a",
   *   "disabled": "b",
   * });
   *
   * var x = goog.getCssName('goog');
   * // The following evaluates to: "a a-b".
   * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
   * </pre>
   * When declared as a map of string literals to string literals, the JSCompiler
   * will replace all calls to goog.getCssName() using the supplied map if the
   * --process_closure_primitives flag is set.
   *
   * @param {!Object} mapping A map of strings to strings where keys are possible
   *     arguments to goog.getCssName() and values are the corresponding values
   *     that should be returned.
   * @param {string=} opt_style The style of css name mapping. There are two valid
   *     options: 'BY_PART', and 'BY_WHOLE'.
   * @see goog.getCssName for a description.
   */
  goog.setCssNameMapping = function (mapping, opt_style) {
    goog.cssNameMapping_ = mapping;
    goog.cssNameMappingStyle_ = opt_style;
  };

  /**
   * To use CSS renaming in compiled mode, one of the input files should have a
   * call to goog.setCssNameMapping() with an object literal that the JSCompiler
   * can extract and use to replace all calls to goog.getCssName(). In uncompiled
   * mode, JavaScript code should be loaded before this base.js file that declares
   * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
   * to ensure that the mapping is loaded before any calls to goog.getCssName()
   * are made in uncompiled mode.
   *
   * A hook for overriding the CSS name mapping.
   * @type {!Object<string, string>|undefined}
   */
  goog.global.CLOSURE_CSS_NAME_MAPPING;

  if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
    // This does not call goog.setCssNameMapping() because the JSCompiler
    // requires that goog.setCssNameMapping() be called with an object literal.
    goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
  }

  /**
   * Gets a localized message.
   *
   * This function is a compiler primitive. If you give the compiler a localized
   * message bundle, it will replace the string at compile-time with a localized
   * version, and expand goog.getMsg call to a concatenated string.
   *
   * Messages must be initialized in the form:
   * <code>
   * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
   * </code>
   *
   * @param {string} str Translatable string, places holders in the form {$foo}.
   * @param {Object<string, string>=} opt_values Maps place holder name to value.
   * @return {string} message with placeholders filled.
   */
  goog.getMsg = function (str, opt_values) {
    if (opt_values) {
      str = str.replace(/\{\$([^}]+)}/g, function (match, key) {
        return opt_values != null && key in opt_values ? opt_values[key] : match;
      });
    }
    return str;
  };

  /**
   * Gets a localized message. If the message does not have a translation, gives a
   * fallback message.
   *
   * This is useful when introducing a new message that has not yet been
   * translated into all languages.
   *
   * This function is a compiler primitive. Must be used in the form:
   * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
   * where MSG_A and MSG_B were initialized with goog.getMsg.
   *
   * @param {string} a The preferred message.
   * @param {string} b The fallback message.
   * @return {string} The best translated message.
   */
  goog.getMsgWithFallback = function (a, b) {
    return a;
  };

  /**
   * Exposes an unobfuscated global namespace path for the given object.
   * Note that fields of the exported object *will* be obfuscated, unless they are
   * exported in turn via this function or goog.exportProperty.
   *
   * Also handy for making public items that are defined in anonymous closures.
   *
   * ex. goog.exportSymbol('public.path.Foo', Foo);
   *
   * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
   *     public.path.Foo.staticFunction();
   *
   * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
   *                       Foo.prototype.myMethod);
   *     new public.path.Foo().myMethod();
   *
   * @param {string} publicPath Unobfuscated name to export.
   * @param {*} object Object the name should point to.
   * @param {Object=} opt_objectToExportTo The object to add the path to; default
   *     is goog.global.
   */
  goog.exportSymbol = function (publicPath, object, opt_objectToExportTo) {
    goog.exportPath_(publicPath, object, opt_objectToExportTo);
  };

  /**
   * Exports a property unobfuscated into the object's namespace.
   * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
   * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
   * @param {Object} object Object whose static property is being exported.
   * @param {string} publicName Unobfuscated name to export.
   * @param {*} symbol Object the name should point to.
   */
  goog.exportProperty = function (object, publicName, symbol) {
    object[publicName] = symbol;
  };

  /**
   * Inherit the prototype methods from one constructor into another.
   *
   * Usage:
   * <pre>
   * function ParentClass(a, b) { }
   * ParentClass.prototype.foo = function(a) { };
   *
   * function ChildClass(a, b, c) {
   *   ChildClass.base(this, 'constructor', a, b);
   * }
   * goog.inherits(ChildClass, ParentClass);
   *
   * var child = new ChildClass('a', 'b', 'see');
   * child.foo(); // This works.
   * </pre>
   *
   * @param {!Function} childCtor Child class.
   * @param {!Function} parentCtor Parent class.
   */
  goog.inherits = function (childCtor, parentCtor) {
    /** @constructor */
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    /** @override */
    childCtor.prototype.constructor = childCtor;

    /**
     * Calls superclass constructor/method.
     *
     * This function is only available if you use goog.inherits to
     * express inheritance relationships between classes.
     *
     * NOTE: This is a replacement for goog.base and for superClass_
     * property defined in childCtor.
     *
     * @param {!Object} me Should always be "this".
     * @param {string} methodName The method name to call. Calling
     *     superclass constructor can be done with the special string
     *     'constructor'.
     * @param {...*} var_args The arguments to pass to superclass
     *     method/constructor.
     * @return {*} The return value of the superclass method/constructor.
     */
    childCtor.base = function (me, methodName, var_args) {
      // Copying using loop to avoid deop due to passing arguments object to
      // function. This is faster in many JS engines as of late 2014.
      var args = new Array(arguments.length - 2);
      for (var i = 2; i < arguments.length; i++) {
        args[i - 2] = arguments[i];
      }
      return parentCtor.prototype[methodName].apply(me, args);
    };
  };

  /**
   * Call up to the superclass.
   *
   * If this is called from a constructor, then this calls the superclass
   * constructor with arguments 1-N.
   *
   * If this is called from a prototype method, then you must pass the name of the
   * method as the second argument to this function. If you do not, you will get a
   * runtime error. This calls the superclass' method with arguments 2-N.
   *
   * This function only works if you use goog.inherits to express inheritance
   * relationships between your classes.
   *
   * This function is a compiler primitive. At compile-time, the compiler will do
   * macro expansion to remove a lot of the extra overhead that this function
   * introduces. The compiler will also enforce a lot of the assumptions that this
   * function makes, and treat it as a compiler error if you break them.
   *
   * @param {!Object} me Should always be "this".
   * @param {*=} opt_methodName The method name if calling a super method.
   * @param {...*} var_args The rest of the arguments.
   * @return {*} The return value of the superclass method.
   * @suppress {es5Strict} This method can not be used in strict mode, but
   *     all Closure Library consumers must depend on this file.
   */
  goog.base = function (me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;

    if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !caller) {
      throw Error('arguments.caller not defined.  goog.base() cannot be used ' + 'with strict mode code. See ' + 'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
    }

    if (caller.superClass_) {
      // Copying using loop to avoid deop due to passing arguments object to
      // function. This is faster in many JS engines as of late 2014.
      var ctorArgs = new Array(arguments.length - 1);
      for (var i = 1; i < arguments.length; i++) {
        ctorArgs[i - 1] = arguments[i];
      }
      // This is a constructor. Call the superclass constructor.
      return caller.superClass_.constructor.apply(me, ctorArgs);
    }

    // Copying using loop to avoid deop due to passing arguments object to
    // function. This is faster in many JS engines as of late 2014.
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) {
      args[i - 2] = arguments[i];
    }
    var foundCaller = false;
    for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
      if (ctor.prototype[opt_methodName] === caller) {
        foundCaller = true;
      } else if (foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args);
      }
    }

    // If we did not find the caller in the prototype chain, then one of two
    // things happened:
    // 1) The caller is an instance method.
    // 2) This method was not called by the right caller.
    if (me[opt_methodName] === caller) {
      return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
      throw Error('goog.base called from a method of one name ' + 'to a method of a different name');
    }
  };

  /**
   * Allow for aliasing within scope functions.  This function exists for
   * uncompiled code - in compiled code the calls will be inlined and the aliases
   * applied.  In uncompiled code the function is simply run since the aliases as
   * written are valid JavaScript.
   *
   *
   * @param {function()} fn Function to call.  This function can contain aliases
   *     to namespaces (e.g. "var dom = goog.dom") or classes
   *     (e.g. "var Timer = goog.Timer").
   */
  goog.scope = function (fn) {
    fn.call(goog.global);
  };

  /*
   * To support uncompiled, strict mode bundles that use eval to divide source
   * like so:
   *    eval('someSource;//# sourceUrl sourcefile.js');
   * We need to export the globally defined symbols "goog" and "COMPILED".
   * Exporting "goog" breaks the compiler optimizations, so we required that
   * be defined externally.
   * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
   * extern generation when that compiler option is enabled.
   */
  if (!COMPILED) {
    goog.global['COMPILED'] = COMPILED;
  }

  goog.provide('goog.string');

  /**
   * Does simple python-style string substitution.
   * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
   * @param {string} str The string containing the pattern.
   * @param {...*} var_args The items to substitute into the pattern.
   * @return {string} A copy of {@code str} in which each occurrence of
   *     {@code %s} has been replaced an argument from {@code var_args}.
   */
  goog.string.subs = function (str, var_args) {
    var splitParts = str.split('%s');
    var returnString = '';

    var subsArguments = Array.prototype.slice.call(arguments, 1);
    while (subsArguments.length &&
    // Replace up to the last split part. We are inserting in the
    // positions between split parts.
    splitParts.length > 1) {
      returnString += splitParts.shift() + subsArguments.shift();
    }

    return returnString + splitParts.join('%s'); // Join unused '%s'
  };

  /**
   * Regular expression that matches an ampersand, for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.AMP_RE_ = /&/g;

  /**
   * Regular expression that matches a less than sign, for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.LT_RE_ = /</g;

  /**
   * Regular expression that matches a greater than sign, for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.GT_RE_ = />/g;

  /**
   * Regular expression that matches a double quote, for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.QUOT_RE_ = /"/g;

  /**
   * Regular expression that matches a single quote, for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.SINGLE_QUOTE_RE_ = /'/g;

  /**
   * Regular expression that matches null character, for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.NULL_RE_ = /\x00/g;

  /**
   * Regular expression that matches a lowercase letter "e", for use in escaping.
   * @const {!RegExp}
   * @private
   */
  goog.string.E_RE_ = /e/g;

  /**
   * Regular expression that matches any character that needs to be escaped.
   * @const {!RegExp}
   * @private
   */
  goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/;

  /**
   * Unescapes an HTML string.
   *
   * @param {string} str The string to unescape.
   * @return {string} An unescaped copy of {@code str}.
   */
  goog.string.unescapeEntities = function (str) {
    if (goog.string.contains(str, '&')) {
      // We are careful not to use a DOM if we do not have one or we explicitly
      // requested non-DOM html unescaping.
      if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING && 'document' in goog.global) {
        return goog.string.unescapeEntitiesUsingDom_(str);
      } else {
        // Fall back on pure XML entities
        return goog.string.unescapePureXmlEntities_(str);
      }
    }
    return str;
  };

  /**
   * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
   * entities. This function is XSS-safe and whitespace-preserving.
   * @private
   * @param {string} str The string to unescape.
   * @param {Document=} opt_document An optional document to use for creating
   *     elements. If this is not specified then the default window.document
   *     will be used.
   * @return {string} The unescaped {@code str} string.
   */
  goog.string.unescapeEntitiesUsingDom_ = function (str, opt_document) {
    /** @type {!Object<string, string>} */
    var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
    var div;
    if (opt_document) {
      div = opt_document.createElement('div');
    } else {
      div = goog.global.document.createElement('div');
    }
    // Match as many valid entity characters as possible. If the actual entity
    // happens to be shorter, it will still work as innerHTML will return the
    // trailing characters unchanged. Since the entity characters do not include
    // open angle bracket, there is no chance of XSS from the innerHTML use.
    // Since no whitespace is passed to innerHTML, whitespace is preserved.
    return str.replace(goog.string.HTML_ENTITY_PATTERN_, function (s, entity) {
      // Check for cached entity.
      var value = seen[s];
      if (value) {
        return value;
      }
      // Check for numeric entity.
      if (entity.charAt(0) == '#') {
        // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
        var n = Number('0' + entity.substr(1));
        if (!isNaN(n)) {
          value = String.fromCharCode(n);
        }
      }
      // Fall back to innerHTML otherwise.
      if (!value) {
        // Append a non-entity character to avoid a bug in Webkit that parses
        // an invalid entity at the end of innerHTML text as the empty string.
        div.innerHTML = s + ' ';
        // Then remove the trailing character from the result.
        value = div.firstChild.nodeValue.slice(0, -1);
      }
      // Cache and return.
      return seen[s] = value;
    });
  };

  /**
   * Unescapes XML entities.
   * @private
   * @param {string} str The string to unescape.
   * @return {string} An unescaped copy of {@code str}.
   */
  goog.string.unescapePureXmlEntities_ = function (str) {
    return str.replace(/&([^;]+);/g, function (s, entity) {
      switch (entity) {
        case 'amp':
          return '&';
        case 'lt':
          return '<';
        case 'gt':
          return '>';
        case 'quot':
          return '"';
        default:
          if (entity.charAt(0) == '#') {
            // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
            var n = Number('0' + entity.substr(1));
            if (!isNaN(n)) {
              return String.fromCharCode(n);
            }
          }
          // For invalid entities we just return the entity
          return s;
      }
    });
  };

  /**
   * Regular expression that matches an HTML entity.
   * See also HTML5: Tokenization / Tokenizing character references.
   * @private
   * @type {!RegExp}
   */
  goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;

  /**
   * Determines whether a string contains a substring.
   * @param {string} str The string to search.
   * @param {string} subString The substring to search for.
   * @return {boolean} Whether {@code str} contains {@code subString}.
   */
  goog.string.contains = function (str, subString) {
    return str.indexOf(subString) != -1;
  };

  /**
   * Escapes double quote '"' and single quote '\'' characters in addition to
   * '&', '<', and '>' so that a string can be included in an HTML tag attribute
   * value within double or single quotes.
   *
   * It should be noted that > doesn't need to be escaped for the HTML or XML to
   * be valid, but it has been decided to escape it for consistency with other
   * implementations.
   *
   * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
   * lowercase letter "e".
   *
   * NOTE(user):
   * HtmlEscape is often called during the generation of large blocks of HTML.
   * Using statics for the regular expressions and strings is an optimization
   * that can more than half the amount of time IE spends in this function for
   * large apps, since strings and regexes both contribute to GC allocations.
   *
   * Testing for the presence of a character before escaping increases the number
   * of function calls, but actually provides a speed increase for the average
   * case -- since the average case often doesn't require the escaping of all 4
   * characters and indexOf() is much cheaper than replace().
   * The worst case does suffer slightly from the additional calls, therefore the
   * opt_isLikelyToContainHtmlChars option has been included for situations
   * where all 4 HTML entities are very likely to be present and need escaping.
   *
   * Some benchmarks (times tended to fluctuate +-0.05ms):
   *                                     FireFox                     IE6
   * (no chars / average (mix of cases) / all 4 chars)
   * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
   * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
   * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
   *
   * An additional advantage of checking if replace actually needs to be called
   * is a reduction in the number of object allocations, so as the size of the
   * application grows the difference between the various methods would increase.
   *
   * @param {string} str string to be escaped.
   * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
   *     if the character needs replacing - use this option if you expect each of
   *     the characters to appear often. Leave false if you expect few html
   *     characters to occur in your strings, such as if you are escaping HTML.
   * @return {string} An escaped copy of {@code str}.
   */
  goog.string.htmlEscape = function (str, opt_isLikelyToContainHtmlChars) {

    if (opt_isLikelyToContainHtmlChars) {
      str = str.replace(goog.string.AMP_RE_, '&amp;').replace(goog.string.LT_RE_, '&lt;').replace(goog.string.GT_RE_, '&gt;').replace(goog.string.QUOT_RE_, '&quot;').replace(goog.string.SINGLE_QUOTE_RE_, '&#39;').replace(goog.string.NULL_RE_, '&#0;');
      if (goog.string.DETECT_DOUBLE_ESCAPING) {
        str = str.replace(goog.string.E_RE_, '&#101;');
      }
      return str;
    } else {
      // quick test helps in the case when there are no chars to replace, in
      // worst case this makes barely a difference to the time taken
      if (!goog.string.ALL_RE_.test(str)) return str;

      // str.indexOf is faster than regex.test in this case
      if (str.indexOf('&') != -1) {
        str = str.replace(goog.string.AMP_RE_, '&amp;');
      }
      if (str.indexOf('<') != -1) {
        str = str.replace(goog.string.LT_RE_, '&lt;');
      }
      if (str.indexOf('>') != -1) {
        str = str.replace(goog.string.GT_RE_, '&gt;');
      }
      if (str.indexOf('"') != -1) {
        str = str.replace(goog.string.QUOT_RE_, '&quot;');
      }
      if (str.indexOf('\'') != -1) {
        str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');
      }
      if (str.indexOf('\x00') != -1) {
        str = str.replace(goog.string.NULL_RE_, '&#0;');
      }
      if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {
        str = str.replace(goog.string.E_RE_, '&#101;');
      }
      return str;
    }
  };

  goog.debug = {};

  /**
   * Returns the type of a value. If a constructor is passed, and a suitable
   * string cannot be found, 'unknown type name' will be returned.
   *
   * <p>Forked rather than moved from {@link goog.asserts.getType_}
   * to avoid adding a dependency to goog.asserts.
   * @param {*} value A constructor, object, or primitive.
   * @return {string} The best display name for the value, or 'unknown type name'.
   */
  goog.debug.runtimeType = function (value) {
    if (value instanceof Function) {
      return value.displayName || value.name || 'unknown type name';
    } else if (value instanceof Object) {
      return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
    } else {
      return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
    }
  };

  // Copyright 2009 The Closure Library Authors. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS-IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  /**
   * @fileoverview Provides a base class for custom Error objects such that the
   * stack is correctly maintained.
   *
   * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
   * sufficient.
   *
   */

  /**
   * Base class for custom error objects.
   * @param {*=} opt_msg The message associated with the error.
   * @constructor
   * @extends {Error}
   */
  goog.debug.Error = function (opt_msg) {

    // Attempt to ensure there is a stack trace.
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, goog.debug.Error);
    } else {
      var stack = new Error().stack;
      if (stack) {
        this.stack = stack;
      }
    }

    if (opt_msg) {
      this.message = String(opt_msg);
    }

    /**
     * Whether to report this error to the server. Setting this to false will
     * cause the error reporter to not report the error back to the server,
     * which can be useful if the client knows that the error has already been
     * logged on the server.
     * @type {boolean}
     */
    this.reportErrorToServer = true;
  };
  goog.inherits(goog.debug.Error, Error);

  /** @override */
  goog.debug.Error.prototype.name = 'CustomError';

  /**
   * @fileoverview Definition of goog.dom.NodeType.
   */

  goog.dom = {};

  /**
   * Constants for the nodeType attribute in the Node interface.
   *
   * These constants match those specified in the Node interface. These are
   * usually present on the Node object in recent browsers, but not in older
   * browsers (specifically, early IEs) and thus are given here.
   *
   * In some browsers (early IEs), these are not defined on the Node object,
   * so they are provided here.
   *
   * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
   * @enum {number}
   */
  goog.dom.NodeType = {
    ELEMENT: 1,
    ATTRIBUTE: 2,
    TEXT: 3,
    CDATA_SECTION: 4,
    ENTITY_REFERENCE: 5,
    ENTITY: 6,
    PROCESSING_INSTRUCTION: 7,
    COMMENT: 8,
    DOCUMENT: 9,
    DOCUMENT_TYPE: 10,
    DOCUMENT_FRAGMENT: 11,
    NOTATION: 12
  };

  // Copyright 2007 The Closure Library Authors. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS-IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  /**
   * @fileoverview Utility functions for supporting Bidi issues.
   */

  /**
   * Namespace for bidi supporting functions.
   */
  goog.provide('goog.i18n.bidi');
  goog.provide('goog.i18n.bidi.Dir');
  goog.provide('goog.i18n.bidi.DirectionalString');
  goog.provide('goog.i18n.bidi.Format');

  /**
   * @define {boolean} FORCE_RTL forces the {@link goog.i18n.bidi.IS_RTL} constant
   * to say that the current locale is a RTL locale.  This should only be used
   * if you want to override the default behavior for deciding whether the
   * current locale is RTL or not.
   *
   * {@see goog.i18n.bidi.IS_RTL}
   */
  goog.define('goog.i18n.bidi.FORCE_RTL', false);

  /**
   * Constant that defines whether or not the current locale is a RTL locale.
   * If {@link goog.i18n.bidi.FORCE_RTL} is not true, this constant will default
   * to check that {@link goog.LOCALE} is one of a few major RTL locales.
   *
   * <p>This is designed to be a maximally efficient compile-time constant. For
   * example, for the default goog.LOCALE, compiling
   * "if (goog.i18n.bidi.IS_RTL) alert('rtl') else {}" should produce no code. It
   * is this design consideration that limits the implementation to only
   * supporting a few major RTL locales, as opposed to the broader repertoire of
   * something like goog.i18n.bidi.isRtlLanguage.
   *
   * <p>Since this constant refers to the directionality of the locale, it is up
   * to the caller to determine if this constant should also be used for the
   * direction of the UI.
   *
   * {@see goog.LOCALE}
   *
   * @type {boolean}
   *
   * TODO(user): write a test that checks that this is a compile-time constant.
   */
  goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == 'ar' || goog.LOCALE.substring(0, 2).toLowerCase() == 'fa' || goog.LOCALE.substring(0, 2).toLowerCase() == 'he' || goog.LOCALE.substring(0, 2).toLowerCase() == 'iw' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ps' || goog.LOCALE.substring(0, 2).toLowerCase() == 'sd' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ug' || goog.LOCALE.substring(0, 2).toLowerCase() == 'ur' || goog.LOCALE.substring(0, 2).toLowerCase() == 'yi') && (goog.LOCALE.length == 2 || goog.LOCALE.substring(2, 3) == '-' || goog.LOCALE.substring(2, 3) == '_') || goog.LOCALE.length >= 3 && goog.LOCALE.substring(0, 3).toLowerCase() == 'ckb' && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == '-' || goog.LOCALE.substring(3, 4) == '_');

  /**
   * Unicode formatting characters and directionality string constants.
   * @enum {string}
   */
  goog.i18n.bidi.Format = {
    /** Unicode "Left-To-Right Embedding" (LRE) character. */
    LRE: '\u202A',
    /** Unicode "Right-To-Left Embedding" (RLE) character. */
    RLE: '\u202B',
    /** Unicode "Pop Directional Formatting" (PDF) character. */
    PDF: '\u202C',
    /** Unicode "Left-To-Right Mark" (LRM) character. */
    LRM: '\u200E',
    /** Unicode "Right-To-Left Mark" (RLM) character. */
    RLM: '\u200F'
  };

  /**
   * Directionality enum.
   * @enum {number}
   */
  goog.i18n.bidi.Dir = {
    /**
     * Left-to-right.
     */
    LTR: 1,

    /**
     * Right-to-left.
     */
    RTL: -1,

    /**
     * Neither left-to-right nor right-to-left.
     */
    NEUTRAL: 0
  };

  /**
   * 'right' string constant.
   * @type {string}
   */
  goog.i18n.bidi.RIGHT = 'right';

  /**
   * 'left' string constant.
   * @type {string}
   */
  goog.i18n.bidi.LEFT = 'left';

  /**
   * 'left' if locale is RTL, 'right' if not.
   * @type {string}
   */
  goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;

  /**
   * 'right' if locale is RTL, 'left' if not.
   * @type {string}
   */
  goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;

  /**
   * Convert a directionality given in various formats to a goog.i18n.bidi.Dir
   * constant. Useful for interaction with different standards of directionality
   * representation.
   *
   * @param {goog.i18n.bidi.Dir|number|boolean|null} givenDir Directionality given
   *     in one of the following formats:
   *     1. A goog.i18n.bidi.Dir constant.
   *     2. A number (positive = LTR, negative = RTL, 0 = neutral).
   *     3. A boolean (true = RTL, false = LTR).
   *     4. A null for unknown directionality.
   * @param {boolean=} opt_noNeutral Whether a givenDir of zero or
   *     goog.i18n.bidi.Dir.NEUTRAL should be treated as null, i.e. unknown, in
   *     order to preserve legacy behavior.
   * @return {?goog.i18n.bidi.Dir} A goog.i18n.bidi.Dir constant matching the
   *     given directionality. If given null, returns null (i.e. unknown).
   */
  goog.i18n.bidi.toDir = function (givenDir, opt_noNeutral) {
    if (typeof givenDir == 'number') {
      // This includes the non-null goog.i18n.bidi.Dir case.
      return givenDir > 0 ? goog.i18n.bidi.Dir.LTR : givenDir < 0 ? goog.i18n.bidi.Dir.RTL : opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
    } else if (givenDir == null) {
      return null;
    } else {
      // Must be typeof givenDir == 'boolean'.
      return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
    }
  };

  /**
   * A practical pattern to identify strong LTR characters. This pattern is not
   * theoretically correct according to the Unicode standard. It is simplified for
   * performance and small code size.
   * @type {string}
   * @private
   */
  goog.i18n.bidi.ltrChars_ = 'A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0800-\u1FFF' + '\u200E\u2C00-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF';

  /**
   * A practical pattern to identify strong RTL character. This pattern is not
   * theoretically correct according to the Unicode standard. It is simplified
   * for performance and small code size.
   * @type {string}
   * @private
   */
  goog.i18n.bidi.rtlChars_ = '\u0591-\u06EF\u06FA-\u07FF\u200F\uFB1D-\uFDFF\uFE70-\uFEFC';

  /**
   * Simplified regular expression for an HTML tag (opening or closing) or an HTML
   * escape. We might want to skip over such expressions when estimating the text
   * directionality.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;

  /**
   * Returns the input text with spaces instead of HTML tags or HTML escapes, if
   * opt_isStripNeeded is true. Else returns the input as is.
   * Useful for text directionality estimation.
   * Note: the function should not be used in other contexts; it is not 100%
   * correct, but rather a good-enough implementation for directionality
   * estimation purposes.
   * @param {string} str The given string.
   * @param {boolean=} opt_isStripNeeded Whether to perform the stripping.
   *     Default: false (to retain consistency with calling functions).
   * @return {string} The given string cleaned of HTML tags / escapes.
   * @private
   */
  goog.i18n.bidi.stripHtmlIfNeeded_ = function (str, opt_isStripNeeded) {
    return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, '') : str;
  };

  /**
   * Regular expression to check for RTL characters.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.rtlCharReg_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + ']');

  /**
   * Regular expression to check for LTR characters.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.ltrCharReg_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + ']');

  /**
   * Test whether the given string has any RTL characters in it.
   * @param {string} str The given string that need to be tested.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether the string contains RTL characters.
   */
  goog.i18n.bidi.hasAnyRtl = function (str, opt_isHtml) {
    return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
  };

  /**
   * Test whether the given string has any RTL characters in it.
   * @param {string} str The given string that need to be tested.
   * @return {boolean} Whether the string contains RTL characters.
   * @deprecated Use hasAnyRtl.
   */
  goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;

  /**
   * Test whether the given string has any LTR characters in it.
   * @param {string} str The given string that need to be tested.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether the string contains LTR characters.
   */
  goog.i18n.bidi.hasAnyLtr = function (str, opt_isHtml) {
    return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
  };

  /**
   * Regular expression pattern to check if the first character in the string
   * is LTR.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.ltrRe_ = new RegExp('^[' + goog.i18n.bidi.ltrChars_ + ']');

  /**
   * Regular expression pattern to check if the first character in the string
   * is RTL.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.rtlRe_ = new RegExp('^[' + goog.i18n.bidi.rtlChars_ + ']');

  /**
   * Check if the first character in the string is RTL or not.
   * @param {string} str The given string that need to be tested.
   * @return {boolean} Whether the first character in str is an RTL char.
   */
  goog.i18n.bidi.isRtlChar = function (str) {
    return goog.i18n.bidi.rtlRe_.test(str);
  };

  /**
   * Check if the first character in the string is LTR or not.
   * @param {string} str The given string that need to be tested.
   * @return {boolean} Whether the first character in str is an LTR char.
   */
  goog.i18n.bidi.isLtrChar = function (str) {
    return goog.i18n.bidi.ltrRe_.test(str);
  };

  /**
   * Check if the first character in the string is neutral or not.
   * @param {string} str The given string that need to be tested.
   * @return {boolean} Whether the first character in str is a neutral char.
   */
  goog.i18n.bidi.isNeutralChar = function (str) {
    return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str);
  };

  /**
   * Regular expressions to check if a piece of text is of LTR directionality
   * on first character with strong directionality.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.ltrDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.rtlChars_ + ']*[' + goog.i18n.bidi.ltrChars_ + ']');

  /**
   * Regular expressions to check if a piece of text is of RTL directionality
   * on first character with strong directionality.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.rtlDirCheckRe_ = new RegExp('^[^' + goog.i18n.bidi.ltrChars_ + ']*[' + goog.i18n.bidi.rtlChars_ + ']');

  /**
   * Check whether the first strongly directional character (if any) is RTL.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether RTL directionality is detected using the first
   *     strongly-directional character method.
   */
  goog.i18n.bidi.startsWithRtl = function (str, opt_isHtml) {
    return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
  };

  /**
   * Check whether the first strongly directional character (if any) is RTL.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether RTL directionality is detected using the first
   *     strongly-directional character method.
   * @deprecated Use startsWithRtl.
   */
  goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;

  /**
   * Check whether the first strongly directional character (if any) is LTR.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether LTR directionality is detected using the first
   *     strongly-directional character method.
   */
  goog.i18n.bidi.startsWithLtr = function (str, opt_isHtml) {
    return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
  };

  /**
   * Check whether the first strongly directional character (if any) is LTR.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether LTR directionality is detected using the first
   *     strongly-directional character method.
   * @deprecated Use startsWithLtr.
   */
  goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;

  /**
   * Regular expression to check if a string looks like something that must
   * always be LTR even in RTL text, e.g. a URL. When estimating the
   * directionality of text containing these, we treat these as weakly LTR,
   * like numbers.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;

  /**
   * Check whether the input string either contains no strongly directional
   * characters or looks like a url.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether neutral directionality is detected.
   */
  goog.i18n.bidi.isNeutralText = function (str, opt_isHtml) {
    str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
    return goog.i18n.bidi.isRequiredLtrRe_.test(str) || !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str);
  };

  /**
   * Regular expressions to check if the last strongly-directional character in a
   * piece of text is LTR.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.ltrChars_ + '][^' + goog.i18n.bidi.rtlChars_ + ']*$');

  /**
   * Regular expressions to check if the last strongly-directional character in a
   * piece of text is RTL.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp('[' + goog.i18n.bidi.rtlChars_ + '][^' + goog.i18n.bidi.ltrChars_ + ']*$');

  /**
   * Check if the exit directionality a piece of text is LTR, i.e. if the last
   * strongly-directional character in the string is LTR.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether LTR exit directionality was detected.
   */
  goog.i18n.bidi.endsWithLtr = function (str, opt_isHtml) {
    return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
  };

  /**
   * Check if the exit directionality a piece of text is LTR, i.e. if the last
   * strongly-directional character in the string is LTR.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether LTR exit directionality was detected.
   * @deprecated Use endsWithLtr.
   */
  goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;

  /**
   * Check if the exit directionality a piece of text is RTL, i.e. if the last
   * strongly-directional character in the string is RTL.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether RTL exit directionality was detected.
   */
  goog.i18n.bidi.endsWithRtl = function (str, opt_isHtml) {
    return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml));
  };

  /**
   * Check if the exit directionality a piece of text is RTL, i.e. if the last
   * strongly-directional character in the string is RTL.
   * @param {string} str String being checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether RTL exit directionality was detected.
   * @deprecated Use endsWithRtl.
   */
  goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;

  /**
   * A regular expression for matching right-to-left language codes.
   * See {@link #isRtlLanguage} for the design.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.rtlLocalesRe_ = new RegExp('^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|' + '.*[-_](Arab|Hebr|Thaa|Nkoo|Tfng))' + '(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)', 'i');

  /**
   * Check if a BCP 47 / III language code indicates an RTL language, i.e. either:
   * - a language code explicitly specifying one of the right-to-left scripts,
   *   e.g. "az-Arab", or<p>
   * - a language code specifying one of the languages normally written in a
   *   right-to-left script, e.g. "fa" (Farsi), except ones explicitly specifying
   *   Latin or Cyrillic script (which are the usual LTR alternatives).<p>
   * The list of right-to-left scripts appears in the 100-199 range in
   * http://www.unicode.org/iso15924/iso15924-num.html, of which Arabic and
   * Hebrew are by far the most widely used. We also recognize Thaana, N'Ko, and
   * Tifinagh, which also have significant modern usage. The rest (Syriac,
   * Samaritan, Mandaic, etc.) seem to have extremely limited or no modern usage
   * and are not recognized to save on code size.
   * The languages usually written in a right-to-left script are taken as those
   * with Suppress-Script: Hebr|Arab|Thaa|Nkoo|Tfng  in
   * http://www.iana.org/assignments/language-subtag-registry,
   * as well as Central (or Sorani) Kurdish (ckb), Sindhi (sd) and Uyghur (ug).
   * Other subtags of the language code, e.g. regions like EG (Egypt), are
   * ignored.
   * @param {string} lang BCP 47 (a.k.a III) language code.
   * @return {boolean} Whether the language code is an RTL language.
   */
  goog.i18n.bidi.isRtlLanguage = function (lang) {
    return goog.i18n.bidi.rtlLocalesRe_.test(lang);
  };

  /**
   * Regular expression for bracket guard replacement in text.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;

  /**
   * Apply bracket guard using LRM and RLM. This is to address the problem of
   * messy bracket display frequently happens in RTL layout.
   * This function works for plain text, not for HTML. In HTML, the opening
   * bracket might be in a different context than the closing bracket (such as
   * an attribute value).
   * @param {string} s The string that need to be processed.
   * @param {boolean=} opt_isRtlContext specifies default direction (usually
   *     direction of the UI).
   * @return {string} The processed string, with all bracket guarded.
   */
  goog.i18n.bidi.guardBracketInText = function (s, opt_isRtlContext) {
    var useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
    var mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
    return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + '$&' + mark);
  };

  /**
   * Enforce the html snippet in RTL directionality regardless overall context.
   * If the html piece was enclosed by tag, dir will be applied to existing
   * tag, otherwise a span tag will be added as wrapper. For this reason, if
   * html snippet start with with tag, this tag must enclose the whole piece. If
   * the tag already has a dir specified, this new one will override existing
   * one in behavior (tested on FF and IE).
   * @param {string} html The string that need to be processed.
   * @return {string} The processed string, with directionality enforced to RTL.
   */
  goog.i18n.bidi.enforceRtlInHtml = function (html) {
    if (html.charAt(0) == '<') {
      return html.replace(/<\w+/, '$& dir=rtl');
    }
    // '\n' is important for FF so that it won't incorrectly merge span groups
    return '\n<span dir=rtl>' + html + '</span>';
  };

  /**
   * Enforce RTL on both end of the given text piece using unicode BiDi formatting
   * characters RLE and PDF.
   * @param {string} text The piece of text that need to be wrapped.
   * @return {string} The wrapped string after process.
   */
  goog.i18n.bidi.enforceRtlInText = function (text) {
    return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF;
  };

  /**
   * Enforce the html snippet in RTL directionality regardless overall context.
   * If the html piece was enclosed by tag, dir will be applied to existing
   * tag, otherwise a span tag will be added as wrapper. For this reason, if
   * html snippet start with with tag, this tag must enclose the whole piece. If
   * the tag already has a dir specified, this new one will override existing
   * one in behavior (tested on FF and IE).
   * @param {string} html The string that need to be processed.
   * @return {string} The processed string, with directionality enforced to RTL.
   */
  goog.i18n.bidi.enforceLtrInHtml = function (html) {
    if (html.charAt(0) == '<') {
      return html.replace(/<\w+/, '$& dir=ltr');
    }
    // '\n' is important for FF so that it won't incorrectly merge span groups
    return '\n<span dir=ltr>' + html + '</span>';
  };

  /**
   * Enforce LTR on both end of the given text piece using unicode BiDi formatting
   * characters LRE and PDF.
   * @param {string} text The piece of text that need to be wrapped.
   * @return {string} The wrapped string after process.
   */
  goog.i18n.bidi.enforceLtrInText = function (text) {
    return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF;
  };

  /**
   * Regular expression to find dimensions such as "padding: .3 0.4ex 5px 6;"
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;

  /**
   * Regular expression for left.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.leftRe_ = /left/gi;

  /**
   * Regular expression for right.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.rightRe_ = /right/gi;

  /**
   * Placeholder regular expression for swapping.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.tempRe_ = /%%%%/g;

  /**
   * Swap location parameters and 'left'/'right' in CSS specification. The
   * processed string will be suited for RTL layout. Though this function can
   * cover most cases, there are always exceptions. It is suggested to put
   * those exceptions in separate group of CSS string.
   * @param {string} cssStr CSS spefication string.
   * @return {string} Processed CSS specification string.
   */
  goog.i18n.bidi.mirrorCSS = function (cssStr) {
    return cssStr.
    // reverse dimensions
    replace(goog.i18n.bidi.dimensionsRe_, ':$1 $4 $3 $2').replace(goog.i18n.bidi.leftRe_, '%%%%'). // swap left and right
    replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
  };

  /**
   * Regular expression for hebrew double quote substitution, finding quote
   * directly after hebrew characters.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;

  /**
   * Regular expression for hebrew single quote substitution, finding quote
   * directly after hebrew characters.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;

  /**
   * Replace the double and single quote directly after a Hebrew character with
   * GERESH and GERSHAYIM. In such case, most likely that's user intention.
   * @param {string} str String that need to be processed.
   * @return {string} Processed string with double/single quote replaced.
   */
  goog.i18n.bidi.normalizeHebrewQuote = function (str) {
    return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, '$1\u05F4').replace(goog.i18n.bidi.singleQuoteSubstituteRe_, '$1\u05F3');
  };

  /**
   * Regular expression to split a string into "words" for directionality
   * estimation based on relative word counts.
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.wordSeparatorRe_ = /\s+/;

  /**
   * Regular expression to check if a string contains any numerals. Used to
   * differentiate between completely neutral strings and those containing
   * numbers, which are weakly LTR.
   *
   * Native Arabic digits (\u0660 - \u0669) are not included because although they
   * do flow left-to-right inside a number, this is the case even if the  overall
   * directionality is RTL, and a mathematical expression using these digits is
   * supposed to flow right-to-left overall, including unary plus and minus
   * appearing to the right of a number, and this does depend on the overall
   * directionality being RTL. The digits used in Farsi (\u06F0 - \u06F9), on the
   * other hand, are included, since Farsi math (including unary plus and minus)
   * does flow left-to-right.
   *
   * @type {RegExp}
   * @private
   */
  goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;

  /**
   * This constant controls threshold of RTL directionality.
   * @type {number}
   * @private
   */
  goog.i18n.bidi.rtlDetectionThreshold_ = 0.40;

  /**
   * Estimates the directionality of a string based on relative word counts.
   * If the number of RTL words is above a certain percentage of the total number
   * of strongly directional words, returns RTL.
   * Otherwise, if any words are strongly or weakly LTR, returns LTR.
   * Otherwise, returns UNKNOWN, which is used to mean "neutral".
   * Numbers are counted as weakly LTR.
   * @param {string} str The string to be checked.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {goog.i18n.bidi.Dir} Estimated overall directionality of {@code str}.
   */
  goog.i18n.bidi.estimateDirection = function (str, opt_isHtml) {
    var rtlCount = 0;
    var totalCount = 0;
    var hasWeaklyLtr = false;
    var tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_);
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (goog.i18n.bidi.startsWithRtl(token)) {
        rtlCount++;
        totalCount++;
      } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) {
        hasWeaklyLtr = true;
      } else if (goog.i18n.bidi.hasAnyLtr(token)) {
        totalCount++;
      } else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) {
        hasWeaklyLtr = true;
      }
    }

    return totalCount == 0 ? hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
  };

  /**
   * Check the directionality of a piece of text, return true if the piece of
   * text should be laid out in RTL direction.
   * @param {string} str The piece of text that need to be detected.
   * @param {boolean=} opt_isHtml Whether str is HTML / HTML-escaped.
   *     Default: false.
   * @return {boolean} Whether this piece of text should be laid out in RTL.
   */
  goog.i18n.bidi.detectRtlDirectionality = function (str, opt_isHtml) {
    return goog.i18n.bidi.estimateDirection(str, opt_isHtml) == goog.i18n.bidi.Dir.RTL;
  };

  /**
   * Sets text input element's directionality and text alignment based on a
   * given directionality. Does nothing if the given directionality is unknown or
   * neutral.
   * @param {Element} element Input field element to set directionality to.
   * @param {goog.i18n.bidi.Dir|number|boolean|null} dir Desired directionality,
   *     given in one of the following formats:
   *     1. A goog.i18n.bidi.Dir constant.
   *     2. A number (positive = LRT, negative = RTL, 0 = neutral).
   *     3. A boolean (true = RTL, false = LTR).
   *     4. A null for unknown directionality.
   */
  goog.i18n.bidi.setElementDirAndAlign = function (element, dir) {
    if (element) {
      dir = goog.i18n.bidi.toDir(dir);
      if (dir) {
        element.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
        element.dir = dir == goog.i18n.bidi.Dir.RTL ? 'rtl' : 'ltr';
      }
    }
  };

  /**
   * Sets element dir based on estimated directionality of the given text.
   * @param {!Element} element
   * @param {string} text
   */
  goog.i18n.bidi.setElementDirByTextDirectionality = function (element, text) {
    switch (goog.i18n.bidi.estimateDirection(text)) {
      case goog.i18n.bidi.Dir.LTR:
        element.dir = 'ltr';
        break;
      case goog.i18n.bidi.Dir.RTL:
        element.dir = 'rtl';
        break;
      default:
        // Default for no direction, inherit from document.
        element.removeAttribute('dir');
    }
  };

  /**
   * Strings that have an (optional) known direction.
   *
   * Implementations of this interface are string-like objects that carry an
   * attached direction, if known.
   * @interface
   */
  goog.i18n.bidi.DirectionalString = function () {};

  /**
   * Interface marker of the DirectionalString interface.
   *
   * This property can be used to determine at runtime whether or not an object
   * implements this interface.  All implementations of this interface set this
   * property to {@code true}.
   * @type {boolean}
   */
  goog.i18n.bidi.DirectionalString.prototype.implementsGoogI18nBidiDirectionalString;

  /**
   * Retrieves this object's known direction (if any).
   * @return {?goog.i18n.bidi.Dir} The known direction. Null if unknown.
   */
  goog.i18n.bidi.DirectionalString.prototype.getDirection;

  // Copyright 2008 The Closure Library Authors. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS-IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  /**
   * @fileoverview Utilities to check the preconditions, postconditions and
   * invariants runtime.
   *
   * Methods in this package should be given special treatment by the compiler
   * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
   * will restrict <code>foo</code> to a truthy value.
   *
   * The compiler has an option to disable asserts. So code like:
   * <code>
   * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
   * </code>
   * will be transformed into:
   * <code>
   * var x = foo();
   * </code>
   * The compiler will leave in foo() (because its return value is used),
   * but it will remove bar() because it assumes it does not have side-effects.
   *
   * @author agrieve@google.com (Andrew Grieve)
   */

  goog.provide('goog.asserts');

  /**
   * @define {boolean} Whether to strip out asserts or to leave them in.
   */
  goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);

  /**
   * Error object for failed assertions.
   * @param {string} messagePattern The pattern that was used to form message.
   * @param {!Array<*>} messageArgs The items to substitute into the pattern.
   * @constructor
   * @extends {goog.debug.Error}
   * @final
   */
  goog.asserts.AssertionError = function (messagePattern, messageArgs) {
    messageArgs.unshift(messagePattern);
    goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
    // Remove the messagePattern afterwards to avoid permanently modifying the
    // passed in array.
    messageArgs.shift();

    /**
     * The message pattern used to format the error message. Error handlers can
     * use this to uniquely identify the assertion.
     * @type {string}
     */
    this.messagePattern = messagePattern;
  };
  goog.inherits(goog.asserts.AssertionError, goog.debug.Error);

  /** @override */
  goog.asserts.AssertionError.prototype.name = 'AssertionError';

  /**
   * The default error handler.
   * @param {!goog.asserts.AssertionError} e The exception to be handled.
   */
  goog.asserts.DEFAULT_ERROR_HANDLER = function (e) {
    throw e;
  };

  /**
   * The handler responsible for throwing or logging assertion errors.
   * @private {function(!goog.asserts.AssertionError)}
   */
  goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;

  /**
   * Throws an exception with the given message and "Assertion failed" prefixed
   * onto it.
   * @param {string} defaultMessage The message to use if givenMessage is empty.
   * @param {Array<*>} defaultArgs The substitution arguments for defaultMessage.
   * @param {string|undefined} givenMessage Message supplied by the caller.
   * @param {Array<*>} givenArgs The substitution arguments for givenMessage.
   * @throws {goog.asserts.AssertionError} When the value is not a number.
   * @private
   */
  goog.asserts.doAssertFailure_ = function (defaultMessage, defaultArgs, givenMessage, givenArgs) {
    var message = 'Assertion failed';
    if (givenMessage) {
      message += ': ' + givenMessage;
      var args = givenArgs;
    } else if (defaultMessage) {
      message += ': ' + defaultMessage;
      args = defaultArgs;
    }
    // The '' + works around an Opera 10 bug in the unit tests. Without it,
    // a stack trace is added to var message above. With this, a stack trace is
    // not added until this line (it causes the extra garbage to be added after
    // the assertion message instead of in the middle of it).
    var e = new goog.asserts.AssertionError('' + message, args || []);
    goog.asserts.errorHandler_(e);
  };

  /**
   * Sets a custom error handler that can be used to customize the behavior of
   * assertion failures, for example by turning all assertion failures into log
   * messages.
   * @param {function(!goog.asserts.AssertionError)} errorHandler
   */
  goog.asserts.setErrorHandler = function (errorHandler) {
    if (goog.asserts.ENABLE_ASSERTS) {
      goog.asserts.errorHandler_ = errorHandler;
    }
  };

  /**
   * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
   * true.
   * @template T
   * @param {T} condition The condition to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {T} The value of the condition.
   * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
   */
  goog.asserts.assert = function (condition, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !condition) {
      goog.asserts.doAssertFailure_('', null, opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return condition;
  };

  /**
   * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
   * when we want to add a check in the unreachable area like switch-case
   * statement:
   *
   * <pre>
   *  switch(type) {
   *    case FOO: doSomething(); break;
   *    case BAR: doSomethingElse(); break;
   *    default: goog.assert.fail('Unrecognized type: ' + type);
   *      // We have only 2 types - "default:" section is unreachable code.
   *  }
   * </pre>
   *
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @throws {goog.asserts.AssertionError} Failure.
   */
  goog.asserts.fail = function (opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS) {
      goog.asserts.errorHandler_(new goog.asserts.AssertionError('Failure' + (opt_message ? ': ' + opt_message : ''), Array.prototype.slice.call(arguments, 1)));
    }
  };

  /**
   * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {number} The value, guaranteed to be a number when asserts enabled.
   * @throws {goog.asserts.AssertionError} When the value is not a number.
   */
  goog.asserts.assertNumber = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
      goog.asserts.doAssertFailure_('Expected number but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {number} */value
    );
  };

  /**
   * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {string} The value, guaranteed to be a string when asserts enabled.
   * @throws {goog.asserts.AssertionError} When the value is not a string.
   */
  goog.asserts.assertString = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
      goog.asserts.doAssertFailure_('Expected string but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {string} */value
    );
  };

  /**
   * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {!Function} The value, guaranteed to be a function when asserts
   *     enabled.
   * @throws {goog.asserts.AssertionError} When the value is not a function.
   */
  goog.asserts.assertFunction = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
      goog.asserts.doAssertFailure_('Expected function but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {!Function} */value
    );
  };

  /**
   * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {!Object} The value, guaranteed to be a non-null object.
   * @throws {goog.asserts.AssertionError} When the value is not an object.
   */
  goog.asserts.assertObject = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
      goog.asserts.doAssertFailure_('Expected object but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {!Object} */value
    );
  };

  /**
   * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {!Array<?>} The value, guaranteed to be a non-null array.
   * @throws {goog.asserts.AssertionError} When the value is not an array.
   */
  goog.asserts.assertArray = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
      goog.asserts.doAssertFailure_('Expected array but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {!Array<?>} */value
    );
  };

  /**
   * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {boolean} The value, guaranteed to be a boolean when asserts are
   *     enabled.
   * @throws {goog.asserts.AssertionError} When the value is not a boolean.
   */
  goog.asserts.assertBoolean = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
      goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {boolean} */value
    );
  };

  /**
   * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
   * @param {*} value The value to check.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @return {!Element} The value, likely to be a DOM Element when asserts are
   *     enabled.
   * @throws {goog.asserts.AssertionError} When the value is not an Element.
   */
  goog.asserts.assertElement = function (value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) {
      goog.asserts.doAssertFailure_('Expected Element but got %s: %s.', [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    }
    return (/** @type {!Element} */value
    );
  };

  /**
   * Checks if the value is an instance of the user-defined type if
   * goog.asserts.ENABLE_ASSERTS is true.
   *
   * The compiler may tighten the type returned by this function.
   *
   * @param {?} value The value to check.
   * @param {function(new: T, ...)} type A user-defined constructor.
   * @param {string=} opt_message Error message in case of failure.
   * @param {...*} var_args The items to substitute into the failure message.
   * @throws {goog.asserts.AssertionError} When the value is not an instance of
   *     type.
   * @return {T}
   * @template T
   */
  goog.asserts.assertInstanceof = function (value, type, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
      goog.asserts.doAssertFailure_('Expected instanceof %s but got %s.', [goog.asserts.getType_(type), goog.asserts.getType_(value)], opt_message, Array.prototype.slice.call(arguments, 3));
    }
    return value;
  };

  /**
   * Checks that no enumerable keys are present in Object.prototype. Such keys
   * would break most code that use {@code for (var ... in ...)} loops.
   */
  goog.asserts.assertObjectPrototypeIsIntact = function () {
    for (var key in Object.prototype) {
      goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
    }
  };

  /**
   * Returns the type of a value. If a constructor is passed, and a suitable
   * string cannot be found, 'unknown type name' will be returned.
   * @param {*} value A constructor, object, or primitive.
   * @return {string} The best display name for the value, or 'unknown type name'.
   * @private
   */
  goog.asserts.getType_ = function (value) {
    if (value instanceof Function) {
      return value.displayName || value.name || 'unknown type name';
    } else if (value instanceof Object) {
      return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
    } else {
      return value === null ? 'null' : typeof value === 'undefined' ? 'undefined' : _typeof(value);
    }
  };

  /**
   * @fileoverview Utility for fast string concatenation.
   */

  /**
   * Utility class to facilitate string concatenation.
   *
   * @param {*=} opt_a1 Optional first initial item to append.
   * @param {...*} var_args Other initial items to
   *     append, e.g., new goog.string.StringBuffer('foo', 'bar').
   * @constructor
   */
  goog.string.StringBuffer = function (opt_a1, var_args) {
    if (opt_a1 != null) {
      this.append.apply(this, arguments);
    }
  };

  /**
   * Internal buffer for the string to be concatenated.
   * @type {string}
   * @private
   */
  goog.string.StringBuffer.prototype.buffer_ = '';

  /**
   * Sets the contents of the string buffer object, replacing what's currently
   * there.
   *
   * @param {*} s String to set.
   */
  goog.string.StringBuffer.prototype.set = function (s) {
    this.buffer_ = '' + s;
  };

  /**
   * Appends one or more items to the buffer.
   *
   * Calling this with null, undefined, or empty arguments is an error.
   *
   * @param {*} a1 Required first string.
   * @param {*=} opt_a2 Optional second string.
   * @param {...?} var_args Other items to append,
   *     e.g., sb.append('foo', 'bar', 'baz').
   * @return {!goog.string.StringBuffer} This same StringBuffer object.
   * @suppress {duplicate}
   */
  goog.string.StringBuffer.prototype.append = function (a1, opt_a2, var_args) {
    // Use a1 directly to avoid arguments instantiation for single-arg case.
    this.buffer_ += String(a1);
    if (opt_a2 != null) {
      // second argument is undefined (null == undefined)
      for (var i = 1; i < arguments.length; i++) {
        this.buffer_ += arguments[i];
      }
    }
    return this;
  };

  /**
   * Clears the internal buffer.
   */
  goog.string.StringBuffer.prototype.clear = function () {
    this.buffer_ = '';
  };

  /**
   * @return {number} the length of the current contents of the buffer.
   */
  goog.string.StringBuffer.prototype.getLength = function () {
    return this.buffer_.length;
  };

  /**
   * @return {string} The concatenated string.
   * @override
   */
  goog.string.StringBuffer.prototype.toString = function () {
    return this.buffer_;
  };

  // Copyright 2012 The Closure Library Authors. All Rights Reserved.
  //
  // Licensed under the Apache License, Version 2.0 (the "License");
  // you may not use this file except in compliance with the License.
  // You may obtain a copy of the License at
  //
  //      http://www.apache.org/licenses/LICENSE-2.0
  //
  // Unless required by applicable law or agreed to in writing, software
  // distributed under the License is distributed on an "AS-IS" BASIS,
  // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  // See the License for the specific language governing permissions and
  // limitations under the License.

  /**
   * @fileoverview Soy data primitives.
   *
   * The goal is to encompass data types used by Soy, especially to mark content
   * as known to be "safe".
   *
   * @author gboyer@google.com (Garrett Boyer)
   */

  goog.soy = {};
  goog.soy.data = {};

  /**
   * A type of textual content.
   *
   * This is an enum of type Object so that these values are unforgeable.
   *
   * @enum {!Object}
   */
  goog.soy.data.SanitizedContentKind = {

    /**
     * A snippet of HTML that does not start or end inside a tag, comment, entity,
     * or DOCTYPE; and that does not contain any executable code
     * (JS, {@code <object>}s, etc.) from a different trust domain.
     */
    HTML: goog.DEBUG ? { sanitizedContentKindHtml: true } : {},

    /**
     * Executable Javascript code or expression, safe for insertion in a
     * script-tag or event handler context, known to be free of any
     * attacker-controlled scripts. This can either be side-effect-free
     * Javascript (such as JSON) or Javascript that's entirely under Google's
     * control.
     */
    JS: goog.DEBUG ? { sanitizedContentJsChars: true } : {},

    /** A properly encoded portion of a URI. */
    URI: goog.DEBUG ? { sanitizedContentUri: true } : {},

    /** A resource URI not under attacker control. */
    TRUSTED_RESOURCE_URI: goog.DEBUG ? { sanitizedContentTrustedResourceUri: true } : {},

    /**
     * Repeated attribute names and values. For example,
     * {@code dir="ltr" foo="bar" onclick="trustedFunction()" checked}.
     */
    ATTRIBUTES: goog.DEBUG ? { sanitizedContentHtmlAttribute: true } : {},

    // TODO: Consider separating rules, declarations, and values into
    // separate types, but for simplicity, we'll treat explicitly blessed
    // SanitizedContent as allowed in all of these contexts.
    /**
     * A CSS3 declaration, property, value or group of semicolon separated
     * declarations.
     */
    CSS: goog.DEBUG ? { sanitizedContentCss: true } : {},

    /**
     * Unsanitized plain-text content.
     *
     * This is effectively the "null" entry of this enum, and is sometimes used
     * to explicitly mark content that should never be used unescaped. Since any
     * string is safe to use as text, being of ContentKind.TEXT makes no
     * guarantees about its safety in any other context such as HTML.
     */
    TEXT: goog.DEBUG ? { sanitizedContentKindText: true } : {}
  };

  /**
   * A string-like object that carries a content-type and a content direction.
   *
   * IMPORTANT! Do not create these directly, nor instantiate the subclasses.
   * Instead, use a trusted, centrally reviewed library as endorsed by your team
   * to generate these objects. Otherwise, you risk accidentally creating
   * SanitizedContent that is attacker-controlled and gets evaluated unescaped in
   * templates.
   *
   * @constructor
   */
  goog.soy.data.SanitizedContent = function () {
    throw Error('Do not instantiate directly');
  };

  /**
   * The context in which this content is safe from XSS attacks.
   * @type {goog.soy.data.SanitizedContentKind}
   */
  goog.soy.data.SanitizedContent.prototype.contentKind;

  /**
   * The content's direction; null if unknown and thus to be estimated when
   * necessary.
   * @type {?goog.i18n.bidi.Dir}
   */
  goog.soy.data.SanitizedContent.prototype.contentDir = null;

  /**
   * The already-safe content.
   * @protected {string}
   */
  goog.soy.data.SanitizedContent.prototype.content;

  /**
   * Gets the already-safe content.
   * @return {string}
   */
  goog.soy.data.SanitizedContent.prototype.getContent = function () {
    return this.content;
  };

  /** @override */
  goog.soy.data.SanitizedContent.prototype.toString = function () {
    return this.content;
  };

  /**
   * An intermediary base class to allow the type system to sepcify text templates
   * without referencing the soydata package.
   * @extends {goog.soy.data.SanitizedContent}
   * @constructor
   */
  goog.soy.data.UnsanitizedText = function () {
    // TODO(gboyer): Delete this class after moving soydata to Closure.
    goog.soy.data.UnsanitizedText.base(this, 'constructor');
  };

  goog.inherits(goog.soy.data.UnsanitizedText, goog.soy.data.SanitizedContent);

  /**
   * Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
   *
   * The content is a string of HTML that can safely be embedded in a PCDATA
   * context in your app.  If you would be surprised to find that an HTML
   * sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
   * you wouldn't write a template that produces {@code s} on security or privacy
   * grounds, then don't pass {@code s} here. The default content direction is
   * unknown, i.e. to be estimated when necessary.
   *
   * @extends {goog.soy.data.SanitizedContent}
   * @constructor
   */
  goog.soy.data.SanitizedHtml = function () {
    goog.soy.data.SanitizedHtml.base(this, 'constructor');
  };
  goog.inherits(goog.soy.data.SanitizedHtml, goog.soy.data.SanitizedContent);

  /** @override */
  goog.soy.data.SanitizedHtml.prototype.contentKind = goog.soy.data.SanitizedContentKind.HTML;

  /**
   * Checks if the value could be used as the Soy type {html}.
   * @param {*} value
   * @return {boolean}
   */
  goog.soy.data.SanitizedHtml.isCompatibleWith = function (value) {
    return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtml || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeHtml;
  };

  /*
   * Copyright 2008 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @fileoverview
   * Utility functions and classes for Soy.
   *
   * <p>
   * The top portion of this file contains utilities for Soy users:<ul>
   *   <li> soy.StringBuilder: Compatible with the 'stringbuilder' code style.
   * </ul>
   *
   * <p>
   * The bottom portion of this file contains utilities that should only be called
   * by Soy-generated JS code. Please do not use these functions directly from
   * your hand-writen code. Their names all start with '$$'.
   *
   */

  // -----------------------------------------------------------------------------
  // StringBuilder (compatible with the 'stringbuilder' code style).

  (function () {
    var soy = {};
    soy.asserts = {};
    soy.esc = {};
    var soydata = {};

    /**
     * Utility class to facilitate much faster string concatenation in IE,
     * using Array.join() rather than the '+' operator. For other browsers
     * we simply use the '+' operator.
     *
     * @param {Object} var_args Initial items to append,
     *     e.g., new soy.StringBuilder('foo', 'bar').
     * @constructor
     */
    soy.StringBuilder = goog.string.StringBuffer;

    // -----------------------------------------------------------------------------
    // soydata: Defines typed strings, e.g. an HTML string {@code "a<b>c"} is
    // semantically distinct from the plain text string {@code "a<b>c"} and smart
    // templates can take that distinction into account.

    /**
     * A type of textual content.
     *
     * This is an enum of type Object so that these values are unforgeable.
     *
     * @enum {!Object}
     */
    soydata.SanitizedContentKind = goog.soy.data.SanitizedContentKind;

    /**
     * Checks whether a given value is of a given content kind.
     *
     * @param {*} value The value to be examined.
     * @param {soydata.SanitizedContentKind} contentKind The desired content
     *     kind.
     * @return {boolean} Whether the given value is of the given kind.
     * @private
     */
    soydata.isContentKind = function (value, contentKind) {
      // TODO(user): This function should really include the assert on
      // value.constructor that is currently sprinkled at most of the call sites.
      // Unfortunately, that would require a (debug-mode-only) switch statement.
      // TODO(user): Perhaps we should get rid of the contentKind property
      // altogether and only at the constructor.
      return value != null && value.contentKind === contentKind;
    };

    /**
     * Content of type {@link goog.soy.data.SanitizedContentKind.HTML}.
     *
     * The content is a string of HTML that can safely be embedded in a PCDATA
     * context in your app.  If you would be surprised to find that an HTML
     * sanitizer produced {@code s} (e.g.  it runs code or fetches bad URLs) and
     * you wouldn't write a template that produces {@code s} on security or privacy
     * grounds, then don't pass {@code s} here. The default content direction is
     * unknown, i.e. to be estimated when necessary.
     *
     * @constructor
     * @extends {goog.soy.data.SanitizedHtml}
     */
    soydata.SanitizedHtml = function () {
      soydata.SanitizedHtml.base(this, 'constructor'); // Throws an exception.
    };
    goog.inherits(soydata.SanitizedHtml, goog.soy.data.SanitizedHtml);

    /**
     * Returns a SanitizedHtml object for a particular value. The content direction
     * is preserved.
     *
     * This HTML-escapes the value unless it is already SanitizedHtml or SafeHtml.
     *
     * @param {*} value The value to convert. If it is already a SanitizedHtml
     *     object, it is left alone.
     * @return {!soydata.SanitizedHtml} A SanitizedHtml object derived from the
     *     stringified value. It is escaped unless the input is SanitizedHtml or
     *     SafeHtml.
     */
    soydata.SanitizedHtml.from = function (value) {
      // The check is soydata.isContentKind_() inlined for performance.
      if (value != null && value.contentKind === goog.soy.data.SanitizedContentKind.HTML) {
        goog.asserts.assert(value.constructor === goog.soy.data.SanitizedHtml || value.constructor === soydata.SanitizedHtml);
        return (/** @type {!soydata.SanitizedHtml} */value
        );
      }
      if (value instanceof goog.html.SafeHtml) {
        return soydata.VERY_UNSAFE.ordainSanitizedHtml(goog.html.SafeHtml.unwrap(value), value.getDirection());
      }
      return soydata.VERY_UNSAFE.ordainSanitizedHtml(soy.esc.$$escapeHtmlHelper(String(value)), soydata.getContentDir(value));
    };

    /**
     * Checks if the value could be used as the Soy type {html}.
     * @param {*} value
     * @return {boolean}
     */
    soydata.SanitizedHtml.isCompatibleWith = function (value) {
      return goog.isString(value) || value instanceof goog.soy.data.SanitizedHtml || value instanceof goog.soy.data.UnsanitizedText || value instanceof goog.html.SafeHtml;
    };

    /**
     * Content of type {@link soydata.SanitizedContentKind.URI}.
     *
     * The content is a URI chunk that the caller knows is safe to emit in a
     * template. The content direction is LTR.
     *
     * @constructor
     * @extends {goog.soy.data.SanitizedContent}
     */
    soydata.SanitizedUri = function () {
      goog.soy.data.SanitizedContent.call(this); // Throws an exception.
    };
    goog.inherits(soydata.SanitizedUri, goog.soy.data.SanitizedContent);

    /** @override */
    soydata.SanitizedUri.prototype.contentKind = soydata.SanitizedContentKind.URI;

    /** @override */
    soydata.SanitizedUri.prototype.contentDir = goog.i18n.bidi.Dir.LTR;

    /**
     * Unsanitized plain text string.
     *
     * While all strings are effectively safe to use as a plain text, there are no
     * guarantees about safety in any other context such as HTML. This is
     * sometimes used to mark that should never be used unescaped.
     *
     * @param {*} content Plain text with no guarantees.
     * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
     *     unknown and thus to be estimated when necessary. Default: null.
     * @constructor
     * @extends {goog.soy.data.UnsanitizedText}
     */
    soydata.UnsanitizedText = function (content, opt_contentDir) {
      /** @override */
      this.content = String(content);
      this.contentDir = opt_contentDir != null ? opt_contentDir : null;
    };
    goog.inherits(soydata.UnsanitizedText, goog.soy.data.UnsanitizedText);

    /** @override */
    soydata.UnsanitizedText.prototype.contentKind = soydata.SanitizedContentKind.TEXT;

    /**
     * Empty string, used as a type in Soy templates.
     * @enum {string}
     * @private
     */
    soydata.$$EMPTY_STRING_ = {
      VALUE: ''
    };

    /**
     * Creates a factory for SanitizedContent types.
     *
     * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
     * instantiate Sanitized* classes, without making the Sanitized* constructors
     * publicly usable. Requiring all construction to use the VERY_UNSAFE names
     * helps callers and their reviewers easily tell that creating SanitizedContent
     * is not always safe and calls for careful review.
     *
     * @param {function(new: T)} ctor A constructor.
     * @return {!function(*, ?goog.i18n.bidi.Dir=): T} A factory that takes
     *     content and an optional content direction and returns a new instance. If
     *     the content direction is undefined, ctor.prototype.contentDir is used.
     * @template T
     * @private
     */
    soydata.$$makeSanitizedContentFactory_ = function (ctor) {
      /**
       * @param {string} content
       * @constructor
       * @extends {goog.soy.data.SanitizedContent}
       */
      function InstantiableCtor(content) {
        /** @override */
        this.content = content;
      }
      InstantiableCtor.prototype = ctor.prototype;
      /**
       * Creates a ctor-type SanitizedContent instance.
       *
       * @param {*} content The content to put in the instance.
       * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction. If
       *     undefined, ctor.prototype.contentDir is used.
       * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
       *     of type T above (ctor's type, a descendant of SanitizedContent), but
       *     there is no way to express that here.
       */
      function sanitizedContentFactory(content, opt_contentDir) {
        var result = new InstantiableCtor(String(content));
        if (opt_contentDir !== undefined) {
          result.contentDir = opt_contentDir;
        }
        return result;
      }
      return sanitizedContentFactory;
    };

    /**
     * Creates a factory for SanitizedContent types that should always have their
     * default directionality.
     *
     * This is a hack so that the soydata.VERY_UNSAFE.ordainSanitized* can
     * instantiate Sanitized* classes, without making the Sanitized* constructors
     * publicly usable. Requiring all construction to use the VERY_UNSAFE names
     * helps callers and their reviewers easily tell that creating SanitizedContent
     * is not always safe and calls for careful review.
     *
     * @param {function(new: T, string)} ctor A constructor.
     * @return {!function(*): T} A factory that takes content and returns a new
     *     instance (with default directionality, i.e. ctor.prototype.contentDir).
     * @template T
     * @private
     */
    soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_ = function (ctor) {
      /**
       * @param {string} content
       * @constructor
       * @extends {goog.soy.data.SanitizedContent}
       */
      function InstantiableCtor(content) {
        /** @override */
        this.content = content;
      }
      InstantiableCtor.prototype = ctor.prototype;
      /**
       * Creates a ctor-type SanitizedContent instance.
       *
       * @param {*} content The content to put in the instance.
       * @return {!goog.soy.data.SanitizedContent} The new instance. It is actually
       *     of type T above (ctor's type, a descendant of SanitizedContent), but
       *     there is no way to express that here.
       */
      function sanitizedContentFactory(content) {
        var result = new InstantiableCtor(String(content));
        return result;
      }
      return sanitizedContentFactory;
    };

    // -----------------------------------------------------------------------------
    // Sanitized content ordainers. Please use these with extreme caution (with the
    // exception of markUnsanitizedText). A good recommendation is to limit usage
    // of these to just a handful of files in your source tree where usages can be
    // carefully audited.


    /**
     * Protects a string from being used in an noAutoescaped context.
     *
     * This is useful for content where there is significant risk of accidental
     * unescaped usage in a Soy template. A great case is for user-controlled
     * data that has historically been a source of vulernabilities.
     *
     * @param {*} content Text to protect.
     * @param {?goog.i18n.bidi.Dir=} opt_contentDir The content direction; null if
     *     unknown and thus to be estimated when necessary. Default: null.
     * @return {!soydata.UnsanitizedText} A wrapper that is rejected by the
     *     Soy noAutoescape print directive.
     */
    soydata.markUnsanitizedText = function (content, opt_contentDir) {
      return new soydata.UnsanitizedText(content, opt_contentDir);
    };

    soydata.VERY_UNSAFE = {};

    /**
    * Takes a leap of faith that the provided content is "safe" to use as a URI
    * in a Soy template.
    *
    * This creates a Soy SanitizedContent object which indicates to Soy there is
    * no need to escape it when printed as a URI (e.g. in an href or src
    * attribute), such as if it's already been encoded or  if it's a Javascript:
    * URI.
    *
    * @param {*} content A chunk of URI that the caller knows is safe to
    *     emit in a template.
    * @return {!soydata.SanitizedUri} Sanitized content wrapper that indicates to
    *     Soy not to escape or filter when printed in URI context.
    */
    soydata.VERY_UNSAFE.ordainSanitizedUri = soydata.$$makeSanitizedContentFactoryWithDefaultDirOnly_(soydata.SanitizedUri);

    // -----------------------------------------------------------------------------
    // Below are private utilities to be used by Soy-generated code only.

    /**
     * Builds an augmented map. The returned map will contain mappings from both
     * the base map and the additional map. If the same key appears in both, then
     * the value from the additional map will be visible, while the value from the
     * base map will be hidden. The base map will be used, but not modified.
     *
     * @param {!Object} baseMap The original map to augment.
     * @param {!Object} additionalMap A map containing the additional mappings.
     * @return {!Object} An augmented map containing both the original and
     *     additional mappings.
     */
    soy.$$augmentMap = function (baseMap, additionalMap) {
      return soy.$$assignDefaults(soy.$$assignDefaults({}, additionalMap), baseMap);
    };

    /**
     * Copies extra properties into an object if they do not already exist. The
     * destination object is mutated in the process.
     *
     * @param {!Object} obj The destination object to update.
     * @param {!Object} defaults An object with default properties to apply.
     * @return {!Object} The destination object for convenience.
     */
    soy.$$assignDefaults = function (obj, defaults) {
      for (var key in defaults) {
        if (!(key in obj)) {
          obj[key] = defaults[key];
        }
      }

      return obj;
    };

    /**
     * Checks that the given map key is a string.
     * @param {*} key Key to check.
     * @return {string} The given key.
     */
    soy.$$checkMapKey = function (key) {
      // TODO: Support map literal with nonstring key.
      if (typeof key != 'string') {
        throw Error('Map literal\'s key expression must evaluate to string' + ' (encountered type "' + (typeof key === 'undefined' ? 'undefined' : _typeof(key)) + '").');
      }
      return key;
    };

    /**
     * Gets the keys in a map as an array. There are no guarantees on the order.
     * @param {Object} map The map to get the keys of.
     * @return {!Array<string>} The array of keys in the given map.
     */
    soy.$$getMapKeys = function (map) {
      var mapKeys = [];
      for (var key in map) {
        mapKeys.push(key);
      }
      return mapKeys;
    };

    /**
     * Returns the argument if it is not null.
     *
     * @param {T} val The value to check
     * @return {T} val if is isn't null
     * @template T
     */
    soy.$$checkNotNull = function (val) {
      if (val == null) {
        throw Error('unexpected null value');
      }
      return val;
    };

    /**
     * Gets a consistent unique id for the given delegate template name. Two calls
     * to this function will return the same id if and only if the input names are
     * the same.
     *
     * <p> Important: This function must always be called with a string constant.
     *
     * <p> If Closure Compiler is not being used, then this is just this identity
     * function. If Closure Compiler is being used, then each call to this function
     * will be replaced with a short string constant, which will be consistent per
     * input name.
     *
     * @param {string} delTemplateName The delegate template name for which to get a
     *     consistent unique id.
     * @return {string} A unique id that is consistent per input name.
     *
     * @consistentIdGenerator
     */
    soy.$$getDelTemplateId = function (delTemplateName) {
      return delTemplateName;
    };

    /**
     * Map from registered delegate template key to the priority of the
     * implementation.
     * @type {Object}
     * @private
     */
    soy.$$DELEGATE_REGISTRY_PRIORITIES_ = {};

    /**
     * Map from registered delegate template key to the implementation function.
     * @type {Object}
     * @private
     */
    soy.$$DELEGATE_REGISTRY_FUNCTIONS_ = {};

    /**
     * Registers a delegate implementation. If the same delegate template key (id
     * and variant) has been registered previously, then priority values are
     * compared and only the higher priority implementation is stored (if
     * priorities are equal, an error is thrown).
     *
     * @param {string} delTemplateId The delegate template id.
     * @param {string} delTemplateVariant The delegate template variant (can be
     *     empty string).
     * @param {number} delPriority The implementation's priority value.
     * @param {Function} delFn The implementation function.
     */
    soy.$$registerDelegateFn = function (delTemplateId, delTemplateVariant, delPriority, delFn) {

      var mapKey = 'key_' + delTemplateId + ':' + delTemplateVariant;
      var currPriority = soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey];
      if (currPriority === undefined || delPriority > currPriority) {
        // Registering new or higher-priority function: replace registry entry.
        soy.$$DELEGATE_REGISTRY_PRIORITIES_[mapKey] = delPriority;
        soy.$$DELEGATE_REGISTRY_FUNCTIONS_[mapKey] = delFn;
      } else if (delPriority == currPriority) {
        // Registering same-priority function: error.
        throw Error('Encountered two active delegates with the same priority ("' + delTemplateId + ':' + delTemplateVariant + '").');
      } else {
        // Registering lower-priority function: do nothing.
      }
    };

    /**
     * Retrieves the (highest-priority) implementation that has been registered for
     * a given delegate template key (id and variant). If no implementation has
     * been registered for the key, then the fallback is the same id with empty
     * variant. If the fallback is also not registered, and allowsEmptyDefault is
     * true, then returns an implementation that is equivalent to an empty template
     * (i.e. rendered output would be empty string).
     *
     * @param {string} delTemplateId The delegate template id.
     * @param {string} delTemplateVariant The delegate template variant (can be
     *     empty string).
     * @param {boolean} allowsEmptyDefault Whether to default to the empty template
     *     function if there's no active implementation.
     * @return {Function} The retrieved implementation function.
     */
    soy.$$getDelegateFn = function (delTemplateId, delTemplateVariant, allowsEmptyDefault) {

      var delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':' + delTemplateVariant];
      if (!delFn && delTemplateVariant != '') {
        // Fallback to empty variant.
        delFn = soy.$$DELEGATE_REGISTRY_FUNCTIONS_['key_' + delTemplateId + ':'];
      }

      if (delFn) {
        return delFn;
      } else if (allowsEmptyDefault) {
        return soy.$$EMPTY_TEMPLATE_FN_;
      } else {
        throw Error('Found no active impl for delegate call to "' + delTemplateId + ':' + delTemplateVariant + '" (and not allowemptydefault="true").');
      }
    };

    /**
     * Private helper soy.$$getDelegateFn(). This is the empty template function
     * that is returned whenever there's no delegate implementation found.
     *
     * @param {Object<string, *>=} opt_data
     * @param {soy.StringBuilder=} opt_sb
     * @param {Object<string, *>=} opt_ijData
     * @return {string}
     * @private
     */
    soy.$$EMPTY_TEMPLATE_FN_ = function (opt_data, opt_sb, opt_ijData) {
      return '';
    };

    // -----------------------------------------------------------------------------
    // Basic directives/functions.


    /**
     * Truncates a string to a given max length (if it's currently longer),
     * optionally adding ellipsis at the end.
     *
     * @param {*} str The string to truncate. Can be other types, but the value will
     *     be coerced to a string.
     * @param {number} maxLen The maximum length of the string after truncation
     *     (including ellipsis, if applicable).
     * @param {boolean} doAddEllipsis Whether to add ellipsis if the string needs
     *     truncation.
     * @return {string} The string after truncation.
     */
    soy.$$truncate = function (str, maxLen, doAddEllipsis) {

      str = String(str);
      if (str.length <= maxLen) {
        return str; // no need to truncate
      }

      // If doAddEllipsis, either reduce maxLen to compensate, or else if maxLen is
      // too small, just turn off doAddEllipsis.
      if (doAddEllipsis) {
        if (maxLen > 3) {
          maxLen -= 3;
        } else {
          doAddEllipsis = false;
        }
      }

      // Make sure truncating at maxLen doesn't cut up a unicode surrogate pair.
      if (soy.$$isHighSurrogate_(str.charAt(maxLen - 1)) && soy.$$isLowSurrogate_(str.charAt(maxLen))) {
        maxLen -= 1;
      }

      // Truncate.
      str = str.substring(0, maxLen);

      // Add ellipsis.
      if (doAddEllipsis) {
        str += '...';
      }

      return str;
    };

    /**
     * Private helper for $$truncate() to check whether a char is a high surrogate.
     * @param {string} ch The char to check.
     * @return {boolean} Whether the given char is a unicode high surrogate.
     * @private
     */
    soy.$$isHighSurrogate_ = function (ch) {
      return 0xD800 <= ch && ch <= 0xDBFF;
    };

    /**
     * Private helper for $$truncate() to check whether a char is a low surrogate.
     * @param {string} ch The char to check.
     * @return {boolean} Whether the given char is a unicode low surrogate.
     * @private
     */
    soy.$$isLowSurrogate_ = function (ch) {
      return 0xDC00 <= ch && ch <= 0xDFFF;
    };

    // -----------------------------------------------------------------------------
    // Assertion methods used by runtime.

    /**
     * Checks if the type assertion is true if goog.asserts.ENABLE_ASSERTS is
     * true. Report errors on runtime types if goog.DEBUG is true.
     * @param {boolean} condition The type check condition.
     * @param {string} paramName The Soy name of the parameter.
     * @param {?} param The JS object for the parameter.
     * @param {!string} jsDocTypeStr SoyDoc type str.
     * @return {?} the param value
     * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
     */
    soy.asserts.assertType = function (condition, paramName, param, jsDocTypeStr) {
      if (goog.asserts.ENABLE_ASSERTS && !condition) {
        var msg = 'expected param ' + paramName + ' of type ' + jsDocTypeStr + (goog.DEBUG ? ', but got ' + goog.debug.runtimeType(param) : '') + '.';
        goog.asserts.fail(msg);
      }
      return param;
    };

    // -----------------------------------------------------------------------------
    // Generated code.


    // START GENERATED CODE FOR ESCAPERS.

    /**
     * @type {function (*) : string}
     */
    soy.esc.$$escapeHtmlHelper = function (v) {
      return goog.string.htmlEscape(String(v));
    };

    /**
     * Allows only data-protocol image URI's.
     *
     * @param {*} value The value to process. May not be a string, but the value
     *     will be coerced to a string.
     * @return {!soydata.SanitizedUri} An escaped version of value.
     */
    soy.$$filterImageDataUri = function (value) {
      // NOTE: Even if it's a SanitizedUri, we will still filter it.
      return soydata.VERY_UNSAFE.ordainSanitizedUri(soy.esc.$$filterImageDataUriHelper(value));
    };

    /**
     * A pattern that vets values produced by the named directives.
     * @private {!RegExp}
     */
    soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_ = /^data:image\/(?:bmp|gif|jpe?g|png|tiff|webp);base64,[a-z0-9+\/]+=*$/i;

    /**
     * A helper for the Soy directive |filterImageDataUri
     * @param {*} value Can be of any type but will be coerced to a string.
     * @return {string} The escaped text.
     */
    soy.esc.$$filterImageDataUriHelper = function (value) {
      var str = String(value);
      if (!soy.esc.$$FILTER_FOR_FILTER_IMAGE_DATA_URI_.test(str)) {
        goog.asserts.fail('Bad value `%s` for |filterImageDataUri', [str]);
        return 'data:image/gif;base64,zSoyz';
      }
      return str;
    };

    var incrementaldom = IncrementalDOM;
    var soyIDOM = {};

    /**
     * Calls an expression in case of a function or outputs it as text content.
     * @param {string|number|boolean|function()?} expr
     */
    soyIDOM.renderDynamicContent = function (expr) {
      if (goog.isFunction(expr)) {
        expr();
      } else if (expr != null) {
        incrementaldom.text(expr);
      }
    };

    /**
     * Prints an expression depending on its type.
     * @param {!SanitizedHtml|string|number|boolean|function()} expr
     */
    soyIDOM.print = function (expr) {
      if (expr instanceof soydata.SanitizedHtml) {
        // For HTML content we need to insert a custom element where we can place
        // the content without incremental dom modifying it.
        var el = incrementaldom.elementOpen('html-blob');
        var content = expr.toString();
        if (el.__innerHTML !== content) {
          soy.renderHtml(el, expr);
          el.__innerHTML = content;
        }
        incrementaldom.skip();
        incrementaldom.elementClose('html-blob');
      } else {
        soyIDOM.renderDynamicContent(expr);
      }
    };

    goog.loadModule(function () {
      goog.module('soy.idom');
      return soyIDOM;
    });

    // END GENERATED CODE

    goog.loadModule(function () {
      goog.module('soy');
      return soy;
    });

    goog.loadModule(function () {
      goog.module('soydata');
      return soydata;
    });

    goog.loadModule(function () {
      goog.module('soy.asserts');
      return soy;
    });
  })();

  goog.loadModule(function () {
    goog.module('incrementaldom');
    return IncrementalDOM;
  });
}).call(typeof exports !== 'undefined' && typeof global !== 'undefined' ? global : window);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * @license
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A cached reference to the hasOwnProperty function.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * A constructor function that will create blank objects.
 * @constructor
 */
function Blank() {}

Blank.prototype = Object.create(null);

/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param {!Object<string, *>} map The map to check.
 * @param {string} property The property to check.
 * @return {boolean} Whether map has property.
 */
var has = function (map, property) {
  return hasOwnProperty.call(map, property);
};

/**
 * Creates an map object without a prototype.
 * @return {!Object}
 */
var createMap = function () {
  return new Blank();
};

/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 * @param {!string} nodeName
 * @param {?string=} key
 * @constructor
 */
function NodeData(nodeName, key) {
  /**
   * The attributes and their values.
   * @const {!Object<string, *>}
   */
  this.attrs = createMap();

  /**
   * An array of attribute name/value pairs, used for quickly diffing the
   * incomming attributes to see if the DOM node's attributes need to be
   * updated.
   * @const {Array<*>}
   */
  this.attrsArr = [];

  /**
   * The incoming attributes for this Node, before they are updated.
   * @const {!Object<string, *>}
   */
  this.newAttrs = createMap();

  /**
   * Whether or not the statics have been applied for the node yet.
   * {boolean}
   */
  this.staticsApplied = false;

  /**
   * The key used to identify this node, used to preserve DOM nodes when they
   * move within their parent.
   * @const
   */
  this.key = key;

  /**
   * Keeps track of children within this node by their key.
   * {!Object<string, !Element>}
   */
  this.keyMap = createMap();

  /**
   * Whether or not the keyMap is currently valid.
   * @type {boolean}
   */
  this.keyMapValid = true;

  /**
   * Whether or the associated node is, or contains, a focused Element.
   * @type {boolean}
   */
  this.focused = false;

  /**
   * The node name for this node.
   * @const {string}
   */
  this.nodeName = nodeName;

  /**
   * @type {?string}
   */
  this.text = null;
}

/**
 * Initializes a NodeData object for a Node.
 *
 * @param {Node} node The node to initialize data for.
 * @param {string} nodeName The node name of node.
 * @param {?string=} key The key that identifies the node.
 * @return {!NodeData} The newly initialized data object
 */
var initData = function (node, nodeName, key) {
  var data = new NodeData(nodeName, key);
  node['__incrementalDOMData'] = data;
  return data;
};

/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 *
 * @param {?Node} node The Node to retrieve the data for.
 * @return {!NodeData} The NodeData for this Node.
 */
var getData = function (node) {
  importNode(node);
  return node['__incrementalDOMData'];
};

/**
 * Imports node and its subtree, initializing caches.
 *
 * @param {?Node} node The Node to import.
 */
var importNode = function (node) {
  if (node['__incrementalDOMData']) {
    return;
  }

  var isElement = node instanceof Element;
  var nodeName = isElement ? node.localName : node.nodeName;
  var key = isElement ? node.getAttribute('key') : null;
  var data = initData(node, nodeName, key);

  if (key) {
    getData(node.parentNode).keyMap[key] = node;
  }

  if (isElement) {
    var attributes = node.attributes;
    var attrs = data.attrs;
    var newAttrs = data.newAttrs;
    var attrsArr = data.attrsArr;

    for (var i = 0; i < attributes.length; i += 1) {
      var attr = attributes[i];
      var name = attr.name;
      var value = attr.value;

      attrs[name] = value;
      newAttrs[name] = undefined;
      attrsArr.push(name);
      attrsArr.push(value);
    }
  }

  for (var child = node.firstChild; child; child = child.nextSibling) {
    importNode(child);
  }
};

/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @param {?Node} parent
 * @return {?string} The namespace to create the tag in.
 */
var getNamespaceForTag = function (tag, parent) {
  if (tag === 'svg') {
    return 'http://www.w3.org/2000/svg';
  }

  if (getData(parent).nodeName === 'foreignObject') {
    return null;
  }

  return parent.namespaceURI;
};

/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {?Node} parent
 * @param {string} tag The tag for the Element.
 * @param {?string=} key A key to identify the Element.
 * @return {!Element}
 */
var createElement = function (doc, parent, tag, key) {
  var namespace = getNamespaceForTag(tag, parent);
  var el = undefined;

  if (namespace) {
    el = doc.createElementNS(namespace, tag);
  } else {
    el = doc.createElement(tag);
  }

  initData(el, tag, key);

  return el;
};

/**
 * Creates a Text Node.
 * @param {Document} doc The document with which to create the Element.
 * @return {!Text}
 */
var createText = function (doc) {
  var node = doc.createTextNode('');
  initData(node, '#text', null);
  return node;
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
var notifications = {
  /**
   * Called after patch has compleated with any Nodes that have been created
   * and added to the DOM.
   * @type {?function(Array<!Node>)}
   */
  nodesCreated: null,

  /**
   * Called after patch has compleated with any Nodes that have been removed
   * from the DOM.
   * Note it's an applications responsibility to handle any childNodes.
   * @type {?function(Array<!Node>)}
   */
  nodesDeleted: null
};

/**
 * Keeps track of the state of a patch.
 * @constructor
 */
function Context() {
  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.created = notifications.nodesCreated && [];

  /**
   * @type {(Array<!Node>|undefined)}
   */
  this.deleted = notifications.nodesDeleted && [];
}

/**
 * @param {!Node} node
 */
Context.prototype.markCreated = function (node) {
  if (this.created) {
    this.created.push(node);
  }
};

/**
 * @param {!Node} node
 */
Context.prototype.markDeleted = function (node) {
  if (this.deleted) {
    this.deleted.push(node);
  }
};

/**
 * Notifies about nodes that were created during the patch opearation.
 */
Context.prototype.notifyChanges = function () {
  if (this.created && this.created.length > 0) {
    notifications.nodesCreated(this.created);
  }

  if (this.deleted && this.deleted.length > 0) {
    notifications.nodesDeleted(this.deleted);
  }
};

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
  * Keeps track whether or not we are in an attributes declaration (after
  * elementOpenStart, but before elementOpenEnd).
  * @type {boolean}
  */
var inAttributes = false;

/**
  * Keeps track whether or not we are in an element that should not have its
  * children cleared.
  * @type {boolean}
  */
var inSkip = false;

/**
 * Makes sure that there is a current patch context.
 * @param {string} functionName
 * @param {*} context
 */
var assertInPatch = function (functionName, context) {
  if (!context) {
    throw new Error('Cannot call ' + functionName + '() unless in patch.');
  }
};

/**
 * Makes sure that a patch closes every node that it opened.
 * @param {?Node} openElement
 * @param {!Node|!DocumentFragment} root
 */
var assertNoUnclosedTags = function (openElement, root) {
  if (openElement === root) {
    return;
  }

  var currentElement = openElement;
  var openTags = [];
  while (currentElement && currentElement !== root) {
    openTags.push(currentElement.nodeName.toLowerCase());
    currentElement = currentElement.parentNode;
  }

  throw new Error('One or more tags were not closed:\n' + openTags.join('\n'));
};

/**
 * Makes sure that the caller is not where attributes are expected.
 * @param {string} functionName
 */
var assertNotInAttributes = function (functionName) {
  if (inAttributes) {
    throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');
  }
};

/**
 * Makes sure that the caller is not inside an element that has declared skip.
 * @param {string} functionName
 */
var assertNotInSkip = function (functionName) {
  if (inSkip) {
    throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');
  }
};

/**
 * Makes sure that the caller is where attributes are expected.
 * @param {string} functionName
 */
var assertInAttributes = function (functionName) {
  if (!inAttributes) {
    throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');
  }
};

/**
 * Makes sure the patch closes virtual attributes call
 */
var assertVirtualAttributesClosed = function () {
  if (inAttributes) {
    throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');
  }
};

/**
  * Makes sure that tags are correctly nested.
  * @param {string} nodeName
  * @param {string} tag
  */
var assertCloseMatchesOpenTag = function (nodeName, tag) {
  if (nodeName !== tag) {
    throw new Error('Received a call to close "' + tag + '" but "' + nodeName + '" was open.');
  }
};

/**
 * Makes sure that no children elements have been declared yet in the current
 * element.
 * @param {string} functionName
 * @param {?Node} previousNode
 */
var assertNoChildrenDeclaredYet = function (functionName, previousNode) {
  if (previousNode !== null) {
    throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');
  }
};

/**
 * Checks that a call to patchOuter actually patched the element.
 * @param {?Node} startNode The value for the currentNode when the patch
 *     started.
 * @param {?Node} currentNode The currentNode when the patch finished.
 * @param {?Node} expectedNextNode The Node that is expected to follow the
 *    currentNode after the patch;
 * @param {?Node} expectedPrevNode The Node that is expected to preceed the
 *    currentNode after the patch.
 */
var assertPatchElementNoExtras = function (startNode, currentNode, expectedNextNode, expectedPrevNode) {
  var wasUpdated = currentNode.nextSibling === expectedNextNode && currentNode.previousSibling === expectedPrevNode;
  var wasChanged = currentNode.nextSibling === startNode.nextSibling && currentNode.previousSibling === expectedPrevNode;
  var wasRemoved = currentNode === startNode;

  if (!wasUpdated && !wasChanged && !wasRemoved) {
    throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');
  }
};

/**
 * Updates the state of being in an attribute declaration.
 * @param {boolean} value
 * @return {boolean} the previous value.
 */
var setInAttributes = function (value) {
  var previous = inAttributes;
  inAttributes = value;
  return previous;
};

/**
 * Updates the state of being in a skip element.
 * @param {boolean} value
 * @return {boolean} the previous value.
 */
var setInSkip = function (value) {
  var previous = inSkip;
  inSkip = value;
  return previous;
};

/**
 * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {!Node} node
 * @return {boolean} True if the node the root of a document, false otherwise.
 */
var isDocumentRoot = function (node) {
  // For ShadowRoots, check if they are a DocumentFragment instead of if they
  // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are
  // not supported.
  return node instanceof Document || node instanceof DocumentFragment;
};

/**
 * @param {!Node} node The node to start at, inclusive.
 * @param {?Node} root The root ancestor to get until, exclusive.
 * @return {!Array<!Node>} The ancestry of DOM nodes.
 */
var getAncestry = function (node, root) {
  var ancestry = [];
  var cur = node;

  while (cur !== root) {
    ancestry.push(cur);
    cur = cur.parentNode;
  }

  return ancestry;
};

/**
 * @param {!Node} node
 * @return {!Node} The root node of the DOM tree that contains node.
 */
var getRoot = function (node) {
  var cur = node;
  var prev = cur;

  while (cur) {
    prev = cur;
    cur = cur.parentNode;
  }

  return prev;
};

/**
 * @param {!Node} node The node to get the activeElement for.
 * @return {?Element} The activeElement in the Document or ShadowRoot
 *     corresponding to node, if present.
 */
var getActiveElement = function (node) {
  var root = getRoot(node);
  return isDocumentRoot(root) ? root.activeElement : null;
};

/**
 * Gets the path of nodes that contain the focused node in the same document as
 * a reference node, up until the root.
 * @param {!Node} node The reference node to get the activeElement for.
 * @param {?Node} root The root to get the focused path until.
 * @return {!Array<Node>}
 */
var getFocusedPath = function (node, root) {
  var activeElement = getActiveElement(node);

  if (!activeElement || !node.contains(activeElement)) {
    return [];
  }

  return getAncestry(activeElement, root);
};

/**
 * Like insertBefore, but instead instead of moving the desired node, instead
 * moves all the other nodes after.
 * @param {?Node} parentNode
 * @param {!Node} node
 * @param {?Node} referenceNode
 */
var moveBefore = function (parentNode, node, referenceNode) {
  var insertReferenceNode = node.nextSibling;
  var cur = referenceNode;

  while (cur !== node) {
    var next = cur.nextSibling;
    parentNode.insertBefore(cur, insertReferenceNode);
    cur = next;
  }
};

/** @type {?Context} */
var context = null;

/** @type {?Node} */
var currentNode = null;

/** @type {?Node} */
var currentParent = null;

/** @type {?Document} */
var doc = null;

/**
 * @param {!Array<Node>} focusPath The nodes to mark.
 * @param {boolean} focused Whether or not they are focused.
 */
var markFocused = function (focusPath, focused) {
  for (var i = 0; i < focusPath.length; i += 1) {
    getData(focusPath[i]).focused = focused;
  }
};

/**
 * Returns a patcher function that sets up and restores a patch context,
 * running the run function with the provided data.
 * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run
 * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}
 * @template T
 */
var patchFactory = function (run) {
  /**
   * TODO(moz): These annotations won't be necessary once we switch to Closure
   * Compiler's new type inference. Remove these once the switch is done.
   *
   * @param {(!Element|!DocumentFragment)} node
   * @param {!function(T)} fn
   * @param {T=} data
   * @return {?Node} node
   * @template T
   */
  var f = function (node, fn, data) {
    var prevContext = context;
    var prevDoc = doc;
    var prevCurrentNode = currentNode;
    var prevCurrentParent = currentParent;
    var previousInAttributes = false;
    var previousInSkip = false;

    context = new Context();
    doc = node.ownerDocument;
    currentParent = node.parentNode;

    if (false) {
      previousInAttributes = setInAttributes(false);
      previousInSkip = setInSkip(false);
    }

    var focusPath = getFocusedPath(node, currentParent);
    markFocused(focusPath, true);
    var retVal = run(node, fn, data);
    markFocused(focusPath, false);

    if (false) {
      assertVirtualAttributesClosed();
      setInAttributes(previousInAttributes);
      setInSkip(previousInSkip);
    }

    context.notifyChanges();

    context = prevContext;
    doc = prevDoc;
    currentNode = prevCurrentNode;
    currentParent = prevCurrentParent;

    return retVal;
  };
  return f;
};

/**
 * Patches the document starting at node with the provided function. This
 * function may be called during an existing patch operation.
 * @param {!Element|!DocumentFragment} node The Element or Document
 *     to patch.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {!Node} The patched node.
 * @template T
 */
var patchInner = patchFactory(function (node, fn, data) {
  currentNode = node;

  enterNode();
  fn(data);
  exitNode();

  if (false) {
    assertNoUnclosedTags(currentNode, node);
  }

  return node;
});

/**
 * Patches an Element with the the provided function. Exactly one top level
 * element call should be made corresponding to `node`.
 * @param {!Element} node The Element where the patch should start.
 * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.
 *     calls that describe the DOM. This should have at most one top level
 *     element call.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {?Node} The node if it was updated, its replacedment or null if it
 *     was removed.
 * @template T
 */
var patchOuter = patchFactory(function (node, fn, data) {
  var startNode = /** @type {!Element} */{ nextSibling: node };
  var expectedNextNode = null;
  var expectedPrevNode = null;

  if (false) {
    expectedNextNode = node.nextSibling;
    expectedPrevNode = node.previousSibling;
  }

  currentNode = startNode;
  fn(data);

  if (false) {
    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode, expectedPrevNode);
  }

  if (node !== currentNode && node.parentNode) {
    removeChild(currentParent, node, getData(currentParent).keyMap);
  }

  return startNode === currentNode ? null : currentNode;
});

/**
 * Checks whether or not the current node matches the specified nodeName and
 * key.
 *
 * @param {!Node} matchNode A node to match the data to.
 * @param {?string} nodeName The nodeName for this node.
 * @param {?string=} key An optional key that identifies a node.
 * @return {boolean} True if the node matches, false otherwise.
 */
var matches = function (matchNode, nodeName, key) {
  var data = getData(matchNode);

  // Key check is done using double equals as we want to treat a null key the
  // same as undefined. This should be okay as the only values allowed are
  // strings, null and undefined so the == semantics are not too weird.
  return nodeName === data.nodeName && key == data.key;
};

/**
 * Aligns the virtual Element definition with the actual DOM, moving the
 * corresponding DOM node to the correct location or creating it if necessary.
 * @param {string} nodeName For an Element, this should be a valid tag string.
 *     For a Text, this should be #text.
 * @param {?string=} key The key used to identify this element.
 */
var alignWithDOM = function (nodeName, key) {
  if (currentNode && matches(currentNode, nodeName, key)) {
    return;
  }

  var parentData = getData(currentParent);
  var currentNodeData = currentNode && getData(currentNode);
  var keyMap = parentData.keyMap;
  var node = undefined;

  // Check to see if the node has moved within the parent.
  if (key) {
    var keyNode = keyMap[key];
    if (keyNode) {
      if (matches(keyNode, nodeName, key)) {
        node = keyNode;
      } else if (keyNode === currentNode) {
        context.markDeleted(keyNode);
      } else {
        removeChild(currentParent, keyNode, keyMap);
      }
    }
  }

  // Create the node if it doesn't exist.
  if (!node) {
    if (nodeName === '#text') {
      node = createText(doc);
    } else {
      node = createElement(doc, currentParent, nodeName, key);
    }

    if (key) {
      keyMap[key] = node;
    }

    context.markCreated(node);
  }

  // Re-order the node into the right position, preserving focus if either
  // node or currentNode are focused by making sure that they are not detached
  // from the DOM.
  if (getData(node).focused) {
    // Move everything else before the node.
    moveBefore(currentParent, node, currentNode);
  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {
    // Remove the currentNode, which can always be added back since we hold a
    // reference through the keyMap. This prevents a large number of moves when
    // a keyed item is removed or moved backwards in the DOM.
    currentParent.replaceChild(node, currentNode);
    parentData.keyMapValid = false;
  } else {
    currentParent.insertBefore(node, currentNode);
  }

  currentNode = node;
};

/**
 * @param {?Node} node
 * @param {?Node} child
 * @param {?Object<string, !Element>} keyMap
 */
var removeChild = function (node, child, keyMap) {
  node.removeChild(child);
  context.markDeleted( /** @type {!Node}*/child);

  var key = getData(child).key;
  if (key) {
    delete keyMap[key];
  }
};

/**
 * Clears out any unvisited Nodes, as the corresponding virtual element
 * functions were never called for them.
 */
var clearUnvisitedDOM = function () {
  var node = currentParent;
  var data = getData(node);
  var keyMap = data.keyMap;
  var keyMapValid = data.keyMapValid;
  var child = node.lastChild;
  var key = undefined;

  if (child === currentNode && keyMapValid) {
    return;
  }

  while (child !== currentNode) {
    removeChild(node, child, keyMap);
    child = node.lastChild;
  }

  // Clean the keyMap, removing any unusued keys.
  if (!keyMapValid) {
    for (key in keyMap) {
      child = keyMap[key];
      if (child.parentNode !== node) {
        context.markDeleted(child);
        delete keyMap[key];
      }
    }

    data.keyMapValid = true;
  }
};

/**
 * Changes to the first child of the current node.
 */
var enterNode = function () {
  currentParent = currentNode;
  currentNode = null;
};

/**
 * @return {?Node} The next Node to be patched.
 */
var getNextNode = function () {
  if (currentNode) {
    return currentNode.nextSibling;
  } else {
    return currentParent.firstChild;
  }
};

/**
 * Changes to the next sibling of the current node.
 */
var nextNode = function () {
  currentNode = getNextNode();
};

/**
 * Changes to the parent of the current node, removing any unvisited children.
 */
var exitNode = function () {
  clearUnvisitedDOM();

  currentNode = currentParent;
  currentParent = currentParent.parentNode;
};

/**
 * Makes sure that the current node is an Element with a matching tagName and
 * key.
 *
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @return {!Element} The corresponding Element.
 */
var coreElementOpen = function (tag, key) {
  nextNode();
  alignWithDOM(tag, key);
  enterNode();
  return (/** @type {!Element} */currentParent
  );
};

/**
 * Closes the currently open Element, removing any unvisited children if
 * necessary.
 *
 * @return {!Element} The corresponding Element.
 */
var coreElementClose = function () {
  if (false) {
    setInSkip(false);
  }

  exitNode();
  return (/** @type {!Element} */currentNode
  );
};

/**
 * Makes sure the current node is a Text node and creates a Text node if it is
 * not.
 *
 * @return {!Text} The corresponding Text Node.
 */
var coreText = function () {
  nextNode();
  alignWithDOM('#text', null);
  return (/** @type {!Text} */currentNode
  );
};

/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
var currentElement = function () {
  if (false) {
    assertInPatch('currentElement', context);
    assertNotInAttributes('currentElement');
  }
  return (/** @type {!Element} */currentParent
  );
};

/**
 * @return {Node} The Node that will be evaluated for the next instruction.
 */
var currentPointer = function () {
  if (false) {
    assertInPatch('currentPointer', context);
    assertNotInAttributes('currentPointer');
  }
  return getNextNode();
};

/**
 * Skips the children in a subtree, allowing an Element to be closed without
 * clearing out the children.
 */
var skip = function () {
  if (false) {
    assertNoChildrenDeclaredYet('skip', currentNode);
    setInSkip(true);
  }
  currentNode = currentParent.lastChild;
};

/**
 * Skips the next Node to be patched, moving the pointer forward to the next
 * sibling of the current pointer.
 */
var skipNode = nextNode;

/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
var symbols = {
  default: '__default'
};

/**
 * @param {string} name
 * @return {string|undefined} The namespace to use for the attribute.
 */
var getNamespace = function (name) {
  if (name.lastIndexOf('xml:', 0) === 0) {
    return 'http://www.w3.org/XML/1998/namespace';
  }

  if (name.lastIndexOf('xlink:', 0) === 0) {
    return 'http://www.w3.org/1999/xlink';
  }
};

/**
 * Applies an attribute or property to a given Element. If the value is null
 * or undefined, it is removed from the Element. Otherwise, the value is set
 * as an attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {?(boolean|number|string)=} value The attribute's value.
 */
var applyAttr = function (el, name, value) {
  if (value == null) {
    el.removeAttribute(name);
  } else {
    var attrNS = getNamespace(name);
    if (attrNS) {
      el.setAttributeNS(attrNS, name, value);
    } else {
      el.setAttribute(name, value);
    }
  }
};

/**
 * Applies a property to a given Element.
 * @param {!Element} el
 * @param {string} name The property's name.
 * @param {*} value The property's value.
 */
var applyProp = function (el, name, value) {
  el[name] = value;
};

/**
 * Applies a value to a style declaration. Supports CSS custom properties by
 * setting properties containing a dash using CSSStyleDeclaration.setProperty.
 * @param {CSSStyleDeclaration} style
 * @param {!string} prop
 * @param {*} value
 */
var setStyleValue = function (style, prop, value) {
  if (prop.indexOf('-') >= 0) {
    style.setProperty(prop, /** @type {string} */value);
  } else {
    style[prop] = value;
  }
};

/**
 * Applies a style to an Element. No vendor prefix expansion is done for
 * property names/values.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} style The style to set. Either a string of css or an object
 *     containing property-value pairs.
 */
var applyStyle = function (el, name, style) {
  if (typeof style === 'string') {
    el.style.cssText = style;
  } else {
    el.style.cssText = '';
    var elStyle = el.style;
    var obj = /** @type {!Object<string,string>} */style;

    for (var prop in obj) {
      if (has(obj, prop)) {
        setStyleValue(elStyle, prop, obj[prop]);
      }
    }
  }
};

/**
 * Updates a single attribute on an Element.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value. If the value is an object or
 *     function it is set on the Element, otherwise, it is set as an HTML
 *     attribute.
 */
var applyAttributeTyped = function (el, name, value) {
  var type = typeof value;

  if (type === 'object' || type === 'function') {
    applyProp(el, name, value);
  } else {
    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);
  }
};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function (el, name, value) {
  var data = getData(el);
  var attrs = data.attrs;

  if (attrs[name] === value) {
    return;
  }

  var mutator = attributes[name] || attributes[symbols.default];
  mutator(el, name, value);

  attrs[name] = value;
};

/**
 * A publicly mutable object to provide custom mutators for attributes.
 * @const {!Object<string, function(!Element, string, *)>}
 */
var attributes = createMap();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
attributes[symbols.default] = applyAttributeTyped;

attributes['style'] = applyStyle;

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {Array<*>}
 */
var argsBuilder = [];

/**
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementOpen = function (tag, key, statics, var_args) {
  if (false) {
    assertNotInAttributes('elementOpen');
    assertNotInSkip('elementOpen');
  }

  var node = coreElementOpen(tag, key);
  var data = getData(node);

  if (!data.staticsApplied) {
    if (statics) {
      for (var _i = 0; _i < statics.length; _i += 2) {
        var name = /** @type {string} */statics[_i];
        var value = statics[_i + 1];
        updateAttribute(node, name, value);
      }
    }
    // Down the road, we may want to keep track of the statics array to use it
    // as an additional signal about whether a node matches or not. For now,
    // just use a marker so that we do not reapply statics.
    data.staticsApplied = true;
  }

  /*
   * Checks to see if one or more attributes have changed for a given Element.
   * When no attributes have changed, this is much faster than checking each
   * individual argument. When attributes have changed, the overhead of this is
   * minimal.
   */
  var attrsArr = data.attrsArr;
  var newAttrs = data.newAttrs;
  var isNew = !attrsArr.length;
  var i = ATTRIBUTES_OFFSET;
  var j = 0;

  for (; i < arguments.length; i += 2, j += 2) {
    var _attr = arguments[i];
    if (isNew) {
      attrsArr[j] = _attr;
      newAttrs[_attr] = undefined;
    } else if (attrsArr[j] !== _attr) {
      break;
    }

    var value = arguments[i + 1];
    if (isNew || attrsArr[j + 1] !== value) {
      attrsArr[j + 1] = value;
      updateAttribute(node, _attr, value);
    }
  }

  if (i < arguments.length || j < attrsArr.length) {
    for (; i < arguments.length; i += 1, j += 1) {
      attrsArr[j] = arguments[i];
    }

    if (j < attrsArr.length) {
      attrsArr.length = j;
    }

    /*
     * Actually perform the attribute update.
     */
    for (i = 0; i < attrsArr.length; i += 2) {
      var name = /** @type {string} */attrsArr[i];
      var value = attrsArr[i + 1];
      newAttrs[name] = value;
    }

    for (var _attr2 in newAttrs) {
      updateAttribute(node, _attr2, newAttrs[_attr2]);
      newAttrs[_attr2] = undefined;
    }
  }

  return node;
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 */
var elementOpenStart = function (tag, key, statics) {
  if (false) {
    assertNotInAttributes('elementOpenStart');
    setInAttributes(true);
  }

  argsBuilder[0] = tag;
  argsBuilder[1] = key;
  argsBuilder[2] = statics;
};

/***
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name
 * @param {*} value
 */
var attr = function (name, value) {
  if (false) {
    assertInAttributes('attr');
  }

  argsBuilder.push(name);
  argsBuilder.push(value);
};

/**
 * Closes an open tag started with elementOpenStart.
 * @return {!Element} The corresponding Element.
 */
var elementOpenEnd = function () {
  if (false) {
    assertInAttributes('elementOpenEnd');
    setInAttributes(false);
  }

  var node = elementOpen.apply(null, argsBuilder);
  argsBuilder.length = 0;
  return node;
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} tag The element's tag.
 * @return {!Element} The corresponding Element.
 */
var elementClose = function (tag) {
  if (false) {
    assertNotInAttributes('elementClose');
  }

  var node = coreElementClose();

  if (false) {
    assertCloseMatchesOpenTag(getData(node).nodeName, tag);
  }

  return node;
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 * @param {string} tag The element's tag.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
var elementVoid = function (tag, key, statics, var_args) {
  elementOpen.apply(null, arguments);
  return elementClose(tag);
};

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 * @return {!Text} The corresponding text node.
 */
var text = function (value, var_args) {
  if (false) {
    assertNotInAttributes('text');
    assertNotInSkip('text');
  }

  var node = coreText();
  var data = getData(node);

  if (data.text !== value) {
    data.text = /** @type {string} */value;

    var formatted = value;
    for (var i = 1; i < arguments.length; i += 1) {
      /*
       * Call the formatter function directly to prevent leaking arguments.
       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
       */
      var fn = arguments[i];
      formatted = fn(formatted);
    }

    node.data = formatted;
  }

  return node;
};

exports.patch = patchInner;
exports.patchInner = patchInner;
exports.patchOuter = patchOuter;
exports.currentElement = currentElement;
exports.currentPointer = currentPointer;
exports.skip = skip;
exports.skipNode = skipNode;
exports.elementVoid = elementVoid;
exports.elementOpenStart = elementOpenStart;
exports.elementOpenEnd = elementOpenEnd;
exports.elementOpen = elementOpen;
exports.elementClose = elementClose;
exports.text = text;
exports.attr = attr;
exports.symbols = symbols;
exports.attributes = attributes;
exports.applyAttr = applyAttr;
exports.applyProp = applyProp;
exports.notifications = notifications;
exports.importNode = importNode;

//# sourceMappingURL=incremental-dom-cjs.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.IncrementalDOM = global.IncrementalDOM || {})));
}(this, (function (exports) { 'use strict';

/**
 * An array used to store the strings generated by calls to
 * elementOpen, elementOpenStart, elementOpenEnd, elementEnd and elementVoid
 */
exports.buffer = [];

/** @type {?Object} */
exports.currentParent = null;

/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
var currentElement = function currentElement() {
  return exports.currentParent;
};

/**
 * @return {Node} The Node that will be evaluated for the next instruction.
 */
var currentPointer = function currentPointer() {
  return {};
};

/**
 * Patches an Element with the the provided function. Exactly one top level
 * element call should be made corresponding to `node`.
 *
 * @param {?object} node The Element where the patch should start.
 * @param {!function(T)} fn A function containing open/close/etc. calls that
 *     describe the DOM. This should have at most one top level element call.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {void} Nothing.
 */
var patch = function patch(node, fn, data) {
  exports.currentParent = node;
  fn(data);
  exports.currentParent.innerHTML = exports.buffer.join('');
  exports.buffer = [];
  return exports.currentParent;
};

var patchOuter = patch;
var patchInner = patch;

/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 *
 * @return {void} Nothing.
 */
var text = function text(value, var_args) {
  var formatted = value;
  for (var i = 1; i < arguments.length; i += 1) {
    var fn = arguments[i];
    formatted = fn(formatted);
  }
  exports.buffer.push(formatted);
};

/** @const */
var symbols = {
  default: '__default'
};

/** @const */
var attributes = {};

/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Array.<string>} el Buffer to append element attributes.
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
var updateAttribute = function updateAttribute(el, name, value) {
  var mutator = attributes[name] || attributes[symbols.default];
  mutator(el, name, value);
};

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
attributes[symbols.default] = function (el, name, value) {
  if (Array.isArray(el)) {
    el.push(' ' + name + '="' + value + '"');
  }
};

/**
 * Truncates an array, removing items up until length.
 * @param {!Array<*>} arr The array to truncate.
 * @param {number} length The new length of the array.
 */
var truncateArray = function truncateArray(arr, length) {
  while (arr.length > length) {
    arr.pop();
  }
};

/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
var ATTRIBUTES_OFFSET = 3;

/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {!Array<*>}
 */
var argsBuilder = [];

/**
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 * @return {void} Nothing.
 */
var attr = function attr(name, value) {
  argsBuilder.push(name);
  argsBuilder.push(value);
};

/**
 * Closes an open virtual Element.
 *
 * @param {string} The Element's tag.
 * @return {void} Nothing.
 */
var elementClose = function elementClose(nameOrCtor) {
  if (typeof nameOrCtor === 'function') {
    new nameOrCtor();
    return;
  }
  exports.buffer.push('</' + nameOrCtor + '>');
};

/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 *
 * @param {string} The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {void} Nothing.
 */
var elementVoid = function elementVoid(nameOrCtor, key, statics, var_args) {
  elementOpen.apply(null, arguments);
  return elementClose(nameOrCtor);
};

/**
 * @param {!string} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {void} Nothing.
 */
var elementOpen = function elementOpen(nameOrCtor, key, statics, var_args) {
  if (typeof nameOrCtor === 'function') {
    new nameOrCtor();
    return exports.currentParent;
  }

  exports.buffer.push('<' + nameOrCtor);

  if (statics) {
    for (var _i = 0; _i < statics.length; _i += 2) {
      var name = /** @type {string} */statics[_i];
      var value = statics[_i + 1];
      updateAttribute(exports.buffer, name, value);
    }
  }

  var i = ATTRIBUTES_OFFSET;
  var j = 0;

  for (; i < arguments.length; i += 2, j += 2) {
    var _name = arguments[i];
    var _value = arguments[i + 1];
    updateAttribute(exports.buffer, _name, _value);
  }

  exports.buffer.push('>');

  return exports.currentParent;
};

/**
 * Closes an open tag started with elementOpenStart.
 *
 * @return {void} Nothing.
 */
var elementOpenEnd = function elementOpenEnd() {
  elementOpen.apply(null, argsBuilder);
  truncateArray(argsBuilder, 0);
};

/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {string} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @return {void} Nothing.
 */
var elementOpenStart = function elementOpenStart(nameOrCtor, key, statics) {
  argsBuilder[0] = nameOrCtor;
  argsBuilder[1] = key;
  argsBuilder[2] = statics;
};

/**
 * Returns the constructred DOM string at this point.
 * @param {function} fn
 * @return {string} The constructed DOM string.
 */
var renderToString = function renderToString(fn) {
  patch({}, fn);
  return currentElement().innerHTML;
};

exports.currentElement = currentElement;
exports.currentPointer = currentPointer;
exports.patch = patch;
exports.patchInner = patchInner;
exports.patchOuter = patchOuter;
exports.text = text;
exports.attr = attr;
exports.elementClose = elementClose;
exports.elementOpen = elementOpen;
exports.elementOpenEnd = elementOpenEnd;
exports.elementOpenStart = elementOpenStart;
exports.elementVoid = elementVoid;
exports.renderToString = renderToString;
exports.symbols = symbols;
exports.attributes = attributes;
exports.updateAttribute = updateAttribute;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(31);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.getPatchingComponent = getPatchingComponent;
exports.patch = patch;

var _metalDom = __webpack_require__(6);

var _data = __webpack_require__(9);

var _render = __webpack_require__(35);

var patchingComponents_ = [];

/**
 * Guarantees that the component's element has a parent. That's necessary
 * when calling incremental dom's `patchOuter` for now, as otherwise it will
 * throw an error if the element needs to be replaced.
 * @return {Element} The parent, in case it was added.
 * @private
 */
function buildParentIfNecessary_(element) {
	if (!element || !element.parentNode) {
		var parent = document.createElement('div');
		if (element) {
			(0, _metalDom.append)(parent, element);
		}
		return parent;
	}
}

/**
 * Calls incremental dom's patch function.
 * @param {!Component} component The component to patch.
 * @param {!Element} element The element the component should be patched on.
 * @param {boolean=} opt_outer Flag indicating if `patchOuter` should be used
 *     instead of `patch`.
 * @private
 */
function callPatch_(component, element, opt_outer) {
	patchingComponents_.push(component);

	var data = (0, _data.getData)(component);
	if (!data.render) {
		// Store reference to avoid binds on every patch.
		data.render = _render.render.bind(null, component);
	}

	var patchFn = opt_outer ? IncrementalDOM.patchOuter : IncrementalDOM.patch;
	patchFn(element, data.render);

	patchingComponents_.pop();
}

/**
 * Gets the component that triggered the current patch operation.
 * @return {Component}
 */
function getPatchingComponent() {
	return patchingComponents_[patchingComponents_.length - 1];
}

/**
 * Patches the component with incremental dom function calls.
 * @param {!Component} component
 */
function patch(component) {
	if (!tryPatchEmptyWithParent_(component)) {
		if (!tryPatchWithNoParent_(component)) {
			var element = component.element;
			callPatch_(component, element, true);
		}
	}
}

/**
 * Checks if the component has no content but was rendered from another
 * component. If so, we'll need to patch this parent to make sure that any new
 * content will be added in the right position.
 * @param {!Component} component
 * @return {?boolean} True if the patch happened. Nothing otherwise.
 * @private
 */
function tryPatchEmptyWithParent_(component) {
	var data = (0, _data.getData)(component);
	if (!component.element && data.parent) {
		data.parent.getRenderer().patch(data.parent);
		return true;
	}
}

/**
 * Checks if the component's element exists and has a parent. If that's not the
 * case, a temporary parent will be created and passed to the `patch` function,
 * since incremental dom requires it. Once the patch is done the temporary
 * parent is removed and the component's content is reattached to the correct
 * final position.
 * @param {!Component} component
 * @return {?boolean} True if the patch happened. Nothing otherwise.
 * @private
 */
function tryPatchWithNoParent_(component) {
	var tempParent = buildParentIfNecessary_(component.element);
	if (tempParent) {
		callPatch_(component, tempParent);
		(0, _metalDom.exitDocument)(component.element);
		if (component.element && component.inDocument) {
			var attach = component.getAttachData();
			component.attachElement(attach.parent, attach.sibling);
		}
		return true;
	}
}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyAttribute = applyAttribute;
exports.convertListenerNamesToFns = convertListenerNamesToFns;

var _metal = __webpack_require__(11);

var _metalDom = __webpack_require__(6);

var _metalComponent = __webpack_require__(0);

var _incrementalDomAop = __webpack_require__(15);

var HANDLE_SUFFIX = '__handle__';
var LISTENER_REGEX = /^(?:on([A-Z].+))|(?:data-on(.+))$/;

/**
 * Applies an attribute to a specified element owned by the given component.
 * @param {!Component} component
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 */
function applyAttribute(component, element, name, value) {
  var eventName = getEventFromListenerAttr_(name);
  if (eventName) {
    attachEvent_(component, element, name, eventName, value);
    return;
  }

  value = fixCheckedAttr_(name, value);
  setValueAttrAsProperty_(element, name, value);

  if ((0, _metal.isBoolean)(value)) {
    setBooleanAttr_(element, name, value);
  } else {
    (0, _incrementalDomAop.getOriginalFn)('attributes')(element, name, value);
  }
}

/**
 * Listens to the specified event, attached via incremental dom calls.
 * @param {!Component} component
 * @param {!Element} element
 * @param {string} attr
 * @param {string} eventName
 * @param {function()} fn
 * @private
 */
function attachEvent_(component, element, attr, eventName, fn) {
  if ((0, _metal.isServerSide)()) {
    return;
  }
  var handleKey = eventName + HANDLE_SUFFIX;
  if (element[handleKey]) {
    element[handleKey].removeListener();
    element[handleKey] = null;
  }
  if (fn) {
    element[attr] = fn;
    element[handleKey] = (0, _metalDom.delegate)(document, eventName, element, fn);
  }
}

/**
 * Converts all event listener attributes given as function names to actual
 * function references. It's important to do this before calling the real
 * incremental dom `elementOpen` function, otherwise if a component passes
 * the same function name that an element was already using for another
 * component, that event won't be reattached as incremental dom will think that
 * the value hasn't changed. Passing the function references as the value will
 * guarantee that different functions will cause events to be reattached,
 * regardless of their original names.
 * @param {!Component} component
 * @param {!Object} config
 */
function convertListenerNamesToFns(component, config) {
  var keys = Object.keys(config);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    config[key] = convertListenerNameToFn_(component, key, config[key]);
  }
}

/**
 * Converts the given attribute's value to a function reference, if it's
 * currently a listener name. It also register the listener name for
 * further usage.
 * @param {!Component} component
 * @param {string} name
 * @param {*} value
 * @return {*}
 * @private
 */
function convertListenerNameToFn_(component, name, value) {
  if ((0, _metal.isString)(value)) {
    var eventName = getEventFromListenerAttr_(name);
    if (eventName) {
      var fn = (0, _metalComponent.getComponentFn)(component, value);
      if (fn) {
        return fn;
      }
    }
  }
  return value;
}

/**
 * Changes the value of the `checked` attribute to be a boolean.
 * NOTE: This is a temporary fix to account for incremental dom setting
 * "checked" as an attribute only, which can cause bugs since that won't
 * necessarily check/uncheck the element it's set on. See
 * https://github.com/google/incremental-dom/issues/198 for more details.
 * @param {string} name
 * @param {*} value
 * @return {*}
 * @private
 */
function fixCheckedAttr_(name, value) {
  if (name === 'checked') {
    value = (0, _metal.isDefAndNotNull)(value) && value !== false;
  }
  return value;
}

/**
 * Returns the event name if the given attribute is a listener (matching the
 * `LISTENER_REGEX` regex), or null if it isn't.
 * @param {string} attr
 * @return {?string}
 * @private
 */
function getEventFromListenerAttr_(attr) {
  var matches = LISTENER_REGEX.exec(attr);
  var eventName = matches ? matches[1] ? matches[1] : matches[2] : null;
  return eventName ? eventName.toLowerCase() : null;
}

/**
 * Sets boolean attributes manually. This is done because incremental dom sets
 * boolean values as string data attributes by default, which is counter
 * intuitive. This changes the behavior to use the actual boolean value.
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 * @private
 */
function setBooleanAttr_(element, name, value) {
  if ((0, _metal.isServerSide)()) {
    return;
  }
  element[name] = value;
  if (value) {
    element.setAttribute(name, '');
  } else {
    element.removeAttribute(name);
  }
}

/**
 * Sets the value of the `value` attribute directly in the element.
 * NOTE: This is a temporary fix to account for incremental dom setting "value"
 * as an attribute only, which can cause bugs since that won't necessarily
 * update the input's content it's set on. See
 * https://github.com/google/incremental-dom/issues/239 for more details. We
 * only do this if the new value is different though, as otherwise the browser
 * will automatically move the typing cursor to the end of the field.
 * @param {!Element} element
 * @param {string} name
 * @param {*} value
 * @private
 */
function setValueAttrAsProperty_(element, name, value) {
  if ((0, _metal.isServerSide)()) {
    return;
  }
  if (name === 'value' && element.value !== value) {
    element[name] = value;
  }
}

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.disposeUnused = disposeUnused;
exports.schedule = schedule;

var _data = __webpack_require__(9);

var comps_ = [];
var disposing_ = false;

/**
 * Disposes all sub components that were not rerendered since the last
 * time this function was scheduled.
 */
function disposeUnused() {
	if (disposing_) {
		return;
	}
	disposing_ = true;

	for (var i = 0; i < comps_.length; i++) {
		var comp = comps_[i];
		if (!comp.isDisposed() && !(0, _data.getData)(comp).parent) {
			// Don't let disposing cause the element to be removed, since it may
			// be currently being reused by another component.
			comp.element = null;
			comp.dispose();
		}
	}
	comps_ = [];
	disposing_ = false;
}

/**
 * Schedules the given components to be checked and disposed if not used
 * anymore when `disposeUnused` is called.
 * @param {!Array<!Component>} comps
 */
function schedule(comps) {
	for (var i = 0; i < comps.length; i++) {
		if (!comps[i].isDisposed()) {
			(0, _data.getData)(comps[i]).parent = null;
			comps_.push(comps[i]);
		}
	}
}

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = undefined;

var _core = __webpack_require__(36);

Object.keys(_core).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _core[key];
    }
  });
});

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(99);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(100);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(101);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(102);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(103);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;
exports.default = _core2.default;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * A collection of core utility functions.
 * @const
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.abstractMethod = abstractMethod;
exports.disableCompatibilityMode = disableCompatibilityMode;
exports.enableCompatibilityMode = enableCompatibilityMode;
exports.getCompatibilityModeData = getCompatibilityModeData;
exports.getFunctionName = getFunctionName;
exports.getStaticProperty = getStaticProperty;
exports.getUid = getUid;
exports.identityFunction = identityFunction;
exports.isBoolean = isBoolean;
exports.isDef = isDef;
exports.isDefAndNotNull = isDefAndNotNull;
exports.isDocument = isDocument;
exports.isDocumentFragment = isDocumentFragment;
exports.isElement = isElement;
exports.isFunction = isFunction;
exports.isNull = isNull;
exports.isNumber = isNumber;
exports.isWindow = isWindow;
exports.isObject = isObject;
exports.isPromise = isPromise;
exports.isString = isString;
exports.isServerSide = isServerSide;
exports.nullFunction = nullFunction;
var compatibilityModeData_ = void 0;

/**
 * Counter for unique id.
 * @type {Number}
 * @private
 */
var uniqueIdCounter_ = 1;

/**
 * Unique id property prefix.
 * @type {String}
 * @protected
 */
var UID_PROPERTY = exports.UID_PROPERTY = 'core_' + (Math.random() * 1e9 >>> 0);

/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function abstractMethod() {
  throw Error('Unimplemented abstract method');
}

/**
 * Disables Metal.js's compatibility mode.
 */
function disableCompatibilityMode() {
  compatibilityModeData_ = undefined;
}

/**
 * Enables Metal.js's compatibility mode with the following features from rc
 * and 1.x versions:
 *     - Using "key" to reference component instances. In the current version
 *       this should be done via "ref" instead. This allows old code still
 *       using "key" to keep working like before. NOTE: this may cause
 *       problems, since "key" is meant to be used differently. Only use this
 *       if it's not possible to upgrade the code to use "ref" instead.
 * @param {Object=} opt_data Optional object with data to specify more
 *     details, such as:
 *         - renderers {Array} the template renderers that should be in
 *           compatibility mode, either their constructors or strings
 *           representing them (e.g. 'soy' or 'jsx'). By default, all the ones
 *           that extend from IncrementalDomRenderer.
 * @type {Object}
 */
function enableCompatibilityMode() {
  var opt_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  compatibilityModeData_ = opt_data;
}

/**
 * Returns the data used for compatibility mode, or nothing if it hasn't been
 * enabled.
 * @return {Object}
 */
function getCompatibilityModeData() {
  // Compatibility mode can be set via the __METAL_COMPATIBILITY__ global var.
  if (compatibilityModeData_ === undefined) {
    if (typeof window !== 'undefined' && window.__METAL_COMPATIBILITY__) {
      enableCompatibilityMode(window.__METAL_COMPATIBILITY__);
    }
  }
  return compatibilityModeData_;
}

/**
 * Returns the first argument if it's truthy, or the second otherwise.
 * @param {*} a
 * @param {*} b
 * @return {*}
 * @protected
 */
function getFirstTruthy_(a, b) {
  return a || b;
}

/**
 * Gets the name of the given function. If the current browser doesn't
 * support the `name` property, this will calculate it from the function's
 * content string.
 * @param {!function()} fn
 * @return {string}
 */
function getFunctionName(fn) {
  if (!fn.name) {
    var str = fn.toString();
    fn.name = str.substring(9, str.indexOf('('));
  }
  return fn.name;
}

/**
 * Gets the value of a static property in the given class. The value will be
 * inherited from ancestors as expected, unless a custom merge function is given,
 * which can change how the super classes' value for that property will be merged
 * together.
 * The final merged value will be stored in another property, so that it won't
 * be recalculated even if this function is called multiple times.
 * @param {!function()} ctor Class constructor.
 * @param {string} propertyName Property name to be merged.
 * @param {function(*, *):*=} opt_mergeFn Function that receives the merged
 *     value of the property so far and the next value to be merged to it.
 *     Should return these two merged together. If not passed the final property
 *     will be the first truthy value among ancestors.
 */
function getStaticProperty(ctor, propertyName, opt_mergeFn) {
  var mergedName = propertyName + '_MERGED';
  if (!ctor.hasOwnProperty(mergedName)) {
    var merged = ctor.hasOwnProperty(propertyName) ? ctor[propertyName] : null;
    if (ctor.__proto__ && !ctor.__proto__.isPrototypeOf(Function)) {
      var mergeFn = opt_mergeFn || getFirstTruthy_;
      merged = mergeFn(merged, getStaticProperty(ctor.__proto__, propertyName, mergeFn));
    }
    ctor[mergedName] = merged;
  }
  return ctor[mergedName];
}

/**
 * Gets an unique id. If `opt_object` argument is passed, the object is
 * mutated with an unique id. Consecutive calls with the same object
 * reference won't mutate the object again, instead the current object uid
 * returns. See {@link UID_PROPERTY}.
 * @param {Object=} opt_object Optional object to be mutated with the uid. If
 *     not specified this method only returns the uid.
 * @param {boolean=} opt_noInheritance Optional flag indicating if this
 *     object's uid property can be inherited from parents or not.
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
function getUid(opt_object, opt_noInheritance) {
  if (opt_object) {
    var id = opt_object[UID_PROPERTY];
    if (opt_noInheritance && !opt_object.hasOwnProperty(UID_PROPERTY)) {
      id = null;
    }
    return id || (opt_object[UID_PROPERTY] = uniqueIdCounter_++);
  }
  return uniqueIdCounter_++;
}

/**
 * The identity function. Returns its first argument.
 * @param {*=} opt_returnValue The single value that will be returned.
 * @return {?} The first argument.
 */
function identityFunction(opt_returnValue) {
  return opt_returnValue;
}

/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
function isBoolean(val) {
  return typeof val === 'boolean';
}

/**
 * Returns true if the specified value is not undefined.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
function isDef(val) {
  return val !== undefined;
}

/**
 * Returns true if value is not undefined or null.
 * @param {*} val
 * @return {boolean}
 */
function isDefAndNotNull(val) {
  return isDef(val) && !isNull(val);
}

/**
 * Returns true if value is a document.
 * @param {*} val
 * @return {boolean}
 */
function isDocument(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 9;
}

/**
 * Returns true if value is a document-fragment.
 * @param {*} val
 * @return {boolean}
 */
function isDocumentFragment(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 11;
}

/**
 * Returns true if value is a dom element.
 * @param {*} val
 * @return {boolean}
 */
function isElement(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && val.nodeType === 1;
}

/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
function isFunction(val) {
  return typeof val === 'function';
}

/**
 * Returns true if value is null.
 * @param {*} val
 * @return {boolean}
 */
function isNull(val) {
  return val === null;
}

/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Returns true if value is a window.
 * @param {*} val
 * @return {boolean}
 */
function isWindow(val) {
  return val !== null && val === val.window;
}

/**
 * Returns true if the specified value is an object. This includes arrays
 * and functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
function isObject(val) {
  var type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
  return type === 'object' && val !== null || type === 'function';
}

/**
 * Returns true if value is a Promise.
 * @param {*} val
 * @return {boolean}
 */
function isPromise(val) {
  return val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' && typeof val.then === 'function';
}

/**
 * Returns true if value is a string.
 * @param {*} val
 * @return {boolean}
 */
function isString(val) {
  return typeof val === 'string' || val instanceof String;
}

/**
 * Sets to true if running inside Node.js environment with extra check for
 * `process.browser` to skip Karma runner environment. Karma environment has
 * `process` defined even though it runs on the browser.
 * @return {boolean}
 */
function isServerSide() {
  return typeof process !== 'undefined' && typeof process.env !== 'undefined' && "production" !== 'test' && !process.browser;
}

/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
function nullFunction() {}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _core = __webpack_require__(36);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	_createClass(array, null, [{
		key: 'equal',

		/**
   * Checks if the given arrays have the same content.
   * @param {!Array<*>} arr1
   * @param {!Array<*>} arr2
   * @return {boolean}
   */
		value: function equal(arr1, arr2) {
			if (arr1 === arr2) {
				return true;
			}
			if (arr1.length !== arr2.length) {
				return false;
			}
			for (var i = 0; i < arr1.length; i++) {
				if (arr1[i] !== arr2[i]) {
					return false;
				}
			}
			return true;
		}

		/**
   * Returns the first value in the given array that isn't undefined.
   * @param {!Array} arr
   * @return {*}
   */

	}, {
		key: 'firstDefinedValue',
		value: function firstDefinedValue(arr) {
			for (var i = 0; i < arr.length; i++) {
				if (arr[i] !== undefined) {
					return arr[i];
				}
			}
		}

		/**
   * Transforms the input nested array to become flat.
   * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
   * @param {Array.<*>} opt_output Optional output array.
   * @return {Array.<*>} Flat array.
   */

	}, {
		key: 'flatten',
		value: function flatten(arr, opt_output) {
			var output = opt_output || [];
			for (var i = 0; i < arr.length; i++) {
				if (Array.isArray(arr[i])) {
					array.flatten(arr[i], output);
				} else {
					output.push(arr[i]);
				}
			}
			return output;
		}

		/**
   * Removes the first occurrence of a particular value from an array.
   * @param {Array.<T>} arr Array from which to remove value.
   * @param {T} obj Object to remove.
   * @return {boolean} True if an element was removed.
   * @template T
   */

	}, {
		key: 'remove',
		value: function remove(arr, obj) {
			var i = arr.indexOf(obj);
			var rv = void 0;
			if (rv = i >= 0) {
				array.removeAt(arr, i);
			}
			return rv;
		}

		/**
   * Removes from an array the element at index i
   * @param {Array} arr Array or array like object from which to remove value.
   * @param {number} i The index to remove.
   * @return {boolean} True if an element was removed.
   */

	}, {
		key: 'removeAt',
		value: function removeAt(arr, i) {
			return Array.prototype.splice.call(arr, i, 1).length === 1;
		}

		/**
   * Slices the given array, just like Array.prototype.slice, but this
   * is faster and working on all array-like objects (like arguments).
   * @param {!Object} arr Array-like object to slice.
   * @param {number} start The index that should start the slice.
   * @param {number=} opt_end The index where the slice should end, not
   *   included in the final array. If not given, all elements after the
   *   start index will be included.
   * @return {!Array}
   */

	}, {
		key: 'slice',
		value: function slice(arr, start, opt_end) {
			var sliced = [];
			var end = (0, _core.isDef)(opt_end) ? opt_end : arr.length;
			for (var i = start; i < end; i++) {
				sliced.push(arr[i]);
			}
			return sliced;
		}
	}]);

	return array;
}();

exports.default = array;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel = void 0;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	_createClass(Disposable, [{
		key: 'dispose',
		value: function dispose() {
			if (!this.disposed_) {
				this.disposeInternal();
				this.disposed_ = true;
			}
		}

		/**
   * Subclasses should override this method to implement any specific
   * disposing logic (like clearing references and calling `dispose` on other
   * disposables).
   */

	}, {
		key: 'disposeInternal',
		value: function disposeInternal() {}

		/**
   * Checks if this instance has already been disposed.
   * @return {boolean}
   */

	}, {
		key: 'isDisposed',
		value: function isDisposed() {
			return this.disposed_;
		}
	}]);

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	_createClass(object, null, [{
		key: 'mixin',

		/**
   * Copies all the members of a source object to a target object.
   * @param {Object} target Target object.
   * @param {...Object} var_args The objects from which values will be copied.
   * @return {Object} Returns the target object reference.
   */
		value: function mixin(target) {
			var key = void 0,
			    source = void 0;
			for (var i = 1; i < arguments.length; i++) {
				source = arguments[i];
				for (key in source) {
					target[key] = source[key];
				}
			}
			return target;
		}

		/**
   * Returns an object based on its fully qualified external name.
   * @param {string} name The fully qualified name.
   * @param {object=} opt_obj The object within which to look; default is
   *     <code>window</code>.
   * @return {?} The value (object or primitive) or, if not found, undefined.
   */

	}, {
		key: 'getObjectByName',
		value: function getObjectByName(name, opt_obj) {
			var scope = opt_obj || window;
			var parts = name.split('.');
			return parts.reduce(function (part, key) {
				return part[key];
			}, scope);
		}

		/**
   * Returns a new object with the same keys as the given one, but with
   * their values set to the return values of the specified function.
   * @param {!Object} obj
   * @param {!function(string, *)} fn
   * @return {!Object}
   */

	}, {
		key: 'map',
		value: function map(obj, fn) {
			var mappedObj = {};
			var keys = Object.keys(obj);
			for (var i = 0; i < keys.length; i++) {
				mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
			}
			return mappedObj;
		}

		/**
   * Checks if the two given objects are equal. This is done via a shallow
   * check, including only the keys directly contained by the 2 objects.
   * @return {boolean}
   */

	}, {
		key: 'shallowEqual',
		value: function shallowEqual(obj1, obj2) {
			if (obj1 === obj2) {
				return true;
			}

			var keys1 = Object.keys(obj1);
			var keys2 = Object.keys(obj2);
			if (keys1.length !== keys2.length) {
				return false;
			}

			for (var i = 0; i < keys1.length; i++) {
				if (obj1[keys1[i]] !== obj2[keys1[i]]) {
					return false;
				}
			}
			return true;
		}
	}]);

	return object;
}();

exports.default = object;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	_createClass(string, null, [{
		key: 'caseInsensitiveCompare',

		/**
   * Compares the given strings without taking the case into account.
   * @param {string|number} str1
   * @param {string|number} str2
   * @return {number} Either -1, 0 or 1, according to if the first string is
   *     "smaller", equal or "bigger" than the second given string.
   */
		value: function caseInsensitiveCompare(str1, str2) {
			var test1 = String(str1).toLowerCase();
			var test2 = String(str2).toLowerCase();

			if (test1 < test2) {
				return -1;
			} else if (test1 === test2) {
				return 0;
			} else {
				return 1;
			}
		}

		/**
   * Removes the breaking spaces from the left and right of the string and
   * collapses the sequences of breaking spaces in the middle into single spaces.
   * The original and the result strings render the same way in HTML.
   * @param {string} str A string in which to collapse spaces.
   * @return {string} Copy of the string with normalized breaking spaces.
   */

	}, {
		key: 'collapseBreakingSpaces',
		value: function collapseBreakingSpaces(str) {
			return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
		}

		/**
  * Escapes characters in the string that are not safe to use in a RegExp.
  * @param {*} str The string to escape. If not a string, it will be casted
  *     to one.
  * @return {string} A RegExp safe, escaped copy of {@code s}.
  */

	}, {
		key: 'escapeRegex',
		value: function escapeRegex(str) {
			return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
		}

		/**
  * Returns a string with at least 64-bits of randomness.
  * @return {string} A random string, e.g. sn1s7vb4gcic.
  */

	}, {
		key: 'getRandomString',
		value: function getRandomString() {
			var x = 2147483648;
			return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
		}

		/**
   * Calculates the hashcode for a string. The hashcode value is computed by
   * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
   * property of using 31 prime is that the multiplication can be replaced by
   * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
   * Modern VMs do this sort of optimization automatically.
   * @param {String} val Target string.
   * @return {Number} Returns the string hashcode.
   */

	}, {
		key: 'hashCode',
		value: function hashCode(val) {
			var hash = 0;
			for (var i = 0, len = val.length; i < len; i++) {
				hash = 31 * hash + val.charCodeAt(i);
				hash %= 0x100000000;
			}
			return hash;
		}

		/**
   * Replaces interval into the string with specified value, e.g.
   * `replaceInterval("abcde", 1, 4, "")` returns "ae".
   * @param {string} str The input string.
   * @param {Number} start Start interval position to be replaced.
   * @param {Number} end End interval position to be replaced.
   * @param {string} value The value that replaces the specified interval.
   * @return {string}
   */

	}, {
		key: 'replaceInterval',
		value: function replaceInterval(str, start, end, value) {
			return str.substring(0, start) + value + str.substring(end);
		}
	}]);

	return string;
}();

exports.default = string;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(105);

var _HTML2IncDom = __webpack_require__(106);

var _HTML2IncDom2 = _interopRequireDefault(_HTML2IncDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _HTML2IncDom2.default;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* jshint ignore:start */

/*
 * HTML5 Parser By Sam Blowes
 *
 * Designed for HTML5 documents
 *
 * Original code by John Resig (ejohn.org)
 * http://ejohn.org/blog/pure-javascript-html-parser/
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * ----------------------------------------------------------------------------
 * License
 * ----------------------------------------------------------------------------
 *
 * This code is triple licensed using Apache Software License 2.0,
 * Mozilla Public License or GNU Public License
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * The contents of this file are subject to the Mozilla Public License
 * Version 1.1 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS"
 * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * The Original Code is Simple HTML Parser.
 *
 * The Initial Developer of the Original Code is Erik Arvidsson.
 * Portions created by Erik Arvidssson are Copyright (C) 2004. All Rights
 * Reserved.
 *
 * ////////////////////////////////////////////////////////////////////////////
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * @license
 */

/*
 *
 * ----------------------------------------------------------------------------
 * Usage
 * ----------------------------------------------------------------------------
 *
 * // Use like so:
 * HTMLParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * // or to get an XML string:
 * HTMLtoXML(htmlString);
 *
 * // or to get an XML DOM Document
 * HTMLtoDOM(htmlString);
 *
 * // or to inject into an existing document/DOM node
 * HTMLtoDOM(htmlString, document);
 * HTMLtoDOM(htmlString, document.body);
 *
 */

(function () {
	// Regular Expressions for parsing tags and attributes
	var startTag = /^<([-A-Za-z0-9_]+)((?:\s+[a-zA-Z_:][-a-zA-Z0-9_:.]*(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)>/,
	    endTag = /^<\/([-A-Za-z0-9_]+)[^>]*>/,
	    attr = /([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|([^>\s]+)))?/g;

	// Empty Elements - HTML 5
	var empty = makeMap("area,base,basefont,br,col,frame,hr,img,input,link,meta,param,embed,command,keygen,source,track,wbr");

	// Block Elements - HTML 5
	var block = makeMap("a,address,article,applet,aside,audio,blockquote,button,canvas,center,dd,del,dir,div,dl,dt,fieldset,figcaption,figure,footer,form,frameset,h1,h2,h3,h4,h5,h6,header,hgroup,hr,iframe,ins,isindex,li,map,menu,noframes,noscript,object,ol,output,p,pre,section,script,table,tbody,td,tfoot,th,thead,tr,ul,video");

	// Inline Elements - HTML 5
	var inline = makeMap("abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");

	// Elements that you can, intentionally, leave open
	// (and which close themselves)
	var closeSelf = makeMap("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

	// Attributes that have their values filled in disabled="disabled"
	var fillAttrs = makeMap("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");

	// Special Elements (can contain anything)
	var special = makeMap("script,style");

	var HTMLParser = window.HTMLParser = function (html, handler) {
		var index,
		    chars,
		    match,
		    stack = [],
		    last = html;
		stack.last = function () {
			return this[this.length - 1];
		};

		while (html) {
			chars = true;

			// Make sure we're not in a script or style element
			if (!stack.last() || !special[stack.last()]) {

				// Comment
				if (html.indexOf("<!--") == 0) {
					index = html.indexOf("-->");

					if (index >= 0) {
						if (handler.comment) handler.comment(html.substring(4, index));
						html = html.substring(index + 3);
						chars = false;
					}

					// end tag
				} else if (html.indexOf("</") == 0) {
						match = html.match(endTag);

						if (match) {
							html = html.substring(match[0].length);
							match[0].replace(endTag, parseEndTag);
							chars = false;
						}

						// start tag
					} else if (html.indexOf("<") == 0) {
							match = html.match(startTag);

							if (match) {
								html = html.substring(match[0].length);
								match[0].replace(startTag, parseStartTag);
								chars = false;
							}
						}

				if (chars) {
					index = html.indexOf("<");

					var text = index < 0 ? html : html.substring(0, index);
					html = index < 0 ? "" : html.substring(index);

					if (handler.chars) handler.chars(text);
				}
			} else {
				html = html.replace(new RegExp("([\\s\\S]*?)<\/" + stack.last() + "[^>]*>"), function (all, text) {
					text = text.replace(/<!--([\s\S]*?)-->|<!\[CDATA\[([\s\S]*?)]]>/g, "$1$2");
					if (handler.chars) handler.chars(text);

					return "";
				});

				parseEndTag("", stack.last());
			}

			if (html == last) throw "Parse Error: " + html;
			last = html;
		}

		// Clean up any remaining tags
		parseEndTag();

		function parseStartTag(tag, tagName, rest, unary) {
			tagName = tagName.toLowerCase();

			if (block[tagName]) {
				// Close last tag if it's inline, except if it's a "span" (since people
				// usually add anything they want to spans, and browsers allow it).
				// Note: this exception for "span" was added manually (i.e. it's not
				// present in the original code).
				while (stack.last() && inline[stack.last()] && stack.last() !== 'span') {
					parseEndTag("", stack.last());
				}
			}

			if (closeSelf[tagName] && stack.last() == tagName) {
				parseEndTag("", tagName);
			}

			unary = empty[tagName] || !!unary;

			if (!unary) stack.push(tagName);

			if (handler.start) {
				var attrs = [];

				rest.replace(attr, function (match, name) {
					var value = arguments[2] ? arguments[2] : arguments[3] ? arguments[3] : arguments[4] ? arguments[4] : fillAttrs[name] ? name : "";

					attrs.push({
						name: name,
						value: value,
						escaped: value.replace(/(^|[^\\])"/g, '$1\\\"') //"
					});
				});

				if (handler.start) handler.start(tagName, attrs, unary);
			}
		}

		function parseEndTag(tag, tagName) {
			// If no tag name is provided, clean shop
			if (!tagName) var pos = 0;

			// Find the closest opened tag of the same type
			else for (var pos = stack.length - 1; pos >= 0; pos--) {
					if (stack[pos] == tagName) break;
				}if (pos >= 0) {
				// Close all the open elements, up the stack
				for (var i = stack.length - 1; i >= pos; i--) {
					if (handler.end) handler.end(stack[i]);
				} // Remove the open elements from the stack
				stack.length = pos;
			}
		}
	};

	function makeMap(str) {
		var obj = {},
		    items = str.split(",");
		for (var i = 0; i < items.length; i++) {
			obj[items[i]] = true;
		}return obj;
	}
}).call(undefined);

/* jshint ignore:end */

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _unescape = __webpack_require__(107);

var _unescape2 = _interopRequireDefault(_unescape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var parser_;

var HTML2IncDom = function () {
	function HTML2IncDom() {
		_classCallCheck(this, HTML2IncDom);
	}

	_createClass(HTML2IncDom, null, [{
		key: 'buildFn',

		/**
   * Should convert the given html string to a function with calls to
   * incremental dom methods.
   * @param {string} html
   * @return {!function()} Function with incremental dom calls for building
   *     the given html string.
   */
		value: function buildFn(html) {
			return function () {
				return HTML2IncDom.run(html);
			};
		}

		/**
   * Gets the html parser being currently used.
   * @return {!function()}
   */

	}, {
		key: 'getParser',
		value: function getParser() {
			return parser_ || window.HTMLParser;
		}

		/**
   * Should convert the given html string to calls to incremental dom methods.
   * @param {string} html
   */

	}, {
		key: 'run',
		value: function run(html) {
			HTML2IncDom.getParser()(html, {
				start: function start(tag, attrs, unary) {
					var fn = unary ? IncrementalDOM.elementVoid : IncrementalDOM.elementOpen;
					var args = [tag, null, []];
					for (var i = 0; i < attrs.length; i++) {
						args.push(attrs[i].name, attrs[i].value);
					}
					fn.apply(null, args);
				},

				end: function end(tag) {
					IncrementalDOM.elementClose(tag);
				},

				chars: function chars(text) {
					IncrementalDOM.text(text, _unescape2.default);
				}
			});
		}

		/**
   * Changes the function that will be used to parse html strings. By default
   * this will use the `HTMLParser` function from
   * https://github.com/blowsie/Pure-JavaScript-HTML5-Parser. This will accept
   * any function that follows that same api, basically accepting the html
   * string and an object with `start`, `end` and `chars` functions to be called
   * during the parsing.
   * @param {!function(string, !Object} newParser
   */

	}, {
		key: 'setParser',
		value: function setParser(newParser) {
			parser_ = newParser;
		}
	}]);

	return HTML2IncDom;
}();

exports.default = HTML2IncDom;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} The unescaped {@code str} string.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
function unescape(str) {
  /** @type {!Object<string, string>} */
  var seen = { '&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"' };
  var div = document.createElement('div');

  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(HTML_ENTITY_PATTERN_, function (s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) === '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    seen[s] = value;
    return value;
  });
}

exports.default = unescape;

/**
 * Regular expression that matches an HTML entity.
 * @type {!RegExp}
 */

var HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var SoyAop = {
	/**
  * The functions that should be called instead of a template call. The last
  * function in the array is the one that is intercepting at the moment. If the
  * array is empty, the original function will be called instead.
  * @type {!Array<function()>}
  * @protected
  */
	interceptFns_: [],

	/**
  * Gets the original function of the given template function. If no original exists,
  * returns the given function itself.
  * @param {!function()} fn
  * @return {!function()}
  */
	getOriginalFn: function getOriginalFn(fn) {
		return fn.originalFn ? fn.originalFn : fn;
	},

	/**
  * Handles a template call, calling the current interception function if one
  * is set, or otherwise just calling the original function instead.
  * @param {!function()} originalFn The original template function that was
  *     intercepted.
  * @param {Object} opt_data Template data object.
  * @param {*} opt_ignored
  * @param {Object} opt_ijData Template injected data object.
  * @return {*} The return value of the function that is called to handle this
  *     interception.
  */
	handleTemplateCall_: function handleTemplateCall_(originalFn, opt_data, opt_ignored, opt_ijData) {
		var interceptFn = SoyAop.interceptFns_[SoyAop.interceptFns_.length - 1];
		if (interceptFn) {
			return interceptFn.call(null, originalFn, opt_data, opt_ignored, opt_ijData);
		} else {
			return originalFn.call(null, opt_data, opt_ignored, opt_ijData);
		}
	},

	/**
  * Registers a template function that should be intercepted.
  * @param {!Object} templates The original templates object containing the
  *     function to be intercepted.
  * @param {string} name The name of the template function to intercept.
  */
	registerForInterception: function registerForInterception(templates, name) {
		var originalFn = templates[name];
		if (!originalFn.originalFn) {
			templates[name] = SoyAop.handleTemplateCall_.bind(null, originalFn);
			templates[name].originalFn = originalFn;
		}
	},

	/**
  * Starts intercepting all template calls, replacing them with a call to the
  * given function instead.
  * @param {!function()} fn
  */
	startInterception: function startInterception(fn) {
		SoyAop.interceptFns_.push(fn);
	},

	/**
  * Stops intercepting template calls.
  */
	stopAllInterceptions: function stopAllInterceptions() {
		SoyAop.interceptFns_ = [];
	},

	/**
  * Stops intercepting template calls with the last registered function.
  */
	stopInterception: function stopInterception() {
		SoyAop.interceptFns_.pop();
	}
};

exports.default = SoyAop;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.string = exports.object = exports.Disposable = exports.async = exports.array = exports.core = undefined;

var _core = __webpack_require__(37);

var _core2 = _interopRequireDefault(_core);

var _array = __webpack_require__(110);

var _array2 = _interopRequireDefault(_array);

var _async = __webpack_require__(111);

var _async2 = _interopRequireDefault(_async);

var _Disposable = __webpack_require__(112);

var _Disposable2 = _interopRequireDefault(_Disposable);

var _object = __webpack_require__(113);

var _object2 = _interopRequireDefault(_object);

var _string = __webpack_require__(114);

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _core2.default;
exports.core = _core2.default;
exports.array = _array2.default;
exports.async = _async2.default;
exports.Disposable = _Disposable2.default;
exports.object = _object2.default;
exports.string = _string2.default;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _core = __webpack_require__(37);

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var array = function () {
	function array() {
		_classCallCheck(this, array);
	}

	/**
  * Checks if the given arrays have the same content.
  * @param {!Array<*>} arr1
  * @param {!Array<*>} arr2
  * @return {boolean}
  */
	array.equal = function equal(arr1, arr2) {
		if (arr1.length !== arr2.length) {
			return false;
		}
		for (var i = 0; i < arr1.length; i++) {
			if (arr1[i] !== arr2[i]) {
				return false;
			}
		}
		return true;
	};

	/**
  * Returns the first value in the given array that isn't undefined.
  * @param {!Array} arr
  * @return {*}
  */


	array.firstDefinedValue = function firstDefinedValue(arr) {
		for (var i = 0; i < arr.length; i++) {
			if (arr[i] !== undefined) {
				return arr[i];
			}
		}
	};

	/**
  * Transforms the input nested array to become flat.
  * @param {Array.<*|Array.<*>>} arr Nested array to flatten.
  * @param {Array.<*>} opt_output Optional output array.
  * @return {Array.<*>} Flat array.
  */


	array.flatten = function flatten(arr, opt_output) {
		var output = opt_output || [];
		for (var i = 0; i < arr.length; i++) {
			if (Array.isArray(arr[i])) {
				array.flatten(arr[i], output);
			} else {
				output.push(arr[i]);
			}
		}
		return output;
	};

	/**
  * Removes the first occurrence of a particular value from an array.
  * @param {Array.<T>} arr Array from which to remove value.
  * @param {T} obj Object to remove.
  * @return {boolean} True if an element was removed.
  * @template T
  */


	array.remove = function remove(arr, obj) {
		var i = arr.indexOf(obj);
		var rv;
		if (rv = i >= 0) {
			array.removeAt(arr, i);
		}
		return rv;
	};

	/**
  * Removes from an array the element at index i
  * @param {Array} arr Array or array like object from which to remove value.
  * @param {number} i The index to remove.
  * @return {boolean} True if an element was removed.
  */


	array.removeAt = function removeAt(arr, i) {
		return Array.prototype.splice.call(arr, i, 1).length === 1;
	};

	/**
  * Slices the given array, just like Array.prototype.slice, but this
  * is faster and working on all array-like objects (like arguments).
  * @param {!Object} arr Array-like object to slice.
  * @param {number} start The index that should start the slice.
  * @param {number=} opt_end The index where the slice should end, not
  *   included in the final array. If not given, all elements after the
  *   start index will be included.
  * @return {!Array}
  */


	array.slice = function slice(arr, start, opt_end) {
		var sliced = [];
		var end = _core2.default.isDef(opt_end) ? opt_end : arr.length;
		for (var i = start; i < end; i++) {
			sliced.push(arr[i]);
		}
		return sliced;
	};

	return array;
}();

exports.default = array;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {/*!
 * Polyfill from Google's Closure Library.
 * Copyright 2013 The Closure Library Authors. All Rights Reserved.
 */



Object.defineProperty(exports, "__esModule", {
	value: true
});
var async = {};

/**
 * Throw an item without interrupting the current execution context.  For
 * example, if processing a group of items in a loop, sometimes it is useful
 * to report an error while still allowing the rest of the batch to be
 * processed.
 * @param {*} exception
 */
async.throwException = function (exception) {
	// Each throw needs to be in its own context.
	async.nextTick(function () {
		throw exception;
	});
};

/**
 * Fires the provided callback just before the current callstack unwinds, or as
 * soon as possible after the current JS execution context.
 * @param {function(this:THIS)} callback
 * @param {THIS=} opt_context Object to use as the "this value" when calling
 *     the provided function.
 * @template THIS
 */
async.run = function (callback, opt_context) {
	if (!async.run.workQueueScheduled_) {
		// Nothing is currently scheduled, schedule it now.
		async.nextTick(async.run.processWorkQueue);
		async.run.workQueueScheduled_ = true;
	}

	async.run.workQueue_.push(new async.run.WorkItem_(callback, opt_context));
};

/** @private {boolean} */
async.run.workQueueScheduled_ = false;

/** @private {!Array.<!async.run.WorkItem_>} */
async.run.workQueue_ = [];

/**
 * Run any pending async.run work items. This function is not intended
 * for general use, but for use by entry point handlers to run items ahead of
 * async.nextTick.
 */
async.run.processWorkQueue = function () {
	// NOTE: additional work queue items may be pushed while processing.
	while (async.run.workQueue_.length) {
		// Don't let the work queue grow indefinitely.
		var workItems = async.run.workQueue_;
		async.run.workQueue_ = [];
		for (var i = 0; i < workItems.length; i++) {
			var workItem = workItems[i];
			try {
				workItem.fn.call(workItem.scope);
			} catch (e) {
				async.throwException(e);
			}
		}
	}

	// There are no more work items, reset the work queue.
	async.run.workQueueScheduled_ = false;
};

/**
 * @constructor
 * @final
 * @struct
 * @private
 *
 * @param {function()} fn
 * @param {Object|null|undefined} scope
 */
async.run.WorkItem_ = function (fn, scope) {
	/** @const */
	this.fn = fn;
	/** @const */
	this.scope = scope;
};

/**
 * Fires the provided callbacks as soon as possible after the current JS
 * execution context. setTimeout(…, 0) always takes at least 5ms for legacy
 * reasons.
 * @param {function(this:SCOPE)} callback Callback function to fire as soon as
 *     possible.
 * @param {SCOPE=} opt_context Object in whose scope to call the listener.
 * @template SCOPE
 */
async.nextTick = function (callback, opt_context) {
	var cb = callback;
	if (opt_context) {
		cb = callback.bind(opt_context);
	}
	cb = async.nextTick.wrapCallback_(cb);
	// Introduced and currently only supported by IE10.
	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof setImmediate === 'function') {
		setImmediate(cb);
		return;
	}
	// Look for and cache the custom fallback version of setImmediate.
	if (!async.nextTick.setImmediate_) {
		async.nextTick.setImmediate_ = async.nextTick.getSetImmediateEmulator_();
	}
	async.nextTick.setImmediate_(cb);
};

/**
 * Cache for the setImmediate implementation.
 * @type {function(function())}
 * @private
 */
async.nextTick.setImmediate_ = null;

/**
 * Determines the best possible implementation to run a function as soon as
 * the JS event loop is idle.
 * @return {function(function())} The "setImmediate" implementation.
 * @private
 */
async.nextTick.getSetImmediateEmulator_ = function () {
	// Create a private message channel and use it to postMessage empty messages
	// to ourselves.
	var Channel;

	// Verify if variable is defined on the current runtime (i.e., node, browser).
	// Can't use typeof enclosed in a function (such as core.isFunction) or an
	// exception will be thrown when the function is called on an environment
	// where the variable is undefined.
	if (typeof MessageChannel === 'function') {
		Channel = MessageChannel;
	}

	// If MessageChannel is not available and we are in a browser, implement
	// an iframe based polyfill in browsers that have postMessage and
	// document.addEventListener. The latter excludes IE8 because it has a
	// synchronous postMessage implementation.
	if (typeof Channel === 'undefined' && typeof window !== 'undefined' && window.postMessage && window.addEventListener) {
		/** @constructor */
		Channel = function Channel() {
			// Make an empty, invisible iframe.
			var iframe = document.createElement('iframe');
			iframe.style.display = 'none';
			iframe.src = '';
			document.documentElement.appendChild(iframe);
			var win = iframe.contentWindow;
			var doc = win.document;
			doc.open();
			doc.write('');
			doc.close();
			var message = 'callImmediate' + Math.random();
			var origin = win.location.protocol + '//' + win.location.host;
			var onmessage = function (e) {
				// Validate origin and message to make sure that this message was
				// intended for us.
				if (e.origin !== origin && e.data !== message) {
					return;
				}
				this.port1.onmessage();
			}.bind(this);
			win.addEventListener('message', onmessage, false);
			this.port1 = {};
			this.port2 = {
				postMessage: function postMessage() {
					win.postMessage(message, origin);
				}
			};
		};
	}
	if (typeof Channel !== 'undefined') {
		var channel = new Channel();
		// Use a fifo linked list to call callbacks in the right order.
		var head = {};
		var tail = head;
		channel.port1.onmessage = function () {
			head = head.next;
			var cb = head.cb;
			head.cb = null;
			cb();
		};
		return function (cb) {
			tail.next = {
				cb: cb
			};
			tail = tail.next;
			channel.port2.postMessage(0);
		};
	}
	// Implementation for IE6-8: Script elements fire an asynchronous
	// onreadystatechange event when inserted into the DOM.
	if (typeof document !== 'undefined' && 'onreadystatechange' in document.createElement('script')) {
		return function (cb) {
			var script = document.createElement('script');
			script.onreadystatechange = function () {
				// Clean up and call the callback.
				script.onreadystatechange = null;
				script.parentNode.removeChild(script);
				script = null;
				cb();
				cb = null;
			};
			document.documentElement.appendChild(script);
		};
	}
	// Fall back to setTimeout with 0. In browsers this creates a delay of 5ms
	// or more.
	return function (cb) {
		setTimeout(cb, 0);
	};
};

/**
 * Helper function that is overrided to protect callbacks with entry point
 * monitor if the application monitors entry points.
 * @param {function()} callback Callback function to fire as soon as possible.
 * @return {function()} The wrapped callback.
 * @private
 */
async.nextTick.wrapCallback_ = function (opt_returnValue) {
	return opt_returnValue;
};

exports.default = async;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Disposable utility. When inherited provides the `dispose` function to its
 * subclass, which is responsible for disposing of any object references
 * when an instance won't be used anymore. Subclasses should override
 * `disposeInternal` to implement any specific disposing logic.
 * @constructor
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Disposable = function () {
	function Disposable() {
		_classCallCheck(this, Disposable);

		/**
   * Flag indicating if this instance has already been disposed.
   * @type {boolean}
   * @protected
   */
		this.disposed_ = false;
	}

	/**
  * Disposes of this instance's object references. Calls `disposeInternal`.
  */


	Disposable.prototype.dispose = function dispose() {
		if (!this.disposed_) {
			this.disposeInternal();
			this.disposed_ = true;
		}
	};

	/**
  * Subclasses should override this method to implement any specific
  * disposing logic (like clearing references and calling `dispose` on other
  * disposables).
  */


	Disposable.prototype.disposeInternal = function disposeInternal() {};

	/**
  * Checks if this instance has already been disposed.
  * @return {boolean}
  */


	Disposable.prototype.isDisposed = function isDisposed() {
		return this.disposed_;
	};

	return Disposable;
}();

exports.default = Disposable;

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var object = function () {
	function object() {
		_classCallCheck(this, object);
	}

	/**
  * Copies all the members of a source object to a target object.
  * @param {Object} target Target object.
  * @param {...Object} var_args The objects from which values will be copied.
  * @return {Object} Returns the target object reference.
  */
	object.mixin = function mixin(target) {
		var key, source;
		for (var i = 1; i < arguments.length; i++) {
			source = arguments[i];
			for (key in source) {
				target[key] = source[key];
			}
		}
		return target;
	};

	/**
  * Returns an object based on its fully qualified external name.
  * @param {string} name The fully qualified name.
  * @param {object=} opt_obj The object within which to look; default is
  *     <code>window</code>.
  * @return {?} The value (object or primitive) or, if not found, undefined.
  */


	object.getObjectByName = function getObjectByName(name, opt_obj) {
		var scope = opt_obj || window;
		var parts = name.split('.');
		return parts.reduce(function (part, key) {
			return part[key];
		}, scope);
	};

	/**
  * Returns a new object with the same keys as the given one, but with
  * their values set to the return values of the specified function.
  * @param {!Object} obj
  * @param {!function(string, *)} fn
  * @return {!Object}
  */


	object.map = function map(obj, fn) {
		var mappedObj = {};
		var keys = Object.keys(obj);
		for (var i = 0; i < keys.length; i++) {
			mappedObj[keys[i]] = fn(keys[i], obj[keys[i]]);
		}
		return mappedObj;
	};

	/**
  * Checks if the two given objects are equal. This is done via a shallow
  * check, including only the keys directly contained by the 2 objects.
  * @return {boolean}
  */


	object.shallowEqual = function shallowEqual(obj1, obj2) {
		if (obj1 === obj2) {
			return true;
		}

		var keys1 = Object.keys(obj1);
		var keys2 = Object.keys(obj2);
		if (keys1.length !== keys2.length) {
			return false;
		}

		for (var i = 0; i < keys1.length; i++) {
			if (obj1[keys1[i]] !== obj2[keys1[i]]) {
				return false;
			}
		}
		return true;
	};

	return object;
}();

exports.default = object;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var string = function () {
	function string() {
		_classCallCheck(this, string);
	}

	/**
  * Removes the breaking spaces from the left and right of the string and
  * collapses the sequences of breaking spaces in the middle into single spaces.
  * The original and the result strings render the same way in HTML.
  * @param {string} str A string in which to collapse spaces.
  * @return {string} Copy of the string with normalized breaking spaces.
  */
	string.collapseBreakingSpaces = function collapseBreakingSpaces(str) {
		return str.replace(/[\t\r\n ]+/g, ' ').replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, '');
	};

	/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} str The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */


	string.escapeRegex = function escapeRegex(str) {
		return String(str).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
	};

	/**
 * Returns a string with at least 64-bits of randomness.
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */


	string.getRandomString = function getRandomString() {
		var x = 2147483648;
		return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ Date.now()).toString(36);
	};

	/**
  * Calculates the hashcode for a string. The hashcode value is computed by
  * the sum algorithm: s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]. A nice
  * property of using 31 prime is that the multiplication can be replaced by
  * a shift and a subtraction for better performance: 31*i == (i<<5)-i.
  * Modern VMs do this sort of optimization automatically.
  * @param {String} val Target string.
  * @return {Number} Returns the string hashcode.
  */


	string.hashCode = function hashCode(val) {
		var hash = 0;
		for (var i = 0, len = val.length; i < len; i++) {
			hash = 31 * hash + val.charCodeAt(i);
			hash %= 0x100000000;
		}
		return hash;
	};

	/**
  * Replaces interval into the string with specified value, e.g.
  * `replaceInterval("abcde", 1, 4, "")` returns "ae".
  * @param {string} str The input string.
  * @param {Number} start Start interval position to be replaced.
  * @param {Number} end End interval position to be replaced.
  * @param {string} value The value that replaces the specified interval.
  * @return {string}
  */


	string.replaceInterval = function replaceInterval(str, start, end, value) {
		return str.substring(0, start) + value + str.substring(end);
	};

	return string;
}();

exports.default = string;

/***/ }),
/* 115 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_dom__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_metal_dom__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Utils_EventEmitter__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Dropdown_soy_js__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__DropdownUtils__ = __webpack_require__(118);








class Dropdown extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {
	/**
	 * Dropdown component.
	 */
	created(){
		let instance = this;
		
		instance.cashItemsData = __WEBPACK_IMPORTED_MODULE_5__DropdownUtils__["a" /* ITEMS_DATA */];
		instance.Listener.on('LISTEN_DROPDOWN_ERROR', err => instance.warning = err);
	}
	
	/**
	 * Set the click event when the body was pressed
	 */
	attached(){
		const showItems = this.showItems;
		document.querySelector('body').addEventListener('click', showItems.bind(this));
	}
	
	/**
	 * Show the dropdowns items
	 * @param {Object} e
	 */
	showItems(e){
		let instance = this,
			active,
			elementClass = e.target.className;
		
		if((elementClass.indexOf('dropdown-display') != -1) || (elementClass.indexOf('dropdown-input') != -1)){
			active = true;
			setTimeout(() => instance.element.querySelector('.dropdown-input').focus(), 200);
		}else {
			instance.focusOut();
		}
		
		instance.shown = active;
	}
	
	/**
	 * Change the selected item in the dropdown
	 * @param {Object} e
	 */
	changeActivePlan(e){
		let instance = this;
		const item = e.target;
		const data = instance.cashItemsData.filter(obj => obj.id == item.getAttribute('data-id'));
		
		item.classList.add('dropdown-list-item--selected');
		
		if(data.length) {
			instance.bindSelectedItemClass(data[0]);
			instance.setState({activeDropdownItem: data[0]});
			instance.emitListener(data[0]);
		}
	}
	
	/**
	 * Clear the input and remove the input focus
	 */
	focusOut(){
		let instance = this;
		const item = instance.element.querySelector('.dropdown-input');
		
		item.value = '';
		instance.items = instance.cashItemsData;
	}
	
	/**
	 * Search items through of the input interaction
	 * @param {Object} e
	 */
	searchItem(e){
		const item = e.target;
		let instance = this;
		instance.items = instance.cashItemsData.filter(obj => obj.name.toLowerCase().indexOf(item.value.toLowerCase()) != -1);
	}
	
	/**
	 * Emit an event to the other components present in the application
	 * @param {Object} data
	 */
	emitListener(data){
		let instance = this;
		instance.warning = false;
		instance.Listener.emit('LISTEN_DROPDOWN_EVENT', data);
	}
	
	/**
	 * Check the key code of the keyboard interactions
	 * @param {Object} e
	 */
	bindKeyCode(e){
		let instance = this;
		if(e.keyCode == 27) return instance.bindESCKey();
		if(e.keyCode == 13) return instance.bindENTERKey(instance.items[0]);
	}
	
	/**
	 * Leave of the dropdown search and
	 * hide the list of items
	 */
	bindESCKey(){
		let instance = this;
		instance.element.querySelector('.dropdown-input').blur();
		instance.shown = false;
	}
	
	/**
	 * Select the first item present in the sarch
	 * if the user didn't search any item
	 * select the first default item
	 */
	bindENTERKey(data){
		let instance = this;
		
		instance.setState({activeDropdownItem: data});
		instance.emitListener(data);
		instance.bindSelectedItemClass(data);
		instance.shown = false;
	}
	
	/**
	 * Change the selected item property
	 * to add the class selected in the component
	 * @param {Object} data
	 */
	bindSelectedItemClass(data){
		let instance = this;
		instance.cashItemsData.forEach(item => item.id == data.id ? item.selected = true : delete item.selected);
	}
}
__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Dropdown, __WEBPACK_IMPORTED_MODULE_4__Dropdown_soy_js__["a" /* default */]);

/**
 * Dropdown state definition
 */
Dropdown.STATE = {
	/**
	 * To show the dropdown items
	 */
	shown: {
		value: false
	},
	
	/**
	 * Active item selected in the dropdown
	 */
	activeDropdownItem: {
		value: false
	},
	
	/**
	 * List of items to the dropdown items list
	 */
	items: {
		value: __WEBPACK_IMPORTED_MODULE_5__DropdownUtils__["a" /* ITEMS_DATA */]
	},
	
	/**
	 * Message of warning of the calculator
	 */
	warning: {
		value: ''
	},
	
	/**
	 * Listener for the others components
	 */
	Listener: {
		value: new __WEBPACK_IMPORTED_MODULE_3__Utils_EventEmitter__["a" /* default */]()
	}
};


/* unused harmony default export */ var _unused_webpack_default_export = (Dropdown);


/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Dropdown */
/* unused harmony export templates */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
/* jshint ignore:start */


var templates;
goog.loadModule(function(exports) {

// This file was automatically generated from Dropdown.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Dropdown.
 * @public
 */

goog.module('Dropdown.incrementaldom');

/** @suppress {extraRequire} */
var soy = goog.require('soy');
/** @suppress {extraRequire} */
var soydata = goog.require('soydata');
/** @suppress {extraRequire} */
goog.require('goog.i18n.bidi');
/** @suppress {extraRequire} */
goog.require('goog.asserts');
var IncrementalDom = goog.require('incrementaldom');
var ie_open = IncrementalDom.elementOpen;
var ie_close = IncrementalDom.elementClose;
var ie_void = IncrementalDom.elementVoid;
var ie_open_start = IncrementalDom.elementOpenStart;
var ie_open_end = IncrementalDom.elementOpenEnd;
var itext = IncrementalDom.text;
var iattr = IncrementalDom.attr;


/**
 * @param {Object<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @param {Object<string, *>=} opt_ijData
 * @return {void}
 * @suppress {checkTypes}
 */
function $render(opt_data, opt_ignored, opt_ijData) {
  ie_open('div', null, null,
      'class', 'dropdown');
    ie_void('span', null, null,
        'class', 'arrow_box');
    ie_open('input', null, null,
        'type', 'text',
        'class', 'dropdown-display ' + (opt_data.warning ? 'input-error' : ''),
        'placeholder', opt_data.activeDropdownItem ? opt_data.activeDropdownItem.name : 'Select your plan',
        'readonly', 'true');
    ie_close('input');
    ie_open('span', null, null,
        'class', 'warning-label ' + (opt_data.warning ? 'show' : ''));
      itext((goog.asserts.assert((opt_data.warning) != null), opt_data.warning));
    ie_close('span');
    ie_open('div', null, null,
        'class', opt_data.shown ? 'dropdown-list-wrapper show' : 'dropdown-list-wrapper');
      ie_open('input', null, null,
          'type', 'text',
          'data-onKeydown', 'bindKeyCode',
          'data-onKeyup', 'searchItem',
          'placeholder', 'Type your search',
          'class', 'dropdown-input');
      ie_close('input');
      ie_open('ul', null, null,
          'class', 'dropdown-list');
        var itemList59 = opt_data.items;
        var itemListLen59 = itemList59.length;
        for (var itemIndex59 = 0; itemIndex59 < itemListLen59; itemIndex59++) {
          var itemData59 = itemList59[itemIndex59];
          ie_open('li', null, null,
              'class', 'dropdown-list-item',
              'data-selected', itemData59.selected,
              'data-id', itemData59.id,
              'data-onClick', 'changeActivePlan');
            itext((goog.asserts.assert((itemData59.name) != null), itemData59.name));
            itext(' (');
            itext((goog.asserts.assert((itemData59.months) != null), itemData59.months));
            itext(' meses)');
          ie_close('li');
        }
      ie_close('ul');
    ie_close('div');
  ie_close('div');
}
exports.render = $render;
if (goog.DEBUG) {
  $render.soyTemplateName = 'Dropdown.render';
}

exports.render.params = ["shown","items","activeDropdownItem","warning"];
exports.render.types = {"shown":"any","items":"any","activeDropdownItem":"any","warning":"any"};
templates = exports;
return exports;

});

class Dropdown extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Dropdown, templates);

/* harmony default export */ __webpack_exports__["a"] = (templates);
/* jshint ignore:end */


/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const ITEMS_DATA = [
	{id: 0, months: 12, interest:5, name: "Initial"},
	{id: 1, months: 24, interest:7, name: "Bronze"},
	{id: 2, months: 36, interest:9, name: "Gold"},
	{id: 3, months: 48, interest:15, name: "Sphere"}
];
/* harmony export (immutable) */ __webpack_exports__["a"] = ITEMS_DATA;



/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Calculator_soy_js__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__CalculatorUtils__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__ = __webpack_require__(16);








class Calculator extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {
	/**
		Calculator component
	 */
	created(){
		let instance = this;
		
		instance.labels.forEach(label => instance.setCalculatorButtonsEvents(label));
		instance.operators.forEach(operator => instance.setCalculatorButtonsEvents(operator));
		instance.Listener.on('LISTEN_CALCULATOR_ERROR', err => instance.warning = err);
	}
	
	/**
	 * Add events for all buttons in the calculator component
	 * located in CalculatorUtils
	 */
	setCalculatorButtonsEvents(button){
		let instance = this;
		
		if(button.isClearButton){
			button.clickFn = instance.delegateDeleteButton.bind(instance);
		}else if(button.isResultButtom){
			button.clickFn = instance.resultOfDisplayExpressions.bind(instance);
		}else {
			button.clickFn = instance.appendIntoDisplay.bind(instance);
		}
	}
	
	/**
	 * Remove digits in the calculator display
	 * to update labelDisplay
	 * and emit the listener to the others components
	 */
	delegateDeleteButton(){
		let instance = this;
		
		instance.labelDisplay = instance.removeLastDigit;
		instance.warning = false;
		instance.emitListener(instance.labelDisplay);
	}
	
	/**
	 * Append digits in the calculator display
	 */
	appendIntoDisplay(e){
		const text = e.target.dataset.text;
		
		let instance = this,labelDisplay = instance.labelDisplay,
				lastDigtOfLabelDisplay = labelDisplay[labelDisplay.length-1];
		
		if(instance.hasOperator(text) && instance.isLastDigitAnOperator(lastDigtOfLabelDisplay)){
			lastDigtOfLabelDisplay = '';
			instance.labelDisplay = instance.removeLastDigit;
		}
		
		if(instance.checkCalculatorExpressions(text, lastDigtOfLabelDisplay)){
			instance.labelDisplay += text;
		}

		instance.warning = false;
		return instance.emitListener(instance.labelDisplay);
	}
	
	/**
	 * Check if is not a digit or
	 * if is a digit, check if the digit
	 * comes after a number or an expression
	 */
	checkCalculatorExpressions(text, lastDigtOfLabelDisplay){
		let instance = this,labelDisplay = instance.labelDisplay;

		if((!instance.hasOperator(text)) ||
			(!instance.hasDoublePeriod(labelDisplay, text)) &&
			(!instance.isFirstDigitAnOperator(labelDisplay+text) &&
				instance.hasOperator(text) &&
				!instance.isLastDigitAnOperator(lastDigtOfLabelDisplay))) return true;
	}
	
	/**
	 *
	 */
	hasDoublePeriod(calculatorExpression, input){
		const numbers = calculatorExpression+input;
		const regex = /^([0-9])*\.([0-9])*\./;
		const lastNumber = numbers.split(/[+\-\/*]/);
		return regex.test(lastNumber[lastNumber.length-1]);
	}
	
	/**
	 * Emit event to the others components
	 */
	emitListener(data){
		return this.Listener.emit('LISTEN_CALCULATOR_EVENT', data);
	}
	
	/**
	 * Remove the calculator digits
	 */
	get removeLastDigit(){
		let textDisplay = this.labelDisplay;

		return textDisplay.substr(0, textDisplay.length - 1);
	}
	
	/**
	 * Process the result of the expressions in the calculator display
	 */
	resultOfDisplayExpressions(){
		let instance = this,
				textDisplay = instance.labelDisplay;
		
		if(!textDisplay) return;
		
		if(instance.isLastDigitAnOperator(textDisplay[textDisplay.length-1])){
			textDisplay = instance.removeLastDigit;
		}
		
		if(instance.hasDifferentNumberOfParentheses(textDisplay)) return instance.warning = "Unmatched parenthesis";
		
		try {
			instance.warning = false;
			instance.labelDisplay = Math.abs(new Function('', 'return '+textDisplay)()).toString();
			return instance.emitListener(instance.labelDisplay);
		}catch(e) {
			return instance.warning = "Please type a valid expression";
		}
	}
	
	/**
	 * Check if has different number of parentheses
	 * in the calculator display
	 */
	hasDifferentNumberOfParentheses(textDisplay){
		let instance = this,
				openParentheses = instance.countDigitOccurrences(textDisplay, '('),
				closedParentheses = instance.countDigitOccurrences(textDisplay, ')');
		
		if(openParentheses != closedParentheses) return true;
	}
	
	/**
	 * Count the number of occurrences of a determinate digit
	 */
	countDigitOccurrences(text, s1){
		return text.split(s1).length - 1;
	}
	
	/**
	 * Check if the last digit is an operator
	 */
	isLastDigitAnOperator(text){
		const regex = /[+-\/*.]$/;
		return regex.test(text);
	}
	
	/**
	 * Check if the first digit is an operator
	 */
	isFirstDigitAnOperator(text){
		const regex = /^[+-\/*.]/;
		return regex.test(text);
	}
	
	/**
	 * Check if has operator in the param
	 */
	hasOperator(text){
		const regex = /[+-\/*.]/;
		return regex.test(text);
	}
}

__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Calculator, __WEBPACK_IMPORTED_MODULE_2__Calculator_soy_js__["a" /* default */]);


/**
 * Alert Component definition.
 */
Calculator.STATE = {
	/**
	 * Array of labels that are calculator buttons
	 */
	labels: {
		value: __WEBPACK_IMPORTED_MODULE_3__CalculatorUtils__["a" /* labels */]
	},
	
	/**
	 * Message of warning of the calculator
	 */
	warning: {
		value: ''
	},
	
	/**
	 * Array of operators that are calculator buttons
	 */
	operators: {
		value: __WEBPACK_IMPORTED_MODULE_3__CalculatorUtils__["b" /* operators */]
	},
	
	/**
	 * Label where will stay the user numeric expression
	 */
	labelDisplay: {
		value: ''
	},
	
	/**
	 * Listener for the others components
	 */
	Listener: {
		value: new __WEBPACK_IMPORTED_MODULE_4__Utils_EventEmitter__["a" /* default */]()
	}
};

/* unused harmony default export */ var _unused_webpack_default_export = (Calculator);


/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Calculator */
/* unused harmony export templates */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
/* jshint ignore:start */


var templates;
goog.loadModule(function(exports) {

// This file was automatically generated from Calculator.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace Calculator.
 * @public
 */

goog.module('Calculator.incrementaldom');

/** @suppress {extraRequire} */
var soy = goog.require('soy');
/** @suppress {extraRequire} */
var soydata = goog.require('soydata');
/** @suppress {extraRequire} */
goog.require('goog.i18n.bidi');
/** @suppress {extraRequire} */
goog.require('goog.asserts');
var IncrementalDom = goog.require('incrementaldom');
var ie_open = IncrementalDom.elementOpen;
var ie_close = IncrementalDom.elementClose;
var ie_void = IncrementalDom.elementVoid;
var ie_open_start = IncrementalDom.elementOpenStart;
var ie_open_end = IncrementalDom.elementOpenEnd;
var itext = IncrementalDom.text;
var iattr = IncrementalDom.attr;

var $templateAlias1 = __WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.getTemplate('CalculatorButton.incrementaldom', 'render');


/**
 * @param {Object<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @param {Object<string, *>=} opt_ijData
 * @return {void}
 * @suppress {checkTypes}
 */
function $render(opt_data, opt_ignored, opt_ijData) {
  opt_data = opt_data || {};
  ie_open('div', null, null,
      'class', 'calculator');
    ie_open('section', null, null,
        'class', 'calculator-display ' + (opt_data.warning ? 'input-error' : ''),
        'id', 'calculator-display');
      itext((goog.asserts.assert((opt_data.labelDisplay) != null), opt_data.labelDisplay));
    ie_close('section');
    ie_open('div', null, null,
        'class', 'warning-label ' + (opt_data.warning ? 'show' : ''));
      itext((goog.asserts.assert((opt_data.warning) != null), opt_data.warning));
    ie_close('div');
    ie_open('section', null, null,
        'class', 'calculator-buttons-wrapper');
      ie_open('section', null, null,
          'class', 'calculator-digits');
        var labelList16 = opt_data.labels;
        var labelListLen16 = labelList16.length;
        for (var labelIndex16 = 0; labelIndex16 < labelListLen16; labelIndex16++) {
          var labelData16 = labelList16[labelIndex16];
          $templateAlias1({text: labelData16.text, click: labelData16.clickFn, buttonClass: labelData16.buttonClass}, null, opt_ijData);
        }
      ie_close('section');
      ie_open('section', null, null,
          'class', 'calculator-operators');
        var operatorList23 = opt_data.operators;
        var operatorListLen23 = operatorList23.length;
        for (var operatorIndex23 = 0; operatorIndex23 < operatorListLen23; operatorIndex23++) {
          var operatorData23 = operatorList23[operatorIndex23];
          $templateAlias1({text: operatorData23.text, click: operatorData23.clickFn, buttonClass: operatorData23.buttonClass}, null, opt_ijData);
        }
      ie_close('section');
    ie_close('section');
  ie_close('div');
}
exports.render = $render;
if (goog.DEBUG) {
  $render.soyTemplateName = 'Calculator.render';
}

exports.render.params = ["labels","labelDisplay","operators","warning"];
exports.render.types = {"labels":"any","labelDisplay":"any","operators":"any","warning":"any"};
templates = exports;
return exports;

});

class Calculator extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(Calculator, templates);

/* harmony default export */ __webpack_exports__["a"] = (templates);
/* jshint ignore:end */


/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const labels = [
	{text: '<', isClearButton: true},
	{text: '('},
	{text: ')'},
	{text: '1'},
	{text: '2'},
	{text: '3'},
	{text: '4'},
	{text: '5'},
	{text: '6'},
	{text: '7'},
	{text: '8'},
	{text: '9'},
	{text: '0', buttonClass: 'calculator-button--double-size'},
	{text: '.'}
];
/* harmony export (immutable) */ __webpack_exports__["a"] = labels;


const operators = [
	{text: '+'},
	{text: '-'},
	{text: '*'},
	{text: '/'},
	{text: '=', isResultButtom: true}
];
/* harmony export (immutable) */ __webpack_exports__["b"] = operators;



/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CalculatorButton_soy_js__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_metal_soy__);






class CalculatorButton extends __WEBPACK_IMPORTED_MODULE_1_metal_component___default.a {
}

__WEBPACK_IMPORTED_MODULE_2_metal_soy___default.a.register(CalculatorButton, __WEBPACK_IMPORTED_MODULE_0__CalculatorButton_soy_js__["a" /* default */]);

/**
 * CalculatorButton State Definition
 */
CalculatorButton.STATE = {
	/**
	 * Text present in button
	 */
	text: {
		value: ''
	},
	/**
	 * The action that the button will do
	 */
	click: {
		value: false
	}
};

/* unused harmony default export */ var _unused_webpack_default_export = (CalculatorButton);


/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CalculatorButton */
/* unused harmony export templates */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_metal_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_metal_component__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_metal_soy___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_metal_soy__);
/* jshint ignore:start */


var templates;
goog.loadModule(function(exports) {

// This file was automatically generated from CalculatorButton.soy.
// Please don't edit this file by hand.

/**
 * @fileoverview Templates in namespace CalculatorButton.
 * @public
 */

goog.module('CalculatorButton.incrementaldom');

/** @suppress {extraRequire} */
var soy = goog.require('soy');
/** @suppress {extraRequire} */
var soydata = goog.require('soydata');
/** @suppress {extraRequire} */
goog.require('goog.i18n.bidi');
/** @suppress {extraRequire} */
goog.require('goog.asserts');
var IncrementalDom = goog.require('incrementaldom');
var ie_open = IncrementalDom.elementOpen;
var ie_close = IncrementalDom.elementClose;
var ie_void = IncrementalDom.elementVoid;
var ie_open_start = IncrementalDom.elementOpenStart;
var ie_open_end = IncrementalDom.elementOpenEnd;
var itext = IncrementalDom.text;
var iattr = IncrementalDom.attr;


/**
 * @param {Object<string, *>=} opt_data
 * @param {(null|undefined)=} opt_ignored
 * @param {Object<string, *>=} opt_ijData
 * @return {void}
 * @suppress {checkTypes}
 */
function $render(opt_data, opt_ignored, opt_ijData) {
  ie_open('button', null, null,
      'data-text', opt_data.text,
      'class', '\t' + (opt_data.buttonClass ? opt_data.buttonClass : 'calculator-button'),
      'data-onClick', opt_data.click);
    itext((goog.asserts.assert((opt_data.text) != null), opt_data.text));
  ie_close('button');
}
exports.render = $render;
if (goog.DEBUG) {
  $render.soyTemplateName = 'CalculatorButton.render';
}

exports.render.params = ["buttonClass","text","click"];
exports.render.types = {"buttonClass":"any","text":"any","click":"any"};
templates = exports;
return exports;

});

class CalculatorButton extends __WEBPACK_IMPORTED_MODULE_0_metal_component___default.a {}
__WEBPACK_IMPORTED_MODULE_1_metal_soy___default.a.register(CalculatorButton, templates);

/* harmony default export */ __webpack_exports__["a"] = (templates);
/* jshint ignore:end */


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2E1OGVkZWEyZWJmZDFmOTY5ZTciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvYWxsL2NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L2xpYi9Tb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2FsbC9kb20uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9tZXRhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvbWV0YWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9kb21EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2luY3JlbWVudGFsLWRvbS1hb3AuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1V0aWxzL0V2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50SGFuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL0RvbUV2ZW50SGFuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2ZlYXR1cmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL0NvbXBvbmVudERhdGFNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9saWIvYWxsL3N0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9saWIvdmFsaWRhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL0NvbXBvbmVudFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL0luY3JlbWVudGFsRG9tUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvaW5jcmVtZW50YWwtZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2NoYW5nZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2hpbGRyZW4vY2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2FsbEFyZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL3JlbmRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9zY3NzL2FwcC5zY3NzPzFmZTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYXBwLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL01ldGFsRm9ybS9NZXRhbEZvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvTWV0YWxGb3JtL01ldGFsRm9ybS5zb3kuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvQ29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL3N5bmMvc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9kb21OYW1lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL2xpYi9FdmVudEVtaXR0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvRXZlbnRFbWl0dGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvRXZlbnRIYW5kbGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL0RvbUV2ZW50RW1pdHRlclByb3h5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2dsb2JhbEV2YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZ2xvYmFsRXZhbFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9Db25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9TdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9Db21wb25lbnRSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295LWJ1bmRsZS9saWIvYnVuZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vZGlzdC9pbmNyZW1lbnRhbC1kb20tY2pzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20tc3RyaW5nL2Rpc3QvaW5jcmVtZW50YWwtZG9tLXN0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9yZW5kZXIvcGF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL2F0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2xlYW51cC91bnVzZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlTmFtZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sMmluY2RvbS9saWIvd2l0aFBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL0hUTUxQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwyaW5jZG9tL2xpYi9IVE1MMkluY0RvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL3VuZXNjYXBlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbGliL1NveUFvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLnNveS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93blV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3IvQ2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DYWxjdWxhdG9yL0NhbGN1bGF0b3Iuc295LmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3IvQ2FsY3VsYXRvclV0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0NhbGN1bGF0b3JCdXR0b24vQ2FsY3VsYXRvckJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9DYWxjdWxhdG9yQnV0dG9uL0NhbGN1bGF0b3JCdXR0b24uc295LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM3REE7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEOzs7Ozs7O0FDekNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVE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Q0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsc0NBQXNDO0FBQzNELGNBQWM7QUFDZDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7Ozs7OztBQ2pUQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUEsNkJBQTZCLG1CQUFtQjs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxFQUFFLG9DQUFvQztBQUNuRDtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFlBQVk7QUFDeEIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCOztBQUVBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBLEVB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Q0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLEtBQUs7QUFDTDtB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0gsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUI7OztBQUdyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQy9OQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxtQkFBbUI7QUFDOUIsWUFBWTtBQUNaLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBLDJCQUEyQix5RkFBeUY7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBLDJCQUEyQixrR0FBa0c7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ1E7QUFDUjtBQUNBOzs7Ozs7OztBQy9GQTtBQUNBLEVBQUUsK0JBQStCO0FBQ2pDLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUsVUFBVTtBQUNaLEVBQUUseURBQXlEO0FBQzNELEVBQUU7QUFDRjtBQUFBO0FBQUE7O0FBRUE7QUFDQSxFQUFFLFVBQVU7QUFDWixFQUFFLFVBQVU7QUFDWixFQUFFLFVBQVU7QUFDWixFQUFFLFVBQVU7QUFDWixFQUFFO0FBQ0Y7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7O0FDdkJBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1osY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ1E7QUFDUjtBQUNBIiwiZmlsZSI6ImFwcGJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDM4KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzYTU4ZWRlYTJlYmZkMWY5NjllNyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ29tcG9uZW50UmVuZGVyZXIgPSBleHBvcnRzLkNvbXBvbmVudFJlZ2lzdHJ5ID0gZXhwb3J0cy5Db21wb25lbnREYXRhTWFuYWdlciA9IGV4cG9ydHMuQ29tcG9uZW50ID0gdW5kZWZpbmVkO1xuXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoJy4uL2V2ZW50cy9ldmVudHMnKTtcblxuT2JqZWN0LmtleXMoX2V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2V2ZW50c1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9Db21wb25lbnQgPSByZXF1aXJlKCcuLi9Db21wb25lbnQnKTtcblxudmFyIF9Db21wb25lbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tcG9uZW50KTtcblxudmFyIF9Db21wb25lbnREYXRhTWFuYWdlciA9IHJlcXVpcmUoJy4uL0NvbXBvbmVudERhdGFNYW5hZ2VyJyk7XG5cbnZhciBfQ29tcG9uZW50RGF0YU1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tcG9uZW50RGF0YU1hbmFnZXIpO1xuXG52YXIgX0NvbXBvbmVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vQ29tcG9uZW50UmVnaXN0cnknKTtcblxudmFyIF9Db21wb25lbnRSZWdpc3RyeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db21wb25lbnRSZWdpc3RyeSk7XG5cbnZhciBfQ29tcG9uZW50UmVuZGVyZXIgPSByZXF1aXJlKCcuLi9Db21wb25lbnRSZW5kZXJlcicpO1xuXG52YXIgX0NvbXBvbmVudFJlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbXBvbmVudFJlbmRlcmVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0NvbXBvbmVudDIuZGVmYXVsdDtcbmV4cG9ydHMuQ29tcG9uZW50ID0gX0NvbXBvbmVudDIuZGVmYXVsdDtcbmV4cG9ydHMuQ29tcG9uZW50RGF0YU1hbmFnZXIgPSBfQ29tcG9uZW50RGF0YU1hbmFnZXIyLmRlZmF1bHQ7XG5leHBvcnRzLkNvbXBvbmVudFJlZ2lzdHJ5ID0gX0NvbXBvbmVudFJlZ2lzdHJ5Mi5kZWZhdWx0O1xuZXhwb3J0cy5Db21wb25lbnRSZW5kZXJlciA9IF9Db21wb25lbnRSZW5kZXJlcjIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL2FsbC9jb21wb25lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52YWxpZGF0b3JzID0gZXhwb3J0cy5Tb3lBb3AgPSBleHBvcnRzLlNveSA9IGV4cG9ydHMuQ29uZmlnID0gdW5kZWZpbmVkO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnJlcXVpcmUoJ21ldGFsLXNveS1idW5kbGUnKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9tZXRhbFN0YXRlID0gcmVxdWlyZSgnbWV0YWwtc3RhdGUnKTtcblxudmFyIF9odG1sMmluY2RvbSA9IHJlcXVpcmUoJ2h0bWwyaW5jZG9tJyk7XG5cbnZhciBfaHRtbDJpbmNkb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaHRtbDJpbmNkb20pO1xuXG52YXIgX21ldGFsSW5jcmVtZW50YWxEb20gPSByZXF1aXJlKCdtZXRhbC1pbmNyZW1lbnRhbC1kb20nKTtcblxudmFyIF9tZXRhbEluY3JlbWVudGFsRG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ldGFsSW5jcmVtZW50YWxEb20pO1xuXG52YXIgX1NveUFvcCA9IHJlcXVpcmUoJy4vU295QW9wJyk7XG5cbnZhciBfU295QW9wMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1NveUFvcCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLy8gVGhlIGluamVjdGVkIGRhdGEgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBzb3kgdGVtcGxhdGVzLlxudmFyIGlqRGF0YSA9IHt9O1xuXG52YXIgU295ID0gZnVuY3Rpb24gKF9JbmNyZW1lbnRhbERvbVJlbmRlcikge1xuXHRfaW5oZXJpdHMoU295LCBfSW5jcmVtZW50YWxEb21SZW5kZXIpO1xuXG5cdGZ1bmN0aW9uIFNveSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgU295KTtcblxuXHRcdHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU295Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU295KSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoU295LCBbe1xuXHRcdGtleTogJ2dldEV4dHJhRGF0YUNvbmZpZycsXG5cblx0XHQvKipcbiAgICogQWRkcyB0aGUgdGVtcGxhdGUgcGFyYW1zIHRvIHRoZSBjb21wb25lbnQncyBzdGF0ZSwgaWYgdGhleSBkb24ndCBleGlzdCB5ZXQuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEV4dHJhRGF0YUNvbmZpZyhjb21wb25lbnQpIHtcblx0XHRcdHZhciBlbGVtZW50VGVtcGxhdGUgPSBjb21wb25lbnQuY29uc3RydWN0b3IuVEVNUExBVEU7XG5cdFx0XHRpZiAoISgwLCBfbWV0YWwuaXNGdW5jdGlvbikoZWxlbWVudFRlbXBsYXRlKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGVsZW1lbnRUZW1wbGF0ZSA9IF9Tb3lBb3AyLmRlZmF1bHQuZ2V0T3JpZ2luYWxGbihlbGVtZW50VGVtcGxhdGUpO1xuXHRcdFx0dGhpcy5zb3lQYXJhbVR5cGVzXyA9IGVsZW1lbnRUZW1wbGF0ZS50eXBlcyB8fCB7fTtcblxuXHRcdFx0dmFyIGtleXMgPSBlbGVtZW50VGVtcGxhdGUucGFyYW1zIHx8IFtdO1xuXHRcdFx0dmFyIGNvbmZpZ3MgPSB7fTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIWNvbXBvbmVudFtrZXlzW2ldXSkge1xuXHRcdFx0XHRcdGNvbmZpZ3Nba2V5c1tpXV0gPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbmZpZ3M7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvcGllcyB0aGUgY29tcG9uZW50J3Mgc3RhdGUgdG8gYW4gb2JqZWN0IHNvIGl0IGNhbiBiZSBwYXNzZWQgYXMgaXQnc1xuICAgKiB0ZW1wbGF0ZSBjYWxsJ3MgZGF0YS4gVGhlIGNvcHlpbmcgbmVlZHMgdG8gYmUgZG9uZSBiZWNhdXNlLCBpZiB0aGUgY29tcG9uZW50XG4gICAqIGl0c2VsZiBpcyBwYXNzZWQgZGlyZWN0bHksIHNvbWUgcHJvYmxlbXMgb2NjdXIgd2hlbiBzb3kgdHJpZXMgdG8gbWVyZ2UgaXRcbiAgICogd2l0aCBvdGhlciBkYXRhLCBkdWUgdG8gcHJvcGVydHkgZ2V0dGVycyBhbmQgc2V0dGVycy4gVGhpcyBpcyBzYWZlci5cbiAgICogQWxzbyBjYWxscyB0aGUgY29tcG9uZW50J3MgXCJwcmVwYXJlU3RhdGVGb3JSZW5kZXJcIiB0byBsZXQgaXQgY2hhbmdlIHRoZVxuICAgKiBkYXRhIHBhc3NlZCB0byB0aGUgdGVtcGxhdGUuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHBhcmFtcyBUaGUgcGFyYW1zIHVzZWQgYnkgdGhpcyB0ZW1wbGF0ZS5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYnVpbGRUZW1wbGF0ZURhdGFfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYnVpbGRUZW1wbGF0ZURhdGFfKGNvbXBvbmVudCwgcGFyYW1zKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0dmFyIGRhdGEgPSBfbWV0YWwub2JqZWN0Lm1peGluKHt9LCB0aGlzLmdldENvbmZpZyhjb21wb25lbnQpKTtcblx0XHRcdGNvbXBvbmVudC5nZXRTdGF0ZUtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gY29tcG9uZW50W2tleV07XG5cdFx0XHRcdGlmIChfdGhpczIuaXNIdG1sUGFyYW1fKGNvbXBvbmVudCwga2V5KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gc295UmVuZGVyZXJfLnRvSW5jRG9tKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0pO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIWRhdGFbcGFyYW1zW2ldXSAmJiAoMCwgX21ldGFsLmlzRnVuY3Rpb24pKGNvbXBvbmVudFtwYXJhbXNbaV1dKSkge1xuXHRcdFx0XHRcdGRhdGFbcGFyYW1zW2ldXSA9IGNvbXBvbmVudFtwYXJhbXNbaV1dLmJpbmQoY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShjb21wb25lbnQucHJlcGFyZVN0YXRlRm9yUmVuZGVyKSkge1xuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50LnByZXBhcmVTdGF0ZUZvclJlbmRlcihkYXRhKSB8fCBkYXRhO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIHJlcXVlc3RlZCB0ZW1wbGF0ZSBmdW5jdGlvbi4gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHdyYXBwZWQgaW5cbiAgICogYW5vdGhlciB0aG91Z2gsIGp1c3QgdG8gZGVmZXIgdGhlIHJlcXVpcmVtZW50IG9mIHRoZSB0ZW1wbGF0ZSdzIG1vZHVsZVxuICAgKiBiZWluZyByZWFkeSB1bnRpbCB0aGUgZnVuY3Rpb24gaXMgYWN0dWFsbHkgY2FsbGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZXNwYWNlIFRoZSBzb3kgdGVtcGxhdGUncyBuYW1lc3BhY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZW1wbGF0ZU5hbWUgVGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFRlbXBsYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0VGVtcGxhdGUobmFtZXNwYWNlLCB0ZW1wbGF0ZU5hbWUpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiAob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG5cdFx0XHRcdGlmICghZ29vZy5sb2FkZWRNb2R1bGVzX1tuYW1lc3BhY2VdKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdObyB0ZW1wbGF0ZSB3aXRoIG5hbWVzcGFjZSBcIicgKyBuYW1lc3BhY2UgKyAnXCIgaGFzIGJlZW4gbG9hZGVkIHlldC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZ29vZy5sb2FkZWRNb2R1bGVzX1tuYW1lc3BhY2VdW3RlbXBsYXRlTmFtZV0ob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJjZXB0ZWQgc295IHRlbXBsYXRlIGNhbGwuIElmIHRoZSBjYWxsIGlzIGZvciBhIGNvbXBvbmVudCdzXG4gICAqIG1haW4gdGVtcGxhdGUsIHRoZW4gaXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgY2FsbCB0aGF0IGluY3JlbWVudGFsIGRvbVxuICAgKiBjYW4gdXNlIGZvciBib3RoIGhhbmRsaW5nIGFuIGluc3RhbmNlIG9mIHRoYXQgY29tcG9uZW50IGFuZCByZW5kZXJpbmcgaXQuXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIHRlbXBsYXRlIGZ1bmN0aW9uIHRoYXQgd2FzXG4gICAqICAgICBpbnRlcmNlcHRlZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIGRhdGEgdGhlIHRlbXBsYXRlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlSW50ZXJjZXB0ZWRDYWxsXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUludGVyY2VwdGVkQ2FsbF8ob3JpZ2luYWxGbikge1xuXHRcdFx0dmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuXHRcdFx0dmFyIGFyZ3MgPSBbb3JpZ2luYWxGbi5jb21wb25lbnRDdG9yLCBudWxsLCBbXV07XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb3B0X2RhdGEpIHtcblx0XHRcdFx0YXJncy5wdXNoKGtleSwgb3B0X2RhdGFba2V5XSk7XG5cdFx0XHR9XG5cdFx0XHRJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZC5hcHBseShudWxsLCBhcmdzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBwYXJhbSB0eXBlIGlzIGh0bWwuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzSHRtbFBhcmFtXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzSHRtbFBhcmFtXyhjb21wb25lbnQsIG5hbWUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IGNvbXBvbmVudC5nZXREYXRhTWFuYWdlcigpLmdldFN0YXRlSW5zdGFuY2UoY29tcG9uZW50KTtcblx0XHRcdGlmIChzdGF0ZS5nZXRTdGF0ZUtleUNvbmZpZyhuYW1lKS5pc0h0bWwpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBlbGVtZW50VGVtcGxhdGUgPSBfU295QW9wMi5kZWZhdWx0LmdldE9yaWdpbmFsRm4oY29tcG9uZW50LmNvbnN0cnVjdG9yLlRFTVBMQVRFKTtcblx0XHRcdHZhciB0eXBlID0gKGVsZW1lbnRUZW1wbGF0ZS50eXBlcyB8fCB7fSlbbmFtZV0gfHwgJyc7XG5cdFx0XHRyZXR1cm4gdHlwZS5zcGxpdCgnfCcpLmluZGV4T2YoJ2h0bWwnKSAhPT0gLTE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gdGVtcGxhdGVzIHRvIGJlIHVzZWQgYnkgYFNveWAgZm9yIHRoZSBzcGVjaWZpZWRcbiAgICogY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY29tcG9uZW50Q3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGNvbXBvbmVudCB0aGF0XG4gICAqICAgICBzaG91bGQgdXNlIHRoZSBnaXZlbiB0ZW1wbGF0ZXMuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gdGVtcGxhdGVzIE9iamVjdCBjb250YWluaW5nIHNveSB0ZW1wbGF0ZSBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gbWFpblRlbXBsYXRlIFRoZSBuYW1lIG9mIHRoZSBtYWluIHRlbXBsYXRlIHRoYXQgc2hvdWxkIGJlXG4gICAqICAgICB1c2VkIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LiBEZWZhdWx0cyB0byBcInJlbmRlclwiLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVnaXN0ZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnRDdG9yLCB0ZW1wbGF0ZXMpIHtcblx0XHRcdHZhciBtYWluVGVtcGxhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdyZW5kZXInO1xuXG5cdFx0XHRjb21wb25lbnRDdG9yLlJFTkRFUkVSID0gc295UmVuZGVyZXJfO1xuXHRcdFx0Y29tcG9uZW50Q3Rvci5URU1QTEFURSA9IF9Tb3lBb3AyLmRlZmF1bHQuZ2V0T3JpZ2luYWxGbih0ZW1wbGF0ZXNbbWFpblRlbXBsYXRlXSk7XG5cdFx0XHRjb21wb25lbnRDdG9yLlRFTVBMQVRFLmNvbXBvbmVudEN0b3IgPSBjb21wb25lbnRDdG9yO1xuXHRcdFx0X1NveUFvcDIuZGVmYXVsdC5yZWdpc3RlckZvckludGVyY2VwdGlvbih0ZW1wbGF0ZXMsIG1haW5UZW1wbGF0ZSk7XG5cdFx0XHRfbWV0YWxDb21wb25lbnQuQ29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXIoY29tcG9uZW50Q3Rvcik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBtZXRob2QgZnJvbSBgSW5jcmVtZW50YWxEb21SZW5kZXJlcmAgc28gdGhlIGNvbXBvbmVudCdzXG4gICAqIHNveSB0ZW1wbGF0ZSBjYW4gYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0geyFPYmplY3R9IGRhdGEgRGF0YSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCB3aGVuIHJlbmRlcmluZyBpdC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJJbmNEb20nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbmNEb20oY29tcG9uZW50KSB7XG5cdFx0XHR2YXIgZWxlbWVudFRlbXBsYXRlID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLlRFTVBMQVRFO1xuXHRcdFx0aWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikoZWxlbWVudFRlbXBsYXRlKSAmJiAhY29tcG9uZW50LnJlbmRlcikge1xuXHRcdFx0XHRlbGVtZW50VGVtcGxhdGUgPSBfU295QW9wMi5kZWZhdWx0LmdldE9yaWdpbmFsRm4oZWxlbWVudFRlbXBsYXRlKTtcblx0XHRcdFx0X1NveUFvcDIuZGVmYXVsdC5zdGFydEludGVyY2VwdGlvbih0aGlzLmhhbmRsZUludGVyY2VwdGVkQ2FsbF8pO1xuXHRcdFx0XHR2YXIgZGF0YSA9IHRoaXMuYnVpbGRUZW1wbGF0ZURhdGFfKGNvbXBvbmVudCwgZWxlbWVudFRlbXBsYXRlLnBhcmFtcyB8fCBbXSk7XG5cdFx0XHRcdGVsZW1lbnRUZW1wbGF0ZShkYXRhLCBudWxsLCBpakRhdGEpO1xuXHRcdFx0XHRfU295QW9wMi5kZWZhdWx0LnN0b3BJbnRlcmNlcHRpb24oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9nZXQoU295LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNveS5wcm90b3R5cGUpLCAncmVuZGVySW5jRG9tJywgdGhpcykuY2FsbCh0aGlzLCBjb21wb25lbnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBpbmplY3RlZCBkYXRhIG9iamVjdCB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGVtcGxhdGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0SW5qZWN0ZWREYXRhJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0SW5qZWN0ZWREYXRhKGRhdGEpIHtcblx0XHRcdGlqRGF0YSA9IGRhdGEgfHwge307XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgb3JpZ2luYWwgYEluY3JlbWVudGFsRG9tUmVuZGVyZXJgIG1ldGhvZCBzbyB0aGF0IG9ubHlcbiAgICogc3RhdGUga2V5cyB1c2VkIGJ5IHRoZSBtYWluIHRlbXBsYXRlIGNhbiBjYXVzZSB1cGRhdGVzLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hvdWxkVXBkYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hvdWxkVXBkYXRlKGNvbXBvbmVudCwgY2hhbmdlcykge1xuXHRcdFx0dmFyIHNob3VsZCA9IF9nZXQoU295LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFNveS5wcm90b3R5cGUpLCAnc2hvdWxkVXBkYXRlJywgdGhpcykuY2FsbCh0aGlzLCBjb21wb25lbnQsIGNoYW5nZXMpO1xuXHRcdFx0aWYgKCFzaG91bGQgfHwgY29tcG9uZW50LnNob3VsZFVwZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gc2hvdWxkO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZm4gPSBjb21wb25lbnQuY29uc3RydWN0b3IuVEVNUExBVEU7XG5cdFx0XHR2YXIgcGFyYW1zID0gZm4gPyBfU295QW9wMi5kZWZhdWx0LmdldE9yaWdpbmFsRm4oZm4pLnBhcmFtcyA6IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGNoYW5nZXMucHJvcHNbcGFyYW1zW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gaW50byBhbiBodG1sIHN0cmluZy5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gaW5jRG9tRm5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndG9IdG1sU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9IdG1sU3RyaW5nKGluY0RvbUZuKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0SW5jcmVtZW50YWxET00ucGF0Y2goZWxlbWVudCwgaW5jRG9tRm4pO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcgaW50byBhbiBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfHtjb250ZW50S2luZDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmd9fSB2YWx1ZVxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3RvSW5jRG9tJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdG9JbmNEb20odmFsdWUpIHtcblx0XHRcdGlmICgoMCwgX21ldGFsLmlzT2JqZWN0KSh2YWx1ZSkgJiYgKDAsIF9tZXRhbC5pc1N0cmluZykodmFsdWUuY29udGVudCkgJiYgdmFsdWUuY29udGVudEtpbmQgPT09ICdIVE1MJykge1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykodmFsdWUpKSB7XG5cdFx0XHRcdHZhbHVlID0gX2h0bWwyaW5jZG9tMi5kZWZhdWx0LmJ1aWxkRm4odmFsdWUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTb3k7XG59KF9tZXRhbEluY3JlbWVudGFsRG9tMi5kZWZhdWx0LmNvbnN0cnVjdG9yKTtcblxudmFyIHNveVJlbmRlcmVyXyA9IG5ldyBTb3koKTtcbnNveVJlbmRlcmVyXy5SRU5ERVJFUl9OQU1FID0gJ3NveSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHNveVJlbmRlcmVyXztcbmV4cG9ydHMuQ29uZmlnID0gX21ldGFsU3RhdGUuQ29uZmlnO1xuZXhwb3J0cy5Tb3kgPSBzb3lSZW5kZXJlcl87XG5leHBvcnRzLlNveUFvcCA9IF9Tb3lBb3AyLmRlZmF1bHQ7XG5leHBvcnRzLnZhbGlkYXRvcnMgPSBfbWV0YWxTdGF0ZS52YWxpZGF0b3JzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9saWIvU295LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZG9tID0gdW5kZWZpbmVkO1xuXG52YXIgX2RvbU5hbWVkID0gcmVxdWlyZSgnLi9kb21OYW1lZCcpO1xuXG5PYmplY3Qua2V5cyhfZG9tTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9kb21OYW1lZFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIGRvbSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9kb21OYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRvbTtcbmV4cG9ydHMuZG9tID0gZG9tO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2xvYmFsRXZhbFN0eWxlcyA9IGV4cG9ydHMuZ2xvYmFsRXZhbCA9IGV4cG9ydHMuZmVhdHVyZXMgPSBleHBvcnRzLkRvbUV2ZW50SGFuZGxlID0gZXhwb3J0cy5Eb21FdmVudEVtaXR0ZXJQcm94eSA9IGV4cG9ydHMuZG9tRGF0YSA9IHVuZGVmaW5lZDtcblxudmFyIF9kb20gPSByZXF1aXJlKCcuLi9kb20nKTtcblxuT2JqZWN0LmtleXMoX2RvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2RvbVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9kb20yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tKTtcblxudmFyIF9kb21EYXRhID0gcmVxdWlyZSgnLi4vZG9tRGF0YScpO1xuXG52YXIgX2RvbURhdGEyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZG9tRGF0YSk7XG5cbnZhciBfRG9tRXZlbnRFbWl0dGVyUHJveHkgPSByZXF1aXJlKCcuLi9Eb21FdmVudEVtaXR0ZXJQcm94eScpO1xuXG52YXIgX0RvbUV2ZW50RW1pdHRlclByb3h5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvbUV2ZW50RW1pdHRlclByb3h5KTtcblxudmFyIF9Eb21FdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4uL0RvbUV2ZW50SGFuZGxlJyk7XG5cbnZhciBfRG9tRXZlbnRIYW5kbGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRG9tRXZlbnRIYW5kbGUpO1xuXG52YXIgX2ZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMnKTtcblxudmFyIF9mZWF0dXJlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mZWF0dXJlcyk7XG5cbnZhciBfZ2xvYmFsRXZhbCA9IHJlcXVpcmUoJy4uL2dsb2JhbEV2YWwnKTtcblxudmFyIF9nbG9iYWxFdmFsMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dsb2JhbEV2YWwpO1xuXG52YXIgX2dsb2JhbEV2YWxTdHlsZXMgPSByZXF1aXJlKCcuLi9nbG9iYWxFdmFsU3R5bGVzJyk7XG5cbnZhciBfZ2xvYmFsRXZhbFN0eWxlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nbG9iYWxFdmFsU3R5bGVzKTtcblxucmVxdWlyZSgnLi4vZXZlbnRzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZG9tRGF0YSA9IF9kb21EYXRhMi5kZWZhdWx0O1xuZXhwb3J0cy5Eb21FdmVudEVtaXR0ZXJQcm94eSA9IF9Eb21FdmVudEVtaXR0ZXJQcm94eTIuZGVmYXVsdDtcbmV4cG9ydHMuRG9tRXZlbnRIYW5kbGUgPSBfRG9tRXZlbnRIYW5kbGUyLmRlZmF1bHQ7XG5leHBvcnRzLmZlYXR1cmVzID0gX2ZlYXR1cmVzMi5kZWZhdWx0O1xuZXhwb3J0cy5nbG9iYWxFdmFsID0gX2dsb2JhbEV2YWwyLmRlZmF1bHQ7XG5leHBvcnRzLmdsb2JhbEV2YWxTdHlsZXMgPSBfZ2xvYmFsRXZhbFN0eWxlczIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kb20yLmRlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9hbGwvZG9tLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRXZlbnRIYW5kbGVyID0gZXhwb3J0cy5FdmVudEhhbmRsZSA9IGV4cG9ydHMuRXZlbnRFbWl0dGVyUHJveHkgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IHVuZGVmaW5lZDtcblxudmFyIF9FdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL0V2ZW50RW1pdHRlcicpO1xuXG52YXIgX0V2ZW50RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEVtaXR0ZXIpO1xuXG52YXIgX0V2ZW50RW1pdHRlclByb3h5ID0gcmVxdWlyZSgnLi9FdmVudEVtaXR0ZXJQcm94eScpO1xuXG52YXIgX0V2ZW50RW1pdHRlclByb3h5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0V2ZW50RW1pdHRlclByb3h5KTtcblxudmFyIF9FdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4vRXZlbnRIYW5kbGUnKTtcblxudmFyIF9FdmVudEhhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEhhbmRsZSk7XG5cbnZhciBfRXZlbnRIYW5kbGVyID0gcmVxdWlyZSgnLi9FdmVudEhhbmRsZXInKTtcblxudmFyIF9FdmVudEhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRXZlbnRIYW5kbGVyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0V2ZW50RW1pdHRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gX0V2ZW50RW1pdHRlcjIuZGVmYXVsdDtcbmV4cG9ydHMuRXZlbnRFbWl0dGVyUHJveHkgPSBfRXZlbnRFbWl0dGVyUHJveHkyLmRlZmF1bHQ7XG5leHBvcnRzLkV2ZW50SGFuZGxlID0gX0V2ZW50SGFuZGxlMi5kZWZhdWx0O1xuZXhwb3J0cy5FdmVudEhhbmRsZXIgPSBfRXZlbnRIYW5kbGVyMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xlYXJEYXRhID0gY2xlYXJEYXRhO1xuZXhwb3J0cy5nZXREYXRhID0gZ2V0RGF0YTtcbnZhciBSRU5ERVJFUl9EQVRBID0gJ19fTUVUQUxfSUNfUkVOREVSRVJfREFUQV9fJztcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBpbmNyZW1lbnRhbCBkb20gcmVuZGVyZXIgZGF0YSBvYmplY3QgZm9yIHRoaXMgY29tcG9uZW50LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gY2xlYXJEYXRhKGNvbXBvbmVudCkge1xuICBjb21wb25lbnRbUkVOREVSRVJfREFUQV0gPSBudWxsO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluY3JlbWVudGFsIGRvbSByZW5kZXJlciBkYXRhIG9iamVjdCBmb3IgdGhpcyBjb21wb25lbnQsIGNyZWF0aW5nXG4gKiBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXREYXRhKGNvbXBvbmVudCkge1xuICBpZiAoIWNvbXBvbmVudFtSRU5ERVJFUl9EQVRBXSkge1xuICAgIGNvbXBvbmVudFtSRU5ERVJFUl9EQVRBXSA9IHt9O1xuICB9XG4gIHJldHVybiBjb21wb25lbnRbUkVOREVSRVJfREFUQV07XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9kYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0cmluZyA9IGV4cG9ydHMub2JqZWN0ID0gZXhwb3J0cy5EaXNwb3NhYmxlID0gZXhwb3J0cy5hc3luYyA9IGV4cG9ydHMuYXJyYXkgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG5PYmplY3Qua2V5cyhfY29yZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hcnJheSA9IHJlcXVpcmUoJy4vYXJyYXkvYXJyYXknKTtcblxudmFyIF9hcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jL2FzeW5jJyk7XG5cbnZhciBfYXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmMpO1xuXG52YXIgX0Rpc3Bvc2FibGUgPSByZXF1aXJlKCcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZScpO1xuXG52YXIgX0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlzcG9zYWJsZSk7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3Qvb2JqZWN0Jyk7XG5cbnZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG5cbnZhciBfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcvc3RyaW5nJyk7XG5cbnZhciBfc3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuYXJyYXkgPSBfYXJyYXkyLmRlZmF1bHQ7XG5leHBvcnRzLmFzeW5jID0gX2FzeW5jMi5kZWZhdWx0O1xuZXhwb3J0cy5EaXNwb3NhYmxlID0gX0Rpc3Bvc2FibGUyLmRlZmF1bHQ7XG5leHBvcnRzLm9iamVjdCA9IF9vYmplY3QyLmRlZmF1bHQ7XG5leHBvcnRzLnN0cmluZyA9IF9zdHJpbmcyLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSBfY29yZTIuZGVmYXVsdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9tZXRhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBNRVRBTF9EQVRBID0gJ19fbWV0YWxfZGF0YV9fJztcblxudmFyIGRvbURhdGEgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGRvbURhdGEoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGRvbURhdGEpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGRvbURhdGEsIG51bGwsIFt7XG5cdFx0a2V5OiAnZ2V0JyxcblxuXHRcdC8qKlxuICAgKiBHZXRzIE1ldGFsLmpzJ3MgZGF0YSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbmFtZSBPcHRpb25hbCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHRvIGJlIHJldHVybmVkLlxuICAgKiBAcGFyYW0geyp9IG9wdF9pbml0aWFsVmFsIE9wdGluYWwgdmFsdWUgdG8gdGhlIHNldCB0aGUgcmVxdWVzdGVkIHByb3BlcnR5XG4gICAqICAgICB0byBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCBpbiB0aGUgZGF0YS5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldChlbGVtZW50LCBvcHRfbmFtZSwgb3B0X2luaXRpYWxWYWwpIHtcblx0XHRcdGlmICghZWxlbWVudFtNRVRBTF9EQVRBXSkge1xuXHRcdFx0XHRlbGVtZW50W01FVEFMX0RBVEFdID0ge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoIW9wdF9uYW1lKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtZW50W01FVEFMX0RBVEFdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFlbGVtZW50W01FVEFMX0RBVEFdW29wdF9uYW1lXSAmJiBvcHRfaW5pdGlhbFZhbCkge1xuXHRcdFx0XHRlbGVtZW50W01FVEFMX0RBVEFdW29wdF9uYW1lXSA9IG9wdF9pbml0aWFsVmFsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnRbTUVUQUxfREFUQV1bb3B0X25hbWVdO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIGRhdGEgc3RvcmVkIGluIGl0LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXMoZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuICEhZWxlbWVudFtNRVRBTF9EQVRBXTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gZG9tRGF0YTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZG9tRGF0YTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2RvbURhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvbWV0YWwuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0T3JpZ2luYWxGbnMgPSBnZXRPcmlnaW5hbEZucztcbmV4cG9ydHMuZ2V0T3JpZ2luYWxGbiA9IGdldE9yaWdpbmFsRm47XG5leHBvcnRzLnN0YXJ0SW50ZXJjZXB0aW9uID0gc3RhcnRJbnRlcmNlcHRpb247XG5leHBvcnRzLnN0b3BJbnRlcmNlcHRpb24gPSBzdG9wSW50ZXJjZXB0aW9uO1xuXG5yZXF1aXJlKCcuL2luY3JlbWVudGFsLWRvbScpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb25zLlxuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0T3JpZ2luYWxGbnMoKSB7XG5cdHJldHVybiBvcmlnaW5hbEZucztcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBvcmlnaW5hbCBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPcmlnaW5hbEZuKG5hbWUpIHtcblx0cmV0dXJuIG9yaWdpbmFsRm5zW25hbWVdO1xufVxuXG4vKipcbiAqIFN0YXJ0cyBpbnRlcmNlcHRpbmcgY2FsbHMgdG8gaW5jcmVtZW50YWwgZG9tLCByZXBsYWNpbmcgdGhlbSB3aXRoIHRoZSBnaXZlblxuICogZnVuY3Rpb25zLiBOb3RlIHRoYXQgYGVsZW1lbnRWb2lkYCwgYGVsZW1lbnRPcGVuU3RhcnRgLCBgZWxlbWVudE9wZW5FbmRgXG4gKiBhbmQgYGF0dHJgIGFyZSB0aGUgb25seSBvbmVzIHRoYXQgY2FuJ3QgYmUgaW50ZXJjZXB0ZWQsIHNpbmNlIHRoZXknbGxcbiAqIGF1dG9tYXRpY2FsbHkgYmUgY29udmVydGVkIGludG8gZXF1aXZhbGVudCBjYWxscyB0byBgZWxlbWVudE9wZW5gIGFuZFxuICogYGVsZW1lbnRDbG9zZWAuXG4gKiBAcGFyYW0geyFPYmplY3R9IGZucyBGdW5jdGlvbnMgdG8gYmUgY2FsbGVkIGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIG9uZXNcbiAqICAgICBmcm9tIGluY3JlbWVudGFsIERPTS4gU2hvdWxkIGJlIGdpdmVuIGFzIGEgbWFwIGZyb20gdGhlIGZ1bmN0aW9uIG5hbWVcbiAqICAgICB0byB0aGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgaW50ZXJjZXB0IGl0LiBBbGwgaW50ZXJjZXB0b3JzIHdpbGwgcmVjZWl2ZVxuICogICAgIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQsIHRoZSBhY3R1YWwgYXJndW1lbnRzIGZyb21cbiAqICAgICBmcm9tIHRoZSBvcmlnaW5hbCBjYWxsIGZvbGxvd2luZyBpdC5cbiAqL1xuZnVuY3Rpb24gc3RhcnRJbnRlcmNlcHRpb24oZm5zKSB7XG5cdGZucy5hdHRyID0gZm5BdHRyO1xuXHRmbnMuZWxlbWVudE9wZW5FbmQgPSBmbk9wZW5FbmQ7XG5cdGZucy5lbGVtZW50T3BlblN0YXJ0ID0gZm5PcGVuU3RhcnQ7XG5cdGZucy5lbGVtZW50Vm9pZCA9IGZuVm9pZDtcblx0Zm5TdGFjay5wdXNoKGZucyk7XG59XG5cbi8qKlxuICogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbCBkb20gdG8gdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBpdCB1c2VkIGJlZm9yZSB0aGUgbGFzdCBjYWxsIHRvIGBzdGFydEludGVyY2VwdGlvbmAuXG4gKi9cbmZ1bmN0aW9uIHN0b3BJbnRlcmNlcHRpb24oKSB7XG5cdGZuU3RhY2sucG9wKCk7XG59XG5cbnZhciBvcmlnaW5hbEZucyA9IHtcblx0YXR0cjogSW5jcmVtZW50YWxET00uYXR0cixcblx0YXR0cmlidXRlczogSW5jcmVtZW50YWxET00uYXR0cmlidXRlc1tJbmNyZW1lbnRhbERPTS5zeW1ib2xzLmRlZmF1bHRdLFxuXHRlbGVtZW50Q2xvc2U6IEluY3JlbWVudGFsRE9NLmVsZW1lbnRDbG9zZSxcblx0ZWxlbWVudE9wZW46IEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuLFxuXHRlbGVtZW50T3BlbkVuZDogSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW5FbmQsXG5cdGVsZW1lbnRPcGVuU3RhcnQ6IEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuU3RhcnQsXG5cdGVsZW1lbnRWb2lkOiBJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZCxcblx0dGV4dDogSW5jcmVtZW50YWxET00udGV4dFxufTtcblxudmFyIGZuU3RhY2sgPSBbXTtcblxudmFyIGNvbGxlY3RlZEFyZ3MgPSBbXTtcblxuZnVuY3Rpb24gZm5BdHRyKG5hbWUsIHZhbHVlKSB7XG5cdGNvbGxlY3RlZEFyZ3MucHVzaChuYW1lLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZuT3BlblN0YXJ0KHRhZywga2V5LCBzdGF0aWNzKSB7XG5cdGNvbGxlY3RlZEFyZ3MgPSBbdGFnLCBrZXksIHN0YXRpY3NdO1xufVxuXG5mdW5jdGlvbiBmbk9wZW5FbmQoKSB7XG5cdHZhciBfSW5jcmVtZW50YWxET007XG5cblx0cmV0dXJuIChfSW5jcmVtZW50YWxET00gPSBJbmNyZW1lbnRhbERPTSkuZWxlbWVudE9wZW4uYXBwbHkoX0luY3JlbWVudGFsRE9NLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sbGVjdGVkQXJncykpO1xufVxuXG5mdW5jdGlvbiBmblZvaWQoKSB7XG5cdEluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdHJldHVybiBJbmNyZW1lbnRhbERPTS5lbGVtZW50Q2xvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2soKSB7XG5cdHJldHVybiBmblN0YWNrLmxlbmd0aCA+IDAgPyBmblN0YWNrW2ZuU3RhY2subGVuZ3RoIC0gMV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBidWlsZEhhbmRsZUNhbGwobmFtZSkge1xuXHR2YXIgZGF0YSA9IHtcblx0XHRuYW1lOiBuYW1lXG5cdH07XG5cdHZhciBmbiA9IGhhbmRsZUNhbGwuYmluZChkYXRhKTtcblx0cmV0dXJuIGZuO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDYWxsKCkge1xuXHR2YXIgbmFtZSA9IHRoaXMubmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHR2YXIgc3RhY2sgPSBnZXRTdGFjaygpO1xuXHR2YXIgZm4gPSBzdGFjayAmJiBzdGFja1tuYW1lXSB8fCBvcmlnaW5hbEZuc1tuYW1lXTtcblx0cmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbkluY3JlbWVudGFsRE9NLmF0dHIgPSBidWlsZEhhbmRsZUNhbGwoJ2F0dHInKTtcbkluY3JlbWVudGFsRE9NLmVsZW1lbnRDbG9zZSA9IGJ1aWxkSGFuZGxlQ2FsbCgnZWxlbWVudENsb3NlJyk7XG5JbmNyZW1lbnRhbERPTS5lbGVtZW50T3BlbiA9IGJ1aWxkSGFuZGxlQ2FsbCgnZWxlbWVudE9wZW4nKTtcbkluY3JlbWVudGFsRE9NLmVsZW1lbnRPcGVuRW5kID0gYnVpbGRIYW5kbGVDYWxsKCdlbGVtZW50T3BlbkVuZCcpO1xuSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW5TdGFydCA9IGJ1aWxkSGFuZGxlQ2FsbCgnZWxlbWVudE9wZW5TdGFydCcpO1xuSW5jcmVtZW50YWxET00uZWxlbWVudFZvaWQgPSBidWlsZEhhbmRsZUNhbGwoJ2VsZW1lbnRWb2lkJyk7XG5JbmNyZW1lbnRhbERPTS50ZXh0ID0gYnVpbGRIYW5kbGVDYWxsKCd0ZXh0Jyk7XG5cbkluY3JlbWVudGFsRE9NLmF0dHJpYnV0ZXNbSW5jcmVtZW50YWxET00uc3ltYm9scy5kZWZhdWx0XSA9IGJ1aWxkSGFuZGxlQ2FsbCgnYXR0cmlidXRlcycpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvaW5jcmVtZW50YWwtZG9tLWFvcC5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEV2ZW50cyBmcm9tICdldmVudHMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRze1xuXHRjb25zdHJ1Y3Rvcigpe1xuXHRcdHN1cGVyKCk7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL1V0aWxzL0V2ZW50RW1pdHRlci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRMaXN0ZW5lcnNGcm9tT2JqID0gYWRkTGlzdGVuZXJzRnJvbU9iajtcbmV4cG9ydHMuZ2V0Q29tcG9uZW50Rm4gPSBnZXRDb21wb25lbnRGbjtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbi8qKlxuICogQWRkcyB0aGUgbGlzdGVuZXJzIHNwZWNpZmllZCBpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudHNcbiAqIEByZXR1cm4geyFBcnJheTwhRXZlbnRIYW5kbGU+fSBIYW5kbGVzIGZyb20gYWxsIHN1YnNjcmliZWQgZXZlbnRzLlxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcnNGcm9tT2JqKGNvbXBvbmVudCwgZXZlbnRzKSB7XG5cdHZhciBldmVudE5hbWVzID0gT2JqZWN0LmtleXMoZXZlbnRzIHx8IHt9KTtcblx0dmFyIGhhbmRsZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGluZm8gPSBleHRyYWN0TGlzdGVuZXJJbmZvXyhjb21wb25lbnQsIGV2ZW50c1tldmVudE5hbWVzW2ldXSk7XG5cdFx0aWYgKGluZm8uZm4pIHtcblx0XHRcdHZhciBoYW5kbGUgPSB2b2lkIDA7XG5cdFx0XHRpZiAoaW5mby5zZWxlY3Rvcikge1xuXHRcdFx0XHRoYW5kbGUgPSBjb21wb25lbnQuZGVsZWdhdGUoZXZlbnROYW1lc1tpXSwgaW5mby5zZWxlY3RvciwgaW5mby5mbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGUgPSBjb21wb25lbnQub24oZXZlbnROYW1lc1tpXSwgaW5mby5mbik7XG5cdFx0XHR9XG5cdFx0XHRoYW5kbGVzLnB1c2goaGFuZGxlKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGhhbmRsZXM7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgbGlzdGVuZXIgaW5mbyBmcm9tIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtmdW5jdGlvbigpfHN0cmluZ3x7c2VsZWN0b3I6c3RyaW5nLGZuOmZ1bmN0aW9uKCl8c3RyaW5nfX0gdmFsdWVcbiAqIEByZXR1cm4geyF7c2VsZWN0b3I6c3RyaW5nLGZuOmZ1bmN0aW9uKCl9fVxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBleHRyYWN0TGlzdGVuZXJJbmZvXyhjb21wb25lbnQsIHZhbHVlKSB7XG5cdHZhciBpbmZvID0ge1xuXHRcdGZuOiB2YWx1ZVxuXHR9O1xuXHRpZiAoKDAsIF9tZXRhbC5pc09iamVjdCkodmFsdWUpICYmICEoMCwgX21ldGFsLmlzRnVuY3Rpb24pKHZhbHVlKSkge1xuXHRcdGluZm8uc2VsZWN0b3IgPSB2YWx1ZS5zZWxlY3Rvcjtcblx0XHRpbmZvLmZuID0gdmFsdWUuZm47XG5cdH1cblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKGluZm8uZm4pKSB7XG5cdFx0aW5mby5mbiA9IGdldENvbXBvbmVudEZuKGNvbXBvbmVudCwgaW5mby5mbik7XG5cdH1cblx0cmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gZnJvbSBpdHMgbmFtZS4gVGhyb3dzIGFuIGVycm9yIGlmIG5vbmUgZXhpc3QuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGZuTmFtZVxuICogQHJldHVybiB7ZnVuY3Rpb24oKX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50Rm4oY29tcG9uZW50LCBmbk5hbWUpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNGdW5jdGlvbikoY29tcG9uZW50W2ZuTmFtZV0pKSB7XG5cdFx0cmV0dXJuIGNvbXBvbmVudFtmbk5hbWVdLmJpbmQoY29tcG9uZW50KTtcblx0fSBlbHNlIHtcblx0XHRjb25zb2xlLmVycm9yKCdObyBmdW5jdGlvbiBuYW1lZCAnICsgZm5OYW1lICsgJyB3YXMgZm91bmQgaW4gdGhlIGNvbXBvbmVudFxcblxcdFxcdFxcdFwiJyArICgwLCBfbWV0YWwuZ2V0RnVuY3Rpb25OYW1lKShjb21wb25lbnQuY29uc3RydWN0b3IpICsgJ1wiLiBNYWtlIHN1cmUgdGhhdCB5b3Ugc3BlY2lmeVxcblxcdFxcdFxcdHZhbGlkIGZ1bmN0aW9uIG5hbWVzIHdoZW4gYWRkaW5nIGlubGluZSBsaXN0ZW5lcnMnKTtcblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlTmFtZWQgPSByZXF1aXJlKCcuL2NvcmVOYW1lZCcpO1xuXG5PYmplY3Qua2V5cyhfY29yZU5hbWVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZU5hbWVkW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlTmFtZWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuZXhwb3J0cy5jb3JlID0gY29yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBleGlzdHMganVzdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIG1ha2luZyBzdXJlIHRoYXQgb2xkXG4vLyBkZWZhdWx0IGltcG9ydHMgZm9yIHRoaXMgZmlsZSBzdGlsbCB3b3JrLiBJdCdzIGJlc3QgdG8gdXNlIHRoZSBuYW1lZCBleHBvcnRzXG4vLyBmb3IgZWFjaCBmdW5jdGlvbiBpbnN0ZWFkIHRob3VnaCwgc2luY2UgdGhhdCBhbGxvd3MgYnVuZGxlcnMgbGlrZSBSb2xsdXAgdG9cbi8vIHJlZHVjZSB0aGUgYnVuZGxlIHNpemUgYnkgcmVtb3ZpbmcgdW51c2VkIGNvZGUuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNvcmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfY29yZU5hbWVkID0gcmVxdWlyZSgnLi9jb3JlTmFtZWQnKTtcblxuT2JqZWN0LmtleXMoX2NvcmVOYW1lZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2NvcmVOYW1lZFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIGNvcmUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfY29yZU5hbWVkKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqKSB7IGlmIChvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBlbHNlIHsgdmFyIG5ld09iaiA9IHt9OyBpZiAob2JqICE9IG51bGwpIHsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IG5ld09iai5kZWZhdWx0ID0gb2JqOyByZXR1cm4gbmV3T2JqOyB9IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY29yZTtcbmV4cG9ydHMuY29yZSA9IGNvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIEV2ZW50SGFuZGxlIHV0aWxpdHkuIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGFuIGV2ZW50IHN1YnNjcmlwdGlvbiwgYW5kXG4gKiBhbGxvd3MgcmVtb3ZpbmcgdGhlbSBlYXNpbHkuXG4gKiBFdmVudEhhbmRsZSBpcyBhIERpc3Bvc2FibGUsIGJ1dCBpdCdzIGltcG9ydGFudCB0byBub3RlIHRoYXQgdGhlXG4gKiBFdmVudEVtaXR0ZXIgdGhhdCBjcmVhdGVkIGl0IGlzIG5vdCB0aGUgb25lIHJlc3BvbnNpYmxlIGZvciBkaXNwb3NpbmcgaXQuXG4gKiBUaGF0IHJlc3BvbnNpYmlsaXR5IGlzIGZvciB0aGUgY29kZSB0aGF0IGhvbGRzIGEgcmVmZXJlbmNlIHRvIGl0LlxuICogQHBhcmFtIHshRXZlbnRFbWl0dGVyfSBlbWl0dGVyIEVtaXR0ZXIgdGhlIGV2ZW50IHdhcyBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBuYW1lIG9mIHRoZSBldmVudCB0aGF0IHdhcyBzdWJzY3JpYmVkIHRvLlxuICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciBzdWJzY3JpYmVkIHRvIHRoZSBldmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Rpc3Bvc2FibGV9XG4gKi9cbnZhciBFdmVudEhhbmRsZSA9IGZ1bmN0aW9uIChfRGlzcG9zYWJsZSkge1xuXHRfaW5oZXJpdHMoRXZlbnRIYW5kbGUsIF9EaXNwb3NhYmxlKTtcblxuXHRmdW5jdGlvbiBFdmVudEhhbmRsZShlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRIYW5kbGUpO1xuXG5cdFx0LyoqXG4gICAqIFRoZSBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdGhhdCB0aGUgZXZlbnQgd2FzIHN1YnNjcmliZWQgdG8uXG4gICAqIEB0eXBlIHtFdmVudEVtaXR0ZXJ9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEV2ZW50SGFuZGxlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRXZlbnRIYW5kbGUpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmVtaXR0ZXJfID0gZW1pdHRlcjtcblxuXHRcdC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCB3YXMgc3Vic2NyaWJlZCB0by5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5ldmVudF8gPSBldmVudDtcblxuXHRcdC8qKlxuICAgKiBUaGUgbGlzdGVuZXIgc3Vic2NyaWJlZCB0byB0aGUgZXZlbnQuXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5saXN0ZW5lcl8gPSBsaXN0ZW5lcjtcblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuXG4gICogQG92ZXJyaWRlXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRXZlbnRIYW5kbGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge1xuXHRcdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdFx0dGhpcy5lbWl0dGVyXyA9IG51bGw7XG5cdFx0XHR0aGlzLmxpc3RlbmVyXyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBlbWl0dGVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlTGlzdGVuZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcblx0XHRcdGlmICghdGhpcy5lbWl0dGVyXy5pc0Rpc3Bvc2VkKCkpIHtcblx0XHRcdFx0dGhpcy5lbWl0dGVyXy5yZW1vdmVMaXN0ZW5lcih0aGlzLmV2ZW50XywgdGhpcy5saXN0ZW5lcl8pO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBFdmVudEhhbmRsZTtcbn0oX21ldGFsLkRpc3Bvc2FibGUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEhhbmRsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50SGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWxFdmVudHMgPSByZXF1aXJlKCdtZXRhbC1ldmVudHMnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIFRoaXMgaXMgYSBzcGVjaWFsIEV2ZW50SGFuZGxlLCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBkb20gZXZlbnRzLCBpbnN0ZWFkXG4gKiBvZiBFdmVudEVtaXR0ZXIgZXZlbnRzLlxuICogQGV4dGVuZHMge0V2ZW50SGFuZGxlfVxuICovXG52YXIgRG9tRXZlbnRIYW5kbGUgPSBmdW5jdGlvbiAoX0V2ZW50SGFuZGxlKSB7XG5cdF9pbmhlcml0cyhEb21FdmVudEhhbmRsZSwgX0V2ZW50SGFuZGxlKTtcblxuXHQvKipcbiAgKiBUaGUgY29uc3RydWN0b3IgZm9yIGBEb21FdmVudEhhbmRsZWAuXG4gICogQHBhcmFtIHshRXZlbnRFbWl0dGVyfSBlbWl0dGVyIEVtaXR0ZXIgdGhlIGV2ZW50IHdhcyBzdWJzY3JpYmVkIHRvLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCB3YXMgc3Vic2NyaWJlZCB0by5cbiAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X2NhcHR1cmUgRmxhZyBpbmRpY2F0aW5nIGlmIGxpc3RlbmVyIHNob3VsZCBiZSB0cmlnZ2VyZWRcbiAgKiAgIGR1cmluZyBjYXB0dXJlIHBoYXNlLCBpbnN0ZWFkIG9mIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAqIEBjb25zdHJ1Y3RvclxuICAqL1xuXHRmdW5jdGlvbiBEb21FdmVudEhhbmRsZShlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIsIG9wdF9jYXB0dXJlKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvbUV2ZW50SGFuZGxlKTtcblxuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEb21FdmVudEhhbmRsZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvbUV2ZW50SGFuZGxlKSkuY2FsbCh0aGlzLCBlbWl0dGVyLCBldmVudCwgbGlzdGVuZXIpKTtcblxuXHRcdF90aGlzLmNhcHR1cmVfID0gb3B0X2NhcHR1cmU7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogQGluaGVyaXREb2NcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEb21FdmVudEhhbmRsZSwgW3tcblx0XHRrZXk6ICdyZW1vdmVMaXN0ZW5lcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKCkge1xuXHRcdFx0dGhpcy5lbWl0dGVyXy5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnRfLCB0aGlzLmxpc3RlbmVyXywgdGhpcy5jYXB0dXJlXyk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERvbUV2ZW50SGFuZGxlO1xufShfbWV0YWxFdmVudHMuRXZlbnRIYW5kbGUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEb21FdmVudEhhbmRsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL0RvbUV2ZW50SGFuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQ2xhc3Mgd2l0aCBzdGF0aWMgbWV0aG9kcyByZXNwb25zaWJsZSBmb3IgZG9pbmcgYnJvd3NlciBmZWF0dXJlIGNoZWNrcy5cbiAqL1xudmFyIGZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBmZWF0dXJlcygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgZmVhdHVyZXMpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGZlYXR1cmVzLCBudWxsLCBbe1xuXHRcdGtleTogJ2NoZWNrQW5pbWF0aW9uRXZlbnROYW1lJyxcblxuXHRcdC8qKlxuICAgKiBTb21lIGJyb3dzZXJzIHN0aWxsIHN1cHBvcnRzIHByZWZpeGVkIGFuaW1hdGlvbiBldmVudHMuIFRoaXMgbWV0aG9kIGNhblxuICAgKiBiZSB1c2VkIHRvIHJldHJpZXZlIHRoZSBjdXJyZW50IGJyb3dzZXIgZXZlbnQgbmFtZSBmb3IgYm90aCwgYW5pbWF0aW9uXG4gICAqIGFuZCB0cmFuc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjaGVja0FuaW1hdGlvbkV2ZW50TmFtZSgpIHtcblx0XHRcdGlmIChmZWF0dXJlcy5hbmltYXRpb25FdmVudE5hbWVfID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0ZmVhdHVyZXMuYW5pbWF0aW9uRXZlbnROYW1lXyA9IHtcblx0XHRcdFx0XHRhbmltYXRpb246IGZlYXR1cmVzLmNoZWNrQW5pbWF0aW9uRXZlbnROYW1lXygnYW5pbWF0aW9uJyksXG5cdFx0XHRcdFx0dHJhbnNpdGlvbjogZmVhdHVyZXMuY2hlY2tBbmltYXRpb25FdmVudE5hbWVfKCd0cmFuc2l0aW9uJylcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmZWF0dXJlcy5hbmltYXRpb25FdmVudE5hbWVfO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgdG8gdGVzdDogYW5pbWF0aW9uLCB0cmFuc2l0aW9uLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEJyb3dzZXIgZXZlbnQgbmFtZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NoZWNrQW5pbWF0aW9uRXZlbnROYW1lXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNoZWNrQW5pbWF0aW9uRXZlbnROYW1lXyh0eXBlKSB7XG5cdFx0XHR2YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNUycsICdPJywgJyddO1xuXHRcdFx0dmFyIHR5cGVUaXRsZUNhc2UgPSBfbWV0YWwuc3RyaW5nLnJlcGxhY2VJbnRlcnZhbCh0eXBlLCAwLCAxLCB0eXBlLnN1YnN0cmluZygwLCAxKS50b1VwcGVyQ2FzZSgpKTtcblx0XHRcdHZhciBzdWZmaXhlcyA9IFt0eXBlVGl0bGVDYXNlICsgJ0VuZCcsIHR5cGVUaXRsZUNhc2UgKyAnRW5kJywgdHlwZVRpdGxlQ2FzZSArICdFbmQnLCB0eXBlICsgJ2VuZCddO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoZmVhdHVyZXMuYW5pbWF0aW9uRWxlbWVudF8uc3R5bGVbcHJlZml4ZXNbaV0gKyB0eXBlVGl0bGVDYXNlXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZWZpeGVzW2ldLnRvTG93ZXJDYXNlKCkgKyBzdWZmaXhlc1tpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHR5cGUgKyAnZW5kJztcblx0XHR9XG5cblx0XHQvKipcbiAgICogU29tZSBicm93c2VycyAobGlrZSBJRTkpIGNoYW5nZSB0aGUgb3JkZXIgb2YgZWxlbWVudCBhdHRyaWJ1dGVzLCB3aGVuIGh0bWxcbiAgICogaXMgcmVuZGVyZWQuIFRoaXMgbWV0aG9kIGNhbiBiZSB1c2VkIHRvIGNoZWNrIGlmIHRoaXMgYmVoYXZpb3IgaGFwcGVucyBvblxuICAgKiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY2hlY2tBdHRyT3JkZXJDaGFuZ2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjaGVja0F0dHJPcmRlckNoYW5nZSgpIHtcblx0XHRcdGlmIChmZWF0dXJlcy5hdHRyT3JkZXJDaGFuZ2VfID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dmFyIG9yaWdpbmFsQ29udGVudCA9ICc8ZGl2IGRhdGEtY29tcG9uZW50PVwiXCIgZGF0YS1yZWY9XCJcIj48L2Rpdj4nO1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHQoMCwgX2RvbS5hcHBlbmQpKGVsZW1lbnQsIG9yaWdpbmFsQ29udGVudCk7XG5cdFx0XHRcdGZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV8gPSBvcmlnaW5hbENvbnRlbnQgIT09IGVsZW1lbnQuaW5uZXJIVE1MO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGZlYXR1cmVzO1xufSgpO1xuXG5mZWF0dXJlcy5hbmltYXRpb25FbGVtZW50XyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuZmVhdHVyZXMuYW5pbWF0aW9uRXZlbnROYW1lXyA9IHVuZGVmaW5lZDtcbmZlYXR1cmVzLmF0dHJPcmRlckNoYW5nZV8gPSB1bmRlZmluZWQ7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZlYXR1cmVzO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZmVhdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfbWV0YWxTdGF0ZSA9IHJlcXVpcmUoJ21ldGFsLXN0YXRlJyk7XG5cbnZhciBfbWV0YWxTdGF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRhbFN0YXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEJMQUNLTElTVCA9IHtcblx0Y29tcG9uZW50czogdHJ1ZSxcblx0Y29udGV4dDogdHJ1ZSxcblx0ZWxlbWVudDogdHJ1ZSxcblx0cmVmczogdHJ1ZSxcblx0c3RhdGU6IHRydWUsXG5cdHN0YXRlS2V5OiB0cnVlLFxuXHR3YXNSZW5kZXJlZDogdHJ1ZVxufTtcbnZhciBEQVRBX01BTkFHRVJfREFUQSA9ICdfX0RBVEFfTUFOQUdFUl9EQVRBX18nO1xuXG52YXIgQ29tcG9uZW50RGF0YU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIENvbXBvbmVudERhdGFNYW5hZ2VyKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnREYXRhTWFuYWdlcik7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoQ29tcG9uZW50RGF0YU1hbmFnZXIsIFt7XG5cdFx0a2V5OiAnY3JlYXRlU3RhdGVfJyxcblxuXHRcdC8qKlxuICAgKiBDcmVhdGVzIHRoZSBgU3RhdGVgIGluc3RhbmNlIHRoYXQgd2lsbCBoYW5kbGUgdGhlIG1haW4gY29tcG9uZW50IGRhdGEuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVTdGF0ZV8oY29tcG9uZW50LCBkYXRhKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSBuZXcgX21ldGFsU3RhdGUyLmRlZmF1bHQoY29tcG9uZW50LmdldEluaXRpYWxDb25maWcoKSwgY29tcG9uZW50LCBjb21wb25lbnQpO1xuXHRcdFx0c3RhdGUuc2V0S2V5c0JsYWNrbGlzdChCTEFDS0xJU1QpO1xuXHRcdFx0c3RhdGUuY29uZmlnU3RhdGUoX21ldGFsLm9iamVjdC5taXhpbih7fSwgZGF0YSwgX21ldGFsU3RhdGUyLmRlZmF1bHQuZ2V0U3RhdGVTdGF0aWMoY29tcG9uZW50LmNvbnN0cnVjdG9yKSkpO1xuXHRcdFx0dGhpcy5nZXRNYW5hZ2VyRGF0YShjb21wb25lbnQpLnN0YXRlXyA9IHN0YXRlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBEaXNwb3NlcyBvZiBhbnkgZGF0YSBiZWluZyB1c2VkIGJ5IHRoZSBtYW5hZ2VyIGluIHRoaXMgY29tcG9uZW50LlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoY29tcG9uZW50KSB7XG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KTtcblx0XHRcdGlmIChkYXRhLnN0YXRlXykge1xuXHRcdFx0XHRkYXRhLnN0YXRlXy5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRbREFUQV9NQU5BR0VSX0RBVEFdID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgZGF0YSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0KGNvbXBvbmVudCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KS5zdGF0ZV8uZ2V0KG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBtYW5hZ2VyIGRhdGEgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE1hbmFnZXJEYXRhJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KSB7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50W0RBVEFfTUFOQUdFUl9EQVRBXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUga2V5cyBmb3Igc3RhdGUgZGF0YSB0aGF0IGNhbiBiZSBzeW5jZWQgdmlhIGBzeW5jYCBmdW5jdGlvbnMuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3luY0tleXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTeW5jS2V5cyhjb21wb25lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLmdldFN0YXRlS2V5cygpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBrZXlzIGZvciBzdGF0ZSBkYXRhLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFN0YXRlS2V5cycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlS2V5cyhjb21wb25lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLmdldFN0YXRlS2V5cygpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSB3aG9sZSBzdGF0ZSBkYXRhLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZShjb21wb25lbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLmdldFN0YXRlKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGBTdGF0ZWAgaW5zdGFuY2UgYmVpbmcgdXNlZC5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFN0YXRlSW5zdGFuY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUluc3RhbmNlKGNvbXBvbmVudCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0TWFuYWdlckRhdGEoY29tcG9uZW50KS5zdGF0ZV87XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFVwZGF0ZXMgYWxsIG5vbiBpbnRlcm5hbCBkYXRhIHdpdGggdGhlIGdpdmVuIHZhbHVlcyAob3IgdG8gdGhlIGRlZmF1bHRcbiAgICogdmFsdWUgaWYgbm9uZSBpcyBnaXZlbikuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZGF0YVxuICAgKiBAcGFyYW0ge1N0YXRlPX0gb3B0X3N0YXRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlTm9uSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlTm9uSW50ZXJuYWwoY29tcG9uZW50LCBkYXRhLCBvcHRfc3RhdGUpIHtcblx0XHRcdHZhciBzdGF0ZSA9IG9wdF9zdGF0ZSB8fCB0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfO1xuXHRcdFx0dmFyIGtleXMgPSBzdGF0ZS5nZXRTdGF0ZUtleXMoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0aWYgKCFzdGF0ZS5nZXRTdGF0ZUtleUNvbmZpZyhrZXkpLmludGVybmFsKSB7XG5cdFx0XHRcdFx0aWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0c3RhdGUuc2V0KGtleSwgZGF0YVtrZXldKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3RhdGUuc2V0RGVmYXVsdFZhbHVlKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIGFsbCB0aGUgc3BlY2lmaWVkIHN0YXRlIGtleXMuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+fSB2YWx1ZXMgQSBtYXAgb2Ygc3RhdGUga2V5cyB0byB0aGUgdmFsdWVzIHRoZXlcbiAgICogICBzaG91bGQgYmUgc2V0IHRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJ1blxuICAgKiAgIGFmdGVyIHRoZSBuZXh0IGJhdGNoZWQgdXBkYXRlIGlzIHRyaWdnZXJlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGUoY29tcG9uZW50LCBzdGF0ZSwgb3B0X2NhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLmdldE1hbmFnZXJEYXRhKGNvbXBvbmVudCkuc3RhdGVfLnNldFN0YXRlKHN0YXRlLCBvcHRfY2FsbGJhY2spO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHVwIHRoZSBzcGVjaWZpZWQgY29tcG9uZW50J3MgZGF0YS5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHshT2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRVcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFVwKGNvbXBvbmVudCwgZGF0YSkge1xuXHRcdFx0Y29tcG9uZW50W0RBVEFfTUFOQUdFUl9EQVRBXSA9IHt9O1xuXHRcdFx0dGhpcy5jcmVhdGVTdGF0ZV8oY29tcG9uZW50LCBkYXRhKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gQ29tcG9uZW50RGF0YU1hbmFnZXI7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG5ldyBDb21wb25lbnREYXRhTWFuYWdlcigpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvQ29tcG9uZW50RGF0YU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU3RhdGUgPSBleHBvcnRzLkNvbmZpZyA9IGV4cG9ydHMudmFsaWRhdG9ycyA9IHVuZGVmaW5lZDtcblxudmFyIF92YWxpZGF0b3JzID0gcmVxdWlyZSgnLi4vdmFsaWRhdG9ycycpO1xuXG52YXIgX3ZhbGlkYXRvcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmFsaWRhdG9ycyk7XG5cbnZhciBfQ29uZmlnID0gcmVxdWlyZSgnLi4vQ29uZmlnJyk7XG5cbnZhciBfQ29uZmlnMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0NvbmZpZyk7XG5cbnZhciBfU3RhdGUgPSByZXF1aXJlKCcuLi9TdGF0ZScpO1xuXG52YXIgX1N0YXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1N0YXRlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX1N0YXRlMi5kZWZhdWx0O1xuZXhwb3J0cy52YWxpZGF0b3JzID0gX3ZhbGlkYXRvcnMyLmRlZmF1bHQ7XG5leHBvcnRzLkNvbmZpZyA9IF9Db25maWcyLmRlZmF1bHQ7XG5leHBvcnRzLlN0YXRlID0gX1N0YXRlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL2xpYi9hbGwvc3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIEVSUk9SX0FSUkFZX09GX1RZUEUgPSAnRXhwZWN0ZWQgYW4gYXJyYXkgb2Ygc2luZ2xlIHR5cGUuJztcbnZhciBFUlJPUl9PQkpFQ1RfT0ZfVFlQRSA9ICdFeHBlY3RlZCBvYmplY3Qgb2Ygb25lIHR5cGUuJztcbnZhciBFUlJPUl9PTkVfT0YgPSAnRXhwZWN0ZWQgb25lIG9mIGdpdmVuIHZhbHVlcy4nO1xudmFyIEVSUk9SX09ORV9PRl9UWVBFID0gJ0V4cGVjdGVkIG9uZSBvZiBnaXZlbiB0eXBlcy4nO1xudmFyIEVSUk9SX1NIQVBFX09GID0gJ0V4cGVjdGVkIG9iamVjdCB3aXRoIGEgc3BlY2lmaWMgc2hhcGUuJztcblxuLyoqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdmFyaW91cyB0eXBlIHZhbGlkYXRvcnMgdGhhdCB3aWxsIHJldHVybiBhblxuICogaW5zdGFuY2Ugb2YgRXJyb3Igd2hlbiB2YWxpZGF0aW9uIGZhaWxzLiBOb3RlIHRoYXQgYWxsIHR5cGUgdmFsaWRhdG9yc1xuICogd2lsbCBhbHNvIGFjY2VwdCBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuIFRvIG5vdCBhY2NlcHQgdGhlc2UgeW91IHNob3VsZFxuICogaW5zdGVhZCBtYWtlIHlvdXIgc3RhdGUgcHJvcGVydHkgcmVxdWlyZWQuXG4gKi9cbnZhciB2YWxpZGF0b3JzID0ge1xuXHRhbnk6IGZ1bmN0aW9uIGFueSgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fSxcblx0YXJyYXk6IGJ1aWxkVHlwZVZhbGlkYXRvcignYXJyYXknKSxcblx0Ym9vbDogYnVpbGRUeXBlVmFsaWRhdG9yKCdib29sZWFuJyksXG5cdGZ1bmM6IGJ1aWxkVHlwZVZhbGlkYXRvcignZnVuY3Rpb24nKSxcblx0bnVtYmVyOiBidWlsZFR5cGVWYWxpZGF0b3IoJ251bWJlcicpLFxuXHRvYmplY3Q6IGJ1aWxkVHlwZVZhbGlkYXRvcignb2JqZWN0JyksXG5cdHN0cmluZzogYnVpbGRUeXBlVmFsaWRhdG9yKCdzdHJpbmcnKSxcblxuXHQvKipcbiAgKiBDcmVhdGVzIGEgdmFsaWRhdG9yIHRoYXQgY2hlY2tzIHRoYXQgdGhlIHZhbHVlIGl0IHJlY2VpdmVzIGlzIGFuIGFycmF5XG4gICogb2YgaXRlbXMsIGFuZCB0aGF0IGFsbCBvZiB0aGUgaXRlbXMgcGFzcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHZhbGlkYXRvciBWYWxpZGF0b3IgdG8gY2hlY2sgZWFjaCBpdGVtIGFnYWluc3QuXG4gICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4gICovXG5cdGFycmF5T2Y6IGZ1bmN0aW9uIGFycmF5T2YodmFsaWRhdG9yKSB7XG5cdFx0cmV0dXJuIG1heWJlKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHZhbGlkYXRvcnMuYXJyYXkodmFsdWUsIG5hbWUsIGNvbnRleHQpO1xuXHRcdFx0aWYgKGlzSW52YWxpZChyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsaWRhdGVBcnJheUl0ZW1zKHZhbGlkYXRvciwgdmFsdWUsIG5hbWUsIGNvbnRleHQpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIENyZWF0ZXMgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBhIGdpdmVuIGNsYXNzLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGV4cGVjdGVkQ2xhc3MgQ2xhc3MgdG8gY2hlY2sgdmFsdWUgYWdhaW5zdC5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0aW5zdGFuY2VPZjogZnVuY3Rpb24gaW5zdGFuY2VPZihleHBlY3RlZENsYXNzKSB7XG5cdFx0cmV0dXJuIG1heWJlKGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgJyArIGV4cGVjdGVkQ2xhc3M7XG5cdFx0XHRyZXR1cm4gY29tcG9zZUVycm9yKG1zZywgbmFtZSwgY29udGV4dCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyB0aGF0IHRoZSB2YWx1ZSBpdCByZWNlaXZlcyBpcyBhbiBvYmplY3QsXG4gICogYW5kIHRoYXQgYWxsIHZhbHVlcyB3aXRoaW4gdGhhdCBvYmplY3QgcGFzcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHZhbGlkYXRvciBWYWxpZGF0b3IgdG8gY2hlY2sgZWFjaCBvYmplY3QgdmFsdWUgYWdhaW5zdC5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0b2JqZWN0T2Y6IGZ1bmN0aW9uIG9iamVjdE9mKHZhbGlkYXRvcikge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAoaXNJbnZhbGlkKHZhbGlkYXRvcih2YWx1ZVtrZXldKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcG9zZUVycm9yKEVSUk9SX09CSkVDVF9PRl9UWVBFLCBuYW1lLCBjb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlXG4gICogZ2l2ZW4gdmFsdWVzLlxuICAqIEBwYXJhbSB7IUFycmF5fSBhcnJheU9mVmFsdWVzIEFycmF5IG9mIHZhbHVlcyB0byBjaGVjayBlcXVhbGl0eSBhZ2FpbnN0LlxuICAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuICAqL1xuXHRvbmVPZjogZnVuY3Rpb24gb25lT2YoYXJyYXlPZlZhbHVlcykge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWxpZGF0b3JzLmFycmF5KGFycmF5T2ZWYWx1ZXMsIG5hbWUsIGNvbnRleHQpO1xuXHRcdFx0aWYgKGlzSW52YWxpZChyZXN1bHQpKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXJyYXlPZlZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEgPyBjb21wb3NlRXJyb3IoRVJST1JfT05FX09GLCBuYW1lLCBjb250ZXh0KSA6IHRydWU7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgbWF0Y2hlcyBvbmUgb2YgdGhlXG4gICogZ2l2ZW4gdHlwZXMuXG4gICogQHBhcmFtIHshQXJyYXl9IGFycmF5T2ZUeXBlVmFsaWRhdG9ycyBBcnJheSBvZiB2YWxpZGF0b3JzIHRvIGNoZWNrIHZhbHVlXG4gICogICAgIGFnYWluc3QuXG4gICogQHJldHVybiB7IWZ1bmN0aW9uKCl9XG4gICovXG5cdG9uZU9mVHlwZTogZnVuY3Rpb24gb25lT2ZUeXBlKGFycmF5T2ZUeXBlVmFsaWRhdG9ycykge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWxpZGF0b3JzLmFycmF5KGFycmF5T2ZUeXBlVmFsaWRhdG9ycywgbmFtZSwgY29udGV4dCk7XG5cdFx0XHRpZiAoaXNJbnZhbGlkKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZVZhbGlkYXRvcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKCFpc0ludmFsaWQoYXJyYXlPZlR5cGVWYWxpZGF0b3JzW2ldKHZhbHVlLCBuYW1lLCBjb250ZXh0KSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbXBvc2VFcnJvcihFUlJPUl9PTkVfT0ZfVFlQRSwgbmFtZSwgY29udGV4dCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBpZiB0aGUgcmVjZWl2ZWQgdmFsdWUgaXMgYW4gb2JqZWN0LCBhbmRcbiAgKiB0aGF0IGl0cyBjb250ZW50cyBtYXRjaCB0aGUgZ2l2ZW4gc2hhcGUuXG4gICogQHBhcmFtIHshT2JqZWN0fSBzaGFwZSBBbiBvYmplY3QgY29udGFpbmluZyB2YWxpZGF0b3JzIGZvciBlYWNoIGtleS5cbiAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgKi9cblx0c2hhcGVPZjogZnVuY3Rpb24gc2hhcGVPZihzaGFwZSkge1xuXHRcdHJldHVybiBtYXliZShmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRcdHZhciByZXN1bHQgPSB2YWxpZGF0b3JzLm9iamVjdChzaGFwZSwgbmFtZSwgY29udGV4dCk7XG5cdFx0XHRpZiAoaXNJbnZhbGlkKHJlc3VsdCkpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNoYXBlKSB7XG5cdFx0XHRcdHZhciB2YWxpZGF0b3IgPSBzaGFwZVtrZXldO1xuXHRcdFx0XHR2YXIgcmVxdWlyZWQgPSBmYWxzZTtcblx0XHRcdFx0aWYgKHZhbGlkYXRvci5jb25maWcpIHtcblx0XHRcdFx0XHRyZXF1aXJlZCA9IHZhbGlkYXRvci5jb25maWcucmVxdWlyZWQ7XG5cdFx0XHRcdFx0dmFsaWRhdG9yID0gdmFsaWRhdG9yLmNvbmZpZy52YWxpZGF0b3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHJlcXVpcmVkICYmICEoMCwgX21ldGFsLmlzRGVmQW5kTm90TnVsbCkodmFsdWVba2V5XSkgfHwgaXNJbnZhbGlkKHZhbGlkYXRvcih2YWx1ZVtrZXldKSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcG9zZUVycm9yKEVSUk9SX1NIQVBFX09GLCBuYW1lLCBjb250ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSk7XG5cdH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHZhbGlkYXRvciB0aGF0IGNoZWNrcyBhZ2FpbnN0IGEgc3BlY2lmaWMgcHJpbWl0aXZlIHR5cGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRUeXBlIFR5cGUgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm4geyFmdW5jdGlvbigpfSBGdW5jdGlvbiB0aGF0IHJ1bnMgdGhlIHZhbGlkYXRvciBpZiBjYWxsZWQgd2l0aFxuICogICAgIGFyZ3VtZW50cywgb3IganVzdCByZXR1cm5zIGl0IG90aGVyd2lzZS4gVGhpcyBtZWFucyB0aGF0IHdoZW4gdXNpbmcgYVxuICogICAgIHR5cGUgdmFsaWRhdG9yIGluIGBTdGF0ZWAgaXQgbWF5IGJlIGp1c3QgcGFzc2VkIGRpcmVjdGx5IChsaWtlXG4gKiAgICAgYHZhbGlkYXRvcnMuYm9vbGApLCBvciBjYWxsZWQgd2l0aCBubyBhcmdzIChsaWtlIGB2YWxpZGF0b3JzLmJvb2woKWApLlxuICogICAgIFRoYXQncyBkb25lIHRvIGFsbG93IGFsbCB2YWxpZGF0b3JzIHRvIGJlIHVzZWQgY29uc2lzdGVudGx5LCBzaW5jZSBzb21lXG4gKiAgICAgKGxpa2UgYGFycmF5T2ZgKSBhbHdheXMgcmVxdWlyZSB0aGF0IHlvdSBjYWxsIHRoZSBmdW5jdGlvbiBiZWZvcmVcbiAqICAgICByZWNlaXZpbmcgdGhlIGFjdHVhbCB2YWxpZGF0b3IuIFR5cGUgdmFsaWRhdG9ycyBkb24ndCBuZWVkIHRoZSBjYWxsLCBidXRcbiAqICAgICB3b3JrIGlmIGl0J3MgbWFkZSBhbnl3YXkuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHlwZVZhbGlkYXRvcihleHBlY3RlZFR5cGUpIHtcblx0dmFyIHZhbGlkYXRvckZuID0gbWF5YmUodmFsaWRhdGVUeXBlLmJpbmQobnVsbCwgZXhwZWN0ZWRUeXBlKSk7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiB2YWxpZGF0b3JGbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZhbGlkYXRvckZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59XG5cbi8qKlxuICogQ29tcG9zZXMgYSB3YXJuaW5nIGEgd2FybmluZyBtZXNzYWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yIEVycm9yIG1lc3NhZ2UgdG8gZGlzcGxheSB0byBjb25zb2xlLlxuICogQHBhcmFtIHs/c3RyaW5nfSBuYW1lIE5hbWUgb2Ygc3RhdGUgcHJvcGVydHkgdGhhdCBpcyBnaXZpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIHByb3BlcnR5J3Mgb3duZXIuXG4gKiBAcmV0dXJuIHshRXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VFcnJvcihlcnJvciwgbmFtZSwgY29udGV4dCkge1xuXHR2YXIgY29tcE5hbWUgPSBjb250ZXh0ID8gKDAsIF9tZXRhbC5nZXRGdW5jdGlvbk5hbWUpKGNvbnRleHQuY29uc3RydWN0b3IpIDogbnVsbDtcblx0dmFyIHJlbmRlcmVyID0gY29udGV4dCAmJiBjb250ZXh0LmdldFJlbmRlcmVyICYmIGNvbnRleHQuZ2V0UmVuZGVyZXIoKTtcblx0dmFyIHBhcmVudCA9IHJlbmRlcmVyICYmIHJlbmRlcmVyLmdldFBhcmVudCAmJiByZW5kZXJlci5nZXRQYXJlbnQoKTtcblx0dmFyIHBhcmVudE5hbWUgPSBwYXJlbnQgPyAoMCwgX21ldGFsLmdldEZ1bmN0aW9uTmFtZSkocGFyZW50LmNvbnN0cnVjdG9yKSA6IG51bGw7XG5cdHZhciBsb2NhdGlvbiA9IHBhcmVudE5hbWUgPyAnQ2hlY2sgcmVuZGVyIG1ldGhvZCBvZiBcXCcnICsgcGFyZW50TmFtZSArICdcXCcuJyA6ICcnO1xuXHRyZXR1cm4gbmV3IEVycm9yKCdXYXJuaW5nOiBJbnZhbGlkIHN0YXRlIHBhc3NlZCB0byBcXCcnICsgbmFtZSArICdcXCcuICcgKyAoZXJyb3IgKyAnIFBhc3NlZCB0byBcXCcnICsgY29tcE5hbWUgKyAnXFwnLiAnICsgbG9jYXRpb24pKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybiB7c3RyaW5nfSBUeXBlIG9mIHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/ICdhcnJheScgOiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbGlkYXRvciByZXN1bHQgc2F5cyB0aGF0IHRoZSB2YWx1ZSBpcyBpbnZhbGlkLlxuICogQHBhcmFtIHtib29sZWFufCFFcnJvcn0gcmVzdWx0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ludmFsaWQocmVzdWx0KSB7XG5cdHJldHVybiByZXN1bHQgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuLyoqXG4gKiBXcmFwcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yIHNvIHRoYXQgaXQgYWxzbyBhY2NlcHRzIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cbiAqICAgYSB2YWxpZGF0b3IgdGhhdCBjaGVja3MgYSB2YWx1ZSBhZ2FpbnN0IGEgc2luZ2xlIHR5cGUsIG51bGwsIG9yXG4gKiB1bmRlZmluZWQuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSB0eXBlVmFsaWRhdG9yIFZhbGlkYXRvciB0byB3cmFwLlxuICogQHJldHVybiB7IWZ1bmN0aW9uKCl9IFdyYXBwZWQgdmFsaWRhdG9yLlxuICovXG5mdW5jdGlvbiBtYXliZSh0eXBlVmFsaWRhdG9yKSB7XG5cdHJldHVybiBmdW5jdGlvbiAodmFsdWUsIG5hbWUsIGNvbnRleHQpIHtcblx0XHRyZXR1cm4gKDAsIF9tZXRhbC5pc0RlZkFuZE5vdE51bGwpKHZhbHVlKSA/IHR5cGVWYWxpZGF0b3IodmFsdWUsIG5hbWUsIGNvbnRleHQpIDogdHJ1ZTtcblx0fTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYWxsIHRoZSBpdGVtcyBvZiB0aGUgZ2l2ZW4gYXJyYXkgcGFzcyB0aGUgZ2l2ZW4gdmFsaWRhdG9yLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gdmFsaWRhdG9yXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhcnJheSB0byB2YWxpZGF0ZSBpdGVtcyBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYXJyYXkgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29udGV4dCBPd25lciBvZiB0aGUgYXJyYXkgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEByZXR1cm4geyFFcnJvcnxib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHR5cGUgbWF0Y2hlcywgb3IgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUFycmF5SXRlbXModmFsaWRhdG9yLCB2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKGlzSW52YWxpZCh2YWxpZGF0b3IodmFsdWVbaV0sIG5hbWUsIGNvbnRleHQpKSkge1xuXHRcdFx0cmV0dXJuIGNvbXBvc2VFcnJvcihFUlJPUl9BUlJBWV9PRl9UWVBFLCBuYW1lLCBjb250ZXh0KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBtYXRjaGVzIHRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkVHlwZSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBleHBlY3RlZCB0eXBlLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2ggdGhlIHR5cGUgb2YuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29udGV4dCBPd25lciBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY2hlY2tlZC5cbiAqIEByZXR1cm4geyFFcnJvcnxib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHR5cGUgbWF0Y2hlcywgb3IgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUoZXhwZWN0ZWRUeXBlLCB2YWx1ZSwgbmFtZSwgY29udGV4dCkge1xuXHR2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXHRpZiAodHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG5cdFx0dmFyIG1zZyA9ICdFeHBlY3RlZCB0eXBlIFxcJycgKyBleHBlY3RlZFR5cGUgKyAnXFwnLCBidXQgcmVjZWl2ZWQgdHlwZSBcXCcnICsgdHlwZSArICdcXCcuJztcblx0XHRyZXR1cm4gY29tcG9zZUVycm9yKG1zZywgbmFtZSwgY29udGV4dCk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRvcnM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbGliL3ZhbGlkYXRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGV4aXN0cyBqdXN0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgbWFraW5nIHN1cmUgdGhhdCBvbGRcbi8vIGRlZmF1bHQgaW1wb3J0cyBmb3IgdGhpcyBmaWxlIHN0aWxsIHdvcmsuIEl0J3MgYmVzdCB0byB1c2UgdGhlIG5hbWVkIGV4cG9ydHNcbi8vIGZvciBlYWNoIGZ1bmN0aW9uIGluc3RlYWQgdGhvdWdoLCBzaW5jZSB0aGF0IGFsbG93cyBidW5kbGVycyBsaWtlIFJvbGx1cCB0b1xuLy8gcmVkdWNlIHRoZSBidW5kbGUgc2l6ZSBieSByZW1vdmluZyB1bnVzZWQgY29kZS5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY29yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlTmFtZWQgPSByZXF1aXJlKCcuL2NvcmVOYW1lZCcpO1xuXG5PYmplY3Qua2V5cyhfY29yZU5hbWVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZU5hbWVkW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xuXG52YXIgY29yZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9jb3JlTmFtZWQpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjb3JlO1xuZXhwb3J0cy5jb3JlID0gY29yZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgY29tcG9uZW50IHJlbmRlcmVycyBzaG91bGQgZXh0ZW5kIGZyb20uIEl0IGRlZmluZXMgdGhlXG4gKiByZXF1aXJlZCBtZXRob2RzIGFsbCByZW5kZXJlcnMgc2hvdWxkIGhhdmUuXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIENvbXBvbmVudFJlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBDb21wb25lbnRSZW5kZXJlcigpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50UmVuZGVyZXIpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKENvbXBvbmVudFJlbmRlcmVyLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXG5cblx0XHQvKipcbiAgICogRGlzcG9zZXMgb2YgYW55IGRhdGEgc3BlY2lmaWMgdG8gdGhlIGdpdmVuIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgZXh0cmEgY29uZmlndXJhdGlvbiBmb3IgZGF0YSB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWFuYWdlci5cbiAgICogU3ViIGNsYXNzZXMgY2FuIG92ZXJyaWRlIHRvIHJldHVybiBgU3RhdGVgIGNvbmZpZyBmb3IgcHJvcGVydGllcyB0aGF0XG4gICAqIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRFeHRyYURhdGFDb25maWcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRFeHRyYURhdGFDb25maWcoKSB7fVxuXG5cdFx0LyoqXG4gICAqIFJlbmRlcnMgdGhlIHdob2xlIGNvbnRlbnQgKGluY2x1ZGluZyBpdHMgbWFpbiBlbGVtZW50KSBhbmQgaW5mb3JtcyB0aGVcbiAgICogY29tcG9uZW50IGFib3V0IGl0LiBTaG91bGQgYmUgb3ZlcnJpZGRlbiBieSBzdWIgY2xhc3Nlcy5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihjb21wb25lbnQpIHtcblx0XHRcdGlmICghY29tcG9uZW50LmVsZW1lbnQpIHtcblx0XHRcdFx0Y29tcG9uZW50LmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudC5pbmZvcm1SZW5kZXJlZCgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgY29tcG9uZW50IHRvIGJlIHVzZWQgYnkgdGhpcyByZW5kZXJlci4gU3ViIGNsYXNzZXMgc2hvdWxkXG4gICAqIG92ZXJyaWRlIGFzIG5lZWRlZCBmb3IgbW9yZSBiZWhhdmlvci5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFVwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VXAoKSB7fVxuXG5cdFx0LyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQgaHRtbC4gVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAqIHRoZSB2YWx1ZSBvZiBhdCBsZWFzdCBvbmUgb2YgdGhlIGNvbXBvbmVudCdzIHN0YXRlIGtleXMgaGFzIGNoYW5nZWQuXG4gICAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWIgY2xhc3Nlcy4gU3ViIGNsYXNzZXMgaGF2ZSB0byByZW1lbWJlciB0byBjYWxsXG4gICAqIFwiaW5mb3JtUmVuZGVyZWRcIiBvbiB0aGUgY29tcG9uZW50IHdoZW4gYW55IHVwZGF0ZSByZW5kZXJpbmcgaXMgZG9uZS5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgT2JqZWN0Pn0gY2hhbmdlcyBPYmplY3QgY29udGFpbmluZyB0aGUgbmFtZXNcbiAgICogICAgIG9mIGFsbCBjaGFuZ2VkIHN0YXRlIGtleXMsIGVhY2ggbWFwcGVkIHRvIGFuIG9iamVjdCB3aXRoIGl0cyBuZXdcbiAgICogICAgIChuZXdWYWwpIGFuZCBwcmV2aW91cyAocHJldlZhbCkgdmFsdWVzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndXBkYXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge31cblx0fV0pO1xuXG5cdHJldHVybiBDb21wb25lbnRSZW5kZXJlcjtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IENvbXBvbmVudFJlbmRlcmVyKCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L2xpYi9Db21wb25lbnRSZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5yZXF1aXJlKCcuL2luY3JlbWVudGFsLWRvbScpO1xuXG52YXIgX2NoYW5nZXMgPSByZXF1aXJlKCcuL2NoYW5nZXMnKTtcblxudmFyIF9kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG5cbnZhciBfY2hpbGRyZW4gPSByZXF1aXJlKCcuL2NoaWxkcmVuL2NoaWxkcmVuJyk7XG5cbnZhciBfcGF0Y2gyID0gcmVxdWlyZSgnLi9yZW5kZXIvcGF0Y2gnKTtcblxudmFyIF9yZW5kZXIgPSByZXF1aXJlKCcuL3JlbmRlci9yZW5kZXInKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSW5jcmVtZW50YWxEb21SZW5kZXJlciA9IGZ1bmN0aW9uIChfQ29tcG9uZW50UmVuZGVyZXIkY28pIHtcblx0X2luaGVyaXRzKEluY3JlbWVudGFsRG9tUmVuZGVyZXIsIF9Db21wb25lbnRSZW5kZXJlciRjbyk7XG5cblx0ZnVuY3Rpb24gSW5jcmVtZW50YWxEb21SZW5kZXJlcigpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5jcmVtZW50YWxEb21SZW5kZXJlcik7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEluY3JlbWVudGFsRG9tUmVuZGVyZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihJbmNyZW1lbnRhbERvbVJlbmRlcmVyKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoSW5jcmVtZW50YWxEb21SZW5kZXJlciwgW3tcblx0XHRrZXk6ICdidWlsZFNob3VsZFVwZGF0ZUFyZ3MnLFxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgYXJncyB0aGF0IHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCdzXG4gICAqIGBzaG91bGRVcGRhdGVgIG1ldGhvZC4gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzdWIgY2xhc3NlcyB0byBjaGFuZ2VcbiAgICogd2hhdCB0aGUgbWV0aG9kIHNob3VsZCByZWNlaXZlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlc1xuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBidWlsZFNob3VsZFVwZGF0ZUFyZ3MoY2hhbmdlcykge1xuXHRcdFx0cmV0dXJuIFtjaGFuZ2VzLnByb3BzXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKGNvbXBvbmVudCkge1xuXHRcdFx0dmFyIGRhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KTtcblx0XHRcdHZhciByZWYgPSBkYXRhLmNvbmZpZy5yZWY7XG5cdFx0XHR2YXIgb3duZXIgPSBkYXRhLm93bmVyO1xuXHRcdFx0aWYgKG93bmVyICYmIG93bmVyLmNvbXBvbmVudHMgJiYgb3duZXIuY29tcG9uZW50c1tyZWZdID09PSBjb21wb25lbnQpIHtcblx0XHRcdFx0ZGVsZXRlIG93bmVyLmNvbXBvbmVudHNbcmVmXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRhdGEuY2hpbGRDb21wb25lbnRzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5jaGlsZENvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSBkYXRhLmNoaWxkQ29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRpZiAoIWNoaWxkLmlzRGlzcG9zZWQoKSkge1xuXHRcdFx0XHRcdFx0Y2hpbGQuZWxlbWVudCA9IG51bGw7XG5cdFx0XHRcdFx0XHRjaGlsZC5kaXNwb3NlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCgwLCBfZGF0YS5jbGVhckRhdGEpKGNvbXBvbmVudCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdlbmVyYXRlcyBhIGtleSBmb3IgdGhlIGVsZW1lbnQgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkIGluIHRoZSBnaXZlblxuICAgKiBjb21wb25lbnQuIEJ5IGRlZmF1bHQsIGp1c3QgcmV0dXJucyB0aGUgb3JpZ2luYWwga2V5LiBTdWIgY2xhc3NlcyBjYW5cbiAgICogb3ZlcnJpZGUgdGhpcyB0byBjaGFuZ2UgdGhlIGJlaGF2aW9yLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4gez9zdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZW5lcmF0ZUtleScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlS2V5KGNvbXBvbmVudCwga2V5KSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXQgdGhlIGNvbXBvbmVudCdzIGNvbmZpZyBkYXRhLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0Q29uZmlnJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0Q29uZmlnKGNvbXBvbmVudCkge1xuXHRcdFx0cmV0dXJuICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpLmNvbmZpZztcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0IHRoZSBjb21wb25lbnQncyBpbmNyZW1lbnRhbCBkb20gcmVuZGVyZXIgZGF0YS5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldERhdGEnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhKGNvbXBvbmVudCkge1xuXHRcdFx0cmV0dXJuICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBjb21wb25lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIGN1cnJlbnQgcGF0Y2ggb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJuIHtDb21wb25lbnR9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRQYXRjaGluZ0NvbXBvbmVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhdGNoaW5nQ29tcG9uZW50KCkge1xuXHRcdFx0cmV0dXJuICgwLCBfcGF0Y2gyLmdldFBhdGNoaW5nQ29tcG9uZW50KSgpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBIYW5kbGVzIGEgbm9kZSBoYXZpbmcganVzdCBiZWVuIHJlbmRlcmVkLiBTdWIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpc1xuICAgKiBmb3IgY3VzdG9tIGJlaGF2aW9yLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlTm9kZVJlbmRlcmVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTm9kZVJlbmRlcmVkKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbmNyZW1lbnRhbCBkb20gbm9kZS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBub2RlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0luY0RvbU5vZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0luY0RvbU5vZGUobm9kZSkge1xuXHRcdFx0cmV0dXJuICEhKDAsIF9jaGlsZHJlbi5nZXRPd25lcikobm9kZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGxzIGluY3JlbWVudGFsIGRvbSdzIHBhdGNoIGZ1bmN0aW9uIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncGF0Y2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwYXRjaChjb21wb25lbnQpIHtcblx0XHRcdCgwLCBfcGF0Y2gyLnBhdGNoKShjb21wb25lbnQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW5kZXJzIHRoZSByZW5kZXJlcidzIGNvbXBvbmVudCBmb3IgdGhlIGZpcnN0IHRpbWUsIHBhdGNoaW5nIGl0cyBlbGVtZW50XG4gICAqIHRocm91Z2ggaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGNhbGxzLiBJZiB0aGUgZmlyc3QgYXJnIGlzIGEgZnVuY3Rpb25cbiAgICogaW5zdGVhZCBvZiBhIGNvbXBvbmVudCBpbnN0YW5jZSwgY3JlYXRlcyBhbmQgcmVuZGVycyB0aGlzIGZ1bmN0aW9uLCB3aGljaFxuICAgKiBjYW4gZWl0aGVyIGJlIGEgc2ltcGxlIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbiBvciBhIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHshQ29tcG9uZW50fGZ1bmN0aW9uKCl9IGNvbXBvbmVudCBDYW4gYmUgYSBjb21wb25lbnQgaW5zdGFuY2UsIGFcbiAgICogICAgIHNpbXBsZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gb3IgYSBjb21wb25lbnQgY29uc3RydWN0b3IuXG4gICAqIEBwYXJhbSB7T2JqZWN0fEVsZW1lbnQ9fSBvcHRfZGF0YU9yRWxlbWVudCBPcHRpb25hbCBjb25maWcgZGF0YSBmb3IgdGhlXG4gICAqICAgICBmdW5jdGlvbiwgb3IgcGFyZW50IGZvciB0aGUgcmVuZGVyZWQgY29udGVudC5cbiAgICogQHBhcmFtIHtFbGVtZW50PX0gb3B0X3BhcmVudCBPcHRpb25hbCBwYXJlbnQgZm9yIHRoZSByZW5kZXJlZCBjb250ZW50LlxuICAgKiBAcmV0dXJuIHshQ29tcG9uZW50fSBUaGUgcmVuZGVyZWQgY29tcG9uZW50J3MgaW5zdGFuY2UuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoY29tcG9uZW50LCBvcHRfZGF0YU9yRWxlbWVudCwgb3B0X3BhcmVudCkge1xuXHRcdFx0aWYgKGNvbXBvbmVudCBpbnN0YW5jZW9mIF9tZXRhbENvbXBvbmVudC5Db21wb25lbnQpIHtcblx0XHRcdFx0dGhpcy5wYXRjaChjb21wb25lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuICgwLCBfcmVuZGVyLnJlbmRlckZ1bmN0aW9uKSh0aGlzLCBjb21wb25lbnQsIG9wdF9kYXRhT3JFbGVtZW50LCBvcHRfcGFyZW50KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gY2hpbGQgbm9kZSB2aWEgaXRzIG93bmVyIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNoaWxkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJDaGlsZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNoaWxkKGNoaWxkKSB7XG5cdFx0XHQoMCwgX3JlbmRlci5yZW5kZXJDaGlsZCkoY2hpbGQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxscyBmdW5jdGlvbnMgZnJvbSBgSW5jcmVtZW50YWxET01gIHRvIGJ1aWxkIHRoZSBjb21wb25lbnQgZWxlbWVudCdzXG4gICAqIGNvbnRlbnQuIENhbiBiZSBvdmVycmlkZW4gYnkgc3ViY2xhc3NlcyAoZm9yIGludGVncmF0aW9uIHdpdGggdGVtcGxhdGVcbiAgICogZW5naW5lcyBmb3IgZXhhbXBsZSkuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJJbmNEb20nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJJbmNEb20oY29tcG9uZW50KSB7XG5cdFx0XHRpZiAoY29tcG9uZW50LnJlbmRlcikge1xuXHRcdFx0XHRjb21wb25lbnQucmVuZGVyKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRJbmNyZW1lbnRhbERPTS5lbGVtZW50Vm9pZCgnZGl2Jyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJ1bnMgdGhlIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbnMgZm9yIHJlbmRlcmluZyB0aGlzIGNvbXBvbmVudCwgd2l0aG91dFxuICAgKiBjYWxsaW5nIGBwYXRjaGAuIFRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgY2FsbGVkIGluc2lkZSBhIGBwYXRjaGAuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW5kZXJJbnNpZGVQYXRjaCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlckluc2lkZVBhdGNoKGNvbXBvbmVudCkge1xuXHRcdFx0dmFyIHNob3VsZFJlbmRlciA9ICFjb21wb25lbnQud2FzUmVuZGVyZWQgfHwgdGhpcy5zaG91bGRVcGRhdGUoY29tcG9uZW50LCAoMCwgX2NoYW5nZXMuZ2V0Q2hhbmdlcykoY29tcG9uZW50KSkgfHwgSW5jcmVtZW50YWxET00uY3VycmVudFBvaW50ZXIoKSAhPT0gY29tcG9uZW50LmVsZW1lbnQ7XG5cdFx0XHRpZiAoc2hvdWxkUmVuZGVyKSB7XG5cdFx0XHRcdCgwLCBfcmVuZGVyLnJlbmRlcikoY29tcG9uZW50KTtcblx0XHRcdH0gZWxzZSBpZiAoY29tcG9uZW50LmVsZW1lbnQpIHtcblx0XHRcdFx0dGhpcy5za2lwUmVuZGVyKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdXAgdGhpcyBjb21wb25lbnQgdG8gYmUgdXNlZCBieSB0aGlzIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VXAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRVcChjb21wb25lbnQpIHtcblx0XHRcdGNvbXBvbmVudC5jb250ZXh0ID0ge307XG5cdFx0XHRjb21wb25lbnQuY29tcG9uZW50cyA9IHt9O1xuXHRcdFx0Y29tcG9uZW50LnJlZnMgPSB7fTtcblxuXHRcdFx0dmFyIGRhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KTtcblx0XHRcdGRhdGEuY29uZmlnID0gY29tcG9uZW50LmdldEluaXRpYWxDb25maWcoKTtcblx0XHRcdCgwLCBfY2hhbmdlcy50cmFja0NoYW5nZXMpKGNvbXBvbmVudCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUgY2hhbmdlcy5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Nob3VsZFVwZGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShjb21wb25lbnQsIGNoYW5nZXMpIHtcblx0XHRcdGlmICghY2hhbmdlcykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29tcG9uZW50LnNob3VsZFVwZGF0ZSkge1xuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50LnNob3VsZFVwZGF0ZS5hcHBseShjb21wb25lbnQsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmJ1aWxkU2hvdWxkVXBkYXRlQXJncyhjaGFuZ2VzKSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNraXBzIHRoZSBuZXh0IGRpc3Bvc2FsIG9mIGNoaWxkcmVuIGNvbXBvbmVudHMsIGJ5IGNsZWFyaW5nIHRoZSBhcnJheSBhc1xuICAgKiBpZiB0aGVyZSB3ZXJlIG5vIGNoaWxkcmVuIHJlbmRlcmVkIHRoZSBsYXN0IHRpbWUuIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgICogYWxsb3dpbmcgY29tcG9uZW50cyB0byBiZSByZXVzZWQgYnkgb3RoZXIgcGFyZW50IGNvbXBvbmVudHMgaW4gc2VwYXJhdGVcbiAgICogcmVuZGVyIHVwZGF0ZSBjeWNsZXMuXG4gICAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdza2lwTmV4dENoaWxkcmVuRGlzcG9zYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBza2lwTmV4dENoaWxkcmVuRGlzcG9zYWwoY29tcG9uZW50KSB7XG5cdFx0XHQoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KS5jaGlsZENvbXBvbmVudHMgPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTa2lwcyByZW5kZXJpbmcgdGhlIGN1cnJlbnQgbm9kZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NraXBSZW5kZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBza2lwUmVuZGVyKCkge1xuXHRcdFx0SW5jcmVtZW50YWxET00uc2tpcE5vZGUoKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZXIncyBjb21wb25lbnQgd2hlbiBzdGF0ZSBjaGFuZ2VzLCBwYXRjaGluZyBpdHMgZWxlbWVudFxuICAgKiB0aHJvdWdoIGluY3JlbWVudGFsIGRvbSBmdW5jdGlvbiBjYWxscy5cbiAgICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3VwZGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShjb21wb25lbnQpIHtcblx0XHRcdGlmICh0aGlzLnNob3VsZFVwZGF0ZShjb21wb25lbnQsICgwLCBfY2hhbmdlcy5nZXRDaGFuZ2VzKShjb21wb25lbnQpKSkge1xuXHRcdFx0XHR0aGlzLnBhdGNoKGNvbXBvbmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEluY3JlbWVudGFsRG9tUmVuZGVyZXI7XG59KF9tZXRhbENvbXBvbmVudC5Db21wb25lbnRSZW5kZXJlci5jb25zdHJ1Y3Rvcik7XG5cbnZhciByZW5kZXJlciA9IG5ldyBJbmNyZW1lbnRhbERvbVJlbmRlcmVyKCk7XG5cbi8vIE5hbWUgb2YgdGhpcyByZW5kZXJlci4gUmVuZGVyZXJzIHNob3VsZCBwcm92aWRlIHRoaXMgYXMgYSB3YXkgdG8gaWRlbnRpZnlcbi8vIHRoZW0gdmlhIGEgc2ltcGxlIHN0cmluZyAod2hlbiBjYWxsaW5nIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlIHRvIGFkZFxuLy8gc3VwcG9ydCB0byBvbGQgZmVhdHVyZXMgZm9yIHNwZWNpZmljIHJlbmRlcmVycyBmb3IgZXhhbXBsZSkuXG5yZW5kZXJlci5SRU5ERVJFUl9OQU1FID0gJ2luY3JlbWVudGFsLWRvbSc7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHJlbmRlcmVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvSW5jcmVtZW50YWxEb21SZW5kZXJlci5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2luY3JlbWVudGFsRG9tID0gcmVxdWlyZSgnaW5jcmVtZW50YWwtZG9tJyk7XG5cbnZhciBJbmNyZW1lbnRhbERPTSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmNyZW1lbnRhbERvbSk7XG5cbnZhciBfaW5jcmVtZW50YWxEb21TdHJpbmcgPSByZXF1aXJlKCdpbmNyZW1lbnRhbC1kb20tc3RyaW5nJyk7XG5cbnZhciBJbmNyZW1lbnRhbERPTVN0cmluZyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9pbmNyZW1lbnRhbERvbVN0cmluZyk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5pZiAoKDAsIF9tZXRhbC5pc1NlcnZlclNpZGUpKCkpIHtcblx0Ly8gT3ZlcnJpZGVzIGdsb2JhbC5JbmNyZW1lbnRhbERPTSB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggaW5jcmVtZW50YWwgZG9tXG5cdC8vIHN0cmluZyBpbXBsZW1lbnRhdGlvbiBmb3Igc2VydmVyIHNpZGUgcmVuZGVyaW5nLiBBdCB0aGUgbW9tZW50IGl0IGRvZXMgbm90XG5cdC8vIG92ZXJyaWRlIGZvciBOb2RlLmpzIHRlc3RzIHNpbmNlIHRlc3RzIGFyZSB1c2luZyBqc2RvbSB0byBzaW11bGF0ZSB0aGVcblx0Ly8gYnJvd3Nlci5cblx0Z2xvYmFsLkluY3JlbWVudGFsRE9NID0gSW5jcmVtZW50YWxET01TdHJpbmc7XG59IGVsc2Uge1xuXHR2YXIgc2NvcGUgPSB0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3c7XG5cblx0c2NvcGUuSW5jcmVtZW50YWxET00gPSBJbmNyZW1lbnRhbERPTTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbGliL2luY3JlbWVudGFsLWRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xlYXJDaGFuZ2VzID0gY2xlYXJDaGFuZ2VzO1xuZXhwb3J0cy5nZXRDaGFuZ2VzID0gZ2V0Q2hhbmdlcztcbmV4cG9ydHMudHJhY2tDaGFuZ2VzID0gdHJhY2tDaGFuZ2VzO1xuXG52YXIgX2RhdGEgPSByZXF1aXJlKCcuL2RhdGEnKTtcblxuLyoqXG4gKiBDbGVhcnMgdGhlIGNoYW5nZXMgdHJhY2tlZCBzbyBmYXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IGRhdGFcbiAqL1xuZnVuY3Rpb24gY2xlYXJDaGFuZ2VzKGRhdGEpIHtcbiAgZGF0YS5jaGFuZ2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBgc3RhdGVLZXlDaGFuZ2VkYCBldmVudCBmcm9tIGEgY29tcG9uZW50LiBTdG9yZXMgY2hhbmdlIGRhdGEuXG4gKiBAcGFyYW0geyFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7IU9iamVjdH0gZXZlbnREYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVTdGF0ZUtleUNoYW5nZWRfKGRhdGEsIGV2ZW50RGF0YSkge1xuICBkYXRhLmNoYW5nZXMgPSBkYXRhLmNoYW5nZXMgfHwge307XG4gIHZhciB0eXBlID0gZXZlbnREYXRhLnR5cGUgfHwgJ3Byb3BzJztcbiAgZGF0YS5jaGFuZ2VzW3R5cGVdID0gZGF0YS5jaGFuZ2VzW3R5cGVdIHx8IHt9O1xuICBkYXRhLmNoYW5nZXNbdHlwZV1bZXZlbnREYXRhLmtleV0gPSBldmVudERhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjaGFuZ2VzIGluIHRoZSBnaXZlbiBjb21wb25lbnQgc2luY2UgdGhlIGxhc3QgdGltZSxcbiAqIG9yIG51bGwgaWYgdGhlcmUgd2VyZW4ndCBhbnkuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDaGFuZ2VzKGNvbXBvbmVudCkge1xuICByZXR1cm4gKDAsIF9kYXRhLmdldERhdGEpKGNvbXBvbmVudCkuY2hhbmdlcztcbn1cblxuLyoqXG4gKiBTdGFydHMgdHJhY2tpbmcgY2hhbmdlcyBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudFxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gdHJhY2tDaGFuZ2VzKGNvbXBvbmVudCkge1xuICB2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuICBjb21wb25lbnQub24oJ3N0YXRlS2V5Q2hhbmdlZCcsIGhhbmRsZVN0YXRlS2V5Q2hhbmdlZF8uYmluZChudWxsLCBkYXRhKSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9jaGFuZ2VzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkNISUxEX09XTkVSID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5jYXB0dXJlQ2hpbGRyZW4gPSBjYXB0dXJlQ2hpbGRyZW47XG5leHBvcnRzLmlzQ2hpbGRUYWcgPSBpc0NoaWxkVGFnO1xuZXhwb3J0cy5nZXRPd25lciA9IGdldE93bmVyO1xuZXhwb3J0cy5yZW5kZXJDaGlsZFRyZWUgPSByZW5kZXJDaGlsZFRyZWU7XG5cbnZhciBfY2FsbEFyZ3MgPSByZXF1aXJlKCcuLi9jYWxsQXJncycpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9pbmNyZW1lbnRhbERvbUFvcCA9IHJlcXVpcmUoJy4uL2luY3JlbWVudGFsLWRvbS1hb3AnKTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBQcm9wZXJ0eSBpZGVudGlmeWluZyBhIHNwZWNpZmljIG9iamVjdCBhcyBhIE1ldGFsLmpzIGNoaWxkIG5vZGUsIGFuZFxuICogcG9pbnRpbmcgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSB0aGF0IGNyZWF0ZWQgaXQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgQ0hJTERfT1dORVIgPSBleHBvcnRzLkNISUxEX09XTkVSID0gJ19fbWV0YWxDaGlsZE93bmVyJztcblxuLyoqXG4gKiBDYXB0dXJlcyBhbGwgY2hpbGQgZWxlbWVudHMgZnJvbSBpbmNyZW1lbnRhbCBkb20gY2FsbHMuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRoYXQgaXMgY2FwdHVyaW5nIGNoaWxkcmVuLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gY2hpbGRyZW4gaGF2ZSBhbGxcbiAqICAgICBiZWVuIGNhcHR1cmVkLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGNhbGxpbmcgaXQuXG4gKi9cbmZ1bmN0aW9uIGNhcHR1cmVDaGlsZHJlbihjb21wb25lbnQsIGNhbGxiYWNrLCBkYXRhKSB7XG5cdG93bmVyXyA9IGNvbXBvbmVudDtcblx0Y2FsbGJhY2tfID0gY2FsbGJhY2s7XG5cdGNhbGxiYWNrRGF0YV8gPSBkYXRhO1xuXHR0cmVlXyA9IHtcblx0XHRwcm9wczoge1xuXHRcdFx0Y2hpbGRyZW46IFtdXG5cdFx0fVxuXHR9O1xuXHR0cmVlXy5jb25maWcgPSB0cmVlXy5wcm9wcztcblx0Y3VycmVudFBhcmVudF8gPSB0cmVlXztcblx0aXNDYXB0dXJpbmdfID0gdHJ1ZTtcblx0KDAsIF9pbmNyZW1lbnRhbERvbUFvcC5zdGFydEludGVyY2VwdGlvbikoe1xuXHRcdGVsZW1lbnRDbG9zZTogaGFuZGxlSW50ZXJjZXB0ZWRDbG9zZUNhbGxfLFxuXHRcdGVsZW1lbnRPcGVuOiBoYW5kbGVJbnRlcmNlcHRlZE9wZW5DYWxsXyxcblx0XHR0ZXh0OiBoYW5kbGVJbnRlcmNlcHRlZFRleHRDYWxsX1xuXHR9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRhZyB3YXMgYnVpbHQgZnJvbSBhIGNvbXBvbmVudCdzIGNoaWxkcmVuLlxuICogQHBhcmFtIHsqfSB0YWdcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2hpbGRUYWcodGFnKSB7XG5cdHJldHVybiAoMCwgX21ldGFsLmlzRGVmKSh0YWcudGFnKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBub2RlJ3Mgb3JpZ2luYWwgb3duZXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0T3duZXIobm9kZSkge1xuXHRyZXR1cm4gbm9kZVtDSElMRF9PV05FUl07XG59XG5cbi8qKlxuICogUmVuZGVycyBhIGNoaWxkcmVuIHRyZWUgdGhyb3VnaCBpbmNyZW1lbnRhbCBkb20uXG4gKiBAcGFyYW0geyF7YXJnczogQXJyYXksIGNoaWxkcmVuOiAhQXJyYXksIGlzVGV4dDogP2Jvb2xlYW59fVxuICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X3NraXBOb2RlIE9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIGZvclxuICogICAgIGVhY2ggbm9kZSB0byBiZSByZW5kZXJlZC4gSWYgaXQgcmV0dXJucyB0cnVlLCB0aGUgbm9kZSB3aWxsIGJlIHNraXBwZWQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNoaWxkVHJlZSh0cmVlLCBvcHRfc2tpcE5vZGUpIHtcblx0aWYgKGlzQ2FwdHVyaW5nXykge1xuXHRcdC8vIElmIGNhcHR1cmluZywganVzdCBhZGQgdGhlIG5vZGUgZGlyZWN0bHkgdG8gdGhlIGNhcHR1cmVkIHRyZWUuXG5cdFx0YWRkQ2hpbGRUb1RyZWUodHJlZSk7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKG9wdF9za2lwTm9kZSAmJiBvcHRfc2tpcE5vZGUuY2FsbChudWxsLCB0cmVlKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICgoMCwgX21ldGFsLmlzRGVmKSh0cmVlLnRleHQpKSB7XG5cdFx0dmFyIGFyZ3MgPSB0cmVlLmFyZ3MgPyB0cmVlLmFyZ3MgOiBbXTtcblx0XHRhcmdzWzBdID0gdHJlZS50ZXh0O1xuXHRcdEluY3JlbWVudGFsRE9NLnRleHQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIF9hcmdzID0gKDAsIF9jYWxsQXJncy5idWlsZENhbGxGcm9tQ29uZmlnKSh0cmVlLnRhZywgdHJlZS5wcm9wcyk7XG5cdFx0X2FyZ3NbMF0gPSB7XG5cdFx0XHR0YWc6IF9hcmdzWzBdLFxuXHRcdFx0b3duZXI6IGdldE93bmVyKHRyZWUpXG5cdFx0fTtcblx0XHRJbmNyZW1lbnRhbERPTS5lbGVtZW50T3Blbi5hcHBseShudWxsLCBfYXJncyk7XG5cdFx0aWYgKHRyZWUucHJvcHMuY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5wcm9wcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRyZW5kZXJDaGlsZFRyZWUodHJlZS5wcm9wcy5jaGlsZHJlbltpXSwgb3B0X3NraXBOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0SW5jcmVtZW50YWxET00uZWxlbWVudENsb3NlKHRyZWUudGFnKTtcblx0fVxufVxuXG52YXIgY2FsbGJhY2tEYXRhXyA9IHZvaWQgMDtcbnZhciBjYWxsYmFja18gPSB2b2lkIDA7XG52YXIgY3VycmVudFBhcmVudF8gPSB2b2lkIDA7XG52YXIgaXNDYXB0dXJpbmdfID0gZmFsc2U7XG52YXIgb3duZXJfID0gdm9pZCAwO1xudmFyIHRyZWVfID0gdm9pZCAwO1xuXG4vKipcbiAqIEFkZHMgYSBjaGlsZCBlbGVtZW50IHRvIHRoZSB0cmVlLlxuICogQHBhcmFtIHshQXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGluY3JlbWVudGFsIGRvbSBjYWxsLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzVGV4dCBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNoaWxkIGlzIGFcbiAqICAgICB0ZXh0IGVsZW1lbnQuXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGFkZENoaWxkQ2FsbFRvVHJlZV8oYXJncywgb3B0X2lzVGV4dCkge1xuXHR2YXIgY2hpbGQgPSBfZGVmaW5lUHJvcGVydHkoe1xuXHRcdHBhcmVudDogY3VycmVudFBhcmVudF9cblx0fSwgQ0hJTERfT1dORVIsIG93bmVyXyk7XG5cblx0aWYgKG9wdF9pc1RleHQpIHtcblx0XHRjaGlsZC50ZXh0ID0gYXJnc1swXTtcblx0XHRpZiAoYXJncy5sZW5ndGggPiAxKSB7XG5cdFx0XHRjaGlsZC5hcmdzID0gYXJncztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Y2hpbGQudGFnID0gYXJnc1swXTtcblx0XHRjaGlsZC5wcm9wcyA9ICgwLCBfY2FsbEFyZ3MuYnVpbGRDb25maWdGcm9tQ2FsbCkoYXJncyk7XG5cdFx0Y2hpbGQucHJvcHMuY2hpbGRyZW4gPSBbXTtcblx0XHRjaGlsZC5jb25maWcgPSBjaGlsZC5wcm9wcztcblx0fVxuXG5cdGFkZENoaWxkVG9UcmVlKGNoaWxkKTtcblx0cmV0dXJuIGNoaWxkO1xufVxuXG5mdW5jdGlvbiBhZGRDaGlsZFRvVHJlZShjaGlsZCkge1xuXHRjdXJyZW50UGFyZW50Xy5wcm9wcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50Q2xvc2VgIGZ1bmN0aW9uIGZyb20gaW5jcmVtZW50YWxcbiAqIGRvbS5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRDbG9zZUNhbGxfKCkge1xuXHRpZiAoY3VycmVudFBhcmVudF8gPT09IHRyZWVfKSB7XG5cdFx0KDAsIF9pbmNyZW1lbnRhbERvbUFvcC5zdG9wSW50ZXJjZXB0aW9uKSgpO1xuXHRcdGlzQ2FwdHVyaW5nXyA9IGZhbHNlO1xuXHRcdHZhciBub2RlID0gY2FsbGJhY2tfLmNhbGwob3duZXJfLCB0cmVlXywgY2FsbGJhY2tEYXRhXyk7XG5cdFx0Y2FsbGJhY2tfID0gbnVsbDtcblx0XHRjYWxsYmFja0RhdGFfID0gbnVsbDtcblx0XHRjdXJyZW50UGFyZW50XyA9IG51bGw7XG5cdFx0b3duZXJfID0gbnVsbDtcblx0XHR0cmVlXyA9IG51bGw7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0gZWxzZSB7XG5cdFx0Y3VycmVudFBhcmVudF8gPSBjdXJyZW50UGFyZW50Xy5wYXJlbnQ7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbFxuICogZG9tLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gb3JpZ2luYWxGbiBUaGUgb3JpZ2luYWwgZnVuY3Rpb24gYmVmb3JlIGludGVyY2VwdGlvbi5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF8oKSB7XG5cdGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdFx0YXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0fVxuXG5cdGN1cnJlbnRQYXJlbnRfID0gYWRkQ2hpbGRDYWxsVG9UcmVlXyhhcmdzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGB0ZXh0YCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsIGRvbS5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IG9yaWdpbmFsRm4gVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGJlZm9yZSBpbnRlcmNlcHRpb24uXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUludGVyY2VwdGVkVGV4dENhbGxfKCkge1xuXHRmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHRcdGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0fVxuXG5cdGFkZENoaWxkQ2FsbFRvVHJlZV8oYXJncywgdHJ1ZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9jaGlsZHJlbi9jaGlsZHJlbi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEJ1aWxkcyB0aGUgY29tcG9uZW50IGNvbmZpZyBvYmplY3QgZnJvbSBpdHMgaW5jcmVtZW50YWwgZG9tIGNhbGwnc1xuICogYXJndW1lbnRzLlxuICogQHBhcmFtIHshQXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4geyFPYmplY3R9XG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYnVpbGRDb25maWdGcm9tQ2FsbCA9IGJ1aWxkQ29uZmlnRnJvbUNhbGw7XG5leHBvcnRzLmJ1aWxkQ2FsbEZyb21Db25maWcgPSBidWlsZENhbGxGcm9tQ29uZmlnO1xuZnVuY3Rpb24gYnVpbGRDb25maWdGcm9tQ2FsbChhcmdzKSB7XG5cdHZhciBjb25maWcgPSB7fTtcblx0aWYgKGFyZ3NbMV0pIHtcblx0XHRjb25maWcua2V5ID0gYXJnc1sxXTtcblx0fVxuXHR2YXIgYXR0cnNBcnIgPSAoYXJnc1syXSB8fCBbXSkuY29uY2F0KGFyZ3Muc2xpY2UoMykpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJzQXJyLmxlbmd0aDsgaSArPSAyKSB7XG5cdFx0Y29uZmlnW2F0dHJzQXJyW2ldXSA9IGF0dHJzQXJyW2kgKyAxXTtcblx0fVxuXHRyZXR1cm4gY29uZmlnO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhbiBpbmNyZW1lbnRhbCBkb20gY2FsbCBhcnJheSBmcm9tIHRoZSBnaXZlbiB0YWcgYW5kIGNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbmZpZ1xuICogQHJldHVybiB7IUFycmF5fVxuICovXG5mdW5jdGlvbiBidWlsZENhbGxGcm9tQ29uZmlnKHRhZywgY29uZmlnKSB7XG5cdHZhciBjYWxsID0gW3RhZywgY29uZmlnLmtleSwgW11dO1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZyk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmIChrZXlzW2ldICE9PSAnY2hpbGRyZW4nICYmIGtleXNbaV0gIT09ICdrZXknKSB7XG5cdFx0XHRjYWxsLnB1c2goa2V5c1tpXSwgY29uZmlnW2tleXNbaV1dKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGNhbGw7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL2xpYi9jYWxsQXJncy5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5leHBvcnRzLmdldENvbXBvbmVudEJlaW5nUmVuZGVyZWQgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkO1xuZXhwb3J0cy5pc0NvbXBvbmVudFRhZ18gPSBpc0NvbXBvbmVudFRhZ187XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMucmVuZGVyQ2hpbGQgPSByZW5kZXJDaGlsZDtcbmV4cG9ydHMucmVuZGVyRnVuY3Rpb24gPSByZW5kZXJGdW5jdGlvbjtcblxudmFyIF9hdHRyaWJ1dGVzID0gcmVxdWlyZSgnLi9hdHRyaWJ1dGVzJyk7XG5cbnZhciBfY2FsbEFyZ3MgPSByZXF1aXJlKCcuLi9jYWxsQXJncycpO1xuXG52YXIgX2NoaWxkcmVuID0gcmVxdWlyZSgnLi4vY2hpbGRyZW4vY2hpbGRyZW4nKTtcblxudmFyIF9jaGFuZ2VzID0gcmVxdWlyZSgnLi4vY2hhbmdlcycpO1xuXG52YXIgX21ldGFsRG9tID0gcmVxdWlyZSgnbWV0YWwtZG9tJyk7XG5cbnZhciBfZGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfdW51c2VkID0gcmVxdWlyZSgnLi4vY2xlYW51cC91bnVzZWQnKTtcblxudmFyIF9pbmNyZW1lbnRhbERvbUFvcCA9IHJlcXVpcmUoJy4uL2luY3JlbWVudGFsLWRvbS1hb3AnKTtcblxudmFyIF9tZXRhbENvbXBvbmVudCA9IHJlcXVpcmUoJ21ldGFsLWNvbXBvbmVudCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciByZW5kZXJpbmdDb21wb25lbnRzXyA9IFtdO1xudmFyIGVtcHR5Q2hpbGRyZW5fID0gW107XG5cbi8qKlxuICogQWRkcyB0aGUgZ2l2ZW4gY3NzIGNsYXNzZXMgdG8gdGhlIHNwZWNpZmllZCBhcmd1bWVudHMgZm9yIGFuIGluY3JlbWVudGFsXG4gKiBkb20gY2FsbCwgbWVyZ2luZyB3aXRoIHRoZSBleGlzdGluZyB2YWx1ZSBpZiB0aGVyZSBpcyBvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudENsYXNzZXNcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRFbGVtZW50Q2xhc3Nlc18oZWxlbWVudENsYXNzZXMsIGNvbmZpZykge1xuXHRpZiAoY29uZmlnLmNsYXNzKSB7XG5cdFx0Y29uZmlnLmNsYXNzICs9ICcgJyArIGVsZW1lbnRDbGFzc2VzO1xuXHRcdGNvbmZpZy5jbGFzcyA9IHJlbW92ZUR1cGxpY2F0ZUNsYXNzZXNfKGNvbmZpZy5jbGFzcyk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZmlnLmNsYXNzID0gZWxlbWVudENsYXNzZXM7XG5cdH1cbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIFwiY2hpbGRyZW5cIiBhcnJheSB0byBiZSBwYXNzZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHshQXJyYXk8IU9iamVjdD59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHshQXJyYXk8IU9iamVjdD59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWlsZENoaWxkcmVuXyhjaGlsZHJlbikge1xuXHRyZXR1cm4gY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gZW1wdHlDaGlsZHJlbl8gOiBjaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgcmVuZGVyIG9wZXJhdGlvbiwgZG9pbmcgc29tZSBjbGVhdXBzLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBSZW5kZXJfKGNvbXBvbmVudCkge1xuXHQoMCwgX2luY3JlbWVudGFsRG9tQW9wLnN0b3BJbnRlcmNlcHRpb24pKCk7XG5cdGlmICghKDAsIF9kYXRhLmdldERhdGEpKGNvbXBvbmVudCkucm9vdEVsZW1lbnRSZWFjaGVkKSB7XG5cdFx0Y29tcG9uZW50LmVsZW1lbnQgPSBudWxsO1xuXHR9XG5cdGNvbXBvbmVudC5pbmZvcm1SZW5kZXJlZCgpO1xuXHRmaW5pc2hlZFJlbmRlcmluZ0NvbXBvbmVudF8oKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBtb3N0IHJlY2VudCBjb21wb25lbnQgZnJvbSB0aGUgcXVldWUgb2YgcmVuZGVyaW5nIGNvbXBvbmVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmaW5pc2hlZFJlbmRlcmluZ0NvbXBvbmVudF8oKSB7XG5cdHJlbmRlcmluZ0NvbXBvbmVudHNfLnBvcCgpO1xuXHRpZiAocmVuZGVyaW5nQ29tcG9uZW50c18ubGVuZ3RoID09PSAwKSB7XG5cdFx0KDAsIF91bnVzZWQuZGlzcG9zZVVudXNlZCkoKTtcblx0fVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBmb3IgdGhlIG5leHQgZWxlbWVudCB0byBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0gez9zdHJpbmd9IGtleSBUaGUga2V5IG9yaWdpbmFsbHkgcGFzc2VkIHRvIHRoZSBlbGVtZW50LlxuICogQHJldHVybiB7P3N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5Xyhjb21wb25lbnQsIGtleSkge1xuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRpZiAoIWRhdGEucm9vdEVsZW1lbnRSZWFjaGVkICYmIGRhdGEuY29uZmlnLmtleSkge1xuXHRcdGtleSA9IGRhdGEuY29uZmlnLmtleTtcblx0fVxuXHRyZXR1cm4gY29tcG9uZW50LmdldFJlbmRlcmVyKCkuZ2VuZXJhdGVLZXkoY29tcG9uZW50LCBrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNoaWxkIGNvbXBvbmVudHMgc3RvcmVkIGluIHRoZSBnaXZlbiBvYmplY3QuXG4gKiBAcGFyYW0geyFPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4geyFBcnJheTwhQ29tcG9uZW50Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldENoaWxkQ29tcG9uZW50c18oZGF0YSkge1xuXHRkYXRhLmNoaWxkQ29tcG9uZW50cyA9IGRhdGEuY2hpbGRDb21wb25lbnRzIHx8IFtdO1xuXHRyZXR1cm4gZGF0YS5jaGlsZENvbXBvbmVudHM7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY29tcG9uZW50IGJlaW5nIGN1cnJlbnRseSByZW5kZXJlZC5cbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50QmVpbmdSZW5kZXJlZCgpIHtcblx0cmV0dXJuIHJlbmRlcmluZ0NvbXBvbmVudHNfW3JlbmRlcmluZ0NvbXBvbmVudHNfLmxlbmd0aCAtIDFdO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGN1cnJlbnRseSB1c2VkLiBUaGlzIG9iamVjdCB3aWxsIGVpdGhlclxuICogY29tZSBmcm9tIHRoZSBjdXJyZW50IGVsZW1lbnQgYmVpbmcgcmVuZGVyZWQgYnkgaW5jcmVtZW50YWwgZG9tIG9yIGZyb21cbiAqIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgYmVpbmcgcmVuZGVyZWQgKG9ubHkgd2hlbiB0aGUgY3VycmVudCBlbGVtZW50IGlzIHRoZVxuICogY29tcG9uZW50J3MgZGlyZWN0IHBhcmVudCkuXG4gKiBAcmV0dXJuIHshT2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudERhdGEoKSB7XG5cdHZhciBlbGVtZW50ID0gSW5jcmVtZW50YWxET00uY3VycmVudEVsZW1lbnQoKTtcblx0dmFyIGNvbXAgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCk7XG5cdHZhciBvYmogPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCk7XG5cdGlmIChvYmoucm9vdEVsZW1lbnRSZWFjaGVkICYmIGVsZW1lbnQgIT09IGNvbXAuZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0b2JqID0gX21ldGFsRG9tLmRvbURhdGEuZ2V0KGVsZW1lbnQpO1xuXHR9XG5cdG9iai5pY0NvbXBvbmVudHNEYXRhID0gb2JqLmljQ29tcG9uZW50c0RhdGEgfHwge307XG5cdHJldHVybiBvYmouaWNDb21wb25lbnRzRGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBcInJlZlwiIHRvIGJlIHVzZWQgZm9yIGEgY29tcG9uZW50LiBVc2VzIFwia2V5XCIgYXMgXCJyZWZcIiB3aGVuXG4gKiBjb21wYXRpYmlsaXR5IG1vZGUgaXMgb24gZm9yIHRoZSBjdXJyZW50IHJlbmRlcmVyLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBvd25lclxuICogQHBhcmFtIHshT2JqZWN0fSBjb25maWdcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRSZWZfKG93bmVyLCBjb25maWcpIHtcblx0dmFyIGNvbXBhdERhdGEgPSAoMCwgX21ldGFsLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSkoKTtcblx0aWYgKGNvbXBhdERhdGEpIHtcblx0XHR2YXIgb3duZXJSZW5kZXJlciA9IG93bmVyLmdldFJlbmRlcmVyKCk7XG5cdFx0dmFyIHJlbmRlcmVycyA9IGNvbXBhdERhdGEucmVuZGVyZXJzO1xuXHRcdHZhciB1c2VLZXkgPSAhcmVuZGVyZXJzIHx8IHJlbmRlcmVycy5pbmRleE9mKG93bmVyUmVuZGVyZXIpICE9PSAtMSB8fCByZW5kZXJlcnMuaW5kZXhPZihvd25lclJlbmRlcmVyLlJFTkRFUkVSX05BTUUpICE9PSAtMTtcblx0XHRpZiAodXNlS2V5ICYmIGNvbmZpZy5rZXkgJiYgIWNvbmZpZy5yZWYpIHtcblx0XHRcdHJldHVybiBjb25maWcua2V5O1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY29uZmlnLnJlZjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdWIgY29tcG9uZW50IHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHRhZyBhbmQgY29uZmlnIGRhdGEsXG4gKiBjcmVhdGluZyBpdCBpZiBpdCBkb2Vzbid0IHlldCBleGlzdC5cbiAqIEBwYXJhbSB7c3RyaW5nfCFGdW5jdGlvbn0gdGFnT3JDdG9yIFRoZSB0YWcgbmFtZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUgc3ViIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gb3duZXJcbiAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSBzdWIgY29tcG9uZW50LlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBnZXRTdWJDb21wb25lbnRfKHRhZ09yQ3RvciwgY29uZmlnLCBvd25lcikge1xuXHR2YXIgQ3RvciA9IHRhZ09yQ3Rvcjtcblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKEN0b3IpKSB7XG5cdFx0Q3RvciA9IF9tZXRhbENvbXBvbmVudC5Db21wb25lbnRSZWdpc3RyeS5nZXRDb25zdHJ1Y3Rvcih0YWdPckN0b3IpO1xuXHR9XG5cblx0dmFyIHJlZiA9IGdldFJlZl8ob3duZXIsIGNvbmZpZyk7XG5cdHZhciBjb21wID0gdm9pZCAwO1xuXHRpZiAoKDAsIF9tZXRhbC5pc0RlZikocmVmKSkge1xuXHRcdGNvbXAgPSBtYXRjaF8ob3duZXIuY29tcG9uZW50c1tyZWZdLCBDdG9yLCBjb25maWcsIG93bmVyKTtcblx0XHRvd25lci5jb21wb25lbnRzW3JlZl0gPSBjb21wO1xuXHRcdG93bmVyLnJlZnNbcmVmXSA9IGNvbXA7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGRhdGEgPSBnZXRDdXJyZW50RGF0YSgpO1xuXHRcdHZhciBrZXkgPSBjb25maWcua2V5O1xuXHRcdGlmICghKDAsIF9tZXRhbC5pc0RlZikoa2V5KSkge1xuXHRcdFx0dmFyIHR5cGUgPSAoMCwgX21ldGFsLmdldFVpZCkoQ3RvciwgdHJ1ZSk7XG5cdFx0XHRkYXRhLmN1cnJDb3VudCA9IGRhdGEuY3VyckNvdW50IHx8IHt9O1xuXHRcdFx0ZGF0YS5jdXJyQ291bnRbdHlwZV0gPSBkYXRhLmN1cnJDb3VudFt0eXBlXSB8fCAwO1xuXHRcdFx0a2V5ID0gJ19fTUVUQUxfSUNfXycgKyB0eXBlICsgJ18nICsgZGF0YS5jdXJyQ291bnRbdHlwZV0rKztcblx0XHR9XG5cdFx0Y29tcCA9IG1hdGNoXyhkYXRhLnByZXZDb21wcyA/IGRhdGEucHJldkNvbXBzW2tleV0gOiBudWxsLCBDdG9yLCBjb25maWcsIG93bmVyKTtcblx0XHRkYXRhLmN1cnJDb21wcyA9IGRhdGEuY3VyckNvbXBzIHx8IHt9O1xuXHRcdGRhdGEuY3VyckNvbXBzW2tleV0gPSBjb21wO1xuXHR9XG5cblx0cmV0dXJuIGNvbXA7XG59XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgZXZlbnQgb2YgY2hpbGRyZW4gaGF2aW5nIGZpbmlzaGVkIGJlaW5nIGNhcHR1cmVkLlxuICogQHBhcmFtIHshT2JqZWN0fSB0cmVlIFRoZSBjYXB0dXJlZCBjaGlsZHJlbiBpbiB0cmVlIGZvcm1hdC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUNoaWxkcmVuQ2FwdHVyZWRfKHRyZWUsIF9yZWYpIHtcblx0dmFyIHByb3BzID0gX3JlZi5wcm9wcyxcblx0ICAgIHRhZyA9IF9yZWYudGFnO1xuXG5cdHByb3BzLmNoaWxkcmVuID0gYnVpbGRDaGlsZHJlbl8odHJlZS5wcm9wcy5jaGlsZHJlbik7XG5cdHJldHVybiByZW5kZXJGcm9tVGFnXyh0YWcsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGEgY2hpbGQgYmVpbmcgcmVuZGVyZWQgdmlhIGBJbmNyZW1lbnRhbERvbUNoaWxkcmVuLnJlbmRlcmAuIFNraXBzXG4gKiBjb21wb25lbnQgbm9kZXMgc28gdGhhdCB0aGV5IGNhbiBiZSByZW5kZXJlZCB0aGUgY29ycmVjdCB3YXkgd2l0aG91dFxuICogaGF2aW5nIHRvIHJlY2FwdHVyZSBib3RoIHRoZW0gYW5kIHRoZWlyIGNoaWxkcmVuIHZpYSBpbmNyZW1lbnRhbCBkb20uXG4gKiBAcGFyYW0geyFPYmplY3R9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBoYW5kbGVDaGlsZFJlbmRlcl8obm9kZSkge1xuXHRpZiAobm9kZS50YWcgJiYgaXNDb21wb25lbnRUYWdfKG5vZGUudGFnKSkge1xuXHRcdG5vZGUucHJvcHMuY2hpbGRyZW4gPSBidWlsZENoaWxkcmVuXyhub2RlLnByb3BzLmNoaWxkcmVuKTtcblx0XHRyZW5kZXJGcm9tVGFnXyhub2RlLnRhZywgbm9kZS5wcm9wcywgKDAsIF9jaGlsZHJlbi5nZXRPd25lcikobm9kZSkpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogSGFuZGxlcyBhbiBpbnRlcmNlcHRlZCBjYWxsIHRvIHRoZSBhdHRyaWJ1dGVzIGRlZmF1bHQgaGFuZGxlciBmcm9tXG4gKiBpbmNyZW1lbnRhbCBkb20uXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRBdHRyaWJ1dGVzQ2FsbF8oZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcblx0KDAsIF9hdHRyaWJ1dGVzLmFwcGx5QXR0cmlidXRlKShnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCksIGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBIYW5kbGVzIGFuIGludGVyY2VwdGVkIGNhbGwgdG8gdGhlIGBlbGVtZW50T3BlbmAgZnVuY3Rpb24gZnJvbSBpbmNyZW1lbnRhbFxuICogZG9tLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF8odGFnKSB7XG5cdGlmIChpc0NvbXBvbmVudFRhZ18odGFnKSkge1xuXHRcdHJldHVybiBoYW5kbGVTdWJDb21wb25lbnRDYWxsXy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBoYW5kbGVSZWd1bGFyQ2FsbF8uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0fVxufVxuXG4vKipcbiAqIEhhbmRsZXMgYW4gaW50ZXJjZXB0ZWQgY2FsbCB0byB0aGUgYGVsZW1lbnRPcGVuYCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsXG4gKiBkb20sIGRvbmUgZm9yIGEgcmVndWxhciBlbGVtZW50LiBBbW9uZyBvdGhlciB0aGluZ3MsIGFkZHMgYW55IGlubGluZVxuICogbGlzdGVuZXJzIGZvdW5kIG9uIHRoZSBmaXJzdCByZW5kZXIgYW5kIG1ha2VzIHN1cmUgdGhhdCBjb21wb25lbnQgcm9vdFxuICogZWxlbWVudHMgYXJlIGFsd2F5cyByZXVzZWQuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IG93bmVyXG4gKiBAcGFyYW0geyFBcnJheX0gYXJnc1xuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSByZW5kZXJlZCBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlUmVndWxhckNhbGxfKCkge1xuXHRmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuXHRcdGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdH1cblxuXHR2YXIgY29uZmlnID0gKDAsIF9jYWxsQXJncy5idWlsZENvbmZpZ0Zyb21DYWxsKShhcmdzKTtcblx0dmFyIHRhZyA9IGFyZ3NbMF07XG5cblx0dmFyIGNvbXAgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCk7XG5cdHZhciBvd25lciA9IGNvbXA7XG5cdGlmICgoMCwgX2NoaWxkcmVuLmlzQ2hpbGRUYWcpKHRhZykpIHtcblx0XHRvd25lciA9IHRhZy5vd25lcjtcblx0XHR0YWcgPSB0YWcudGFnO1xuXHR9XG5cdGNvbmZpZy5rZXkgPSBnZW5lcmF0ZUtleV8oY29tcCwgY29uZmlnLmtleSk7XG5cblx0aWYgKCEoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCkucm9vdEVsZW1lbnRSZWFjaGVkKSB7XG5cdFx0dmFyIGVsZW1lbnRDbGFzc2VzID0gY29tcC5nZXREYXRhTWFuYWdlcigpLmdldChjb21wLCAnZWxlbWVudENsYXNzZXMnKTtcblx0XHRpZiAoZWxlbWVudENsYXNzZXMpIHtcblx0XHRcdGFkZEVsZW1lbnRDbGFzc2VzXyhlbGVtZW50Q2xhc3NlcywgY29uZmlnKTtcblx0XHR9XG5cdH1cblx0KDAsIF9hdHRyaWJ1dGVzLmNvbnZlcnRMaXN0ZW5lck5hbWVzVG9GbnMpKGNvbXAsIGNvbmZpZyk7XG5cblx0dmFyIGNhbGwgPSAoMCwgX2NhbGxBcmdzLmJ1aWxkQ2FsbEZyb21Db25maWcpKHRhZywgY29uZmlnKTtcblx0dmFyIG5vZGUgPSAoMCwgX2luY3JlbWVudGFsRG9tQW9wLmdldE9yaWdpbmFsRm4pKCdlbGVtZW50T3BlbicpLmFwcGx5KG51bGwsIGNhbGwpO1xuXHRyZXNldE5vZGVEYXRhXyhub2RlKTtcblx0dXBkYXRlRWxlbWVudElmTm90UmVhY2hlZF8oY29tcCwgbm9kZSk7XG5cblx0aWYgKCgwLCBfbWV0YWwuaXNEZWZBbmROb3ROdWxsKShjb25maWcucmVmKSkge1xuXHRcdG93bmVyLnJlZnNbY29uZmlnLnJlZl0gPSBub2RlO1xuXHR9XG5cdG93bmVyLmdldFJlbmRlcmVyKCkuaGFuZGxlTm9kZVJlbmRlcmVkKG5vZGUpO1xuXG5cdHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEhhbmRsZXMgYW4gaW50ZXJjZXB0ZWQgY2FsbCB0byB0aGUgYGVsZW1lbnRPcGVuYCBmdW5jdGlvbiBmcm9tIGluY3JlbWVudGFsXG4gKiBkb20sIGRvbmUgZm9yIGEgc3ViIGNvbXBvbmVudCBlbGVtZW50LiBDcmVhdGVzIGFuZCB1cGRhdGVzIHRoZSBhcHByb3ByaWF0ZVxuICogc3ViIGNvbXBvbmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVN1YkNvbXBvbmVudENhbGxfKCkge1xuXHRmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHRcdGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcblx0fVxuXG5cdCgwLCBfY2hpbGRyZW4uY2FwdHVyZUNoaWxkcmVuKShnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCksIGhhbmRsZUNoaWxkcmVuQ2FwdHVyZWRfLCB7XG5cdFx0cHJvcHM6ICgwLCBfY2FsbEFyZ3MuYnVpbGRDb25maWdGcm9tQ2FsbCkoYXJncyksXG5cdFx0dGFnOiBhcmdzWzBdXG5cdH0pO1xufVxuXG4vKipcbiAqIFBhc3NlcyBkb3duIGVsZW1lbnRDbGFzc2VzIHRvIGEgY2hpbGQgY29tcG9uZW50IGlmIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gKiByZXR1cm5zIGFub3RoZXIgY29tcG9uZW50IGF0IHRoZSB0b3AgbGV2ZWwgKEhPQykuXG4gKiBAcGFyYW0geyp9IHBhcmVudCBUaGUgcGFyZW50IGNvbXBvbmVudFxuICogQHBhcmFtIHsqfSBjb25maWcgVGhlIGNvbmZpZyBvZiB0aGUgc3ViY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIGluaGVyaXRFbGVtZW50Q2xhc3Nlc18ocGFyZW50LCBjb25maWcpIHtcblx0dmFyIHBhcmVudERhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkocGFyZW50KTtcblx0dmFyIHBhcmVudENvbmZpZyA9IHBhcmVudERhdGEuY29uZmlnO1xuXG5cdGlmICghcGFyZW50RGF0YS5yb290RWxlbWVudFJlYWNoZWQgJiYgcGFyZW50Q29uZmlnICYmICgwLCBfbWV0YWwuaXNTdHJpbmcpKHBhcmVudENvbmZpZy5lbGVtZW50Q2xhc3NlcykpIHtcblx0XHR2YXIgY3VycmVudENsYXNzZXMgPSAnJztcblx0XHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoY29uZmlnLmVsZW1lbnRDbGFzc2VzKSkge1xuXHRcdFx0Y3VycmVudENsYXNzZXMgPSBjb25maWcuZWxlbWVudENsYXNzZXMgKyAnICc7XG5cdFx0fVxuXG5cdFx0Y29uZmlnLmVsZW1lbnRDbGFzc2VzID0gY3VycmVudENsYXNzZXMgKyBwYXJlbnRDb25maWcuZWxlbWVudENsYXNzZXM7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHRhZyByZXByZXNlbnRzIGEgbWV0YWwgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQ29tcG9uZW50VGFnXyh0YWcpIHtcblx0cmV0dXJuICgwLCBfbWV0YWwuaXNGdW5jdGlvbikodGFnKSB8fCAoMCwgX21ldGFsLmlzU3RyaW5nKSh0YWcpICYmIHRhZ1swXSA9PT0gdGFnWzBdLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjb21wb25lbnQgY2FuIGJlIGEgbWF0Y2ggZm9yIGEgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IEN0b3JcbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gb3duZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc01hdGNoXyhjb21wLCBDdG9yLCBvd25lcikge1xuXHRpZiAoIWNvbXAgfHwgY29tcC5jb25zdHJ1Y3RvciAhPT0gQ3RvciB8fCBjb21wLmlzRGlzcG9zZWQoKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gKDAsIF9kYXRhLmdldERhdGEpKGNvbXApLm93bmVyID09PSBvd25lcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBjb21wb25lbnQgaWYgaXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGNvbnN0cnVjdG9yXG4gKiBmdW5jdGlvbi4gT3RoZXJ3aXNlLCByZXR1cm5zIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBnaXZlbiBjb25zdHJ1Y3Rvci4gT25cbiAqIGJvdGggY2FzZXMgdGhlIGNvbXBvbmVudCdzIHN0YXRlIGFuZCBjb25maWcgd2lsbCBiZSB1cGRhdGVkLlxuICogQHBhcmFtIHtDb21wb25lbnR9IGNvbXBcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IEN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IG93bmVyXG4gKiBAcmV0dXJuIHshQ29tcG9uZW50fVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWF0Y2hfKGNvbXAsIEN0b3IsIGNvbmZpZywgb3duZXIpIHtcblx0aWYgKGlzTWF0Y2hfKGNvbXAsIEN0b3IsIG93bmVyKSkge1xuXHRcdGNvbXAuc3RhcnRTa2lwVXBkYXRlcygpO1xuXHRcdGNvbXAuZ2V0RGF0YU1hbmFnZXIoKS5yZXBsYWNlTm9uSW50ZXJuYWwoY29tcCwgY29uZmlnKTtcblx0XHRjb21wLnN0b3BTa2lwVXBkYXRlcygpO1xuXHR9IGVsc2Uge1xuXHRcdGNvbXAgPSBuZXcgQ3Rvcihjb25maWcsIGZhbHNlKTtcblx0fVxuXHQoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCkuY29uZmlnID0gY29uZmlnO1xuXHRyZXR1cm4gY29tcDtcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgcmVuZGVyIG9wZXJhdGlvbiwgcmVzZXR0aW5nIHRoZSBjb21wb25lbnQncyBkYXRhIGFuZCBzdGFydGluZ1xuICogdGhlIGluY3JlbWVudGFsIGRvbSBpbnRlcmNlcHRpb24uXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHJlcGFyZVJlbmRlcl8oY29tcG9uZW50KSB7XG5cdHJlbmRlcmluZ0NvbXBvbmVudHNfLnB1c2goY29tcG9uZW50KTtcblxuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRyZXNldENvbXBvbmVudHNEYXRhXyhkYXRhLmljQ29tcG9uZW50c0RhdGEpO1xuXHQoMCwgX2NoYW5nZXMuY2xlYXJDaGFuZ2VzKShkYXRhKTtcblx0ZGF0YS5yb290RWxlbWVudFJlYWNoZWQgPSBmYWxzZTtcblx0Y29tcG9uZW50LnJlZnMgPSB7fTtcblxuXHRpZiAoZGF0YS5jaGlsZENvbXBvbmVudHMpIHtcblx0XHQoMCwgX3VudXNlZC5zY2hlZHVsZSkoZGF0YS5jaGlsZENvbXBvbmVudHMpO1xuXHRcdGRhdGEuY2hpbGRDb21wb25lbnRzID0gbnVsbDtcblx0fVxuXG5cdCgwLCBfaW5jcmVtZW50YWxEb21Bb3Auc3RhcnRJbnRlcmNlcHRpb24pKHtcblx0XHRhdHRyaWJ1dGVzOiBoYW5kbGVJbnRlcmNlcHRlZEF0dHJpYnV0ZXNDYWxsXyxcblx0XHRlbGVtZW50T3BlbjogaGFuZGxlSW50ZXJjZXB0ZWRPcGVuQ2FsbF9cblx0fSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgY3NzIGNsYXNzZXMgZnJvbSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzU3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVDbGFzc2VzXyhjbGFzc1N0cmluZykge1xuXHR2YXIgY2xhc3NlcyA9IFtdO1xuXHR2YXIgYWxsID0gY2xhc3NTdHJpbmcuc3BsaXQoL1xccysvKTtcblx0dmFyIHVzZWQgPSB7fTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIXVzZWRbYWxsW2ldXSkge1xuXHRcdFx0dXNlZFthbGxbaV1dID0gdHJ1ZTtcblx0XHRcdGNsYXNzZXMucHVzaChhbGxbaV0pO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY29tcG9uZW50IHdpdGggaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGNhbGxzLiBUaGlzIGFzc3VtZXMgdGhhdFxuICogYW4gaW5jcmVtZW50YWwgZG9tIGBwYXRjaGAgaXMgYWxyZWFkeSBydW5uaW5nLCBhbmQgdGhhdCB0aGlzIGZ1bmN0aW9uIGhhc1xuICogYmVlbiBjYWxsZWQgaW5zaWRlIGl0LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gcmVuZGVyKGNvbXBvbmVudCkge1xuXHRwcmVwYXJlUmVuZGVyXyhjb21wb25lbnQpO1xuXHRjb21wb25lbnQuZ2V0UmVuZGVyZXIoKS5yZW5kZXJJbmNEb20oY29tcG9uZW50KTtcblx0Y2xlYW5VcFJlbmRlcl8oY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBnaXZlbiBjaGlsZCBub2RlLlxuICogQHBhcmFtIHshT2JqZWN0fSBjaGlsZFxuICovXG5mdW5jdGlvbiByZW5kZXJDaGlsZChjaGlsZCkge1xuXHQoMCwgX2NoaWxkcmVuLnJlbmRlckNoaWxkVHJlZSkoY2hpbGQsIGhhbmRsZUNoaWxkUmVuZGVyXyk7XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY29udGVudHMgZm9yIHRoZSBnaXZlbiB0YWcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfHN0cmluZ30gdGFnXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbmZpZ1xuICogQHBhcmFtIHtDb21wb25lbnQ9fSBvcHRfb3duZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckZyb21UYWdfKHRhZywgY29uZmlnLCBvcHRfb3duZXIpIHtcblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKHRhZykgfHwgdGFnLnByb3RvdHlwZS5nZXRSZW5kZXJlcikge1xuXHRcdHZhciBjb21wID0gcmVuZGVyU3ViQ29tcG9uZW50Xyh0YWcsIGNvbmZpZywgb3B0X293bmVyKTtcblx0XHR1cGRhdGVFbGVtZW50SWZOb3RSZWFjaGVkXyhnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCksIGNvbXAuZWxlbWVudCk7XG5cdFx0cmV0dXJuIGNvbXAuZWxlbWVudDtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gdGFnKGNvbmZpZyk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZW5kZXJzIHRoZSBnaXZlbiBmdW5jdGlvbiwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIHNpbXBsZVxuICogaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIG9yIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHshSW5jcmVtZW50YWxEb21SZW5kZXJlcn0gcmVuZGVyZXJcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuT3JDdG9yIEVpdGhlciBhIHNpbXBsZSBpbmNyZW1lbnRhbCBkb20gZnVuY3Rpb24gb3IgYVxuICogICAgIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7T2JqZWN0fEVsZW1lbnQ9fSBvcHRfZGF0YU9yRWxlbWVudCBPcHRpb25hbCBjb25maWcgZGF0YSBmb3IgdGhlXG4gKiAgICAgZnVuY3Rpb24gb3IgcGFyZW50IGZvciB0aGUgcmVuZGVyZWQgY29udGVudC5cbiAqIEBwYXJhbSB7RWxlbWVudD19IG9wdF9wYXJlbnQgT3B0aW9uYWwgcGFyZW50IGZvciB0aGUgcmVuZGVyZWQgY29udGVudC5cbiAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSByZW5kZXJlZCBjb21wb25lbnQncyBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyRnVuY3Rpb24ocmVuZGVyZXIsIGZuT3JDdG9yLCBvcHRfZGF0YU9yRWxlbWVudCwgb3B0X3BhcmVudCkge1xuXHRpZiAoIV9tZXRhbENvbXBvbmVudC5Db21wb25lbnQuaXNDb21wb25lbnRDdG9yKGZuT3JDdG9yKSkge1xuXHRcdHZhciBmbiA9IGZuT3JDdG9yO1xuXG5cdFx0dmFyIFRlbXBDb21wb25lbnQgPSBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuXHRcdFx0X2luaGVyaXRzKFRlbXBDb21wb25lbnQsIF9Db21wb25lbnQpO1xuXG5cdFx0XHRmdW5jdGlvbiBUZW1wQ29tcG9uZW50KCkge1xuXHRcdFx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGVtcENvbXBvbmVudCk7XG5cblx0XHRcdFx0cmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChUZW1wQ29tcG9uZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGVtcENvbXBvbmVudCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuXHRcdFx0fVxuXG5cdFx0XHRfY3JlYXRlQ2xhc3MoVGVtcENvbXBvbmVudCwgW3tcblx0XHRcdFx0a2V5OiAnY3JlYXRlZCcsXG5cdFx0XHRcdHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBnZXRDb21wb25lbnRCZWluZ1JlbmRlcmVkKCk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdFx0dXBkYXRlQ29udGV4dF8odGhpcywgcGFyZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sIHtcblx0XHRcdFx0a2V5OiAncmVuZGVyJyxcblx0XHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcblx0XHRcdFx0XHRmbih0aGlzLmdldEluaXRpYWxDb25maWcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1dKTtcblxuXHRcdFx0cmV0dXJuIFRlbXBDb21wb25lbnQ7XG5cdFx0fShfbWV0YWxDb21wb25lbnQuQ29tcG9uZW50KTtcblxuXHRcdFRlbXBDb21wb25lbnQuUkVOREVSRVIgPSByZW5kZXJlcjtcblx0XHRmbk9yQ3RvciA9IFRlbXBDb21wb25lbnQ7XG5cdH1cblx0cmV0dXJuIF9tZXRhbENvbXBvbmVudC5Db21wb25lbnQucmVuZGVyKGZuT3JDdG9yLCBvcHRfZGF0YU9yRWxlbWVudCwgb3B0X3BhcmVudCk7XG59XG5cbi8qKlxuICogVGhpcyB1cGRhdGVzIHRoZSBzdWIgY29tcG9uZW50IHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGRhdGEuXG4gKiBUaGUgc3ViIGNvbXBvbmVudCBpcyBjcmVhdGVkLCBhZGRlZCB0byBpdHMgcGFyZW50IGFuZCByZW5kZXJlZC4gSWYgaXRcbiAqIGhhZCBhbHJlYWR5IGJlZW4gcmVuZGVyZWQgYmVmb3JlIHRob3VnaCwgaXQgd2lsbCBvbmx5IGhhdmUgaXRzIHN0YXRlXG4gKiB1cGRhdGVkIGluc3RlYWQuXG4gKiBAcGFyYW0ge3N0cmluZ3whZnVuY3Rpb24oKX0gdGFnT3JDdG9yIFRoZSB0YWcgbmFtZSBvciBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnIFRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUgc3ViIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7Q29tcG9uZW50UmVuZGVyZXI9fSBvcHRfb3duZXJcbiAqIEByZXR1cm4geyFDb21wb25lbnR9IFRoZSB1cGRhdGVkIHN1YiBjb21wb25lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXJTdWJDb21wb25lbnRfKHRhZ09yQ3RvciwgY29uZmlnLCBvcHRfb3duZXIpIHtcblx0dmFyIHBhcmVudCA9IGdldENvbXBvbmVudEJlaW5nUmVuZGVyZWQoKTtcblx0dmFyIG93bmVyID0gb3B0X293bmVyIHx8IHBhcmVudDtcblxuXHRpbmhlcml0RWxlbWVudENsYXNzZXNfKHBhcmVudCwgY29uZmlnKTtcblxuXHR2YXIgY29tcCA9IGdldFN1YkNvbXBvbmVudF8odGFnT3JDdG9yLCBjb25maWcsIG93bmVyKTtcblx0dXBkYXRlQ29udGV4dF8oY29tcCwgcGFyZW50KTtcblxuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wKTtcblx0ZGF0YS5wYXJlbnQgPSBwYXJlbnQ7XG5cdGRhdGEub3duZXIgPSBvd25lcjtcblxuXHR2YXIgcGFyZW50RGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShwYXJlbnQpO1xuXHRnZXRDaGlsZENvbXBvbmVudHNfKHBhcmVudERhdGEpLnB1c2goY29tcCk7XG5cdGlmICghY29uZmlnLmtleSAmJiAhcGFyZW50RGF0YS5yb290RWxlbWVudFJlYWNoZWQpIHtcblx0XHRjb25maWcua2V5ID0gcGFyZW50RGF0YS5jb25maWcua2V5O1xuXHR9XG5cblx0Y29tcC5nZXRSZW5kZXJlcigpLnJlbmRlckluc2lkZVBhdGNoKGNvbXApO1xuXHRpZiAoIWNvbXAud2FzUmVuZGVyZWQpIHtcblx0XHRjb21wLnJlbmRlckNvbXBvbmVudCgpO1xuXHR9XG5cdHJldHVybiBjb21wO1xufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgZ2l2ZW4gaW5jcmVtZW50YWwgZG9tIGRhdGEgb2JqZWN0LCBwcmVwYXJpbmcgaXQgZm9yIHRoZSBuZXh0IHBhc3MuXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXRDb21wb25lbnRzRGF0YV8oZGF0YSkge1xuXHRpZiAoZGF0YSkge1xuXHRcdGRhdGEucHJldkNvbXBzID0gZGF0YS5jdXJyQ29tcHM7XG5cdFx0ZGF0YS5jdXJyQ29tcHMgPSBudWxsO1xuXHRcdGRhdGEuY3VyckNvdW50ID0gbnVsbDtcblx0fVxufVxuLyoqXG4gKiBSZXNldHMgYWxsIGRhdGEgc3RvcmVkIGluIHRoZSBnaXZlbiBub2RlLlxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzZXROb2RlRGF0YV8obm9kZSkge1xuXHRpZiAoX21ldGFsRG9tLmRvbURhdGEuaGFzKG5vZGUpKSB7XG5cdFx0cmVzZXRDb21wb25lbnRzRGF0YV8oX21ldGFsRG9tLmRvbURhdGEuZ2V0KG5vZGUpLmljQ29tcG9uZW50c0RhdGEpO1xuXHR9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgZ2l2ZW4gY29tcG9uZW50J3MgY29udGV4dCBhY2NvcmRpbmcgdG8gdGhlIGRhdGEgZnJvbSB0aGVcbiAqIGNvbXBvbmVudCB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyByZW5kZXJlZC5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcFxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Xyhjb21wLCBwYXJlbnQpIHtcblx0dmFyIGNvbnRleHQgPSBjb21wLmNvbnRleHQ7XG5cdHZhciBjaGlsZENvbnRleHQgPSBwYXJlbnQuZ2V0Q2hpbGRDb250ZXh0ID8gcGFyZW50LmdldENoaWxkQ29udGV4dCgpIDogbnVsbDtcblx0X21ldGFsLm9iamVjdC5taXhpbihjb250ZXh0LCBwYXJlbnQuY29udGV4dCwgY2hpbGRDb250ZXh0KTtcblx0Y29tcC5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgcmVuZGVyZXIncyBjb21wb25lbnQncyBlbGVtZW50IHdpdGggdGhlIGdpdmVuIHZhbHVlcywgdW5sZXNzXG4gKiBpdCBoYXMgYWxyZWFkeSBiZWVuIHJlYWNoZWQgYnkgYW4gZWFybGllciBjYWxsLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnRJZk5vdFJlYWNoZWRfKGNvbXBvbmVudCwgbm9kZSkge1xuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRpZiAoIWRhdGEucm9vdEVsZW1lbnRSZWFjaGVkKSB7XG5cdFx0ZGF0YS5yb290RWxlbWVudFJlYWNoZWQgPSB0cnVlO1xuXHRcdGlmIChjb21wb25lbnQuZWxlbWVudCAhPT0gbm9kZSkge1xuXHRcdFx0Y29tcG9uZW50LmVsZW1lbnQgPSBub2RlO1xuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL3JlbmRlci5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgZXhpc3RzIGp1c3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCBtYWtpbmcgc3VyZSB0aGF0IG9sZFxuLy8gZGVmYXVsdCBpbXBvcnRzIGZvciB0aGlzIGZpbGUgc3RpbGwgd29yay4gSXQncyBiZXN0IHRvIHVzZSB0aGUgbmFtZWQgZXhwb3J0c1xuLy8gZm9yIGVhY2ggZnVuY3Rpb24gaW5zdGVhZCB0aG91Z2gsIHNpbmNlIHRoYXQgYWxsb3dzIGJ1bmRsZXJzIGxpa2UgUm9sbHVwIHRvXG4vLyByZWR1Y2UgdGhlIGJ1bmRsZSBzaXplIGJ5IHJlbW92aW5nIHVudXNlZCBjb2RlLlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jb3JlID0gdW5kZWZpbmVkO1xuXG52YXIgX2NvcmVOYW1lZCA9IHJlcXVpcmUoJy4vY29yZU5hbWVkJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlTmFtZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9jb3JlTmFtZWRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbnZhciBjb3JlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX2NvcmVOYW1lZCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5leHBvcnRzLmNvcmUgPSBjb3JlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgY29yZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gY29yZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgY29yZSk7XG5cdH1cblxuXHQvKipcbiAgKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICAqIEZvby5wcm90b3R5cGUuYmFyID0gY29yZS5hYnN0cmFjdE1ldGhvZFxuICAqXG4gICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAgKlxuICAqIEB0eXBlIHshRnVuY3Rpb259XG4gICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICAqL1xuXHRjb3JlLmFic3RyYWN0TWV0aG9kID0gZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG5cdFx0dGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG5cdH07XG5cblx0LyoqXG4gICogTG9vcHMgY29uc3RydWN0b3Igc3VwZXIgY2xhc3NlcyBjb2xsZWN0aW5nIGl0cyBwcm9wZXJ0aWVzIHZhbHVlcy4gSWZcbiAgKiBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBzdXBlciBjbGFzcyBgdW5kZWZpbmVkYCB3aWxsIGJlXG4gICogY29sbGVjdGVkIGFzIHZhbHVlIGZvciB0aGUgY2xhc3MgaGllcmFyY2h5IHBvc2l0aW9uLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGNvbnN0cnVjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBjb2xsZWN0ZWQuXG4gICogQHJldHVybiB7QXJyYXkuPCo+fSBBcnJheSBvZiBjb2xsZWN0ZWQgdmFsdWVzLlxuICAqIFRPRE8oKik6IFJldGhpbmsgc3VwZXJjbGFzcyBsb29wLlxuICAqL1xuXG5cblx0Y29yZS5jb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkgPSBmdW5jdGlvbiBjb2xsZWN0U3VwZXJDbGFzc2VzUHJvcGVydHkoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkge1xuXHRcdHZhciBwcm9wZXJ0eVZhbHVlcyA9IFtjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdXTtcblx0XHR3aGlsZSAoY29uc3RydWN0b3IuX19wcm90b19fICYmICFjb25zdHJ1Y3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcblx0XHRcdGNvbnN0cnVjdG9yID0gY29uc3RydWN0b3IuX19wcm90b19fO1xuXHRcdFx0cHJvcGVydHlWYWx1ZXMucHVzaChjb25zdHJ1Y3Rvcltwcm9wZXJ0eU5hbWVdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHByb3BlcnR5VmFsdWVzO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAgKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICAqIGNvbnRlbnQgc3RyaW5nLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gICogQHJldHVybiB7c3RyaW5nfVxuICAqL1xuXG5cblx0Y29yZS5nZXRGdW5jdGlvbk5hbWUgPSBmdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcblx0XHRpZiAoIWZuLm5hbWUpIHtcblx0XHRcdHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuXHRcdFx0Zm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmbi5uYW1lO1xuXHR9O1xuXG5cdC8qKlxuICAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAgKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICAqIHJldHVybnMuIFNlZSB7QGxpbmsgY29yZS5VSURfUFJPUEVSVFl9LlxuICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAgKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAgKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gICovXG5cblxuXHRjb3JlLmdldFVpZCA9IGZ1bmN0aW9uIGdldFVpZChvcHRfb2JqZWN0LCBvcHRfbm9Jbmhlcml0YW5jZSkge1xuXHRcdGlmIChvcHRfb2JqZWN0KSB7XG5cdFx0XHR2YXIgaWQgPSBvcHRfb2JqZWN0W2NvcmUuVUlEX1BST1BFUlRZXTtcblx0XHRcdGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShjb3JlLlVJRF9QUk9QRVJUWSkpIHtcblx0XHRcdFx0aWQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W2NvcmUuVUlEX1BST1BFUlRZXSA9IGNvcmUudW5pcXVlSWRDb3VudGVyXysrKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvcmUudW5pcXVlSWRDb3VudGVyXysrO1xuXHR9O1xuXG5cdC8qKlxuICAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAgKi9cblxuXG5cdGNvcmUuaWRlbnRpdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG5cdFx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gICovXG5cblxuXHRjb3JlLmlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gICovXG5cblxuXHRjb3JlLmlzRGVmID0gZnVuY3Rpb24gaXNEZWYodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gICogQHBhcmFtIHsqfSB2YWxcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuXG5cblx0Y29yZS5pc0RlZkFuZE5vdE51bGwgPSBmdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG5cdFx0cmV0dXJuIGNvcmUuaXNEZWYodmFsKSAmJiAhY29yZS5pc051bGwodmFsKTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzRG9jdW1lbnQgPSBmdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuXHRcdHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gICogQHBhcmFtIHsqfSB2YWxcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqL1xuXG5cblx0Y29yZS5pc0VsZW1lbnQgPSBmdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICAqL1xuXG5cblx0Y29yZS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcblx0XHRyZXR1cm4gdmFsID09PSBudWxsO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAgKi9cblxuXG5cdGNvcmUuaXNOdW1iZXIgPSBmdW5jdGlvbiBpc051bWJlcih2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICAqIEBwYXJhbSB7Kn0gdmFsXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cblxuXG5cdGNvcmUuaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gICogYW5kIGZ1bmN0aW9ucy5cbiAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICAqL1xuXG5cblx0Y29yZS5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcblx0XHRyZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcblx0XHRyZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xuXHR9O1xuXG5cdC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAgKiBAcGFyYW0geyp9IHZhbFxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5cblxuXHRjb3JlLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xuXHR9O1xuXG5cdC8qKlxuICAqIE1lcmdlcyB0aGUgdmFsdWVzIG9mIGEgc3RhdGljIHByb3BlcnR5IGEgY2xhc3Mgd2l0aCB0aGUgdmFsdWVzIG9mIHRoYXRcbiAgKiBwcm9wZXJ0eSBmb3IgYWxsIGl0cyBzdXBlciBjbGFzc2VzLCBhbmQgc3RvcmVzIGl0IGFzIGEgbmV3IHN0YXRpY1xuICAqIHByb3BlcnR5IG9mIHRoYXQgY2xhc3MuIElmIHRoZSBzdGF0aWMgcHJvcGVydHkgYWxyZWFkeSBleGlzdGVkLCBpdCB3b24ndFxuICAqIGJlIHJlY2FsY3VsYXRlZC5cbiAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjb25zdHJ1Y3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgY29sbGVjdGVkLlxuICAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYW4gYXJyYXkgZmlsbGVkXG4gICogICB3aXRoIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgY3VycmVudCBjbGFzcyBhbmQgYWxsIGl0cyBzdXBlciBjbGFzc2VzLlxuICAqICAgU2hvdWxkIHJldHVybiB0aGUgbWVyZ2VkIHZhbHVlIHRvIGJlIHN0b3JlZCBvbiB0aGUgY3VycmVudCBjbGFzcy5cbiAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgbWVyZ2UgaGFwcGVucywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqL1xuXG5cblx0Y29yZS5tZXJnZVN1cGVyQ2xhc3Nlc1Byb3BlcnR5ID0gZnVuY3Rpb24gbWVyZ2VTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuXHRcdHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuXHRcdGlmIChjb25zdHJ1Y3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBtZXJnZWQgPSBjb3JlLmNvbGxlY3RTdXBlckNsYXNzZXNQcm9wZXJ0eShjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKTtcblx0XHRpZiAob3B0X21lcmdlRm4pIHtcblx0XHRcdG1lcmdlZCA9IG9wdF9tZXJnZUZuKG1lcmdlZCk7XG5cdFx0fVxuXHRcdGNvbnN0cnVjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qKlxuICAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAgKi9cblxuXG5cdGNvcmUubnVsbEZ1bmN0aW9uID0gZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge307XG5cblx0cmV0dXJuIGNvcmU7XG59KCk7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5jb3JlLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvcmUudW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNvcmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9zY3NzL2FwcC5zY3NzJztcbmltcG9ydCBNZXRhbEZvcm0gZnJvbSAnLi9jb21wb25lbnRzL01ldGFsRm9ybS9NZXRhbEZvcm0nO1xuaW1wb3J0IERyb3Bkb3duIGZyb20gJy4vY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93bic7XG5pbXBvcnQgQ2FsY3VsYXRvciBmcm9tICcuL2NvbXBvbmVudHMvQ2FsY3VsYXRvci9DYWxjdWxhdG9yJztcbmltcG9ydCBDYWxjdWxhdG9yQnV0dG9uIGZyb20gJy4vY29tcG9uZW50cy9DYWxjdWxhdG9yQnV0dG9uL0NhbGN1bGF0b3JCdXR0b24nO1xuXG5uZXcgTWV0YWxGb3JtKHtcblx0ZW5kcG9pbnQ6ICdodHRwOi8vbG9jYWxob3N0OjMxMDAvY2FsY3VsYXRvcidcbn0pO1xuXG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHAuc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gUHJlcGFyZSBjc3NUcmFuc2Zvcm1hdGlvblxudmFyIHRyYW5zZm9ybTtcblxudmFyIG9wdGlvbnMgPSB7fVxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHAuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9hcHAuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvc2Nzcy9hcHAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh1bmRlZmluZWQpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PU9wZW4rU2Fucyk7XCIsIFwiXCJdKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJodG1sLCBib2R5LCBkaXYsIHNwYW4sIGFwcGxldCwgb2JqZWN0LCBpZnJhbWUsIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYsIHAsIGJsb2NrcXVvdGUsIHByZSwgYSwgYWJiciwgYWNyb255bSwgYWRkcmVzcywgYmlnLCBjaXRlLCBjb2RlLCBkZWwsIGRmbiwgZW0sIGltZywgaW5zLCBrYmQsIHEsIHMsIHNhbXAsIHNtYWxsLCBzdHJpa2UsIHN0cm9uZywgc3ViLCBzdXAsIHR0LCB2YXIsIGIsIHUsIGksIGNlbnRlciwgZGwsIGR0LCBkZCwgb2wsIHVsLCBsaSwgZmllbGRzZXQsIGZvcm0sIGxhYmVsLCBsZWdlbmQsIHRhYmxlLCBjYXB0aW9uLCB0Ym9keSwgdGZvb3QsIHRoZWFkLCB0ciwgdGgsIHRkLCBhcnRpY2xlLCBhc2lkZSwgY2FudmFzLCBkZXRhaWxzLCBlbWJlZCwgZmlndXJlLCBmaWdjYXB0aW9uLCBmb290ZXIsIGhlYWRlciwgaGdyb3VwLCBtZW51LCBuYXYsIG91dHB1dCwgcnVieSwgc2VjdGlvbiwgc3VtbWFyeSwgdGltZSwgbWFyaywgYXVkaW8sIHZpZGVvIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxuICBib3JkZXI6IDA7XFxuICBmb250LXNpemU6IDEwMCU7XFxuICBmb250OiBpbmhlcml0O1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lOyB9XFxuXFxuLyogSFRNTDUgZGlzcGxheS1yb2xlIHJlc2V0IGZvciBvbGRlciBicm93c2VycyAqL1xcbmFydGljbGUsIGFzaWRlLCBkZXRhaWxzLCBmaWdjYXB0aW9uLCBmaWd1cmUsIGZvb3RlciwgaGVhZGVyLCBoZ3JvdXAsIG1lbnUsIG5hdiwgc2VjdGlvbiB7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbmJvZHkge1xcbiAgbGluZS1oZWlnaHQ6IDE7IH1cXG5cXG5vbCwgdWwge1xcbiAgbGlzdC1zdHlsZTogbm9uZTsgfVxcblxcbmJsb2NrcXVvdGUsIHEge1xcbiAgcXVvdGVzOiBub25lOyB9XFxuXFxuYmxvY2txdW90ZTpiZWZvcmUsIGJsb2NrcXVvdGU6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBjb250ZW50OiBub25lOyB9XFxuXFxucTpiZWZvcmUsIHE6YWZ0ZXIge1xcbiAgY29udGVudDogJyc7XFxuICBjb250ZW50OiBub25lOyB9XFxuXFxudGFibGUge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwOyB9XFxuXFxuKiwgKjphZnRlciwgKjpiZWZvcmUge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgfVxcblxcbmJvZHkge1xcbiAgZm9udC1mYW1pbHk6IFxcXCJPcGVuIFNhbnNcXFwiO1xcbiAgZm9udC1zaXplOiAxM3B4O1xcbiAgYmFja2dyb3VuZDogI2ZhZmFmYTsgfVxcbiAgYm9keTpiZWZvcmUge1xcbiAgICBjb250ZW50OiBcXFwiXFxcIjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiA0MjFweDtcXG4gICAgYmFja2dyb3VuZDogIzNlOWNmYztcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwOyB9XFxuXFxuaHRtbCwgYm9keSB7XFxuICBoZWlnaHQ6IDEwMCU7IH1cXG5cXG5hIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTsgfVxcblxcbi53cmFwcGVyIHtcXG4gIHBhZGRpbmctdG9wOiA1NnB4O1xcbiAgbWluLWhlaWdodDogY2FsYygxMDAlIC0gMTY4cHgpO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuXFxuLmNvbnRhaW5lciB7XFxuICBwYWRkaW5nOiAwIDIwcHg7XFxuICBtYXgtd2lkdGg6IDEyODBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWFyZ2luOiAwIGF1dG87IH1cXG4gIC5jb250YWluZXI6YWZ0ZXIge1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmb250LXNpemU6IDA7XFxuICAgIGNvbnRlbnQ6IFxcXCIgXFxcIjtcXG4gICAgY2xlYXI6IGJvdGg7XFxuICAgIGhlaWdodDogMDsgfVxcblxcbmZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvciB7XFxuICBjb2xvcjogI2QwMDIxYjtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMjA4LCAxLCAyNywgMC4yKTsgfVxcbiAgZm9ybS5sb2FuLWZvcm0gZmllbGRzZXQgLmlucHV0LWVycm9yOjotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICNkMDAyMWI7IH1cXG4gIGZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvcjotbW96LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICNkMDAyMWI7IH1cXG4gIGZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvcjo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiAjZDAwMjFiOyB9XFxuICBmb3JtLmxvYW4tZm9ybSBmaWVsZHNldCAuaW5wdXQtZXJyb3I6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcXG4gICAgY29sb3I6ICNkMDAyMWI7IH1cXG4gIGZvcm0ubG9hbi1mb3JtIGZpZWxkc2V0IC5pbnB1dC1lcnJvcjphY3RpdmUge1xcbiAgICBib3JkZXItY29sb3I6ICNkMDAyMWI7IH1cXG5cXG5idXR0b246aG92ZXIsIGJ1dHRvbjpmb2N1cywgYnV0dG9uOmFjdGl2ZSwgYTpob3ZlciwgYTpmb2N1cywgYTphY3RpdmUsIGlucHV0OmhvdmVyLCBpbnB1dDpmb2N1cywgaW5wdXQ6YWN0aXZlIHtcXG4gIG91dGxpbmU6IG5vbmU7IH1cXG5cXG5oMSB7XFxuICBmb250LXNpemU6IDM4cHg7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBtYXJnaW4tYm90dG9tOiA0NnB4OyB9XFxuICBoMSBzbWFsbCB7XFxuICAgIG1hcmdpbi10b3A6IDM1cHg7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxuICAgIGZvbnQtd2VpZ2h0OiAzMDA7IH1cXG5cXG4uc2l0ZS1mb290ZXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEyOHB4O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1vei1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXg7XFxuICBkaXNwbGF5OiAtby1mbGV4O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgbGluZS1oZWlnaHQ6IDEuNTtcXG4gIGNvbG9yOiAjOWI5YjliO1xcbiAgYmFja2dyb3VuZDogI2ZmZmZmZjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYm90dG9tOiAtMTY4cHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7IH1cXG5cXG4uZHJvcGRvd24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgZm9udC1zaXplOiAxNHB4OyB9XFxuICAuZHJvcGRvd24gLmRyb3Bkb3duLWRpc3BsYXkge1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7IH1cXG4gIC5kcm9wZG93biAuZHJvcGRvd24tbGlzdC13cmFwcGVyIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHRvcDogNDBweDtcXG4gICAgYm94LXNoYWRvdzogMCAycHggMTRweCAwIHJnYmEoOTcsIDE0OSwgMjM3LCAwLjEpO1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjZTRlOWVjO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHotaW5kZXg6IDU7XFxuICAgIGJhY2tncm91bmQ6ICNmZmY7IH1cXG4gICAgLmRyb3Bkb3duIC5kcm9wZG93bi1saXN0LXdyYXBwZXIgaW5wdXQge1xcbiAgICAgIGJhY2tncm91bmQ6IG5vLXJlcGVhdCA1cHggY2VudGVyIHRyYW5zcGFyZW50IHVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQRDk0Yld3Z2RtVnljMmx2YmowaU1TNHdJaUJsYm1OdlpHbHVaejBpVlZSR0xUZ2lQejROQ2p3aFJFOURWRmxRUlNCemRtY2dVRlZDVEVsRElDSXRMeTlYTTBNdkwwUlVSQ0JUVmtjZ01TNHhMeTlGVGlJZ0ltaDBkSEE2THk5M2QzY3Vkek11YjNKbkwwZHlZWEJvYVdOekwxTldSeTh4TGpFdlJGUkVMM04yWnpFeExtUjBaQ0krRFFvOGMzWm5JSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SWdlRzFzYm5NNmVHeHBibXM5SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpFNU9Ua3ZlR3hwYm1zaUlIWmxjbk5wYjI0OUlqRXVNU0lnSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJajROQ2lBZ0lEeHdZWFJvSUdacGJHdzlJaU13TURBd01EQWlJR1E5SWswNUxqVXNNMEUyTGpVc05pNDFJREFnTUN3eElERTJMRGt1TlVNeE5pd3hNUzR4TVNBeE5TNDBNU3d4TWk0MU9TQXhOQzQwTkN3eE15NDNNMHd4TkM0M01Td3hORWd4TlM0MVRESXdMalVzTVRsTU1Ua3NNakF1TlV3eE5Dd3hOUzQxVmpFMExqY3hUREV6TGpjekxERTBMalEwUXpFeUxqVTVMREUxTGpReElERXhMakV4TERFMklEa3VOU3d4TmtFMkxqVXNOaTQxSURBZ01Dd3hJRE1zT1M0MVFUWXVOU3cyTGpVZ01DQXdMREVnT1M0MUxETk5PUzQxTERWRE55dzFJRFVzTnlBMUxEa3VOVU0xTERFeUlEY3NNVFFnT1M0MUxERTBRekV5TERFMElERTBMREV5SURFMExEa3VOVU14TkN3M0lERXlMRFVnT1M0MUxEVmFJaUF2UGcwS1BDOXpkbWMrXFxcIik7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAzOHB4O1xcbiAgICAgIHBhZGRpbmctdG9wOiA5cHg7XFxuICAgICAgcGFkZGluZy1ib3R0b206IDEycHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogMDsgfVxcbiAgICAgIC5kcm9wZG93biAuZHJvcGRvd24tbGlzdC13cmFwcGVyIGlucHV0LCAuZHJvcGRvd24gLmRyb3Bkb3duLWxpc3Qtd3JhcHBlciBpbnB1dDpmb2N1cyB7XFxuICAgICAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNlNGU5ZWM7IH1cXG4gIC5kcm9wZG93biAuYXJyb3dfYm94IHtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBiYWNrZ3JvdW5kOiAjODY5Y2FlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiAxMnB4O1xcbiAgICB6LWluZGV4OiAyO1xcbiAgICBoZWlnaHQ6IDRweDtcXG4gICAgdG9wOiAxOXB4OyB9XFxuICAgIC5kcm9wZG93biAuYXJyb3dfYm94OmFmdGVyIHtcXG4gICAgICBib3R0b206IDEwMCU7XFxuICAgICAgbGVmdDogNTAlO1xcbiAgICAgIGJvcmRlcjogc29saWQgdHJhbnNwYXJlbnQ7XFxuICAgICAgY29udGVudDogXFxcIiBcXFwiO1xcbiAgICAgIGhlaWdodDogMDtcXG4gICAgICB3aWR0aDogMDtcXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICAgICAgYm9yZGVyLWJvdHRvbS1jb2xvcjogIzg2OWNhZTtcXG4gICAgICBib3JkZXItd2lkdGg6IDRweDtcXG4gICAgICBtYXJnaW4tbGVmdDogLTRweDsgfVxcbiAgICAuZHJvcGRvd24gLmFycm93X2JveDpiZWZvcmUge1xcbiAgICAgIHRvcDogMTAwJTtcXG4gICAgICBsZWZ0OiA1MCU7XFxuICAgICAgYm9yZGVyOiBzb2xpZCB0cmFuc3BhcmVudDtcXG4gICAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgICAgaGVpZ2h0OiAwO1xcbiAgICAgIHdpZHRoOiAwO1xcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgICBib3JkZXItdG9wLWNvbG9yOiAjODY5Y2FlO1xcbiAgICAgIGJvcmRlci13aWR0aDogNHB4O1xcbiAgICAgIG1hcmdpbi1sZWZ0OiAtNHB4OyB9XFxuXFxuLmJveC1jYWxjdWxhdG9yIHtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGZsZXg6IDEgMCAyMDJweDtcXG4gIG1hcmdpbjogMCA2NXB4IDAgMDsgfVxcbiAgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWRpc3BsYXkge1xcbiAgICB3aWR0aDogMjAycHg7XFxuICAgIGhlaWdodDogNTZweDtcXG4gICAgcGFkZGluZzogMjFweCAxNnB4IDA7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgb3ZlcmZsb3c6IGF1dG87XFxuICAgIGJhY2tncm91bmQ6ICNlYWYwZjM7IH1cXG4gIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b25zLXdyYXBwZXIge1xcbiAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICAgIGRpc3BsYXk6IC1tb3otZmxleDtcXG4gICAgZGlzcGxheTogLW1zLWZsZXg7XFxuICAgIGRpc3BsYXk6IC1vLWZsZXg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgIHdpZHRoOiAyMDJweDtcXG4gICAgbWFyZ2luLXRvcDogMTBweDsgfVxcbiAgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWRpZ2l0cyB7XFxuICAgIHdpZHRoOiAxNDRweDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4OyB9XFxuICAuYm94LWNhbGN1bGF0b3IgLmNhbGN1bGF0b3Itb3BlcmF0b3JzIHtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICB3aWR0aDogNDdweDsgfVxcbiAgICAuYm94LWNhbGN1bGF0b3IgLmNhbGN1bGF0b3Itb3BlcmF0b3JzIC5jYWxjdWxhdG9yLWJ1dHRvbiwgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLW9wZXJhdG9ycyAuY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplIHtcXG4gICAgICBtYXJnaW4tcmlnaHQ6IDA7IH1cXG4gIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b24sIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB3aWR0aDogNDdweDtcXG4gICAgaGVpZ2h0OiA0N3B4O1xcbiAgICBmbG9hdDogbGVmdDtcXG4gICAgbWFyZ2luOiAwIDFweCAxcHggMDtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDYyLCAxNTYsIDI1MiwgMC4zKTtcXG4gICAgY29sb3I6ICMzZTljZmM7IH1cXG4gICAgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWJ1dHRvbjpob3ZlciwgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWJ1dHRvbi0tZG91YmxlLXNpemU6aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQ6IHJnYmEoNjIsIDE1NiwgMjUyLCAwLjQ1KTsgfVxcbiAgICAuYm94LWNhbGN1bGF0b3IgLmNhbGN1bGF0b3ItYnV0dG9uOmFjdGl2ZSwgLmJveC1jYWxjdWxhdG9yIC5jYWxjdWxhdG9yLWJ1dHRvbi0tZG91YmxlLXNpemU6YWN0aXZlIHtcXG4gICAgICBiYWNrZ3JvdW5kOiByZ2JhKDYyLCAxNTYsIDI1MiwgMC41NSk7IH1cXG4gIC5ib3gtY2FsY3VsYXRvciAuY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplIHtcXG4gICAgd2lkdGg6IDk1cHg7IH1cXG5cXG4ubG9hbi1mb3JtIHtcXG4gIGJhY2tncm91bmQ6ICNmZmY7XFxuICBwYWRkaW5nOiA2MXB4IDY1cHg7XFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxuICBib3gtc2hhZG93OiAwIDAgMjBweCAwIHJnYmEoMCwgNSwgNjEsIDAuMSk7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbW96LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleDtcXG4gIGRpc3BsYXk6IC1vLWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIGFsaWduLWl0ZW1zOiBpbml0aWFsO1xcbiAganVzdGlmeS1jb250ZW50OiBzdHJldGNoO1xcbiAgbWFyZ2luOiAwIGF1dG8gMTIycHg7XFxuICB3aWR0aDogNjg4cHg7XFxuICBmbGV4LXdyYXA6IHdyYXA7IH1cXG5cXG4uYm94LWxvYW4tb3B0aW9ucyB7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbW96LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleDtcXG4gIGRpc3BsYXk6IC1vLWZsZXg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbiAgZmxleDogMSAwIDI5MHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlOyB9XFxuICAuYm94LWxvYW4tb3B0aW9ucyBpbnB1dCwgLmJveC1sb2FuLW9wdGlvbnMgbGFiZWwsIC5ib3gtbG9hbi1vcHRpb25zIGJ1dHRvbiB7XFxuICAgIHdpZHRoOiAxMDAlOyB9XFxuICAuYm94LWxvYW4tb3B0aW9ucyAuY2FsY3VsYXRlLWludGVyZXN0IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBtYXJnaW4tdG9wOiAtM3B4O1xcbiAgICB0cmFuc2l0aW9uOiBlYXNlLW91dCAuM3MgYWxsO1xcbiAgICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAjM2U5Y2ZjOyB9XFxuICAgIC5ib3gtbG9hbi1vcHRpb25zIC5jYWxjdWxhdGUtaW50ZXJlc3Q6aG92ZXIge1xcbiAgICAgIGJveC1zaGFkb3c6IGluc2V0IDAgNTBweCAwICMzZTljZmM7XFxuICAgICAgY29sb3I6ICNmZmY7IH1cXG4gIC5ib3gtbG9hbi1vcHRpb25zIC5nZXQtcXVvdCB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBtYXgtd2lkdGg6IDI5MHB4O1xcbiAgICBib3R0b206IDA7IH1cXG4gIC5ib3gtbG9hbi1vcHRpb25zICNpbnB1dC10b3RhbCB7XFxuICAgIG1hcmdpbi1ib3R0b206IDI2cHg7IH1cXG5cXG5pbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl0ge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgYmFja2dyb3VuZDogI2VhZjBmMztcXG4gIHBhZGRpbmc6IDExcHggMTBweDtcXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XFxuICBjb2xvcjogIzM5NTM2YztcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50OyB9XFxuICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl06Oi13ZWJraXQtaW5wdXQtcGxhY2Vob2xkZXIge1xcbiAgICBjb2xvcjogcmdiYSgxMzQsIDE1NiwgMTczLCAwLjUpOyB9XFxuICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl06LW1vei1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiByZ2JhKDEzNCwgMTU2LCAxNzMsIDAuNSk7IH1cXG4gIGlucHV0W3R5cGU9XFxcInRleHRcXFwiXTo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAgIGNvbG9yOiByZ2JhKDEzNCwgMTU2LCAxNzMsIDAuNSk7IH1cXG4gIGlucHV0W3R5cGU9XFxcInRleHRcXFwiXTotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xcbiAgICBjb2xvcjogcmdiYSgxMzQsIDE1NiwgMTczLCAwLjUpOyB9XFxuICBpbnB1dFt0eXBlPVxcXCJ0ZXh0XFxcIl06Zm9jdXMge1xcbiAgICBib3JkZXItY29sb3I6ICM2NWI0ZjA7IH1cXG5cXG4ud2FybmluZy1sYWJlbCB7XFxuICBmb250LXNpemU6IDEyLjVweDtcXG4gIG1hcmdpbi10b3A6IDZweDtcXG4gIGxpbmUtaGVpZ2h0OiAxNnB4O1xcbiAgY29sb3I6ICNkMDAyMWI7XFxuICBkaXNwbGF5OiBub25lOyB9XFxuICAud2FybmluZy1sYWJlbCBpIHtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXFxuLmRyb3Bkb3duIC5kcm9wZG93bi1saXN0LXdyYXBwZXIuc2hvdywgLndhcm5pbmctbGFiZWwuc2hvdyB7XFxuICBkaXNwbGF5OiBibG9jazsgfVxcblxcbmxhYmVsIHtcXG4gIG1hcmdpbi1ib3R0b206IDI3cHg7IH1cXG4gIGxhYmVsOmFmdGVyIHtcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gICAgZm9udC1zaXplOiAwO1xcbiAgICBjb250ZW50OiBcXFwiIFxcXCI7XFxuICAgIGNsZWFyOiBib3RoO1xcbiAgICBoZWlnaHQ6IDA7IH1cXG4gIGxhYmVsIC5jYXB0aW9uIHtcXG4gICAgY29sb3I6ICM0YTRhNGE7XFxuICAgIGZvbnQtc2l6ZTogMThweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogNnB4O1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcbiAgbGFiZWwgLm1hbmRhdG9yeS1zaWduIHtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIGNvbG9yOiAjZjU5ODRjOyB9XFxuXFxuLmJ1dHRvbiwgLmJ1dHRvbi0tZmlsbGVkIHtcXG4gIGNvbG9yOiAjMzA4ZmZmO1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGJhY2tncm91bmQ6ICNmZmZmZmY7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBmb250LXdlaWdodDogNTAwO1xcbiAgYm9yZGVyOiAxcHggc29saWQgIzMwOGZmZjtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDsgfVxcbiAgLmJ1dHRvbltkaXNhYmxlZF0sIFtkaXNhYmxlZF0uYnV0dG9uLS1maWxsZWQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzI4Njk0O1xcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50OyB9XFxuXFxuLmJ1dHRvbi0tZmlsbGVkIHtcXG4gIGJhY2tncm91bmQ6ICMzMDhmZmY7XFxuICBjb2xvcjogI2ZmZmZmZjsgfVxcblxcbi5kcm9wZG93bi1saXN0LWl0ZW0sIC5kcm9wZG93bi1saXN0LWl0ZW06aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbiAgcGFkZGluZzogMTBweDsgfVxcbiAgLmRyb3Bkb3duLWxpc3QtaXRlbTpob3ZlciB7XFxuICAgIGJhY2tncm91bmQ6ICNmOGZhZmE7IH1cXG4gIC5kcm9wZG93bi1saXN0LWl0ZW1bZGF0YS1zZWxlY3RlZF0ge1xcbiAgICBjb2xvcjogIzMyOWRlNjsgfVxcblxcbi5zdWJtaXQtbGFiZWwge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgYm90dG9tOiA0NXB4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBjb2xvcjogI2ZmZjtcXG4gIGJhY2tncm91bmQ6ICMzZTljZmM7XFxuICBwYWRkaW5nOiAwLjVyZW07XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxuICBvcGFjaXR5OiAwO1xcbiAgdmlzaWJpbGl0eTogaGlkZGVuO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDEwcHgpO1xcbiAgei1pbmRleDogMjtcXG4gIHRyYW5zaXRpb246IGFsbCAuM3MgZWFzZS1pbi1vdXQ7IH1cXG4gIC5zdWJtaXQtbGFiZWw6YmVmb3JlIHtcXG4gICAgY29udGVudDogXFxcIlxcXCI7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBib3JkZXI6IHNvbGlkIDdweCB0cmFuc3BhcmVudDtcXG4gICAgYm9yZGVyLXRvcC1jb2xvcjogIzNlOWNmYztcXG4gICAgd2lkdGg6IDA7XFxuICAgIGhlaWdodDogMDtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBib3R0b206IC0xMXB4O1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIG1hcmdpbi1sZWZ0OiAtMTBweDsgfVxcbiAgLnN1Ym1pdC1sYWJlbC5kYW5nZXIge1xcbiAgICBiYWNrZ3JvdW5kOiAjYmUwMDAwOyB9XFxuICAgIC5zdWJtaXQtbGFiZWwuZGFuZ2VyOmJlZm9yZSB7XFxuICAgICAgYm9yZGVyLXRvcC1jb2xvcjogI2JlMDAwMDsgfVxcbiAgLnN1Ym1pdC1sYWJlbC5zaG93LW1lc3NhZ2Uge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2xpYi9sb2FkZXIuanMhLi9zcmMvc2Nzcy9hcHAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBXaGVuIHNvdXJjZSBtYXBzIGFyZSBlbmFibGVkLCBgc3R5bGUtbG9hZGVyYCB1c2VzIGEgbGluayBlbGVtZW50IHdpdGggYSBkYXRhLXVyaSB0b1xuICogZW1iZWQgdGhlIGNzcyBvbiB0aGUgcGFnZS4gVGhpcyBicmVha3MgYWxsIHJlbGF0aXZlIHVybHMgYmVjYXVzZSBub3cgdGhleSBhcmUgcmVsYXRpdmUgdG8gYVxuICogYnVuZGxlIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgcGFnZS5cbiAqXG4gKiBPbmUgc29sdXRpb24gaXMgdG8gb25seSB1c2UgZnVsbCB1cmxzLCBidXQgdGhhdCBtYXkgYmUgaW1wb3NzaWJsZS5cbiAqXG4gKiBJbnN0ZWFkLCB0aGlzIGZ1bmN0aW9uIFwiZml4ZXNcIiB0aGUgcmVsYXRpdmUgdXJscyB0byBiZSBhYnNvbHV0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBBIHJ1ZGltZW50YXJ5IHRlc3Qgc3VpdGUgaXMgbG9jYXRlZCBhdCBgdGVzdC9maXhVcmxzLmpzYCBhbmQgY2FuIGJlIHJ1biB2aWEgdGhlIGBucG0gdGVzdGAgY29tbWFuZC5cbiAqXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzKSB7XG4gIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uXG4gIHZhciBsb2NhdGlvbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmxvY2F0aW9uO1xuXG4gIGlmICghbG9jYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaXhVcmxzIHJlcXVpcmVzIHdpbmRvdy5sb2NhdGlvblwiKTtcbiAgfVxuXG5cdC8vIGJsYW5rIG9yIG51bGw/XG5cdGlmICghY3NzIHx8IHR5cGVvZiBjc3MgIT09IFwic3RyaW5nXCIpIHtcblx0ICByZXR1cm4gY3NzO1xuICB9XG5cbiAgdmFyIGJhc2VVcmwgPSBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIGxvY2F0aW9uLmhvc3Q7XG4gIHZhciBjdXJyZW50RGlyID0gYmFzZVVybCArIGxvY2F0aW9uLnBhdGhuYW1lLnJlcGxhY2UoL1xcL1teXFwvXSokLywgXCIvXCIpO1xuXG5cdC8vIGNvbnZlcnQgZWFjaCB1cmwoLi4uKVxuXHQvKlxuXHRUaGlzIHJlZ3VsYXIgZXhwcmVzc2lvbiBpcyBqdXN0IGEgd2F5IHRvIHJlY3Vyc2l2ZWx5IG1hdGNoIGJyYWNrZXRzIHdpdGhpblxuXHRhIHN0cmluZy5cblxuXHQgL3VybFxccypcXCggID0gTWF0Y2ggb24gdGhlIHdvcmQgXCJ1cmxcIiB3aXRoIGFueSB3aGl0ZXNwYWNlIGFmdGVyIGl0IGFuZCB0aGVuIGEgcGFyZW5zXG5cdCAgICggID0gU3RhcnQgYSBjYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAoPzogID0gU3RhcnQgYSBub24tY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgICAgIFteKShdICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAoPzogID0gU3RhcnQgYW5vdGhlciBub24tY2FwdHVyaW5nIGdyb3Vwc1xuXHQgICAgICAgICAgICAgICAgIFteKShdKyAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICB8ICA9IE9SXG5cdCAgICAgICAgICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICAgICAgW14pKF0qICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIFxcKSAgPSBNYXRjaCBhIGVuZCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKSAgPSBFbmQgR3JvdXBcbiAgICAgICAgICAgICAgKlxcKSA9IE1hdGNoIGFueXRoaW5nIGFuZCB0aGVuIGEgY2xvc2UgcGFyZW5zXG4gICAgICAgICAgKSAgPSBDbG9zZSBub24tY2FwdHVyaW5nIGdyb3VwXG4gICAgICAgICAgKiAgPSBNYXRjaCBhbnl0aGluZ1xuICAgICAgICkgID0gQ2xvc2UgY2FwdHVyaW5nIGdyb3VwXG5cdCBcXCkgID0gTWF0Y2ggYSBjbG9zZSBwYXJlbnNcblxuXHQgL2dpICA9IEdldCBhbGwgbWF0Y2hlcywgbm90IHRoZSBmaXJzdC4gIEJlIGNhc2UgaW5zZW5zaXRpdmUuXG5cdCAqL1xuXHR2YXIgZml4ZWRDc3MgPSBjc3MucmVwbGFjZSgvdXJsXFxzKlxcKCgoPzpbXikoXXxcXCgoPzpbXikoXSt8XFwoW14pKF0qXFwpKSpcXCkpKilcXCkvZ2ksIGZ1bmN0aW9uKGZ1bGxNYXRjaCwgb3JpZ1VybCkge1xuXHRcdC8vIHN0cmlwIHF1b3RlcyAoaWYgdGhleSBleGlzdClcblx0XHR2YXIgdW5xdW90ZWRPcmlnVXJsID0gb3JpZ1VybFxuXHRcdFx0LnRyaW0oKVxuXHRcdFx0LnJlcGxhY2UoL15cIiguKilcIiQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSlcblx0XHRcdC5yZXBsYWNlKC9eJyguKiknJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KTtcblxuXHRcdC8vIGFscmVhZHkgYSBmdWxsIHVybD8gbm8gY2hhbmdlXG5cdFx0aWYgKC9eKCN8ZGF0YTp8aHR0cDpcXC9cXC98aHR0cHM6XFwvXFwvfGZpbGU6XFwvXFwvXFwvKS9pLnRlc3QodW5xdW90ZWRPcmlnVXJsKSkge1xuXHRcdCAgcmV0dXJuIGZ1bGxNYXRjaDtcblx0XHR9XG5cblx0XHQvLyBjb252ZXJ0IHRoZSB1cmwgdG8gYSBmdWxsIHVybFxuXHRcdHZhciBuZXdVcmw7XG5cblx0XHRpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvL1wiKSA9PT0gMCkge1xuXHRcdCAgXHQvL1RPRE86IHNob3VsZCB3ZSBhZGQgcHJvdG9jb2w/XG5cdFx0XHRuZXdVcmwgPSB1bnF1b3RlZE9yaWdVcmw7XG5cdFx0fSBlbHNlIGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi9cIikgPT09IDApIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHVybFxuXHRcdFx0bmV3VXJsID0gYmFzZVVybCArIHVucXVvdGVkT3JpZ1VybDsgLy8gYWxyZWFkeSBzdGFydHMgd2l0aCAnLydcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gY3VycmVudCBkaXJlY3Rvcnlcblx0XHRcdG5ld1VybCA9IGN1cnJlbnREaXIgKyB1bnF1b3RlZE9yaWdVcmwucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpOyAvLyBTdHJpcCBsZWFkaW5nICcuLydcblx0XHR9XG5cblx0XHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIHVybCguLi4pXG5cdFx0cmV0dXJuIFwidXJsKFwiICsgSlNPTi5zdHJpbmdpZnkobmV3VXJsKSArIFwiKVwiO1xuXHR9KTtcblxuXHQvLyBzZW5kIGJhY2sgdGhlIGZpeGVkIGNzc1xuXHRyZXR1cm4gZml4ZWRDc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB0ZW1wbGF0ZXMgZnJvbSAnLi9NZXRhbEZvcm0uc295LmpzJztcbmltcG9ydCBjb3JlIGZyb20gJ21ldGFsJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi4vLi4vVXRpbHMvRXZlbnRFbWl0dGVyJztcblxuY2xhc3MgTWV0YWxGb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIE1ldGFsRm9ybSBjb21wb25lbnRcblx0ICovXG5cdGNyZWF0ZWQoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0aW5zdGFuY2UuQXBwbGljYXRpb25FbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRcdGluc3RhbmNlLkFwcGxpY2F0aW9uRW1pdHRlci5vbignTElTVEVOX0RST1BET1dOX0VWRU5UJywgZGF0YSA9PiBpbnN0YW5jZS5kcm9wZG93bkRhdGEgPSBkYXRhKTtcblx0XHRpbnN0YW5jZS5BcHBsaWNhdGlvbkVtaXR0ZXIub24oJ0xJU1RFTl9DQUxDVUxBVE9SX0VWRU5UJywgZGF0YSA9PiBpbnN0YW5jZS5jYWxjdWxhdG9yRGF0YSA9IGRhdGEpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBmb3JtIGRlZmF1bHQgYmVoYXZpb3Jcblx0ICogU2V0IGJvZHkgZXZlbnQgdG8gdmVyaWZ5IHRoZSBidXR0b24gc2hvdyBtZXNzYWdlXG5cdCAqL1xuXHRhdHRhY2hlZCgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0XG5cdFx0aW5zdGFuY2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdmb3JtJykuYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgZSA9PiBlLnByZXZlbnREZWZhdWx0KCkpO1xuXHRcdFxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKT0+IHtcblx0XHRcdGlmKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnZ2V0LXF1b3QnKSkgcmV0dXJuXG5cdFx0XHRpbnN0YW5jZS5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zdWJtaXQtbGFiZWwnKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93LW1lc3NhZ2UnKTtcblx0XHR9KTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGhhcyBvcGVyYXRvcnMgaW4gdGhlIGNhbGN1bGF0b3IgZGlzcGxheVxuXHQgKiBAcGFyYW0ge1NyaW5nfSB0ZXh0XG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aGFzQ2FsY3VsYXRvck9wZXJhdG9ycyh0ZXh0KXtcblx0XHRyZXR1cm4gL1soKStcXC0vKl0vLnRlc3QodGV4dCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBoYXMgZXJyb3IgaW4gdGhlIGZvcm1cblx0ICogQHJldHVybnMge2Jvb2xlYW4gfHwgbnVsbH1cblx0ICovXG5cdGhhc0Vycm9ySW5UaGVGb3JtKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcyxcblx0XHRcdFx0ZXJyO1xuXHRcdFxuXHRcdGlmKCFpbnN0YW5jZS5jaGVja0Ryb3Bkb3duRGF0YSgpKSBlcnIgPSB0cnVlO1xuXHRcdGlmKCFpbnN0YW5jZS5jaGVja0NhbGN1bGF0b3JEYXRhKCkpIGVyciA9IHRydWU7XG5cdFx0XG5cdFx0cmV0dXJuIGluc3RhbmNlLmVycm9yID0gZXJyO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2FsY3VsYXRlIHRoZSBmb3JtIHVzaW5nIHRoZSBjb21wb3VuZCBpbnRlcmVzdCBmb3JtdWxhXG5cdCAqIGFuZCBzaG93IHRoZSByZXN1bHQgaW4gdGhlIHRvdGFsIGlucHV0XG5cdCAqL1xuXHRjYWxjdWxhdGVGb3JtKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGlmKGluc3RhbmNlLmhhc0Vycm9ySW5UaGVGb3JtKCkpIHJldHVybjtcblx0XHRcblx0XHRpbnN0YW5jZS5kZWJ0ID0gaW5zdGFuY2UuY2FsY3VsYXRlRGVidCh7XG5cdFx0XHRhbW91bnQ6IGluc3RhbmNlLmNhbGN1bGF0b3JEYXRhLFxuXHRcdFx0aW50ZXJlc3Q6IGluc3RhbmNlLmRyb3Bkb3duRGF0YS5pbnRlcmVzdCxcblx0XHRcdG1vbnRoczogaW5zdGFuY2UuZHJvcGRvd25EYXRhLm1vbnRoc1xuXHRcdH0pO1xuXG5cdFx0aW5zdGFuY2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjaW5wdXQtdG90YWwnKS5wbGFjZWhvbGRlciA9IGBSJDogJHtpbnN0YW5jZS5kZWJ0fWA7XG5cdFx0aW5zdGFuY2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZ2V0LXF1b3QnKS5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgdGhlIGRlYml0IHVzaW5nIHRoZSBjb21wb3VuZCBpbnRlcmVzdCBmb3JtdWxhXG5cdCAqIEByZXR1cm5zIHsgc3RyaW5nIH1cblx0ICovXG5cdGNhbGN1bGF0ZURlYnQoe2Ftb3VudCwgaW50ZXJlc3QsIG1vbnRoc30pe1xuXHRcdGxldCByZXN1bHQ7XG5cdFx0aW50ZXJlc3QgPSBpbnRlcmVzdCAvIDEwMDtcblx0XHRyZXN1bHQgPSAoYW1vdW50ICogTWF0aC5wb3coMSArIGludGVyZXN0LCBtb250aHMpKS50b0xvY2FsZVN0cmluZygncHQtQlInKTtcblx0XHRcblx0XHRpZihyZXN1bHQuc3BsaXQoJywnKVsxXS5sZW5ndGggPiAyKSByZXN1bHQgPSByZXN1bHQuc3Vic3RyKDAsIHJlc3VsdC5sZW5ndGgtMSk7XG5cdFx0XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBkcm9wZG93biBoYXMgaXRlbSBzZWxlY3RlZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGNoZWNrRHJvcGRvd25EYXRhKCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcyxcblx0XHRcdFx0aXNWYWxpZCA9IHRydWU7XG5cdFx0XG5cdFx0aWYoIWluc3RhbmNlLmRyb3Bkb3duRGF0YSl7XG5cdFx0XHRpbnN0YW5jZS5BcHBsaWNhdGlvbkVtaXR0ZXIuZW1pdCgnTElTVEVOX0RST1BET1dOX0VSUk9SJywgJ1BsZWFzZSwgc2VsZWN0IGFuIGl0ZW0gb2YgdGhlIGRyb3Bkb3duJyk7XG5cdFx0XHRpc1ZhbGlkID0gZmFsc2U7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBpc1ZhbGlkO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIGNhbGN1bGF0b3IgaGFzIGp1c3QgbnVtYmVycyAoaW50ZWdlcnMgb3IgZmxvYXRzKVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGNoZWNrQ2FsY3VsYXRvckRhdGEoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzLFxuXHRcdFx0ZGF0YSA9IGluc3RhbmNlLmNhbGN1bGF0b3JEYXRhLFxuXHRcdFx0aXNWYWxpZCA9IHRydWU7XG5cdFx0XG5cdFx0aWYoaW5zdGFuY2UuaGFzQ2FsY3VsYXRvck9wZXJhdG9ycyhkYXRhKSB8fCAhZGF0YSB8fCAhcGFyc2VGbG9hdChkYXRhKSl7XG5cdFx0XHRpbnN0YW5jZS5BcHBsaWNhdGlvbkVtaXR0ZXIuZW1pdCgnTElTVEVOX0NBTENVTEFUT1JfRVJST1InLCBcIlBsZWFzZSwgdHlwZSBhbiBleGVwcmVzc2lvbiBpbiB5b3VyIGNhbGN1bGF0b3IgYW5kIGNsaWNrIGluIHRoZSBidXR0b24gJz0nXCIpO1xuXHRcdFx0aXNWYWxpZCA9IGZhbHNlO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm4gaXNWYWxpZDtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNlbmQgdGhlIGNvdW50IHJlc3VsdHMgdG8gdGhlIHNlcnZlclxuXHQgKi9cblx0c3VibWl0Rm9ybSgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0Y29uc3RcdGRhdGEgPSBKU09OLnN0cmluZ2lmeSh7XG5cdFx0XHRpbnRlcmVzdDogaW5zdGFuY2UuZHJvcGRvd25EYXRhLmludGVyZXN0LFxuXHRcdFx0bG9hbjogaW5zdGFuY2UuY2FsY3VsYXRvckRhdGEsXG5cdFx0XHRudW1iZXJPZk1vbnRoczogaW5zdGFuY2UuZHJvcGRvd25EYXRhLm1vbnRocyxcblx0XHRcdHRvdGFsRGVidDogaW5zdGFuY2UuZGVidFxuXHRcdH0pO1xuXHRcdFxuXHRcdFxuXHRcdGZldGNoKGluc3RhbmNlLmVuZHBvaW50LCB7XG5cdFx0XHRtZXRob2Q6IFwiUE9TVFwiLFxuXHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHQnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKicsXG5cdFx0XHRcdCdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcblx0XHRcdH0sXG5cdFx0XHRib2R5OiBkYXRhXG5cdFx0fSkudGhlbihyZXNwID0+IHJlc3AuanNvbigpKVxuXHRcdFx0LnRoZW4oKHtzdGF0dXN9KSA9PiBpbnN0YW5jZS5zaG93Rm9ybU1lc3NhZ2Uoc3RhdHVzKSlcblx0XHRcdC5jYXRjaChlcnIgPT4gaW5zdGFuY2Uuc2hvd0Zvcm1NZXNzYWdlKGBzb21ldGhpbmcgd3JvbmcuIFBsZWFzZSBjb250YWN0IHRoZSBhZG1pbmlzdHJhdG9yLmAsIHRydWUpKVxuXHR9XG5cdFxuXHQvKipcblx0ICogIFNob3cgYSB2aXp1YWwgZmVlZGJhY2sgaW4gdGhlIGZvcm1cblx0ICogQHBhcmFtIHsgU3RyaW5nIH0gdGV4dFxuXHQgKiBAcGFyYW0geyBCb29sZWFuIH0gaGFzRXJyb3Jcblx0ICovXG5cdHNob3dGb3JtTWVzc2FnZSh0ZXh0LCBoYXNFcnJvcil7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRsZXQgZWxlbWVudCA9IGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLnN1Ym1pdC1sYWJlbCcpO1xuXHRcdFxuXHRcdGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGFuZ2VyJyk7XG5cdFx0XG5cdFx0aWYoaGFzRXJyb3IpIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnZGFuZ2VyJyk7XG5cdFx0cmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvdy1tZXNzYWdlJyk7XG5cdH1cbn1cblxuU295LnJlZ2lzdGVyKE1ldGFsRm9ybSwgdGVtcGxhdGVzKTtcblxuLyoqXG4gKiBNZXRhbEZvcm0gU3RhdGUgRGVmaW5pdGlvblxuICovXG5NZXRhbEZvcm0uU1RBVEUgPSB7XG5cdC8qKlxuXHQgKiBUaGUgZW1pdHRlciBvZiB0aGUgYXBwbGljYXRpb25cblx0ICogdG8gY29tbXVuaWNhdGUgd2l0aCB0aGUgb3RoZXIgY29tcG9uZW50c1xuXHQgKi9cblx0QXBwbGljYXRpb25FbWl0dGVyOiB7XG5cdFx0dmFsdWU6IGZhbHNlXG5cdH0sXG5cdC8qKlxuXHQgKiBUaGUgdXNlciBkZWJpdCBjYWxjdWxhdGVkIGluIHRoaXMgY29tcG9uZW50XG5cdCAqL1xuXHRkZWJ0OiB7XG5cdFx0dmFsdWU6IG51bGxcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBFeHByZXNzaW9uIHRoYXQgaXMgaW4gdGhlIGNhbGN1bGF0b3IgZGlzcGxheVxuXHQgKi9cblx0Y2FsY3VsYXRvckRhdGE6IHtcblx0XHR2YWx1ZTogbnVsbFxuXHR9LFxuXHRcblx0LyoqXG5cdCAqIEl0ZW0gc2VsZWN0ZWQgaW4gdGhlIGRyb3Bkb3duIGNvbXBvbmVudFxuXHQgKi9cblx0ZHJvcGRvd25EYXRhOiB7XG5cdFx0dmFsdWU6IG51bGxcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBVcmwgb2YgdGhlIHNlcnZlciwgdGhhdCB3aWxsIHNhdmUgdGhlIGZvcm0gZGF0YVxuXHQgKi9cblx0ZW5kcG9pbnQ6IHtcblx0XHR2YWx1ZTogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzEwMC9jYWxjdWxhdG9yJ1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBNZXRhbEZvcm07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL01ldGFsRm9ybS9NZXRhbEZvcm0uanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcbnZhciB0ZW1wbGF0ZXM7XG5nb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykge1xuXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gTWV0YWxGb3JtLnNveS5cbi8vIFBsZWFzZSBkb24ndCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGVtcGxhdGVzIGluIG5hbWVzcGFjZSBNZXRhbEZvcm0uXG4gKiBAcHVibGljXG4gKi9cblxuZ29vZy5tb2R1bGUoJ01ldGFsRm9ybS5pbmNyZW1lbnRhbGRvbScpO1xuXG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ID0gZ29vZy5yZXF1aXJlKCdzb3knKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3lkYXRhID0gZ29vZy5yZXF1aXJlKCdzb3lkYXRhJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuaTE4bi5iaWRpJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xudmFyIEluY3JlbWVudGFsRG9tID0gZ29vZy5yZXF1aXJlKCdpbmNyZW1lbnRhbGRvbScpO1xudmFyIGllX29wZW4gPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbjtcbnZhciBpZV9jbG9zZSA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRDbG9zZTtcbnZhciBpZV92b2lkID0gSW5jcmVtZW50YWxEb20uZWxlbWVudFZvaWQ7XG52YXIgaWVfb3Blbl9zdGFydCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuU3RhcnQ7XG52YXIgaWVfb3Blbl9lbmQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbkVuZDtcbnZhciBpdGV4dCA9IEluY3JlbWVudGFsRG9tLnRleHQ7XG52YXIgaWF0dHIgPSBJbmNyZW1lbnRhbERvbS5hdHRyO1xuXG52YXIgJHRlbXBsYXRlQWxpYXMxID0gU295LmdldFRlbXBsYXRlKCdDYWxjdWxhdG9yLmluY3JlbWVudGFsZG9tJywgJ3JlbmRlcicpO1xuXG52YXIgJHRlbXBsYXRlQWxpYXMyID0gU295LmdldFRlbXBsYXRlKCdEcm9wZG93bi5pbmNyZW1lbnRhbGRvbScsICdyZW5kZXInKTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfZGF0YVxuICogQHBhcmFtIHsobnVsbHx1bmRlZmluZWQpPX0gb3B0X2lnbm9yZWRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfaWpEYXRhXG4gKiBAcmV0dXJuIHt2b2lkfVxuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICovXG5mdW5jdGlvbiAkcmVuZGVyKG9wdF9kYXRhLCBvcHRfaWdub3JlZCwgb3B0X2lqRGF0YSkge1xuICBpZV9vcGVuKCdtYWluJywgbnVsbCwgbnVsbCxcbiAgICAgICdjbGFzcycsICd3cmFwcGVyJyk7XG4gICAgaWVfb3BlbignaDEnKTtcbiAgICAgIGllX29wZW4oJ3NwYW4nKTtcbiAgICAgICAgaXRleHQoJ1BlcnNvbmFsIExvYW4nKTtcbiAgICAgIGllX2Nsb3NlKCdzcGFuJyk7XG4gICAgICBpZV9vcGVuKCdzbWFsbCcpO1xuICAgICAgICBpdGV4dCgnU2F2ZSBhbmQgbm8gcmVkIHRhcGUgbG9hbi4nKTtcbiAgICAgIGllX2Nsb3NlKCdzbWFsbCcpO1xuICAgIGllX2Nsb3NlKCdoMScpO1xuICAgIGllX29wZW4oJ2Zvcm0nLCBudWxsLCBudWxsLFxuICAgICAgICAnbWV0aG9kJywgJ3Bvc3QnLFxuICAgICAgICAnY2xhc3MnLCAnbG9hbi1mb3JtJyk7XG4gICAgICBpZV9vcGVuKCdmaWVsZHNldCcsIG51bGwsIG51bGwsXG4gICAgICAgICAgJ2NsYXNzJywgJ2JveC1jYWxjdWxhdG9yJyk7XG4gICAgICAgICR0ZW1wbGF0ZUFsaWFzMSh7TGlzdGVuZXI6IG9wdF9kYXRhLkFwcGxpY2F0aW9uRW1pdHRlcn0sIG51bGwsIG9wdF9pakRhdGEpO1xuICAgICAgaWVfY2xvc2UoJ2ZpZWxkc2V0Jyk7XG4gICAgICBpZV9vcGVuKCdmaWVsZHNldCcsIG51bGwsIG51bGwsXG4gICAgICAgICAgJ2NsYXNzJywgJ2JveC1sb2FuLW9wdGlvbnMnKTtcbiAgICAgICAgaWVfb3BlbignbGFiZWwnLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgJ2ZvcicsICdzZWxlY3QtbW9udGhzJyk7XG4gICAgICAgICAgaWVfb3Blbignc3BhbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAgICdjbGFzcycsICdjYXB0aW9uJyk7XG4gICAgICAgICAgICBpdGV4dCgnTW9udGhzICcpO1xuICAgICAgICAgICAgaWVfb3Blbignc3BhbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJywgJ21hbmRhdG9yeS1zaWduJyk7XG4gICAgICAgICAgICAgIGl0ZXh0KCcqJyk7XG4gICAgICAgICAgICBpZV9jbG9zZSgnc3BhbicpO1xuICAgICAgICAgIGllX2Nsb3NlKCdzcGFuJyk7XG4gICAgICAgICAgJHRlbXBsYXRlQWxpYXMyKHtzaG93bjogJycsIExpc3RlbmVyOiBvcHRfZGF0YS5BcHBsaWNhdGlvbkVtaXR0ZXJ9LCBudWxsLCBvcHRfaWpEYXRhKTtcbiAgICAgICAgaWVfY2xvc2UoJ2xhYmVsJyk7XG4gICAgICAgIGllX29wZW4oJ2J1dHRvbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLCAnYnV0dG9uIGNhbGN1bGF0ZS1pbnRlcmVzdCcsXG4gICAgICAgICAgICAnZGF0YS1vbmNsaWNrJywgJ2NhbGN1bGF0ZUZvcm0nKTtcbiAgICAgICAgICBpdGV4dCgnQ2FsY3VsYXRlJyk7XG4gICAgICAgIGllX2Nsb3NlKCdidXR0b24nKTtcbiAgICAgICAgaWVfb3BlbignbGFiZWwnLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgJ2ZvcicsICdpbnB1dC10b3RhbCcpO1xuICAgICAgICAgIGllX29wZW4oJ3NwYW4nLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAnY2xhc3MnLCAnY2FwdGlvbicpO1xuICAgICAgICAgICAgaXRleHQoJ1RvdGFsJyk7XG4gICAgICAgICAgaWVfY2xvc2UoJ3NwYW4nKTtcbiAgICAgICAgICBpZV9vcGVuKCdpbnB1dCcsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAgICd0eXBlJywgJ3RleHQnLFxuICAgICAgICAgICAgICAnaWQnLCAnaW5wdXQtdG90YWwnLFxuICAgICAgICAgICAgICAnZGlzYWJsZWQnLCAnJyxcbiAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVyJywgJ1IkOiAwLDAwJyxcbiAgICAgICAgICAgICAgJ3JlYWRvbmx5JywgJycpO1xuICAgICAgICAgIGllX2Nsb3NlKCdpbnB1dCcpO1xuICAgICAgICBpZV9jbG9zZSgnbGFiZWwnKTtcbiAgICAgICAgaWVfdm9pZCgnc3BhbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLCAnc3VibWl0LWxhYmVsJyk7XG4gICAgICAgIGllX29wZW4oJ2J1dHRvbicsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAnY2xhc3MnLCAnZ2V0LXF1b3QgYnV0dG9uLS1maWxsZWQnLFxuICAgICAgICAgICAgJ2RhdGEtb25jbGljaycsICdzdWJtaXRGb3JtJyxcbiAgICAgICAgICAgICdkaXNhYmxlZCcsICcnKTtcbiAgICAgICAgICBpdGV4dCgnR2V0IFF1b3QnKTtcbiAgICAgICAgaWVfY2xvc2UoJ2J1dHRvbicpO1xuICAgICAgaWVfY2xvc2UoJ2ZpZWxkc2V0Jyk7XG4gICAgaWVfY2xvc2UoJ2Zvcm0nKTtcbiAgICBpZV9vcGVuKCdmb290ZXInLCBudWxsLCBudWxsLFxuICAgICAgICAnY2xhc3MnLCAnc2l0ZS1mb290ZXInKTtcbiAgICAgIGllX29wZW4oJ2RpdicsIG51bGwsIG51bGwsXG4gICAgICAgICAgJ2NsYXNzJywgJ2NvbnRhaW5lcicpO1xuICAgICAgICBpZV9vcGVuKCdwJyk7XG4gICAgICAgICAgaXRleHQoJyBMaWZlcmF5IEluYy4gJyk7XG4gICAgICAgICAgaWVfb3BlbignYnInKTtcbiAgICAgICAgICBpZV9jbG9zZSgnYnInKTtcbiAgICAgICAgICBpdGV4dCgnIENvcHlyaWdodCBcXHUwMEE5IDIwMTYgQWxsIFJpZ2h0cyBSZXNlcnZlZC4nKTtcbiAgICAgICAgaWVfY2xvc2UoJ3AnKTtcbiAgICAgIGllX2Nsb3NlKCdkaXYnKTtcbiAgICBpZV9jbG9zZSgnZm9vdGVyJyk7XG4gIGllX2Nsb3NlKCdtYWluJyk7XG59XG5leHBvcnRzLnJlbmRlciA9ICRyZW5kZXI7XG5pZiAoZ29vZy5ERUJVRykge1xuICAkcmVuZGVyLnNveVRlbXBsYXRlTmFtZSA9ICdNZXRhbEZvcm0ucmVuZGVyJztcbn1cblxuZXhwb3J0cy5yZW5kZXIucGFyYW1zID0gW1wiQXBwbGljYXRpb25FbWl0dGVyXCJdO1xuZXhwb3J0cy5yZW5kZXIudHlwZXMgPSB7XCJBcHBsaWNhdGlvbkVtaXR0ZXJcIjpcImFueVwifTtcbnRlbXBsYXRlcyA9IGV4cG9ydHM7XG5yZXR1cm4gZXhwb3J0cztcblxufSk7XG5cbmNsYXNzIE1ldGFsRm9ybSBleHRlbmRzIENvbXBvbmVudCB7fVxuU295LnJlZ2lzdGVyKE1ldGFsRm9ybSwgdGVtcGxhdGVzKTtcbmV4cG9ydCB7IE1ldGFsRm9ybSwgdGVtcGxhdGVzIH07XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZXM7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9NZXRhbEZvcm0vTWV0YWxGb3JtLnNveS5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb3JlIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmFic3RyYWN0TWV0aG9kID0gYWJzdHJhY3RNZXRob2Q7XG5leHBvcnRzLmRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSA9IGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBlbmFibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhID0gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhO1xuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbk5hbWU7XG5leHBvcnRzLmdldFN0YXRpY1Byb3BlcnR5ID0gZ2V0U3RhdGljUHJvcGVydHk7XG5leHBvcnRzLmdldFVpZCA9IGdldFVpZDtcbmV4cG9ydHMuaWRlbnRpdHlGdW5jdGlvbiA9IGlkZW50aXR5RnVuY3Rpb247XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbmV4cG9ydHMuaXNEZWYgPSBpc0RlZjtcbmV4cG9ydHMuaXNEZWZBbmROb3ROdWxsID0gaXNEZWZBbmROb3ROdWxsO1xuZXhwb3J0cy5pc0RvY3VtZW50ID0gaXNEb2N1bWVudDtcbmV4cG9ydHMuaXNEb2N1bWVudEZyYWdtZW50ID0gaXNEb2N1bWVudEZyYWdtZW50O1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5leHBvcnRzLmlzV2luZG93ID0gaXNXaW5kb3c7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNTZXJ2ZXJTaWRlID0gaXNTZXJ2ZXJTaWRlO1xuZXhwb3J0cy5udWxsRnVuY3Rpb24gPSBudWxsRnVuY3Rpb247XG52YXIgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHZvaWQgMDtcblxuLyoqXG4gKiBDb3VudGVyIGZvciB1bmlxdWUgaWQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVuaXF1ZUlkQ291bnRlcl8gPSAxO1xuXG4vKipcbiAqIFVuaXF1ZSBpZCBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG52YXIgVUlEX1BST1BFUlRZID0gZXhwb3J0cy5VSURfUFJPUEVSVFkgPSAnY29yZV8nICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApO1xuXG4vKipcbiAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG4gKiBGb28ucHJvdG90eXBlLmJhciA9IGFic3RyYWN0TWV0aG9kXG4gKlxuICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICpcbiAqIEB0eXBlIHshRnVuY3Rpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kKCkge1xuICB0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUgd2l0aCB0aGUgZm9sbG93aW5nIGZlYXR1cmVzIGZyb20gcmNcbiAqIGFuZCAxLnggdmVyc2lvbnM6XG4gKiAgICAgLSBVc2luZyBcImtleVwiIHRvIHJlZmVyZW5jZSBjb21wb25lbnQgaW5zdGFuY2VzLiBJbiB0aGUgY3VycmVudCB2ZXJzaW9uXG4gKiAgICAgICB0aGlzIHNob3VsZCBiZSBkb25lIHZpYSBcInJlZlwiIGluc3RlYWQuIFRoaXMgYWxsb3dzIG9sZCBjb2RlIHN0aWxsXG4gKiAgICAgICB1c2luZyBcImtleVwiIHRvIGtlZXAgd29ya2luZyBsaWtlIGJlZm9yZS4gTk9URTogdGhpcyBtYXkgY2F1c2VcbiAqICAgICAgIHByb2JsZW1zLCBzaW5jZSBcImtleVwiIGlzIG1lYW50IHRvIGJlIHVzZWQgZGlmZmVyZW50bHkuIE9ubHkgdXNlIHRoaXNcbiAqICAgICAgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVwZ3JhZGUgdGhlIGNvZGUgdG8gdXNlIFwicmVmXCIgaW5zdGVhZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGEgT3B0aW9uYWwgb2JqZWN0IHdpdGggZGF0YSB0byBzcGVjaWZ5IG1vcmVcbiAqICAgICBkZXRhaWxzLCBzdWNoIGFzOlxuICogICAgICAgICAtIHJlbmRlcmVycyB7QXJyYXl9IHRoZSB0ZW1wbGF0ZSByZW5kZXJlcnMgdGhhdCBzaG91bGQgYmUgaW5cbiAqICAgICAgICAgICBjb21wYXRpYmlsaXR5IG1vZGUsIGVpdGhlciB0aGVpciBjb25zdHJ1Y3RvcnMgb3Igc3RyaW5nc1xuICogICAgICAgICAgIHJlcHJlc2VudGluZyB0aGVtIChlLmcuICdzb3knIG9yICdqc3gnKS4gQnkgZGVmYXVsdCwgYWxsIHRoZSBvbmVzXG4gKiAgICAgICAgICAgdGhhdCBleHRlbmQgZnJvbSBJbmNyZW1lbnRhbERvbVJlbmRlcmVyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIHZhciBvcHRfZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG9wdF9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlLCBvciBub3RoaW5nIGlmIGl0IGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGEoKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgbW9kZSBjYW4gYmUgc2V0IHZpYSB0aGUgX19NRVRBTF9DT01QQVRJQklMSVRZX18gZ2xvYmFsIHZhci5cbiAgaWYgKGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pIHtcbiAgICAgIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wYXRpYmlsaXR5TW9kZURhdGFfO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgdHJ1dGh5LCBvciB0aGUgc2Vjb25kIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBnZXRGaXJzdFRydXRoeV8oYSwgYikge1xuICByZXR1cm4gYSB8fCBiO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiBjb250ZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAoIWZuLm5hbWUpIHtcbiAgICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICBmbi5uYW1lID0gc3RyLnN1YnN0cmluZyg5LCBzdHIuaW5kZXhPZignKCcpKTtcbiAgfVxuICByZXR1cm4gZm4ubmFtZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBwcm9wZXJ0eSBpbiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gKiBpbmhlcml0ZWQgZnJvbSBhbmNlc3RvcnMgYXMgZXhwZWN0ZWQsIHVubGVzcyBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiBpcyBnaXZlbixcbiAqIHdoaWNoIGNhbiBjaGFuZ2UgaG93IHRoZSBzdXBlciBjbGFzc2VzJyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eSB3aWxsIGJlIG1lcmdlZFxuICogdG9nZXRoZXIuXG4gKiBUaGUgZmluYWwgbWVyZ2VkIHZhbHVlIHdpbGwgYmUgc3RvcmVkIGluIGFub3RoZXIgcHJvcGVydHksIHNvIHRoYXQgaXQgd29uJ3RcbiAqIGJlIHJlY2FsY3VsYXRlZCBldmVuIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOio9fSBvcHRfbWVyZ2VGbiBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBtZXJnZWRcbiAqICAgICB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgc28gZmFyIGFuZCB0aGUgbmV4dCB2YWx1ZSB0byBiZSBtZXJnZWQgdG8gaXQuXG4gKiAgICAgU2hvdWxkIHJldHVybiB0aGVzZSB0d28gbWVyZ2VkIHRvZ2V0aGVyLiBJZiBub3QgcGFzc2VkIHRoZSBmaW5hbCBwcm9wZXJ0eVxuICogICAgIHdpbGwgYmUgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSBhbW9uZyBhbmNlc3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IsIHByb3BlcnR5TmFtZSwgb3B0X21lcmdlRm4pIHtcbiAgdmFyIG1lcmdlZE5hbWUgPSBwcm9wZXJ0eU5hbWUgKyAnX01FUkdFRCc7XG4gIGlmICghY3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuICAgIHZhciBtZXJnZWQgPSBjdG9yLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgPyBjdG9yW3Byb3BlcnR5TmFtZV0gOiBudWxsO1xuICAgIGlmIChjdG9yLl9fcHJvdG9fXyAmJiAhY3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcbiAgICAgIHZhciBtZXJnZUZuID0gb3B0X21lcmdlRm4gfHwgZ2V0Rmlyc3RUcnV0aHlfO1xuICAgICAgbWVyZ2VkID0gbWVyZ2VGbihtZXJnZWQsIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IuX19wcm90b19fLCBwcm9wZXJ0eU5hbWUsIG1lcmdlRm4pKTtcbiAgICB9XG4gICAgY3RvclttZXJnZWROYW1lXSA9IG1lcmdlZDtcbiAgfVxuICByZXR1cm4gY3RvclttZXJnZWROYW1lXTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIHVuaXF1ZSBpZC4gSWYgYG9wdF9vYmplY3RgIGFyZ3VtZW50IGlzIHBhc3NlZCwgdGhlIG9iamVjdCBpc1xuICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG4gKiByZXR1cm5zLiBTZWUge0BsaW5rIFVJRF9QUk9QRVJUWX0uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3QgT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZlxuICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9Jbmhlcml0YW5jZSBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhpc1xuICogICAgIG9iamVjdCdzIHVpZCBwcm9wZXJ0eSBjYW4gYmUgaW5oZXJpdGVkIGZyb20gcGFyZW50cyBvciBub3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGdldFVpZChvcHRfb2JqZWN0LCBvcHRfbm9Jbmhlcml0YW5jZSkge1xuICBpZiAob3B0X29iamVjdCkge1xuICAgIHZhciBpZCA9IG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXTtcbiAgICBpZiAob3B0X25vSW5oZXJpdGFuY2UgJiYgIW9wdF9vYmplY3QuaGFzT3duUHJvcGVydHkoVUlEX1BST1BFUlRZKSkge1xuICAgICAgaWQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaWQgfHwgKG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXSA9IHVuaXF1ZUlkQ291bnRlcl8rKyk7XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZUlkQ291bnRlcl8rKztcbn1cblxuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uIFJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7P30gVGhlIGZpcnN0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWYodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcbiAgcmV0dXJuIGlzRGVmKHZhbCkgJiYgIWlzTnVsbCh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQtZnJhZ21lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb20gZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHdpbmRvdy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuICogYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcbiAgcmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuLyoqXG4gKiBTZXRzIHRvIHRydWUgaWYgcnVubmluZyBpbnNpZGUgTm9kZS5qcyBlbnZpcm9ubWVudCB3aXRoIGV4dHJhIGNoZWNrIGZvclxuICogYHByb2Nlc3MuYnJvd3NlcmAgdG8gc2tpcCBLYXJtYSBydW5uZXIgZW52aXJvbm1lbnQuIEthcm1hIGVudmlyb25tZW50IGhhc1xuICogYHByb2Nlc3NgIGRlZmluZWQgZXZlbiB0aG91Z2ggaXQgcnVucyBvbiB0aGUgYnJvd3Nlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2VydmVyU2lkZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgIXByb2Nlc3MuYnJvd3Nlcjtcbn1cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge31cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9jb3JlTmFtZWQuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIGFycmF5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBhcnJheSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoYXJyYXksIG51bGwsIFt7XG5cdFx0a2V5OiAnZXF1YWwnLFxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudC5cbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjFcbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IGFycjJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVxdWFsKGFycjEsIGFycjIpIHtcblx0XHRcdGlmIChhcnIxID09PSBhcnIyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGUgZ2l2ZW4gYXJyYXkgdGhhdCBpc24ndCB1bmRlZmluZWQuXG4gICAqIEBwYXJhbSB7IUFycmF5fSBhcnJcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZpcnN0RGVmaW5lZFZhbHVlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmlyc3REZWZpbmVkVmFsdWUoYXJyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyW2ldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gYXJyW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cbiAgICogQHBhcmFtIHtBcnJheS48KnxBcnJheS48Kj4+fSBhcnIgTmVzdGVkIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAqIEBwYXJhbSB7QXJyYXkuPCo+fSBvcHRfb3V0cHV0IE9wdGlvbmFsIG91dHB1dCBhcnJheS5cbiAgICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmxhdHRlbicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gb3B0X291dHB1dCB8fCBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0XHRhcnJheS5mbGF0dGVuKGFycltpXSwgb3V0cHV0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGEgcGFydGljdWxhciB2YWx1ZSBmcm9tIGFuIGFycmF5LlxuICAgKiBAcGFyYW0ge0FycmF5LjxUPn0gYXJyIEFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1R9IG9iaiBPYmplY3QgdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoYXJyLCBvYmopIHtcblx0XHRcdHZhciBpID0gYXJyLmluZGV4T2Yob2JqKTtcblx0XHRcdHZhciBydiA9IHZvaWQgMDtcblx0XHRcdGlmIChydiA9IGkgPj0gMCkge1xuXHRcdFx0XHRhcnJheS5yZW1vdmVBdChhcnIsIGkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJ2O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgQXJyYXkgb3IgYXJyYXkgbGlrZSBvYmplY3QgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFRoZSBpbmRleCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZUF0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQXQoYXJyLCBpKSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKGFyciwgaSwgMSkubGVuZ3RoID09PSAxO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTbGljZXMgdGhlIGdpdmVuIGFycmF5LCBqdXN0IGxpa2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgdGhpc1xuICAgKiBpcyBmYXN0ZXIgYW5kIHdvcmtpbmcgb24gYWxsIGFycmF5LWxpa2Ugb2JqZWN0cyAobGlrZSBhcmd1bWVudHMpLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGFyciBBcnJheS1saWtlIG9iamVjdCB0byBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0aGF0IHNob3VsZCBzdGFydCB0aGUgc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0X2VuZCBUaGUgaW5kZXggd2hlcmUgdGhlIHNsaWNlIHNob3VsZCBlbmQsIG5vdFxuICAgKiAgIGluY2x1ZGVkIGluIHRoZSBmaW5hbCBhcnJheS4gSWYgbm90IGdpdmVuLCBhbGwgZWxlbWVudHMgYWZ0ZXIgdGhlXG4gICAqICAgc3RhcnQgaW5kZXggd2lsbCBiZSBpbmNsdWRlZC5cbiAgICogQHJldHVybiB7IUFycmF5fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2xpY2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzbGljZShhcnIsIHN0YXJ0LCBvcHRfZW5kKSB7XG5cdFx0XHR2YXIgc2xpY2VkID0gW107XG5cdFx0XHR2YXIgZW5kID0gKDAsIF9jb3JlLmlzRGVmKShvcHRfZW5kKSA/IG9wdF9lbmQgOiBhcnIubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdFx0c2xpY2VkLnB1c2goYXJyW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzbGljZWQ7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGFycmF5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcnJheTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hcnJheS9hcnJheS5qc1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyohXG4gKiBQb2x5ZmlsbCBmcm9tIEdvb2dsZSdzIENsb3N1cmUgTGlicmFyeS5cbiAqIENvcHlyaWdodCAyMDEzIFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgYXN5bmMgPSB7fTtcblxuLyoqXG4gKiBUaHJvdyBhbiBpdGVtIHdpdGhvdXQgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LiAgRm9yXG4gKiBleGFtcGxlLCBpZiBwcm9jZXNzaW5nIGEgZ3JvdXAgb2YgaXRlbXMgaW4gYSBsb29wLCBzb21ldGltZXMgaXQgaXMgdXNlZnVsXG4gKiB0byByZXBvcnQgYW4gZXJyb3Igd2hpbGUgc3RpbGwgYWxsb3dpbmcgdGhlIHJlc3Qgb2YgdGhlIGJhdGNoIHRvIGJlXG4gKiBwcm9jZXNzZWQuXG4gKiBAcGFyYW0geyp9IGV4Y2VwdGlvblxuICovXG5hc3luYy50aHJvd0V4Y2VwdGlvbiA9IGZ1bmN0aW9uIChleGNlcHRpb24pIHtcblx0Ly8gRWFjaCB0aHJvdyBuZWVkcyB0byBiZSBpbiBpdHMgb3duIGNvbnRleHQuXG5cdGFzeW5jLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcblx0XHR0aHJvdyBleGNlcHRpb247XG5cdH0pO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2sganVzdCBiZWZvcmUgdGhlIGN1cnJlbnQgY2FsbHN0YWNrIHVud2luZHMsIG9yIGFzXG4gKiBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbiBjb250ZXh0LlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlRISVMpfSBjYWxsYmFja1xuICogQHBhcmFtIHtUSElTPX0gb3B0X2NvbnRleHQgT2JqZWN0IHRvIHVzZSBhcyB0aGUgXCJ0aGlzIHZhbHVlXCIgd2hlbiBjYWxsaW5nXG4gKiAgICAgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICogQHRlbXBsYXRlIFRISVNcbiAqL1xuYXN5bmMucnVuID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHRpZiAoIWFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfKSB7XG5cdFx0Ly8gTm90aGluZyBpcyBjdXJyZW50bHkgc2NoZWR1bGVkLCBzY2hlZHVsZSBpdCBub3cuXG5cdFx0YXN5bmMubmV4dFRpY2soYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUpO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gdHJ1ZTtcblx0fVxuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVfLnB1c2gobmV3IGFzeW5jLnJ1bi5Xb3JrSXRlbV8oY2FsbGJhY2ssIG9wdF9jb250ZXh0KSk7XG59O1xuXG4vKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xuXG4vKiogQHByaXZhdGUgeyFBcnJheS48IWFzeW5jLnJ1bi5Xb3JrSXRlbV8+fSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblxuLyoqXG4gKiBSdW4gYW55IHBlbmRpbmcgYXN5bmMucnVuIHdvcmsgaXRlbXMuIFRoaXMgZnVuY3Rpb24gaXMgbm90IGludGVuZGVkXG4gKiBmb3IgZ2VuZXJhbCB1c2UsIGJ1dCBmb3IgdXNlIGJ5IGVudHJ5IHBvaW50IGhhbmRsZXJzIHRvIHJ1biBpdGVtcyBhaGVhZCBvZlxuICogYXN5bmMubmV4dFRpY2suXG4gKi9cbmFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlID0gZnVuY3Rpb24gKCkge1xuXHQvLyBOT1RFOiBhZGRpdGlvbmFsIHdvcmsgcXVldWUgaXRlbXMgbWF5IGJlIHB1c2hlZCB3aGlsZSBwcm9jZXNzaW5nLlxuXHR3aGlsZSAoYXN5bmMucnVuLndvcmtRdWV1ZV8ubGVuZ3RoKSB7XG5cdFx0Ly8gRG9uJ3QgbGV0IHRoZSB3b3JrIHF1ZXVlIGdyb3cgaW5kZWZpbml0ZWx5LlxuXHRcdHZhciB3b3JrSXRlbXMgPSBhc3luYy5ydW4ud29ya1F1ZXVlXztcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgd29ya0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgd29ya0l0ZW0gPSB3b3JrSXRlbXNbaV07XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3b3JrSXRlbS5mbi5jYWxsKHdvcmtJdGVtLnNjb3BlKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0YXN5bmMudGhyb3dFeGNlcHRpb24oZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gVGhlcmUgYXJlIG5vIG1vcmUgd29yayBpdGVtcywgcmVzZXQgdGhlIHdvcmsgcXVldWUuXG5cdGFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGZpbmFsXG4gKiBAc3RydWN0XG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fG51bGx8dW5kZWZpbmVkfSBzY29wZVxuICovXG5hc3luYy5ydW4uV29ya0l0ZW1fID0gZnVuY3Rpb24gKGZuLCBzY29wZSkge1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuZm4gPSBmbjtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLnNjb3BlID0gc2NvcGU7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFja3MgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKU1xuICogZXhlY3V0aW9uIGNvbnRleHQuIHNldFRpbWVvdXQo4oCmLCAwKSBhbHdheXMgdGFrZXMgYXQgbGVhc3QgNW1zIGZvciBsZWdhY3lcbiAqIHJlYXNvbnMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6U0NPUEUpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXNcbiAqICAgICBwb3NzaWJsZS5cbiAqIEBwYXJhbSB7U0NPUEU9fSBvcHRfY29udGV4dCBPYmplY3QgaW4gd2hvc2Ugc2NvcGUgdG8gY2FsbCB0aGUgbGlzdGVuZXIuXG4gKiBAdGVtcGxhdGUgU0NPUEVcbiAqL1xuYXN5bmMubmV4dFRpY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdHZhciBjYiA9IGNhbGxiYWNrO1xuXHRpZiAob3B0X2NvbnRleHQpIHtcblx0XHRjYiA9IGNhbGxiYWNrLmJpbmQob3B0X2NvbnRleHQpO1xuXHR9XG5cdGNiID0gYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyhjYik7XG5cdC8vIEludHJvZHVjZWQgYW5kIGN1cnJlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBJRTEwLlxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHNldEltbWVkaWF0ZShjYik7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdC8vIExvb2sgZm9yIGFuZCBjYWNoZSB0aGUgY3VzdG9tIGZhbGxiYWNrIHZlcnNpb24gb2Ygc2V0SW1tZWRpYXRlLlxuXHRpZiAoIWFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8pIHtcblx0XHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfKCk7XG5cdH1cblx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyhjYik7XG59O1xuXG4vKipcbiAqIENhY2hlIGZvciB0aGUgc2V0SW1tZWRpYXRlIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfVxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IG51bGw7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbiB0byBydW4gYSBmdW5jdGlvbiBhcyBzb29uIGFzXG4gKiB0aGUgSlMgZXZlbnQgbG9vcCBpcyBpZGxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9IFRoZSBcInNldEltbWVkaWF0ZVwiIGltcGxlbWVudGF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2suZ2V0U2V0SW1tZWRpYXRlRW11bGF0b3JfID0gZnVuY3Rpb24gKCkge1xuXHQvLyBDcmVhdGUgYSBwcml2YXRlIG1lc3NhZ2UgY2hhbm5lbCBhbmQgdXNlIGl0IHRvIHBvc3RNZXNzYWdlIGVtcHR5IG1lc3NhZ2VzXG5cdC8vIHRvIG91cnNlbHZlcy5cblx0dmFyIENoYW5uZWwgPSB2b2lkIDA7XG5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdENoYW5uZWwgPSBNZXNzYWdlQ2hhbm5lbDtcblx0fVxuXG5cdC8vIElmIE1lc3NhZ2VDaGFubmVsIGlzIG5vdCBhdmFpbGFibGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIsIGltcGxlbWVudFxuXHQvLyBhbiBpZnJhbWUgYmFzZWQgcG9seWZpbGwgaW4gYnJvd3NlcnMgdGhhdCBoYXZlIHBvc3RNZXNzYWdlIGFuZFxuXHQvLyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyLiBUaGUgbGF0dGVyIGV4Y2x1ZGVzIElFOCBiZWNhdXNlIGl0IGhhcyBhXG5cdC8vIHN5bmNocm9ub3VzIHBvc3RNZXNzYWdlIGltcGxlbWVudGF0aW9uLlxuXHRpZiAodHlwZW9mIENoYW5uZWwgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdC8qKiBAY29uc3RydWN0b3IgKi9cblx0XHRDaGFubmVsID0gZnVuY3Rpb24gQ2hhbm5lbCgpIHtcblx0XHRcdC8vIE1ha2UgYW4gZW1wdHksIGludmlzaWJsZSBpZnJhbWUuXG5cdFx0XHR2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0XHRpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdGlmcmFtZS5zcmMgPSAnJztcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdFx0dmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuXHRcdFx0dmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcblx0XHRcdGRvYy5vcGVuKCk7XG5cdFx0XHRkb2Mud3JpdGUoJycpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cdFx0XHR2YXIgbWVzc2FnZSA9ICdjYWxsSW1tZWRpYXRlJyArIE1hdGgucmFuZG9tKCk7XG5cdFx0XHR2YXIgb3JpZ2luID0gd2luLmxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIHdpbi5sb2NhdGlvbi5ob3N0O1xuXHRcdFx0dmFyIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIFZhbGlkYXRlIG9yaWdpbiBhbmQgbWVzc2FnZSB0byBtYWtlIHN1cmUgdGhhdCB0aGlzIG1lc3NhZ2Ugd2FzXG5cdFx0XHRcdC8vIGludGVuZGVkIGZvciB1cy5cblx0XHRcdFx0aWYgKGUub3JpZ2luICE9PSBvcmlnaW4gJiYgZS5kYXRhICE9PSBtZXNzYWdlKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucG9ydDEub25tZXNzYWdlKCk7XG5cdFx0XHR9LmJpbmQodGhpcyk7XG5cdFx0XHR3aW4uYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9ubWVzc2FnZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5wb3J0MSA9IHt9O1xuXHRcdFx0dGhpcy5wb3J0MiA9IHtcblx0XHRcdFx0cG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKCkge1xuXHRcdFx0XHRcdHdpbi5wb3N0TWVzc2FnZShtZXNzYWdlLCBvcmlnaW4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH1cblx0aWYgKHR5cGVvZiBDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdHZhciBjaGFubmVsID0gbmV3IENoYW5uZWwoKTtcblx0XHQvLyBVc2UgYSBmaWZvIGxpbmtlZCBsaXN0IHRvIGNhbGwgY2FsbGJhY2tzIGluIHRoZSByaWdodCBvcmRlci5cblx0XHR2YXIgaGVhZCA9IHt9O1xuXHRcdHZhciB0YWlsID0gaGVhZDtcblx0XHRjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGhlYWQgPSBoZWFkLm5leHQ7XG5cdFx0XHR2YXIgY2IgPSBoZWFkLmNiO1xuXHRcdFx0aGVhZC5jYiA9IG51bGw7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dGFpbC5uZXh0ID0ge1xuXHRcdFx0XHRjYjogY2Jcblx0XHRcdH07XG5cdFx0XHR0YWlsID0gdGFpbC5uZXh0O1xuXHRcdFx0Y2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcblx0XHR9O1xuXHR9XG5cdC8vIEltcGxlbWVudGF0aW9uIGZvciBJRTYtODogU2NyaXB0IGVsZW1lbnRzIGZpcmUgYW4gYXN5bmNocm9ub3VzXG5cdC8vIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aGVuIGluc2VydGVkIGludG8gdGhlIERPTS5cblx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQvLyBDbGVhbiB1cCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXG5cdFx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXHRcdFx0XHRzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdFx0XHRzY3JpcHQgPSBudWxsO1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0XHRjYiA9IG51bGw7XG5cdFx0XHR9O1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0fTtcblx0fVxuXHQvLyBGYWxsIGJhY2sgdG8gc2V0VGltZW91dCB3aXRoIDAuIEluIGJyb3dzZXJzIHRoaXMgY3JlYXRlcyBhIGRlbGF5IG9mIDVtc1xuXHQvLyBvciBtb3JlLlxuXHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0c2V0VGltZW91dChjYiwgMCk7XG5cdH07XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGlzIG92ZXJyaWRlZCB0byBwcm90ZWN0IGNhbGxiYWNrcyB3aXRoIGVudHJ5IHBvaW50XG4gKiBtb25pdG9yIGlmIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9ycyBlbnRyeSBwb2ludHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhcyBwb3NzaWJsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKCl9IFRoZSB3cmFwcGVkIGNhbGxiYWNrLlxuICogQHByaXZhdGVcbiAqL1xuYXN5bmMubmV4dFRpY2sud3JhcENhbGxiYWNrXyA9IGZ1bmN0aW9uIChvcHRfcmV0dXJuVmFsdWUpIHtcblx0cmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFzeW5jO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3Bvc2FibGUpO1xuXG5cdFx0LyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHRoaXMuZGlzcG9zZWRfID0gZmFsc2U7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKERpc3Bvc2FibGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpY1xuICAgKiBkaXNwb3NpbmcgbG9naWMgKGxpa2UgY2xlYXJpbmcgcmVmZXJlbmNlcyBhbmQgY2FsbGluZyBgZGlzcG9zZWAgb24gb3RoZXJcbiAgICogZGlzcG9zYWJsZXMpLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNEaXNwb3NlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERpc3Bvc2FibGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3Bvc2FibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIG9iamVjdCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgb2JqZWN0KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhvYmplY3QsIG51bGwsIFt7XG5cdFx0a2V5OiAnbWl4aW4nLFxuXG5cdFx0LyoqXG4gICAqIENvcGllcyBhbGwgdGhlIG1lbWJlcnMgb2YgYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2UuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBtaXhpbih0YXJnZXQpIHtcblx0XHRcdHZhciBrZXkgPSB2b2lkIDAsXG5cdFx0XHQgICAgc291cmNlID0gdm9pZCAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0XHR0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZS5cbiAgICogQHBhcmFtIHtvYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3Qgd2l0aGluIHdoaWNoIHRvIGxvb2s7IGRlZmF1bHQgaXNcbiAgICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG4gICAqIEByZXR1cm4gez99IFRoZSB2YWx1ZSAob2JqZWN0IG9yIHByaW1pdGl2ZSkgb3IsIGlmIG5vdCBmb3VuZCwgdW5kZWZpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0T2JqZWN0QnlOYW1lJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0T2JqZWN0QnlOYW1lKG5hbWUsIG9wdF9vYmopIHtcblx0XHRcdHZhciBzY29wZSA9IG9wdF9vYmogfHwgd2luZG93O1xuXHRcdFx0dmFyIHBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xuXHRcdFx0cmV0dXJuIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAocGFydCwga2V5KSB7XG5cdFx0XHRcdHJldHVybiBwYXJ0W2tleV07XG5cdFx0XHR9LCBzY29wZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgZ2l2ZW4gb25lLCBidXQgd2l0aFxuICAgKiB0aGVpciB2YWx1ZXMgc2V0IHRvIHRoZSByZXR1cm4gdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKHN0cmluZywgKil9IGZuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYXAnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYXAob2JqLCBmbikge1xuXHRcdFx0dmFyIG1hcHBlZE9iaiA9IHt9O1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG1hcHBlZE9ialtrZXlzW2ldXSA9IGZuKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwcGVkT2JqO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHR3byBnaXZlbiBvYmplY3RzIGFyZSBlcXVhbC4gVGhpcyBpcyBkb25lIHZpYSBhIHNoYWxsb3dcbiAgICogY2hlY2ssIGluY2x1ZGluZyBvbmx5IHRoZSBrZXlzIGRpcmVjdGx5IGNvbnRhaW5lZCBieSB0aGUgMiBvYmplY3RzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hhbGxvd0VxdWFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iajEsIG9iajIpIHtcblx0XHRcdGlmIChvYmoxID09PSBvYmoyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcblx0XHRcdHZhciBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuXHRcdFx0aWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAob2JqMVtrZXlzMVtpXV0gIT09IG9iajJba2V5czFbaV1dKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gb2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBvYmplY3Q7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtY29tcG9uZW50L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvb2JqZWN0L29iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBzdHJpbmcoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIHN0cmluZyk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Moc3RyaW5nLCBudWxsLCBbe1xuXHRcdGtleTogJ2Nhc2VJbnNlbnNpdGl2ZUNvbXBhcmUnLFxuXG5cdFx0LyoqXG4gICAqIENvbXBhcmVzIHRoZSBnaXZlbiBzdHJpbmdzIHdpdGhvdXQgdGFraW5nIHRoZSBjYXNlIGludG8gYWNjb3VudC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIxXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEVpdGhlciAtMSwgMCBvciAxLCBhY2NvcmRpbmcgdG8gaWYgdGhlIGZpcnN0IHN0cmluZyBpc1xuICAgKiAgICAgXCJzbWFsbGVyXCIsIGVxdWFsIG9yIFwiYmlnZ2VyXCIgdGhhbiB0aGUgc2Vjb25kIGdpdmVuIHN0cmluZy5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNhc2VJbnNlbnNpdGl2ZUNvbXBhcmUoc3RyMSwgc3RyMikge1xuXHRcdFx0dmFyIHRlc3QxID0gU3RyaW5nKHN0cjEpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR2YXIgdGVzdDIgPSBTdHJpbmcoc3RyMikudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKHRlc3QxIDwgdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fSBlbHNlIGlmICh0ZXN0MSA9PT0gdGVzdDIpIHtcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgYnJlYWtpbmcgc3BhY2VzIGZyb20gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBzdHJpbmcgYW5kXG4gICAqIGNvbGxhcHNlcyB0aGUgc2VxdWVuY2VzIG9mIGJyZWFraW5nIHNwYWNlcyBpbiB0aGUgbWlkZGxlIGludG8gc2luZ2xlIHNwYWNlcy5cbiAgICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIEEgc3RyaW5nIGluIHdoaWNoIHRvIGNvbGxhcHNlIHNwYWNlcy5cbiAgICogQHJldHVybiB7c3RyaW5nfSBDb3B5IG9mIHRoZSBzdHJpbmcgd2l0aCBub3JtYWxpemVkIGJyZWFraW5nIHNwYWNlcy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NvbGxhcHNlQnJlYWtpbmdTcGFjZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb2xsYXBzZUJyZWFraW5nU3BhY2VzKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9bXFx0XFxyXFxuIF0rL2csICcgJykucmVwbGFjZSgvXltcXHRcXHJcXG4gXSt8W1xcdFxcclxcbiBdKyQvZywgJycpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIEVzY2FwZXMgY2hhcmFjdGVycyBpbiB0aGUgc3RyaW5nIHRoYXQgYXJlIG5vdCBzYWZlIHRvIHVzZSBpbiBhIFJlZ0V4cC5cbiAgKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuICAqICAgICB0byBvbmUuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIFJlZ0V4cCBzYWZlLCBlc2NhcGVkIGNvcHkgb2Yge0Bjb2RlIHN9LlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlc2NhcGVSZWdleCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuXHRcdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFx4MDgnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBSZXR1cm5zIGEgc3RyaW5nIHdpdGggYXQgbGVhc3QgNjQtYml0cyBvZiByYW5kb21uZXNzLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSByYW5kb20gc3RyaW5nLCBlLmcuIHNuMXM3dmI0Z2NpYy5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UmFuZG9tU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZG9tU3RyaW5nKCkge1xuXHRcdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdFx0cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpLnRvU3RyaW5nKDM2KSArIE1hdGguYWJzKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHgpIF4gRGF0ZS5ub3coKSkudG9TdHJpbmcoMzYpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuICAgKiB0aGUgc3VtIGFsZ29yaXRobTogc1swXSozMV4obi0xKSArIHNbMV0qMzFeKG4tMikgKyAuLi4gKyBzW24tMV0uIEEgbmljZVxuICAgKiBwcm9wZXJ0eSBvZiB1c2luZyAzMSBwcmltZSBpcyB0aGF0IHRoZSBtdWx0aXBsaWNhdGlvbiBjYW4gYmUgcmVwbGFjZWQgYnlcbiAgICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuICAgKiBNb2Rlcm4gVk1zIGRvIHRoaXMgc29ydCBvZiBvcHRpbWl6YXRpb24gYXV0b21hdGljYWxseS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbCBUYXJnZXQgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2hhc2hDb2RlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFzaENvZGUodmFsKSB7XG5cdFx0XHR2YXIgaGFzaCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGhhc2ggPSAzMSAqIGhhc2ggKyB2YWwuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0aGFzaCAlPSAweDEwMDAwMDAwMDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXBsYWNlcyBpbnRlcnZhbCBpbnRvIHRoZSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgdmFsdWUsIGUuZy5cbiAgICogYHJlcGxhY2VJbnRlcnZhbChcImFiY2RlXCIsIDEsIDQsIFwiXCIpYCByZXR1cm5zIFwiYWVcIi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgaW5wdXQgc3RyaW5nLlxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgRW5kIGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcmVwbGFjZXMgdGhlIHNwZWNpZmllZCBpbnRlcnZhbC5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVwbGFjZUludGVydmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZUludGVydmFsKHN0ciwgc3RhcnQsIGVuZCwgdmFsdWUpIHtcblx0XHRcdHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KSArIHZhbHVlICsgc3RyLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBzdHJpbmc7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9ldmVudHMgPSByZXF1aXJlKCcuL2V2ZW50cy9ldmVudHMnKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfc3luYyA9IHJlcXVpcmUoJy4vc3luYy9zeW5jJyk7XG5cbnZhciBfbWV0YWxEb20gPSByZXF1aXJlKCdtZXRhbC1kb20nKTtcblxudmFyIF9Db21wb25lbnREYXRhTWFuYWdlciA9IHJlcXVpcmUoJy4vQ29tcG9uZW50RGF0YU1hbmFnZXInKTtcblxudmFyIF9Db21wb25lbnREYXRhTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Db21wb25lbnREYXRhTWFuYWdlcik7XG5cbnZhciBfQ29tcG9uZW50UmVuZGVyZXIgPSByZXF1aXJlKCcuL0NvbXBvbmVudFJlbmRlcmVyJyk7XG5cbnZhciBfQ29tcG9uZW50UmVuZGVyZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQ29tcG9uZW50UmVuZGVyZXIpO1xuXG52YXIgX21ldGFsRXZlbnRzID0gcmVxdWlyZSgnbWV0YWwtZXZlbnRzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQ29tcG9uZW50IGNvbGxlY3RzIGNvbW1vbiBiZWhhdmlvcnMgdG8gYmUgZm9sbG93ZWQgYnkgVUkgY29tcG9uZW50cywgc3VjaFxuICogYXMgTGlmZWN5Y2xlLCBDU1MgY2xhc3NlcyBtYW5hZ2VtZW50LCBldmVudHMgZW5jYXBzdWxhdGlvbiBhbmQgc3VwcG9ydCBmb3JcbiAqIGRpZmZlcmVudCB0eXBlcyBvZiByZW5kZXJpbmcuXG4gKiBSZW5kZXJpbmcgbG9naWMgY2FuIGJlIGRvbmUgYnkgZWl0aGVyOlxuICogICAgIC0gTGlzdGVuaW5nIHRvIHRoZSBgcmVuZGVyYCBldmVudCBpbnNpZGUgdGhlIGBjcmVhdGVkYCBsaWZlY3ljbGUgZnVuY3Rpb25cbiAqICAgICAgIGFuZCBhZGRpbmcgdGhlIHJlbmRlcmluZyBsb2dpYyB0byB0aGUgbGlzdGVuZXIuXG4gKiAgICAgLSBVc2luZyBhbiBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBvZiBgQ29tcG9uZW50UmVuZGVyZXJgIGxpa2UgYFNveWAsXG4gKiAgICAgICBhbmQgZm9sbG93aW5nIGl0cyBwYXR0ZXJucy5cbiAqICAgICAtIEJ1aWxkaW5nIHlvdXIgb3duIGltcGxlbWVudGF0aW9uIG9mIGEgYENvbXBvbmVudFJlbmRlcmVyYC5cbiAqIFNwZWNpZnlpbmcgdGhlIHJlbmRlcmVyIHRoYXQgd2lsbCBiZSB1c2VkIGNhbiBiZSBkb25lIGJ5IHNldHRpbmcgdGhlIFJFTkRFUkVSXG4gKiBzdGF0aWMgdmFyaWFibGUgdG8gdGhlIHJlbmRlcmVyJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiA8Y29kZT5cbiAqIGNsYXNzIEN1c3RvbUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XG4gKiAgIGNyZWF0ZWQoKSB7XG4gKiAgIH1cbiAqXG4gKiAgIHJlbmRlcmVkKCkge1xuICogICB9XG4gKlxuICogICBhdHRhY2hlZCgpIHtcbiAqICAgfVxuICpcbiAqICAgZGV0YWNoZWQoKSB7XG4gKiAgIH1cbiAqXG4gKiAgIGRpc3Bvc2VkKCkge1xuICogICB9XG4gKiB9XG4gKlxuICogQ3VzdG9tQ29tcG9uZW50LlJFTkRFUkVSID0gTXlSZW5kZXJlcjtcbiAqXG4gKiBDdXN0b21Db21wb25lbnQuU1RBVEUgPSB7XG4gKiAgIHRpdGxlOiB7IHZhbHVlOiAnVGl0bGUnIH0sXG4gKiAgIGZvbnRTaXplOiB7IHZhbHVlOiAnMTBweCcgfVxuICogfTtcbiAqIDwvY29kZT5cbiAqXG4gKiBAZXh0ZW5kcyB7U3RhdGV9XG4gKi9cbnZhciBDb21wb25lbnQgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuXHRfaW5oZXJpdHMoQ29tcG9uZW50LCBfRXZlbnRFbWl0dGVyKTtcblxuXHQvKipcbiAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgYENvbXBvbmVudGAuXG4gICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfY29uZmlnIEFuIG9iamVjdCB3aXRoIHRoZSBpbml0aWFsIHZhbHVlcyBmb3IgdGhpc1xuICAqICAgICBjb21wb25lbnQncyBzdGF0ZS5cbiAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfEVsZW1lbnQ9fSBvcHRfcGFyZW50RWxlbWVudCBUaGUgZWxlbWVudCB3aGVyZSB0aGVcbiAgKiAgICAgY29tcG9uZW50IHNob3VsZCBiZSByZW5kZXJlZC4gQ2FuIGJlIGdpdmVuIGFzIGEgc2VsZWN0b3Igb3IgYW4gZWxlbWVudC5cbiAgKiAgICAgSWYgYGZhbHNlYCBpcyBwYXNzZWQsIHRoZSBjb21wb25lbnQgd29uJ3QgYmUgcmVuZGVyZWQgYXV0b21hdGljYWxseVxuICAqICAgICBhZnRlciBjcmVhdGVkLlxuICAqIEBjb25zdHJ1Y3RvclxuICAqL1xuXHRmdW5jdGlvbiBDb21wb25lbnQob3B0X2NvbmZpZywgb3B0X3BhcmVudEVsZW1lbnQpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG9uZW50KTtcblxuXHRcdC8qKlxuICAgKiBJbnN0YW5jZSBvZiBgRG9tRXZlbnRFbWl0dGVyUHJveHlgIHdoaWNoIHByb3hpZXMgZXZlbnRzIGZyb20gdGhlIGNvbXBvbmVudCdzXG4gICAqIGVsZW1lbnQgdG8gdGhlIGNvbXBvbmVudCBpdHNlbGYuXG4gICAqIEB0eXBlIHshRG9tRXZlbnRFbWl0dGVyUHJveHl9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENvbXBvbmVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbXBvbmVudCkpLmNhbGwodGhpcykpO1xuXG5cdFx0X3RoaXMuZWxlbWVudEV2ZW50UHJveHlfID0gbmV3IF9tZXRhbERvbS5Eb21FdmVudEVtaXR0ZXJQcm94eShudWxsLCBfdGhpcywgcHJveHlCbGFja0xpc3RfKTtcblxuXHRcdC8qKlxuICAgKiBUaGUgYEV2ZW50SGFuZGxlcmAgaW5zdGFuY2UgZm9yIGV2ZW50cyBhdHRhY2hlZCBmcm9tIHRoZSBgZXZlbnRzYCBzdGF0ZSBrZXkuXG4gICAqIEB0eXBlIHtFdmVudEhhbmRsZXJ9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMuZXZlbnRzU3RhdGVLZXlIYW5kbGVyXyA9IG51bGw7XG5cblx0XHQvKipcbiAgICogV2hldGhlciB0aGUgZWxlbWVudCBpcyBpbiBkb2N1bWVudC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuXHRcdF90aGlzLmluRG9jdW1lbnQgPSBmYWxzZTtcblxuXHRcdC8qKlxuICAgKiBUaGUgaW5pdGlhbCBjb25maWcgb3B0aW9uIHBhc3NlZCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5pbml0aWFsQ29uZmlnXyA9IG9wdF9jb25maWcgfHwge307XG5cblx0XHQvKipcbiAgICogV2hldGhlciB0aGUgZWxlbWVudCB3YXMgcmVuZGVyZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblx0XHRfdGhpcy53YXNSZW5kZXJlZCA9IGZhbHNlO1xuXG5cdFx0LyoqXG4gICAqIFRoZSBjb21wb25lbnQncyBlbGVtZW50IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIGVsZW1lbnQgdGhpcyB2YXJpYWJsZSBpc1xuICAgKiBzZXQgdG8sIHVubGVzcyB0aGUgdXNlciBzcGVjaWZpZXMgYW5vdGhlciBwYXJlbnQgd2hlbiBjYWxsaW5nIGByZW5kZXJgIG9yXG4gICAqIGBhdHRhY2hgLlxuICAgKiBAdHlwZSB7IUVsZW1lbnR9XG4gICAqL1xuXHRcdF90aGlzLkRFRkFVTFRfRUxFTUVOVF9QQVJFTlQgPSBkb2N1bWVudC5ib2R5O1xuXG5cdFx0X3RoaXMuc2V0U2hvdWxkVXNlRmFjYWRlKHRydWUpO1xuXHRcdF90aGlzLmVsZW1lbnQgPSBfdGhpcy5pbml0aWFsQ29uZmlnXy5lbGVtZW50O1xuXG5cdFx0X3RoaXMuc2V0VXBSZW5kZXJlcl8oKTtcblx0XHRfdGhpcy5zZXRVcERhdGFNYW5hZ2VyXygpO1xuXHRcdF90aGlzLnNldFVwU3luY1VwZGF0ZXNfKCk7XG5cblx0XHRfdGhpcy5vbignc3RhdGVDaGFuZ2VkJywgX3RoaXMuaGFuZGxlQ29tcG9uZW50U3RhdGVDaGFuZ2VkXyk7XG5cdFx0X3RoaXMub24oJ2V2ZW50c0NoYW5nZWQnLCBfdGhpcy5vbkV2ZW50c0NoYW5nZWRfKTtcblx0XHRfdGhpcy5hZGRMaXN0ZW5lcnNGcm9tT2JqXyhfdGhpcy5kYXRhTWFuYWdlcl8uZ2V0KF90aGlzLCAnZXZlbnRzJykpO1xuXG5cdFx0X3RoaXMuY3JlYXRlZCgpO1xuXHRcdF90aGlzLmNvbXBvbmVudENyZWF0ZWRfID0gdHJ1ZTtcblx0XHRpZiAob3B0X3BhcmVudEVsZW1lbnQgIT09IGZhbHNlKSB7XG5cdFx0XHRfdGhpcy5yZW5kZXJDb21wb25lbnQob3B0X3BhcmVudEVsZW1lbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gX3RoaXM7XG5cdH1cblxuXHQvKipcbiAgKiBHZXR0ZXIgbG9naWMgZm9yIHRoZSBlbGVtZW50IHByb3BlcnR5LlxuICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoQ29tcG9uZW50LCBbe1xuXHRcdGtleTogJ2FkZExpc3RlbmVyc0Zyb21PYmpfJyxcblxuXG5cdFx0LyoqXG4gICAqIEFkZHMgdGhlIGxpc3RlbmVycyBzcGVjaWZpZWQgaW4gdGhlIGdpdmVuIG9iamVjdC5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXJzRnJvbU9ial8ob2JqKSB7XG5cdFx0XHR2YXIgX2V2ZW50c1N0YXRlS2V5SGFuZGxlO1xuXG5cdFx0XHRpZiAoIXRoaXMuZXZlbnRzU3RhdGVLZXlIYW5kbGVyXykge1xuXHRcdFx0XHR0aGlzLmV2ZW50c1N0YXRlS2V5SGFuZGxlcl8gPSBuZXcgX21ldGFsRXZlbnRzLkV2ZW50SGFuZGxlcigpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhbmRsZXMgPSAoMCwgX2V2ZW50cy5hZGRMaXN0ZW5lcnNGcm9tT2JqKSh0aGlzLCBvYmopO1xuXHRcdFx0KF9ldmVudHNTdGF0ZUtleUhhbmRsZSA9IHRoaXMuZXZlbnRzU3RhdGVLZXlIYW5kbGVyXykuYWRkLmFwcGx5KF9ldmVudHNTdGF0ZUtleUhhbmRsZSwgX3RvQ29uc3VtYWJsZUFycmF5KGhhbmRsZXMpKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogSW52b2tlcyB0aGUgYXR0YWNoZWQgTGlmZWN5Y2xlLiBXaGVuIGF0dGFjaGVkLCB0aGUgY29tcG9uZW50IGVsZW1lbnQgaXNcbiAgICogYXBwZW5kZWQgdG8gdGhlIERPTSBhbmQgYW55IG90aGVyIGFjdGlvbiB0byBiZSBwZXJmb3JtZWQgbXVzdCBiZVxuICAgKiBpbXBsZW1lbnRlZCBpbiB0aGlzIG1ldGhvZCwgc3VjaCBhcywgYmluZGluZyBET00gZXZlbnRzLiBBIGNvbXBvbmVudCBjYW5cbiAgICogYmUgcmUtYXR0YWNoZWQgbXVsdGlwbGUgdGltZXMuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xFbGVtZW50KT19IG9wdF9wYXJlbnRFbGVtZW50IE9wdGlvbmFsIHBhcmVudCBlbGVtZW50XG4gICAqICAgICB0byByZW5kZXIgdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHsoc3RyaW5nfEVsZW1lbnQpPX0gb3B0X3NpYmxpbmdFbGVtZW50IE9wdGlvbmFsIHNpYmxpbmcgZWxlbWVudFxuICAgKiAgICAgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQgYmVmb3JlIGl0LiBSZWxldmFudCB3aGVuIHRoZSBjb21wb25lbnQgbmVlZHNcbiAgICogICAgIHRvIGJlIHJlbmRlcmVkIGJlZm9yZSBhbiBleGlzdGluZyBlbGVtZW50IGluIHRoZSBET00uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGNoYWluYWJsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXR0YWNoJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXR0YWNoKG9wdF9wYXJlbnRFbGVtZW50LCBvcHRfc2libGluZ0VsZW1lbnQpIHtcblx0XHRcdGlmICghdGhpcy5pbkRvY3VtZW50KSB7XG5cdFx0XHRcdHRoaXMuYXR0YWNoRWxlbWVudChvcHRfcGFyZW50RWxlbWVudCwgb3B0X3NpYmxpbmdFbGVtZW50KTtcblx0XHRcdFx0dGhpcy5pbkRvY3VtZW50ID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5hdHRhY2hEYXRhXyA9IHtcblx0XHRcdFx0XHRwYXJlbnQ6IG9wdF9wYXJlbnRFbGVtZW50LFxuXHRcdFx0XHRcdHNpYmxpbmc6IG9wdF9zaWJsaW5nRWxlbWVudFxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmVtaXQoJ2F0dGFjaGVkJywgdGhpcy5hdHRhY2hEYXRhXyk7XG5cdFx0XHRcdHRoaXMuYXR0YWNoZWQoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBMaWZlY3ljbGUuIFdoZW4gYXR0YWNoZWQsIHRoZSBjb21wb25lbnQgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgRE9NXG4gICAqIGFuZCBhbnkgb3RoZXIgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCBtdXN0IGJlIGltcGxlbWVudGVkIGluIHRoaXMgbWV0aG9kLFxuICAgKiBzdWNoIGFzLCBiaW5kaW5nIERPTSBldmVudHMuIEEgY29tcG9uZW50IGNhbiBiZSByZS1hdHRhY2hlZCBtdWx0aXBsZVxuICAgKiB0aW1lcywgdGhlcmVmb3JlIHRoZSB1bmRvIGJlaGF2aW9yIGZvciBhbnkgYWN0aW9uIHBlcmZvcm1lZCBpbiB0aGlzIHBoYXNlXG4gICAqIG11c3QgYmUgaW1wbGVtZW50ZWQgb24gdGhlIGRldGFjaCBwaGFzZS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2F0dGFjaGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXR0YWNoZWQoKSB7fVxuXG5cdFx0LyoqXG4gICAqIEF0dGFjaGVzIHRoZSBjb21wb25lbnQgZWxlbWVudCBpbnRvIHRoZSBET00uXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xFbGVtZW50KT19IG9wdF9wYXJlbnRFbGVtZW50IE9wdGlvbmFsIHBhcmVudCBlbGVtZW50XG4gICAqICAgICB0byByZW5kZXIgdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHsoc3RyaW5nfEVsZW1lbnQpPX0gb3B0X3NpYmxpbmdFbGVtZW50IE9wdGlvbmFsIHNpYmxpbmcgZWxlbWVudFxuICAgKiAgICAgdG8gcmVuZGVyIHRoZSBjb21wb25lbnQgYmVmb3JlIGl0LiBSZWxldmFudCB3aGVuIHRoZSBjb21wb25lbnQgbmVlZHNcbiAgICogICAgIHRvIGJlIHJlbmRlcmVkIGJlZm9yZSBhbiBleGlzdGluZyBlbGVtZW50IGluIHRoZSBET00sIGUuZy5cbiAgICogICAgIGBjb21wb25lbnQuYXR0YWNoKG51bGwsIGV4aXN0aW5nRWxlbWVudClgLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXR0YWNoRWxlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGF0dGFjaEVsZW1lbnQob3B0X3BhcmVudEVsZW1lbnQsIG9wdF9zaWJsaW5nRWxlbWVudCkge1xuXHRcdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRpZiAoZWxlbWVudCAmJiAob3B0X3NpYmxpbmdFbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudE5vZGUpKSB7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSAoMCwgX21ldGFsRG9tLnRvRWxlbWVudCkob3B0X3BhcmVudEVsZW1lbnQpIHx8IHRoaXMuREVGQVVMVF9FTEVNRU5UX1BBUkVOVDtcblx0XHRcdFx0cGFyZW50Lmluc2VydEJlZm9yZShlbGVtZW50LCAoMCwgX21ldGFsRG9tLnRvRWxlbWVudCkob3B0X3NpYmxpbmdFbGVtZW50KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIExpZmVjeWNsZS4gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBqdXN0IGJlZW4gY3JlYXRlZCwgYmVmb3JlXG4gICAqIGl0J3MgcmVuZGVyZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjcmVhdGVkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY3JlYXRlZCgpIHt9XG5cblx0XHQvKipcbiAgICogTGlzdGVucyB0byBhIGRlbGVnYXRlIGV2ZW50IG9uIHRoZSBjb21wb25lbnQncyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG8uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBUaGUgc2VsZWN0b3IgdGhhdCBtYXRjaGVzIHRoZSBjaGlsZCBlbGVtZW50cyB0aGF0XG4gICAqICAgdGhlIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQgZm9yLlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbighT2JqZWN0KX0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGV2ZW50IGlzXG4gICAqICAgdHJpZ2dlcmVkLiBJdCB3aWxsIHJlY2VpdmUgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkZWxlZ2F0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRlbGVnYXRlKGV2ZW50TmFtZSwgc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vbignZGVsZWdhdGU6JyArIGV2ZW50TmFtZSArICc6JyArIHNlbGVjdG9yLCBjYWxsYmFjayk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEludm9rZXMgdGhlIGRldGFjaGVkIExpZmVjeWNsZS4gV2hlbiBkZXRhY2hlZCwgdGhlIGNvbXBvbmVudCBlbGVtZW50IGlzXG4gICAqIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGFuZCBhbnkgb3RoZXIgYWN0aW9uIHRvIGJlIHBlcmZvcm1lZCBtdXN0IGJlXG4gICAqIGltcGxlbWVudGVkIGluIHRoaXMgbWV0aG9kLCBzdWNoIGFzLCB1bmJpbmRpbmcgRE9NIGV2ZW50cy4gQSBjb21wb25lbnRcbiAgICogY2FuIGJlIGRldGFjaGVkIG11bHRpcGxlIHRpbWVzLlxuICAgKiBAY2hhaW5hYmxlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkZXRhY2gnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkZXRhY2goKSB7XG5cdFx0XHRpZiAodGhpcy5pbkRvY3VtZW50KSB7XG5cdFx0XHRcdGlmICh0aGlzLmVsZW1lbnQgJiYgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuaW5Eb2N1bWVudCA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLmRldGFjaGVkKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVtaXQoJ2RldGFjaGVkJyk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogTGlmZWN5Y2xlLiBXaGVuIGRldGFjaGVkLCB0aGUgY29tcG9uZW50IGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICogYW5kIGFueSBvdGhlciBhY3Rpb24gdG8gYmUgcGVyZm9ybWVkIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gdGhpcyBtZXRob2QsXG4gICAqIHN1Y2ggYXMsIHVuYmluZGluZyBET00gZXZlbnRzLiBBIGNvbXBvbmVudCBjYW4gYmUgZGV0YWNoZWQgbXVsdGlwbGVcbiAgICogdGltZXMsIHRoZXJlZm9yZSB0aGUgdW5kbyBiZWhhdmlvciBmb3IgYW55IGFjdGlvbiBwZXJmb3JtZWQgaW4gdGhpcyBwaGFzZVxuICAgKiBtdXN0IGJlIGltcGxlbWVudGVkIG9uIHRoZSBhdHRhY2ggcGhhc2UuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkZXRhY2hlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRldGFjaGVkKCkge31cblxuXHRcdC8qKlxuICAgKiBMaWZlY3ljbGUuIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgZGlzcG9zZWQuIFNob3VsZCBiZSBvdmVycmlkZGVuIGJ5XG4gICAqIHN1YiBjbGFzc2VzIHRvIGRpc3Bvc2Ugb2YgYW55IGludGVybmFsIGRhdGEgb3IgZXZlbnRzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlZCgpIHt9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHRcdHRoaXMuZGV0YWNoKCk7XG5cdFx0XHR0aGlzLmRpc3Bvc2VkKCk7XG5cblx0XHRcdHRoaXMuZWxlbWVudEV2ZW50UHJveHlfLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuZWxlbWVudEV2ZW50UHJveHlfID0gbnVsbDtcblxuXHRcdFx0dGhpcy5kYXRhTWFuYWdlcl8uZGlzcG9zZSh0aGlzKTtcblx0XHRcdHRoaXMuZGF0YU1hbmFnZXJfID0gbnVsbDtcblxuXHRcdFx0dGhpcy5yZW5kZXJlcl8uZGlzcG9zZSh0aGlzKTtcblx0XHRcdHRoaXMucmVuZGVyZXJfID0gbnVsbDtcblxuXHRcdFx0X2dldChDb21wb25lbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29tcG9uZW50LnByb3RvdHlwZSksICdkaXNwb3NlSW50ZXJuYWwnLCB0aGlzKS5jYWxsKHRoaXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIGRhdGEgYWJvdXQgd2hlcmUgdGhpcyBjb21wb25lbnQgd2FzIGF0dGFjaGVkIGF0LlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0QXR0YWNoRGF0YScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldEF0dGFjaERhdGEoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRhY2hEYXRhXztcblx0XHR9XG5cblx0XHQvKipcbiAgICogR2V0cyB0aGUgYENvbXBvbmVudERhdGFNYW5hZ2VyYCBiZWluZyB1c2VkLlxuICAgKiBAcmV0dXJuIHshQ29tcG9uZW50RGF0YU1hbmFnZXJ9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXREYXRhTWFuYWdlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldERhdGFNYW5hZ2VyKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YU1hbmFnZXJfO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhpcyBjb21wb25lbnQncyBjb25zdHJ1Y3Rvci5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldEluaXRpYWxDb25maWcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsQ29uZmlnKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5pdGlhbENvbmZpZ187XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgc3RhdGUgZGF0YSBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0YU1hbmFnZXJfLmdldFN0YXRlKHRoaXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBrZXlzIGZvciB0aGUgc3RhdGUgZGF0YS5cbiAgICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdGF0ZUtleXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUtleXMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kYXRhTWFuYWdlcl8uZ2V0U3RhdGVLZXlzKHRoaXMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBgQ29tcG9uZW50UmVuZGVyZXJgIGluc3RhbmNlIGJlaW5nIHVzZWQuXG4gICAqIEByZXR1cm4geyFDb21wb25lbnRSZW5kZXJlcn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJlbmRlcmVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0UmVuZGVyZXIoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5yZW5kZXJlcl87XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEhhbmRsZXMgYSBjaGFuZ2UgaW4gdGhlIGNvbXBvbmVudCdzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcHJldlZhbFxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5ld1ZhbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYW5kbGVDb21wb25lbnRFbGVtZW50Q2hhbmdlZF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVDb21wb25lbnRFbGVtZW50Q2hhbmdlZF8ocHJldlZhbCwgbmV3VmFsKSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRFdmVudFByb3h5Xy5zZXRPcmlnaW5FbWl0dGVyKG5ld1ZhbCk7XG5cdFx0XHRpZiAodGhpcy5jb21wb25lbnRDcmVhdGVkXykge1xuXHRcdFx0XHR0aGlzLmVtaXQoJ2VsZW1lbnRDaGFuZ2VkJywge1xuXHRcdFx0XHRcdHByZXZWYWw6IHByZXZWYWwsXG5cdFx0XHRcdFx0bmV3VmFsOiBuZXdWYWxcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChuZXdWYWwgJiYgdGhpcy53YXNSZW5kZXJlZCkge1xuXHRcdFx0XHRcdHRoaXMuc3luY1Zpc2libGUodGhpcy5kYXRhTWFuYWdlcl8uZ2V0KHRoaXMsICd2aXNpYmxlJykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEhhbmRsZXMgc3RhdGUgYmF0Y2ggY2hhbmdlcy4gQ2FsbHMgYW55IGV4aXN0aW5nIGBzeW5jYCBmdW5jdGlvbnMgdGhhdFxuICAgKiBtYXRjaCB0aGUgY2hhbmdlZCBzdGF0ZSBrZXlzLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYW5kbGVDb21wb25lbnRTdGF0ZUNoYW5nZWRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ29tcG9uZW50U3RhdGVDaGFuZ2VkXyhldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLmhhc1N5bmNVcGRhdGVzKCkpIHtcblx0XHRcdFx0dGhpcy51cGRhdGVSZW5kZXJlcl8oZXZlbnQpO1xuXHRcdFx0fVxuXHRcdFx0KDAsIF9zeW5jLnN5bmNTdGF0ZSkodGhpcywgZXZlbnQuY2hhbmdlcyk7XG5cdFx0XHR0aGlzLmVtaXQoJ3N0YXRlU3luY2VkJywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBIYW5kbGVzIGEgYHN0YXRlS2V5Q2hhbmdlZGAgZXZlbnQuIFRoaXMgaXMgb25seSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdGhhdFxuICAgKiBoYXZlIHJlcXVlc3RlZCB1cGRhdGVzIHRvIGhhcHBlbiBzeW5jaHJvbm91c2x5LlxuICAgKiBAcGFyYW0geyF7a2V5OiBzdHJpbmcsIG5ld1ZhbDogKiwgcHJldlZhbDogKn19IGRhdGFcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFuZGxlQ29tcG9uZW50U3RhdGVLZXlDaGFuZ2VkXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNvbXBvbmVudFN0YXRlS2V5Q2hhbmdlZF8oZGF0YSkge1xuXHRcdFx0dGhpcy51cGRhdGVSZW5kZXJlcl8oe1xuXHRcdFx0XHRjaGFuZ2VzOiBfZGVmaW5lUHJvcGVydHkoe30sIGRhdGEua2V5LCBkYXRhKVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGNvbXBvbmVudCBoYXMgc3luYyB1cGRhdGVzIGVuYWJsZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNTeW5jVXBkYXRlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc1N5bmNVcGRhdGVzKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc3luY1VwZGF0ZXNfO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBJbmZvcm1zIHRoYXQgdGhlIGNvbXBvbmVudCB0aGF0IHRoZSByZW5kZXJlZCBoYXMgZmluaXNoZWQgcmVuZGVyaW5nIGl0LiBUaGVcbiAgICogcmVuZGVyZXIgaXMgdGhlIG9uZSByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGlzIHdoZW4gYXBwcm9wcmlhdGUuIFRoaXNcbiAgICogd2lsbCBlbWl0IGV2ZW50cyBhbmQgcnVuIHRoZSBhcHByb3ByaWF0ZSBsaWZlY3ljbGUgZm9yIHRoZSBmaXJzdCByZW5kZXIuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpbmZvcm1SZW5kZXJlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGluZm9ybVJlbmRlcmVkKCkge1xuXHRcdFx0dmFyIGZpcnN0UmVuZGVyID0gIXRoaXMuaGFzUmVuZGVyZXJSZW5kZXJlZF87XG5cdFx0XHR0aGlzLmhhc1JlbmRlcmVyUmVuZGVyZWRfID0gdHJ1ZTtcblx0XHRcdHRoaXMucmVuZGVyZWQoZmlyc3RSZW5kZXIpO1xuXHRcdFx0dGhpcy5lbWl0KCdyZW5kZXJlZCcsIGZpcnN0UmVuZGVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBmdW5jdGlvbiBpcyBhIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm4gQW55IGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtZXJnZUVsZW1lbnRDbGFzc2VzXycsXG5cblxuXHRcdC8qKlxuICAgKiBNZXJnZXMgdHdvIHZhbHVlcyBmb3IgdGhlIEVMRU1FTlRfQ0xBU1NFUyBwcm9wZXJ0eSBpbnRvIGEgc2luZ2xlIG9uZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzMVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3MyXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1lcmdlZCB2YWx1ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gbWVyZ2VFbGVtZW50Q2xhc3Nlc18oY2xhc3MxLCBjbGFzczIpIHtcblx0XHRcdHJldHVybiBjbGFzczEgPyBjbGFzczEgKyAnICcgKyAoY2xhc3MyIHx8ICcnKSA6IGNsYXNzMjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogRmlyZWQgd2hlbiB0aGUgYGV2ZW50c2Agc3RhdGUgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdvbkV2ZW50c0NoYW5nZWRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gb25FdmVudHNDaGFuZ2VkXyhldmVudCkge1xuXHRcdFx0dGhpcy5ldmVudHNTdGF0ZUtleUhhbmRsZXJfLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHRcdFx0dGhpcy5hZGRMaXN0ZW5lcnNGcm9tT2JqXyhldmVudC5uZXdWYWwpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDcmVhdGVzIGFuZCByZW5kZXJzIGEgY29tcG9uZW50IGZvciB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24uIFRoaXNcbiAgICogd2lsbCBhbHdheXMgbWFrZSBzdXJlIHRoYXQgdGhlIGNvbnN0cnVjdG9yIHJ1bnMgd2l0aG91dCByZW5kZXJpbmcgdGhlXG4gICAqIGNvbXBvbmVudCwgaGF2aW5nIHRoZSBgcmVuZGVyYCBzdGVwIGhhcHBlbiBvbmx5IGFmdGVyIGl0IGhhcyBmaW5pc2hlZC5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gQ3RvciBUaGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fEVsZW1lbnQ9fSBvcHRfY29uZmlnT3JFbGVtZW50IE9wdGlvbmFsIGNvbmZpZyBkYXRhIG9yIHBhcmVudFxuICAgKiAgICAgZm9yIHRoZSBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7RWxlbWVudD19IG9wdF9lbGVtZW50IE9wdGlvbmFsIHBhcmVudCBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICogQHJldHVybiB7IUNvbXBvbmVudH0gVGhlIHJlbmRlcmVkIGNvbXBvbmVudCdzIGluc3RhbmNlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVuZGVyQ29tcG9uZW50JyxcblxuXG5cdFx0LyoqXG4gICAqIFJlbmRlcnMgdGhlIGNvbXBvbmVudCBpbnRvIHRoZSBET00gdmlhIGl0cyBgQ29tcG9uZW50UmVuZGVyZXJgLiBTdG9yZXMgdGhlXG4gICAqIGdpdmVuIHBhcmVudCBlbGVtZW50IHRvIGJlIHVzZWQgd2hlbiB0aGUgcmVuZGVyZXIgaXMgZG9uZSAoYGluZm9ybVJlbmRlcmVkYCkuXG4gICAqIEBwYXJhbSB7KHN0cmluZ3xFbGVtZW50fGJvb2xlYW4pPX0gb3B0X3BhcmVudEVsZW1lbnQgT3B0aW9uYWwgcGFyZW50IGVsZW1lbnRcbiAgICogICAgIHRvIHJlbmRlciB0aGUgY29tcG9uZW50LiBJZiBzZXQgdG8gYGZhbHNlYCwgdGhlIGVsZW1lbnQgd29uJ3QgYmVcbiAgICogICAgIGF0dGFjaGVkIHRvIGFueSBlbGVtZW50IGFmdGVyIHJlbmRlcmluZy4gSW4gdGhpcyBjYXNlLCBgYXR0YWNoYCBzaG91bGRcbiAgICogICAgIGJlIGNhbGxlZCBtYW51YWxseSBsYXRlciB0byBhY3R1YWxseSBhdHRhY2ggaXQgdG8gdGhlIGRvbS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChvcHRfcGFyZW50RWxlbWVudCkge1xuXHRcdFx0aWYgKCF0aGlzLmhhc1JlbmRlcmVyUmVuZGVyZWRfKSB7XG5cdFx0XHRcdGlmICh3aW5kb3cuX19NRVRBTF9ERVZfVE9PTFNfSE9PS19fKSB7XG5cdFx0XHRcdFx0d2luZG93Ll9fTUVUQUxfREVWX1RPT0xTX0hPT0tfXyh0aGlzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmdldFJlbmRlcmVyKCkucmVuZGVyKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lbWl0KCdyZW5kZXInKTtcblx0XHRcdCgwLCBfc3luYy5zeW5jU3RhdGUpKHRoaXMpO1xuXHRcdFx0dGhpcy5hdHRhY2gob3B0X3BhcmVudEVsZW1lbnQpO1xuXHRcdFx0dGhpcy53YXNSZW5kZXJlZCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHRlciBsb2dpYyBmb3IgdGhlIGVsZW1lbnQgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7P3N0cmluZ3xFbGVtZW50fSB2YWxcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFN0YXRlJyxcblxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIGFsbCB0aGUgc3BlY2lmaWVkIHN0YXRlIGtleXMuXG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCo+fSB2YWx1ZXMgQSBtYXAgb2Ygc3RhdGUga2V5cyB0byB0aGUgdmFsdWVzIHRoZXlcbiAgICogICBzaG91bGQgYmUgc2V0IHRvLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfY2FsbGJhY2sgQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJ1blxuICAgKiAgIGFmdGVyIHRoZSBuZXh0IGJhdGNoZWQgdXBkYXRlIGlzIHRyaWdnZXJlZC5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlLCBvcHRfY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuZGF0YU1hbmFnZXJfLnNldFN0YXRlKHRoaXMsIHN0YXRlLCBvcHRfY2FsbGJhY2spO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXR0ZXIgZm9yIHRoZSBgZWxlbWVudENsYXNzZXNgIGRhdGEgcHJvcGVydHkuIEFwcGVuZHMgZ2l2ZW4gdmFsdWUgd2l0aFxuICAgKiB0aGUgb25lIHNwZWNpZmllZCBpbiBgRUxFTUVOVF9DTEFTU0VTYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldHRlckVsZW1lbnRDbGFzc2VzRm5fJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0dGVyRWxlbWVudENsYXNzZXNGbl8odmFsKSB7XG5cdFx0XHR2YXIgZWxlbWVudENsYXNzZXMgPSAoMCwgX21ldGFsLmdldFN0YXRpY1Byb3BlcnR5KSh0aGlzLmNvbnN0cnVjdG9yLCAnRUxFTUVOVF9DTEFTU0VTJywgdGhpcy5tZXJnZUVsZW1lbnRDbGFzc2VzXyk7XG5cdFx0XHRpZiAoZWxlbWVudENsYXNzZXMpIHtcblx0XHRcdFx0dmFsICs9ICcgJyArIGVsZW1lbnRDbGFzc2VzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbC50cmltKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdXAgdGhlIGNvbXBvbmVudCdzIGRhdGEgbWFuYWdlci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VXBEYXRhTWFuYWdlcl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRVcERhdGFNYW5hZ2VyXygpIHtcblx0XHRcdHRoaXMuZGF0YU1hbmFnZXJfID0gKDAsIF9tZXRhbC5nZXRTdGF0aWNQcm9wZXJ0eSkodGhpcy5jb25zdHJ1Y3RvciwgJ0RBVEFfTUFOQUdFUicpO1xuXHRcdFx0dGhpcy5kYXRhTWFuYWdlcl8uc2V0VXAodGhpcywgX21ldGFsLm9iamVjdC5taXhpbih7fSwgdGhpcy5yZW5kZXJlcl8uZ2V0RXh0cmFEYXRhQ29uZmlnKHRoaXMpLCBDb21wb25lbnQuREFUQSkpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHVwIHRoZSBjb21wb25lbnQncyByZW5kZXJlci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0VXBSZW5kZXJlcl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRVcFJlbmRlcmVyXygpIHtcblx0XHRcdHRoaXMucmVuZGVyZXJfID0gKDAsIF9tZXRhbC5nZXRTdGF0aWNQcm9wZXJ0eSkodGhpcy5jb25zdHJ1Y3RvciwgJ1JFTkRFUkVSJyk7XG5cdFx0XHR0aGlzLnJlbmRlcmVyXy5zZXRVcCh0aGlzKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB1cCB0aGUgY29tcG9uZW50IHRvIHVzZSBzeW5jIHVwZGF0ZXMgd2hlbiBgU1lOQ19VUERBVEVTYCBpcyBgdHJ1ZWAuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFVwU3luY1VwZGF0ZXNfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0VXBTeW5jVXBkYXRlc18oKSB7XG5cdFx0XHR0aGlzLnN5bmNVcGRhdGVzXyA9ICgwLCBfbWV0YWwuZ2V0U3RhdGljUHJvcGVydHkpKHRoaXMuY29uc3RydWN0b3IsICdTWU5DX1VQREFURVMnKTtcblx0XHRcdGlmICh0aGlzLmhhc1N5bmNVcGRhdGVzKCkpIHtcblx0XHRcdFx0dGhpcy5vbignc3RhdGVLZXlDaGFuZ2VkJywgdGhpcy5oYW5kbGVDb21wb25lbnRTdGF0ZUtleUNoYW5nZWRfLmJpbmQodGhpcykpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTa2lwcyByZW5kZXJlciB1cGRhdGVzIHVudGlsIGBzdG9wU2tpcFVwZGF0ZXNgIGlzIGNhbGxlZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3N0YXJ0U2tpcFVwZGF0ZXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzdGFydFNraXBVcGRhdGVzKCkge1xuXHRcdFx0dGhpcy5za2lwVXBkYXRlc18gPSB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdG9wcyBza2lwcGluZyByZW5kZXJlciB1cGRhdGVzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc3RvcFNraXBVcGRhdGVzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc3RvcFNraXBVcGRhdGVzKCkge1xuXHRcdFx0dGhpcy5za2lwVXBkYXRlc18gPSBmYWxzZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU3RhdGUgc3luY2hyb25pemF0aW9uIGxvZ2ljIGZvciBgdmlzaWJsZWAgc3RhdGUga2V5LlxuICAgKiBVcGRhdGVzIHRoZSBlbGVtZW50J3MgZGlzcGxheSB2YWx1ZSBhY2NvcmRpbmcgdG8gaXRzIHZpc2liaWxpdHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV3VmFsXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzeW5jVmlzaWJsZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHN5bmNWaXNpYmxlKG5ld1ZhbCkge1xuXHRcdFx0aWYgKHRoaXMuZWxlbWVudCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG5ld1ZhbCA/ICcnIDogJ25vbmUnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBMaWZlY3ljbGUuIENhbGxlZCB3aGVuZXZlciB0aGUgY29tcG9uZW50IGhhcyBqdXN0IGJlZW4gcmVuZGVyZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlyc3RSZW5kZXIgRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgd2FzIHRoZSBjb21wb25lbnQnc1xuICAgKiAgICAgZmlyc3QgcmVuZGVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVuZGVyZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXJlZCgpIHt9XG5cblx0XHQvKipcbiAgICogQ2FsbHMgXCJ1cGRhdGVcIiBvbiB0aGUgcmVuZGVyZXIsIHBhc3NpbmcgaXQgdGhlIGNoYW5nZWQgZGF0YS5cbiAgICogQHBhcmFtIHshe2NoYW5nZXM6ICFPYmplY3R9fSBkYXRhXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3VwZGF0ZVJlbmRlcmVyXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVJlbmRlcmVyXyhkYXRhKSB7XG5cdFx0XHRpZiAoIXRoaXMuc2tpcFVwZGF0ZXNfICYmIHRoaXMuaGFzUmVuZGVyZXJSZW5kZXJlZF8pIHtcblx0XHRcdFx0dGhpcy5nZXRSZW5kZXJlcigpLnVwZGF0ZSh0aGlzLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVmFsaWRhdG9yIGxvZ2ljIGZvciB0aGUgYGV2ZW50c2Agc3RhdGUga2V5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZhbGlkYXRvckV2ZW50c0ZuXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRvckV2ZW50c0ZuXyh2YWwpIHtcblx0XHRcdHJldHVybiAhKDAsIF9tZXRhbC5pc0RlZkFuZE5vdE51bGwpKHZhbCkgfHwgKDAsIF9tZXRhbC5pc09iamVjdCkodmFsKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdlbGVtZW50Jyxcblx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnRWYWx1ZV87XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcblx0XHRcdGlmICghKDAsIF9tZXRhbC5pc0VsZW1lbnQpKHZhbCkgJiYgISgwLCBfbWV0YWwuaXNTdHJpbmcpKHZhbCkgJiYgKDAsIF9tZXRhbC5pc0RlZkFuZE5vdE51bGwpKHZhbCkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsKSB7XG5cdFx0XHRcdHZhbCA9ICgwLCBfbWV0YWxEb20udG9FbGVtZW50KSh2YWwpIHx8IHRoaXMuZWxlbWVudFZhbHVlXztcblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuZWxlbWVudFZhbHVlXyAhPT0gdmFsKSB7XG5cdFx0XHRcdHZhciBwcmV2ID0gdGhpcy5lbGVtZW50VmFsdWVfO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnRWYWx1ZV8gPSB2YWw7XG5cdFx0XHRcdHRoaXMuaGFuZGxlQ29tcG9uZW50RWxlbWVudENoYW5nZWRfKHByZXYsIHZhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSwgW3tcblx0XHRrZXk6ICdpc0NvbXBvbmVudEN0b3InLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0NvbXBvbmVudEN0b3IoZm4pIHtcblx0XHRcdHJldHVybiBmbi5wcm90b3R5cGUgJiYgZm4ucHJvdG90eXBlW0NvbXBvbmVudC5DT01QT05FTlRfRkxBR107XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAncmVuZGVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKEN0b3IsIG9wdF9jb25maWdPckVsZW1lbnQsIG9wdF9lbGVtZW50KSB7XG5cdFx0XHR2YXIgY29uZmlnID0gb3B0X2NvbmZpZ09yRWxlbWVudDtcblx0XHRcdHZhciBlbGVtZW50ID0gb3B0X2VsZW1lbnQ7XG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc0VsZW1lbnQpKG9wdF9jb25maWdPckVsZW1lbnQpKSB7XG5cdFx0XHRcdGNvbmZpZyA9IG51bGw7XG5cdFx0XHRcdGVsZW1lbnQgPSBvcHRfY29uZmlnT3JFbGVtZW50O1xuXHRcdFx0fVxuXHRcdFx0dmFyIGluc3RhbmNlID0gbmV3IEN0b3IoY29uZmlnLCBmYWxzZSk7XG5cdFx0XHRpbnN0YW5jZS5yZW5kZXJDb21wb25lbnQoZWxlbWVudCk7XG5cdFx0XHRyZXR1cm4gaW5zdGFuY2U7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENyZWF0ZXMgYW5kIHJlbmRlcnMgYSBjb21wb25lbnQgZm9yIHRoZSBnaXZlbiBjb25zdHJ1Y3RvciBmdW5jdGlvbiBhc1xuICAgKiBzdHJpbmcuIFRoaXMgd2lsbCBhbHdheXMgbWFrZSBzdXJlIHRoYXQgdGhlIGNvbnN0cnVjdG9yIHJ1bnMgd2l0aG91dFxuICAgKiByZW5kZXJpbmcgdGhlIGNvbXBvbmVudCwgaGF2aW5nIHRoZSBgcmVuZGVyYCBzdGVwIGhhcHBlbiBvbmx5IGFmdGVyIGl0XG4gICAqIGhhcyBmaW5pc2hlZC5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX0gQ3RvciBUaGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fEVsZW1lbnQ9fSBvcHRfY29uZmlnT3JFbGVtZW50IE9wdGlvbmFsIGNvbmZpZyBkYXRhIG9yXG4gICAqICAgICBwYXJlbnQgZm9yIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4geyFTdHJpbmd9IFRoZSByZW5kZXJlZCBjb21wb25lbnQncyBjb250ZW50IGFzIHN0cmluZy5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbmRlclRvU3RyaW5nJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoQ3Rvciwgb3B0X2NvbmZpZykge1xuXHRcdFx0dmFyIHJlbmRlcmVyTmFtZSA9IEN0b3IuUkVOREVSRVIgJiYgQ3Rvci5SRU5ERVJFUi5SRU5ERVJFUl9OQU1FO1xuXHRcdFx0c3dpdGNoIChyZW5kZXJlck5hbWUpIHtcblx0XHRcdFx0Y2FzZSAnanN4Jzpcblx0XHRcdFx0Y2FzZSAnc295Jzpcblx0XHRcdFx0Y2FzZSAnaW5jcmVtZW50YWwtZG9tJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIEluY3JlbWVudGFsRE9NID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yLiBUcnlpbmcgdG8gcmVuZGVyIGluY3JlbWVudGFsIGRvbSAnICsgJ2Jhc2VkIGNvbXBvbmVudCB0byBzdHJpbmcgcmVxdWlyZXMgSW5jcmVtZW50YWxET00gJyArICdpbXBsZW1lbnRhdGlvbiB0byBiZSBsb2FkZWQuJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBJbmNyZW1lbnRhbCBkb20gcGF0Y2hlcyBmb3IgY29tcG9uZW50cyBvciBuZXN0ZWQgY29tcG9uZW50cyBhcmVcblx0XHRcdFx0XHRcdC8vIGlzb2xhdGVkIGluc2lkZSB0aGUgY29tcG9uZW50IGVsZW1lbnQuIFRoZSBmb2xsb3dpbmcgY29kZSBpbnRlcmNlcHRzXG5cdFx0XHRcdFx0XHQvLyBpbmNyZW1lbnRhbCBkb20gcGF0Y2hlcyBhbmQgY29sbGVjdCByZXN1bHRzIGludG8gdGVtcG9yYXJ5IHN0YWNrIGluXG5cdFx0XHRcdFx0XHQvLyBvcmRlciB0byBzdWNjZXNzZnVsbHkgY29sbGVjdCB0aGUgZmluYWwgc3RyaW5nIG9mIHRoZSBvdXRlcm1vc3Rcblx0XHRcdFx0XHRcdC8vIGNvbXBvbmVudCBhZnRlciBhbGwgbmVzdGVkIGNvbXBvbmVudHMgc3RhY2sgcmVuZGVyZWQuXG5cdFx0XHRcdFx0XHR2YXIgaW50ZXJjZXB0ZWRDb21wb25lbnRTdHJpbmdzID0gW107XG5cdFx0XHRcdFx0XHR2YXIgcGF0Y2ggPSBJbmNyZW1lbnRhbERPTS5wYXRjaDtcblx0XHRcdFx0XHRcdHZhciBwYXRjaEludGVyY2VwdG9yID0gZnVuY3Rpb24gcGF0Y2hJbnRlcmNlcHRvcigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRFbGVtZW50ID0gcGF0Y2guYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0XHRcdFx0aW50ZXJjZXB0ZWRDb21wb25lbnRTdHJpbmdzLnB1c2goY3VycmVudEVsZW1lbnQuaW5uZXJIVE1MKTtcblx0XHRcdFx0XHRcdFx0SW5jcmVtZW50YWxET00ucGF0Y2ggPSBwYXRjaDtcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRJbmNyZW1lbnRhbERPTS5wYXRjaCA9IHBhdGNoSW50ZXJjZXB0b3I7XG5cdFx0XHRcdFx0XHRDb21wb25lbnQucmVuZGVyKEN0b3IsIG9wdF9jb25maWcpLmRpc3Bvc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBpbnRlcmNlcHRlZENvbXBvbmVudFN0cmluZ3NbMF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignRXJyb3IuIFRyeWluZyB0byByZW5kZXIgbm9uIGluY3JlbWVudGFsIGRvbSAnICsgJ2Jhc2VkIGNvbXBvbmVudCB0byBzdHJpbmcuJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIENvbXBvbmVudDtcbn0oX21ldGFsRXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogQ29tcG9uZW50IGRhdGEgZGVmaW5pdGlvbi5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKi9cblxuXG5Db21wb25lbnQuREFUQSA9IHtcblx0LyoqXG4gICogT2JqZWN0cyBkZXNjcmliaW5nIGNoaWxkcmVuIGVsZW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gYmUgcmVuZGVyZWQgaW5zaWRlXG4gICogdGhpcyBjb21wb25lbnQuXG4gICogQHR5cGUgeyFBcnJheTwhT2JqZWN0Pn1cbiAgKi9cblx0Y2hpbGRyZW46IHtcblx0XHR2YWxpZGF0b3I6IEFycmF5LmlzQXJyYXksXG5cdFx0dmFsdWU6IFtdXG5cdH0sXG5cblx0LyoqXG4gICogQ1NTIGNsYXNzZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cbiAgKiBAdHlwZSB7c3RyaW5nfVxuICAqL1xuXHRlbGVtZW50Q2xhc3Nlczoge1xuXHRcdHNldHRlcjogJ3NldHRlckVsZW1lbnRDbGFzc2VzRm5fJyxcblx0XHR2YWxpZGF0b3I6IF9tZXRhbC5pc1N0cmluZyxcblx0XHR2YWx1ZTogJydcblx0fSxcblxuXHQvKipcbiAgKiBMaXN0ZW5lcnMgdGhhdCBzaG91bGQgYmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuIFNob3VsZCBiZSBwcm92aWRlZCBhc1xuICAqIGFuIG9iamVjdCwgd2hlcmUgdGhlIGtleXMgYXJlIGV2ZW50IG5hbWVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGUgbGlzdGVuZXJcbiAgKiBmdW5jdGlvbnMgKG9yIGZ1bmN0aW9uIG5hbWVzKS5cbiAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgKGZ1bmN0aW9uKCl8c3RyaW5nfHtzZWxlY3Rvcjogc3RyaW5nLCBmbjogZnVuY3Rpb24oKXxzdHJpbmd9KT59XG4gICovXG5cdGV2ZW50czoge1xuXHRcdHZhbGlkYXRvcjogJ3ZhbGlkYXRvckV2ZW50c0ZuXycsXG5cdFx0dmFsdWU6IG51bGxcblx0fSxcblxuXHQvKipcbiAgKiBJbmRpY2F0ZXMgaWYgdGhlIGNvbXBvbmVudCBpcyB2aXNpYmxlIG9yIG5vdC5cbiAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgKi9cblx0dmlzaWJsZToge1xuXHRcdHZhbGlkYXRvcjogX21ldGFsLmlzQm9vbGVhbixcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9XG59O1xuXG4vKipcbiAqIE5hbWUgb2YgdGhlIGZsYWcgdXNlZCB0byBpZGVudGlmeSBjb21wb25lbnQgY29uc3RydWN0b3JzIHZpYSB0aGVpciBwcm90b3R5cGUuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Db21wb25lbnQuQ09NUE9ORU5UX0ZMQUcgPSAnX19tZXRhbF9jb21wb25lbnRfXyc7XG5cbi8qKlxuICogVGhlIGBDb21wb25lbnREYXRhTWFuYWdlcmAgY2xhc3MgdGhhdCBzaG91bGQgYmUgdXNlZC4gVGhpcyBjbGFzcyB3aWxsIGJlXG4gKiByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGNvbXBvbmVudCdzIGRhdGEuIEVhY2ggY29tcG9uZW50IG1heSBoYXZlIGl0c1xuICogb3duIGltcGxlbWVudGF0aW9uLlxuICogQHR5cGUgeyFDb21wb25lbnREYXRhTWFuYWdlcn1cbiAqL1xuQ29tcG9uZW50LkRBVEFfTUFOQUdFUiA9IF9Db21wb25lbnREYXRhTWFuYWdlcjIuZGVmYXVsdDtcblxuLyoqXG4gKiBDU1MgY2xhc3NlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50LlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuQ29tcG9uZW50LkVMRU1FTlRfQ0xBU1NFUyA9ICcnO1xuXG4vKipcbiAqIFRoZSBgQ29tcG9uZW50UmVuZGVyZXJgIHRoYXQgc2hvdWxkIGJlIHVzZWQuIENvbXBvbmVudHMgbmVlZCB0byBzZXQgdGhpc1xuICogdG8gYSBzdWJjbGFzcyBvZiBgQ29tcG9uZW50UmVuZGVyZXJgIHRoYXQgaGFzIHRoZSByZW5kZXJpbmcgbG9naWMsIGxpa2VcbiAqIGBTb3lSZW5kZXJlcmAuXG4gKiBAdHlwZSB7IUNvbXBvbmVudFJlbmRlcmVyfVxuICovXG5Db21wb25lbnQuUkVOREVSRVIgPSBfQ29tcG9uZW50UmVuZGVyZXIyLmRlZmF1bHQ7XG5cbi8qKlxuICogRmxhZyBpbmRpY2F0aW5nIGlmIGNvbXBvbmVudCB1cGRhdGVzIHdpbGwgaGFwcGVuIHN5bmNocm9ub3VzbHkuIFVwZGF0ZXMgYXJlXG4gKiBkb25lIGFzeW5jaHJvbm91c2x5IGJ5IGRlZmF1bHQsIHdoaWNoIGFsbG93cyBjaGFuZ2VzIHRvIGJlIGJhdGNoZWQgYW5kXG4gKiBhcHBsaWVkIHRvZ2V0aGVyLlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbkNvbXBvbmVudC5TWU5DX1VQREFURVMgPSBmYWxzZTtcblxuLyoqXG4gKiBTZXRzIGEgcHJvdG90eXBlIGZsYWcgdG8gZWFzaWx5IGRldGVybWluZSBpZiBhIGdpdmVuIGNvbnN0cnVjdG9yIGlzIGZvclxuICogYSBjb21wb25lbnQgb3Igbm90LlxuICovXG5Db21wb25lbnQucHJvdG90eXBlW0NvbXBvbmVudC5DT01QT05FTlRfRkxBR10gPSB0cnVlO1xuXG52YXIgcHJveHlCbGFja0xpc3RfID0ge1xuXHRldmVudHNDaGFuZ2VkOiB0cnVlLFxuXHRzdGF0ZUNoYW5nZWQ6IHRydWUsXG5cdHN0YXRlS2V5Q2hhbmdlZDogdHJ1ZVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tcG9uZW50O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN5bmNTdGF0ZSA9IHN5bmNTdGF0ZTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBTWU5DX0ZOU19LRVkgPSAnX19NRVRBTF9TWU5DX0ZOU19fJztcblxuLyoqXG4gKiBHZXRzIHRoZSBgc3luY2AgbWV0aG9kcyBmb3IgdGhpcyBjb21wb25lbnQncyBzdGF0ZS4gQ2FjaGVzIHRoZSByZXN1bHRzIGluXG4gKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2hlbmV2ZXIgcG9zc2libGUsIHNvIHRoYXQgdGhpcyBkb2Vzbid0IG5lZWQgdG9cbiAqIGJlIGNhbGN1bGF0ZWQgYWdhaW4uIEl0J3Mgbm90IHBvc3NpYmxlIHRvIGNhY2hlIHRoZSByZXN1bHRzIHdoZW4gYXQgbGVhc3RcbiAqIG9uZSBzeW5jIG1ldGhvZCBpcyBkZWZpbmVkIGluIHRoZSBpbnN0YW5jZSBpdHNlbGYgaW5zdGVhZCBvZiBpbiBpdHNcbiAqIHByb3RvdHlwZSwgYXMgaXQgbWF5IGJlIGJvdW5kIHRvIHRoZSBpbnN0YW5jZSAobm90IHJldXNhYmxlIGJ5IG90aGVycykuXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7IU9iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFN5bmNGbnNfKGNvbXBvbmVudCkge1xuXHR2YXIgY3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvcjtcblx0aWYgKGN0b3IuaGFzT3duUHJvcGVydHkoU1lOQ19GTlNfS0VZKSkge1xuXHRcdHJldHVybiBjdG9yW1NZTkNfRk5TX0tFWV07XG5cdH1cblxuXHR2YXIgZm5zID0ge307XG5cdHZhciBrZXlzID0gY29tcG9uZW50LmdldERhdGFNYW5hZ2VyKCkuZ2V0U3luY0tleXMoY29tcG9uZW50KTtcblx0dmFyIGNhbkNhY2hlID0gdHJ1ZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIG5hbWUgPSAnc3luYycgKyBrZXlzW2ldLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5c1tpXS5zbGljZSgxKTtcblx0XHR2YXIgZm4gPSBjb21wb25lbnRbbmFtZV07XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHRmbnNba2V5c1tpXV0gPSBmbjtcblx0XHRcdGNhbkNhY2hlID0gY2FuQ2FjaGUgJiYgY29tcG9uZW50LmNvbnN0cnVjdG9yLnByb3RvdHlwZVtuYW1lXTtcblx0XHR9XG5cdH1cblxuXHRpZiAoY2FuQ2FjaGUpIHtcblx0XHRjdG9yW1NZTkNfRk5TX0tFWV0gPSBmbnM7XG5cdH1cblx0cmV0dXJuIGZucztcbn1cblxuLyoqXG4gKiBDYWxscyBcInN5bmNcIiBmdW5jdGlvbnMgZm9yIHRoZSBnaXZlbiBjb21wb25lbnQncyBzdGF0ZS5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9jaGFuZ2VzIFdoZW4gZ2l2ZW4sIG9ubHkgdGhlIHByb3BlcnRpZXMgaW5zaWRlIGl0IHdpbGxcbiAqICAgICBiZSBzeW5jZWQuIE90aGVyd2lzZSBhbGwgc3RhdGUgcHJvcGVydGllcyB3aWxsIGJlIHN5bmNlZC5cbiAqL1xuZnVuY3Rpb24gc3luY1N0YXRlKGNvbXBvbmVudCwgb3B0X2NoYW5nZXMpIHtcblx0dmFyIHN5bmNGbnMgPSBnZXRTeW5jRm5zXyhjb21wb25lbnQpO1xuXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdF9jaGFuZ2VzIHx8IHN5bmNGbnMpO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgZm4gPSBzeW5jRm5zW2tleXNbaV1dO1xuXHRcdGlmICgoMCwgX21ldGFsLmlzRnVuY3Rpb24pKGZuKSkge1xuXHRcdFx0dmFyIGNoYW5nZSA9IG9wdF9jaGFuZ2VzICYmIG9wdF9jaGFuZ2VzW2tleXNbaV1dO1xuXHRcdFx0dmFyIG1hbmFnZXIgPSBjb21wb25lbnQuZ2V0RGF0YU1hbmFnZXIoKTtcblx0XHRcdGZuLmNhbGwoY29tcG9uZW50LCBjaGFuZ2UgPyBjaGFuZ2UubmV3VmFsIDogbWFuYWdlci5nZXQoY29tcG9uZW50LCBrZXlzW2ldKSwgY2hhbmdlID8gY2hhbmdlLnByZXZWYWwgOiB1bmRlZmluZWQpO1xuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWNvbXBvbmVudC9saWIvc3luYy9zeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmN1c3RvbUV2ZW50cyA9IHVuZGVmaW5lZDtcbmV4cG9ydHMuYWRkQ2xhc3NlcyA9IGFkZENsYXNzZXM7XG5leHBvcnRzLmNsb3Nlc3QgPSBjbG9zZXN0O1xuZXhwb3J0cy5hcHBlbmQgPSBhcHBlbmQ7XG5leHBvcnRzLmJ1aWxkRnJhZ21lbnQgPSBidWlsZEZyYWdtZW50O1xuZXhwb3J0cy5jb250YWlucyA9IGNvbnRhaW5zO1xuZXhwb3J0cy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuZXhwb3J0cy5lbnRlckRvY3VtZW50ID0gZW50ZXJEb2N1bWVudDtcbmV4cG9ydHMuZXhpdERvY3VtZW50ID0gZXhpdERvY3VtZW50O1xuZXhwb3J0cy5oYXNDbGFzcyA9IGhhc0NsYXNzO1xuZXhwb3J0cy5pc0VtcHR5ID0gaXNFbXB0eTtcbmV4cG9ydHMubWF0Y2ggPSBtYXRjaDtcbmV4cG9ydHMubmV4dCA9IG5leHQ7XG5leHBvcnRzLm9uID0gb247XG5leHBvcnRzLm9uY2UgPSBvbmNlO1xuZXhwb3J0cy5wYXJlbnQgPSBwYXJlbnQ7XG5leHBvcnRzLnJlZ2lzdGVyQ3VzdG9tRXZlbnQgPSByZWdpc3RlckN1c3RvbUV2ZW50O1xuZXhwb3J0cy5yZW1vdmVDaGlsZHJlbiA9IHJlbW92ZUNoaWxkcmVuO1xuZXhwb3J0cy5yZW1vdmVDbGFzc2VzID0gcmVtb3ZlQ2xhc3NlcztcbmV4cG9ydHMucmVwbGFjZSA9IHJlcGxhY2U7XG5leHBvcnRzLnN1cHBvcnRzRXZlbnQgPSBzdXBwb3J0c0V2ZW50O1xuZXhwb3J0cy50b0VsZW1lbnQgPSB0b0VsZW1lbnQ7XG5leHBvcnRzLnRvZ2dsZUNsYXNzZXMgPSB0b2dnbGVDbGFzc2VzO1xuZXhwb3J0cy50cmlnZ2VyRXZlbnQgPSB0cmlnZ2VyRXZlbnQ7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX2RvbURhdGEgPSByZXF1aXJlKCcuL2RvbURhdGEnKTtcblxudmFyIF9kb21EYXRhMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RvbURhdGEpO1xuXG52YXIgX0RvbURlbGVnYXRlZEV2ZW50SGFuZGxlID0gcmVxdWlyZSgnLi9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZScpO1xuXG52YXIgX0RvbURlbGVnYXRlZEV2ZW50SGFuZGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0RvbURlbGVnYXRlZEV2ZW50SGFuZGxlKTtcblxudmFyIF9Eb21FdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4vRG9tRXZlbnRIYW5kbGUnKTtcblxudmFyIF9Eb21FdmVudEhhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Eb21FdmVudEhhbmRsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBlbGVtZW50c0J5VGFnXyA9IHt9O1xudmFyIHN1cHBvcnRDYWNoZV8gPSB7fTtcbnZhciBjdXN0b21FdmVudHMgPSBleHBvcnRzLmN1c3RvbUV2ZW50cyA9IHt9O1xuXG52YXIgTEFTVF9DT05UQUlORVIgPSAnX19tZXRhbF9sYXN0X2NvbnRhaW5lcl9fJztcbnZhciBVU0VfQ0FQVFVSRSA9IHtcblx0Ymx1cjogdHJ1ZSxcblx0ZXJyb3I6IHRydWUsXG5cdGZvY3VzOiB0cnVlLFxuXHRpbnZhbGlkOiB0cnVlLFxuXHRsb2FkOiB0cnVlLFxuXHRzY3JvbGw6IHRydWVcbn07XG5cbi8qKlxuICogQWRkcyB0aGUgcmVxdWVzdGVkIENTUyBjbGFzc2VzIHRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fCFOb2RlbGlzdH0gZWxlbWVudHMgVGhlIGVsZW1lbnQgb3IgZWxlbWVudHMgdG8gYWRkIENTUyBjbGFzc2VzIHRvLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgQ1NTIGNsYXNzZXMgdG8gYWRkLlxuICovXG5mdW5jdGlvbiBhZGRDbGFzc2VzKGVsZW1lbnRzLCBjbGFzc2VzKSB7XG5cdGlmICghKDAsIF9tZXRhbC5pc09iamVjdCkoZWxlbWVudHMpIHx8ICEoMCwgX21ldGFsLmlzU3RyaW5nKShjbGFzc2VzKSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlmICghZWxlbWVudHMubGVuZ3RoKSB7XG5cdFx0ZWxlbWVudHMgPSBbZWxlbWVudHNdO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGlmICgnY2xhc3NMaXN0JyBpbiBlbGVtZW50c1tpXSkge1xuXHRcdFx0YWRkQ2xhc3Nlc1dpdGhOYXRpdmVfKGVsZW1lbnRzW2ldLCBjbGFzc2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWRkQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnRzW2ldLCBjbGFzc2VzKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSByZXF1ZXN0ZWQgQ1NTIGNsYXNzZXMgdG8gYW4gZWxlbWVudCB1c2luZyBjbGFzc0xpc3QuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGFkZCBDU1MgY2xhc3NlcyB0by5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIENTUyBjbGFzc2VzIHRvIGFkZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzZXNXaXRoTmF0aXZlXyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRpZiAoY2xhc3NOYW1lKSB7XG5cdFx0XHRlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vKipcbiAqIEFkZHMgdGhlIHJlcXVlc3RlZCBDU1MgY2xhc3NlcyB0byBhbiBlbGVtZW50IHdpdGhvdXQgdXNpbmcgY2xhc3NMaXN0LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB0byBhZGQgQ1NTIGNsYXNzZXMgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byBhZGQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHR2YXIgZWxlbWVudENsYXNzTmFtZSA9ICcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnO1xuXHR2YXIgY2xhc3Nlc1RvQXBwZW5kID0gJyc7XG5cblx0Y2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoJyAnKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY2xhc3NOYW1lID0gY2xhc3Nlc1tpXTtcblxuXHRcdGlmIChlbGVtZW50Q2xhc3NOYW1lLmluZGV4T2YoJyAnICsgY2xhc3NOYW1lICsgJyAnKSA9PT0gLTEpIHtcblx0XHRcdGNsYXNzZXNUb0FwcGVuZCArPSAnICcgKyBjbGFzc05hbWU7XG5cdFx0fVxuXHR9XG5cblx0aWYgKGNsYXNzZXNUb0FwcGVuZCkge1xuXHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUgKyBjbGFzc2VzVG9BcHBlbmQ7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBnaXZlbiBlbGVtZW50LCB0byBiZSB0cmlnZ2VyZWQgdmlhIGRlbGVnYXRlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEVsZW1lbnRMaXN0ZW5lcl8oZWxlbWVudCwgZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHRhZGRUb0Fycl8oX2RvbURhdGEyLmRlZmF1bHQuZ2V0KGVsZW1lbnQsICdsaXN0ZW5lcnMnLCB7fSksIGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xufVxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGdpdmVuIGVsZW1lbnQsIHRvIGJlIHRyaWdnZXJlZCB2aWEgZGVsZWdhdGVcbiAqIHNlbGVjdG9ycy5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZFNlbGVjdG9yTGlzdGVuZXJfKGVsZW1lbnQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIGxpc3RlbmVyKSB7XG5cdHZhciBkZWxlZ2F0aW5nRGF0YSA9IF9kb21EYXRhMi5kZWZhdWx0LmdldChlbGVtZW50LCAnZGVsZWdhdGluZycsIHt9KTtcblx0YWRkVG9BcnJfKGRlbGVnYXRpbmdEYXRhW2V2ZW50TmFtZV0uc2VsZWN0b3JzLCBzZWxlY3RvciwgbGlzdGVuZXIpO1xufVxuXG4vKipcbiAqIEFkZHMgYSB2YWx1ZSB0byBhbiBhcnJheSBpbnNpZGUgYW4gb2JqZWN0LCBjcmVhdGluZyBpdCBmaXJzdCBpZiBpdCBkb2Vzbid0XG4gKiB5ZXQgZXhpc3QuXG4gKiBAcGFyYW0geyFBcnJheX0gYXJyXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRUb0Fycl8oYXJyLCBrZXksIHZhbHVlKSB7XG5cdGlmICghYXJyW2tleV0pIHtcblx0XHRhcnJba2V5XSA9IFtdO1xuXHR9XG5cdGFycltrZXldLnB1c2godmFsdWUpO1xufVxuXG4vKipcbiAqIEF0dGFjaGVzIGEgZGVsZWdhdGUgbGlzdGVuZXIsIHVubGVzcyB0aGVyZSdzIGFscmVhZHkgb25lIGF0dGFjaGVkLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXR0YWNoRGVsZWdhdGVFdmVudF8oZWxlbWVudCwgZXZlbnROYW1lKSB7XG5cdHZhciBkZWxlZ2F0aW5nRGF0YSA9IF9kb21EYXRhMi5kZWZhdWx0LmdldChlbGVtZW50LCAnZGVsZWdhdGluZycsIHt9KTtcblx0aWYgKCFkZWxlZ2F0aW5nRGF0YVtldmVudE5hbWVdKSB7XG5cdFx0ZGVsZWdhdGluZ0RhdGFbZXZlbnROYW1lXSA9IHtcblx0XHRcdGhhbmRsZTogb24oZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVEZWxlZ2F0ZUV2ZW50XywgISFVU0VfQ0FQVFVSRVtldmVudE5hbWVdKSxcblx0XHRcdHNlbGVjdG9yczoge31cblx0XHR9O1xuXHR9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY2xvc2VzdCBlbGVtZW50IHVwIHRoZSB0cmVlIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgKGluY2x1ZGluZ1xuICogaXRzZWxmKSB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBzZWxlY3Rvciwgb3IgbnVsbCBpZiBub25lIG1hdGNoLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcblx0d2hpbGUgKGVsZW1lbnQgJiYgIW1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xuXHRcdGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cdH1cblx0cmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyBhIGNoaWxkIG5vZGUgd2l0aCB0ZXh0IG9yIG90aGVyIG5vZGVzIHRvIGEgcGFyZW50IG5vZGUuIElmXG4gKiBjaGlsZCBpcyBhIEhUTUwgc3RyaW5nIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYSBkb2N1bWVudFxuICogZnJhZ21lbnQgYmVmb3JlIGFwcGVuZGluZyBpdCB0byB0aGUgcGFyZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gcGFyZW50IFRoZSBub2RlIHRvIGFwcGVuZCBub2RlcyB0by5cbiAqIEBwYXJhbSB7IShFbGVtZW50fE5vZGVMaXN0fHN0cmluZyl9IGNoaWxkIFRoZSB0aGluZyB0byBhcHBlbmQgdG8gdGhlIHBhcmVudC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgYXBwZW5kZWQgY2hpbGQuXG4gKi9cbmZ1bmN0aW9uIGFwcGVuZChwYXJlbnQsIGNoaWxkKSB7XG5cdGlmICgoMCwgX21ldGFsLmlzU3RyaW5nKShjaGlsZCkpIHtcblx0XHRjaGlsZCA9IGJ1aWxkRnJhZ21lbnQoY2hpbGQpO1xuXHR9XG5cdGlmIChjaGlsZCBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG5cdFx0dmFyIGNoaWxkQXJyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY2hpbGQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRBcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZEFycltpXSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdH1cblx0cmV0dXJuIGNoaWxkO1xufVxuXG4vKipcbiAqIEhlbHBlciBmb3IgY29udmVydGluZyBhIEhUTUwgc3RyaW5nIGludG8gYSBkb2N1bWVudCBmcmFnbWVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sU3RyaW5nIFRoZSBIVE1MIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSByZXN1bHRpbmcgZG9jdW1lbnQgZnJhZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoaHRtbFN0cmluZykge1xuXHR2YXIgdGVtcERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHR0ZW1wRGl2LmlubmVySFRNTCA9ICc8YnI+JyArIGh0bWxTdHJpbmc7XG5cdHRlbXBEaXYucmVtb3ZlQ2hpbGQodGVtcERpdi5maXJzdENoaWxkKTtcblxuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdHdoaWxlICh0ZW1wRGl2LmZpcnN0Q2hpbGQpIHtcblx0XHRmcmFnbWVudC5hcHBlbmRDaGlsZCh0ZW1wRGl2LmZpcnN0Q2hpbGQpO1xuXHR9XG5cdHJldHVybiBmcmFnbWVudDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGZpcnN0IGVsZW1lbnQgY29udGFpbnMgdGhlIHNlY29uZCBvbmUuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50MVxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zKGVsZW1lbnQxLCBlbGVtZW50Mikge1xuXHRpZiAoKDAsIF9tZXRhbC5pc0RvY3VtZW50KShlbGVtZW50MSkpIHtcblx0XHQvLyBkb2N1bWVudC5jb250YWlucyBpcyBub3QgZGVmaW5lZCBvbiBJRTksIHNvIGNhbGwgaXQgb24gZG9jdW1lbnRFbGVtZW50IGluc3RlYWQuXG5cdFx0cmV0dXJuIGVsZW1lbnQxLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbGVtZW50Mik7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGVsZW1lbnQxLmNvbnRhaW5zKGVsZW1lbnQyKTtcblx0fVxufVxuXG4vKipcbiAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQsIGJ1dCBvbmx5IGNhbGxzIHRoZVxuICogZ2l2ZW4gY2FsbGJhY2sgbGlzdGVuZXIgd2hlbiBpdCdzIHRyaWdnZXJlZCBieSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZVxuICogZ2l2ZW4gc2VsZWN0b3Igb3IgdGFyZ2V0IGVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB0aGUgZXZlbnQgc2hvdWxkIGJlIGxpc3RlbmVkIG9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICogQHBhcmFtIHshRWxlbWVudHxzdHJpbmd9IHNlbGVjdG9yT3JUYXJnZXQgRWl0aGVyIGFuIGVsZW1lbnQgb3IgY3NzIHNlbGVjdG9yXG4gKiAgICAgdGhhdCBzaG91bGQgbWF0Y2ggdGhlIGV2ZW50IGZvciB0aGUgbGlzdGVuZXIgdG8gYmUgdHJpZ2dlcmVkLlxuICogQHBhcmFtIHshZnVuY3Rpb24oIU9iamVjdCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudFxuICogICAgIGlzIHRyaWdnZXJlZC4gSXQgd2lsbCByZWNlaXZlIHRoZSBub3JtYWxpemVkIGV2ZW50IG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9kZWZhdWx0IE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGlzIGEgZGVmYXVsdFxuICogICAgIGxpc3RlbmVyLiBUaGF0IG1lYW5zIHRoYXQgaXQgd291bGQgb25seSBiZSBleGVjdXRlZCBhZnRlciBhbGwgbm9uXG4gKiAgICAgZGVmYXVsdCBsaXN0ZW5lcnMsIGFuZCBvbmx5IGlmIHRoZSBldmVudCBpc24ndCBwcmV2ZW50ZWQgdmlhXG4gKiAgICAgYHByZXZlbnREZWZhdWx0YC5cbiAqIEByZXR1cm4geyFFdmVudEhhbmRsZX0gQ2FuIGJlIHVzZWQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gZGVsZWdhdGUoZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3Rvck9yVGFyZ2V0LCBjYWxsYmFjaywgb3B0X2RlZmF1bHQpIHtcblx0dmFyIGN1c3RvbUNvbmZpZyA9IGN1c3RvbUV2ZW50c1tldmVudE5hbWVdO1xuXHRpZiAoY3VzdG9tQ29uZmlnICYmIGN1c3RvbUNvbmZpZy5kZWxlZ2F0ZSkge1xuXHRcdGV2ZW50TmFtZSA9IGN1c3RvbUNvbmZpZy5vcmlnaW5hbEV2ZW50O1xuXHRcdGNhbGxiYWNrID0gY3VzdG9tQ29uZmlnLmhhbmRsZXIuYmluZChjdXN0b21Db25maWcsIGNhbGxiYWNrKTtcblx0fVxuXG5cdGlmIChvcHRfZGVmYXVsdCkge1xuXHRcdC8vIFdyYXAgY2FsbGJhY2sgc28gd2UgZG9uJ3Qgc2V0IHByb3BlcnR5IGRpcmVjdGx5IG9uIGl0LlxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2suYmluZCgpO1xuXHRcdGNhbGxiYWNrLmRlZmF1bHRMaXN0ZW5lcl8gPSB0cnVlO1xuXHR9XG5cblx0YXR0YWNoRGVsZWdhdGVFdmVudF8oZWxlbWVudCwgZXZlbnROYW1lKTtcblx0aWYgKCgwLCBfbWV0YWwuaXNTdHJpbmcpKHNlbGVjdG9yT3JUYXJnZXQpKSB7XG5cdFx0YWRkU2VsZWN0b3JMaXN0ZW5lcl8oZWxlbWVudCwgZXZlbnROYW1lLCBzZWxlY3Rvck9yVGFyZ2V0LCBjYWxsYmFjayk7XG5cdH0gZWxzZSB7XG5cdFx0YWRkRWxlbWVudExpc3RlbmVyXyhzZWxlY3Rvck9yVGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrKTtcblx0fVxuXG5cdHJldHVybiBuZXcgX0RvbURlbGVnYXRlZEV2ZW50SGFuZGxlMi5kZWZhdWx0KCgwLCBfbWV0YWwuaXNTdHJpbmcpKHNlbGVjdG9yT3JUYXJnZXQpID8gZWxlbWVudCA6IHNlbGVjdG9yT3JUYXJnZXQsIGV2ZW50TmFtZSwgY2FsbGJhY2ssICgwLCBfbWV0YWwuaXNTdHJpbmcpKHNlbGVjdG9yT3JUYXJnZXQpID8gc2VsZWN0b3JPclRhcmdldCA6IG51bGwpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIGlmIHRoZSBlbGVtZW50IGlzIGFibGUgdG8gdHJpZ2dlciB0aGUgQ2xpY2sgZXZlbnQsXG4gKiBzaW11bGF0aW5nIGJyb3dzZXJzIGJlaGF2aW91ciwgYXZvaWRpbmcgZXZlbnQgbGlzdGVuZXJzIHRvIGJlIGNhbGxlZCBieSB0cmlnZ2VyRXZlbnQgbWV0aG9kLlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0FibGVUb0ludGVyYWN0V2l0aF8obm9kZSwgZXZlbnROYW1lLCBvcHRfZXZlbnRPYmopIHtcblx0aWYgKG9wdF9ldmVudE9iaiAmJiBldmVudE5hbWUgPT09ICdjbGljaycgJiYgb3B0X2V2ZW50T2JqLmJ1dHRvbiA9PT0gMikge1xuXHRcdC8vIEZpcmVmb3ggdHJpZ2dlcnMgXCJjbGlja1wiIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgZm9yIHJpZ2h0IGNsaWNrcy4gVGhpc1xuXHRcdC8vIGNhdXNlcyBvdXIgZGVsZWdhdGUgbG9naWMgdG8gdHJpZ2dlciBpdCBmb3IgcmVndWxhciBlbGVtZW50cyB0b28sIHdoaWNoXG5cdFx0Ly8gc2hvdWxkbid0IGhhcHBlbi4gSWdub3JpbmcgdGhlbSBoZXJlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBtYXRjaGVzU2VsZWN0b3IgPSBbJ0JVVFRPTicsICdJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnLCAnRklFTERTRVQnXTtcblx0aWYgKGV2ZW50TmFtZSA9PT0gJ2NsaWNrJyAmJiBtYXRjaGVzU2VsZWN0b3IuaW5kZXhPZihub2RlLnRhZ05hbWUpID4gLTEpIHtcblx0XHRyZXR1cm4gIShub2RlLmRpc2FibGVkIHx8IHBhcmVudChub2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdJykpO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEluc2VydHMgbm9kZSBpbiBkb2N1bWVudCBhcyBsYXN0IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byByZW1vdmUgY2hpbGRyZW4gZnJvbS5cbiAqL1xuZnVuY3Rpb24gZW50ZXJEb2N1bWVudChub2RlKSB7XG5cdG5vZGUgJiYgYXBwZW5kKGRvY3VtZW50LmJvZHksIG5vZGUpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgbm9kZSBmcm9tIGRvY3VtZW50LlxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGNoaWxkcmVuIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGV4aXREb2N1bWVudChub2RlKSB7XG5cdGlmIChub2RlICYmIG5vZGUucGFyZW50Tm9kZSkge1xuXHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYW4gZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IGEgZGVsZWdhdGUgbGlzdGVuZXIuIEFsbFxuICogbWF0Y2hpbmcgbGlzdGVuZXJzIG9mIHRoaXMgZXZlbnQgdHlwZSBmcm9tIGB0YXJnZXRgIHRvIGBjdXJyZW50VGFyZ2V0YCB3aWxsXG4gKiBiZSB0cmlnZ2VyZWQuXG4gKiBAcGFyYW0geyFFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHBheWxvYWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRyaWdnZXJlZCBjYWxsYmFja3MgcmV0dXJuc1xuICogICAgIGZhbHNlLCBvciB0cnVlIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURlbGVnYXRlRXZlbnRfKGV2ZW50KSB7XG5cdG5vcm1hbGl6ZURlbGVnYXRlRXZlbnRfKGV2ZW50KTtcblx0dmFyIHJldCA9IHRydWU7XG5cdHZhciBjb250YWluZXIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuXHR2YXIgZGVmRm5zID0gW107XG5cblx0cmV0ICY9IHRyaWdnZXJEZWxlZ2F0ZWRMaXN0ZW5lcnNfKGNvbnRhaW5lciwgZXZlbnQsIGRlZkZucyk7XG5cdHJldCAmPSB0cmlnZ2VyRGVmYXVsdERlbGVnYXRlZExpc3RlbmVyc18oZGVmRm5zLCBldmVudCk7XG5cblx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBudWxsO1xuXHRldmVudFtMQVNUX0NPTlRBSU5FUl0gPSBjb250YWluZXI7XG5cdHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGhhcyB0aGUgcmVxdWVzdGVkIGNzcyBjbGFzcy5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuXHRpZiAoJ2NsYXNzTGlzdCcgaW4gZWxlbWVudCkge1xuXHRcdHJldHVybiBoYXNDbGFzc1dpdGhOYXRpdmVfKGVsZW1lbnQsIGNsYXNzTmFtZSk7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIGhhc0NsYXNzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3NOYW1lKTtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBjc3MgY2xhc3MgdXNpbmcgY2xhc3NMaXN0LlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhc0NsYXNzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3NOYW1lKSB7XG5cdHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBoYXMgdGhlIHJlcXVlc3RlZCBjc3MgY2xhc3Mgd2l0aG91dCB1c2luZyBjbGFzc0xpc3QuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFzQ2xhc3NXaXRob3V0TmF0aXZlXyhlbGVtZW50LCBjbGFzc05hbWUpIHtcblx0cmV0dXJuICgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbGFzc05hbWUgKyAnICcpID49IDA7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGVtcHR5IG9yIG5vdC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkoZWxlbWVudCkge1xuXHRyZXR1cm4gZWxlbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBnaXZlbiBzZWxlY3Rvci5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaChlbGVtZW50LCBzZWxlY3Rvcikge1xuXHRpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBwID0gRWxlbWVudC5wcm90b3R5cGU7XG5cdHZhciBtID0gcC5tYXRjaGVzIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHAubXNNYXRjaGVzU2VsZWN0b3IgfHwgcC5vTWF0Y2hlc1NlbGVjdG9yO1xuXHRpZiAobSkge1xuXHRcdHJldHVybiBtLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xuXHR9XG5cblx0cmV0dXJuIG1hdGNoRmFsbGJhY2tfKGVsZW1lbnQsIHNlbGVjdG9yKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgYSBnaXZlbiBzZWxlY3RvciwgdXNpbmcgYW4gaW50ZXJuYWwgaW1wbGVtZW50YXRpb25cbiAqIGluc3RlYWQgb2YgY2FsbGluZyBleGlzdGluZyBqYXZhc2NyaXB0IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWF0Y2hGYWxsYmFja18oZWxlbWVudCwgc2VsZWN0b3IpIHtcblx0dmFyIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgZWxlbWVudC5wYXJlbnROb2RlKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuXHRcdGlmIChub2Rlc1tpXSA9PT0gZWxlbWVudCkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGdpdmVuIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWRcbiAqIHNlbGVjdG9yLCBvciBudWxsIGlmIHRoZXJlIGlzIG5vbmUuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0gez9zdHJpbmd9IHNlbGVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcblx0ZG8ge1xuXHRcdGVsZW1lbnQgPSBlbGVtZW50Lm5leHRTaWJsaW5nO1xuXHRcdGlmIChlbGVtZW50ICYmIG1hdGNoKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHR9IHdoaWxlIChlbGVtZW50KTtcblx0cmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZXZlbnQgcGF5bG9hZCBmb3IgZGVsZWdhdGUgbGlzdGVuZXJzLlxuICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEZWxlZ2F0ZUV2ZW50XyhldmVudCkge1xuXHRldmVudC5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb25fO1xuXHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gPSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25fO1xufVxuXG4vKipcbiAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQuIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplc1xuICogRE9NIGV2ZW50IHBheWxvYWRzIGFuZCBmdW5jdGlvbnMgc28gdGhleSdsbCB3b3JrIHRoZSBzYW1lIHdheSBvbiBhbGwgc3VwcG9ydGVkXG4gKiBicm93c2Vycy5cbiAqIEBwYXJhbSB7IUVsZW1lbnR8c3RyaW5nfSBlbGVtZW50IFRoZSBET00gZWxlbWVudCB0byBsaXN0ZW4gdG8gdGhlIGV2ZW50IG9uLCBvclxuICogICBhIHNlbGVjdG9yIHRoYXQgc2hvdWxkIGJlIGRlbGVnYXRlZCBvbiB0aGUgZW50aXJlIGRvY3VtZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICogQHBhcmFtIHshZnVuY3Rpb24oIU9iamVjdCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpc1xuICogICB0cmlnZ2VyZWQuIEl0IHdpbGwgcmVjZWl2ZSB0aGUgbm9ybWFsaXplZCBldmVudCBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF9jYXB0dXJlIEZsYWcgaW5kaWNhdGluZyBpZiBsaXN0ZW5lciBzaG91bGQgYmUgdHJpZ2dlcmVkXG4gKiAgIGR1cmluZyBjYXB0dXJlIHBoYXNlLCBpbnN0ZWFkIG9mIGR1cmluZyB0aGUgYnViYmxpbmcgcGhhc2UuIERlZmF1bHRzIHRvIGZhbHNlLlxuICogQHJldHVybiB7IURvbUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBvbihlbGVtZW50LCBldmVudE5hbWUsIGNhbGxiYWNrLCBvcHRfY2FwdHVyZSkge1xuXHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoZWxlbWVudCkpIHtcblx0XHRyZXR1cm4gZGVsZWdhdGUoZG9jdW1lbnQsIGV2ZW50TmFtZSwgZWxlbWVudCwgY2FsbGJhY2spO1xuXHR9XG5cdHZhciBjdXN0b21Db25maWcgPSBjdXN0b21FdmVudHNbZXZlbnROYW1lXTtcblx0aWYgKGN1c3RvbUNvbmZpZyAmJiBjdXN0b21Db25maWcuZXZlbnQpIHtcblx0XHRldmVudE5hbWUgPSBjdXN0b21Db25maWcub3JpZ2luYWxFdmVudDtcblx0XHRjYWxsYmFjayA9IGN1c3RvbUNvbmZpZy5oYW5kbGVyLmJpbmQoY3VzdG9tQ29uZmlnLCBjYWxsYmFjayk7XG5cdH1cblx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIG9wdF9jYXB0dXJlKTtcblx0cmV0dXJuIG5ldyBfRG9tRXZlbnRIYW5kbGUyLmRlZmF1bHQoZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaywgb3B0X2NhcHR1cmUpO1xufVxuXG4vKipcbiAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gRE9NIGVsZW1lbnQgb25jZS4gVGhpc1xuICogZnVuY3Rpb24gbm9ybWFsaXplcyBET00gZXZlbnQgcGF5bG9hZHMgYW5kIGZ1bmN0aW9ucyBzbyB0aGV5J2xsIHdvcmsgdGhlXG4gKiBzYW1lIHdheSBvbiBhbGwgc3VwcG9ydGVkIGJyb3dzZXJzLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgRE9NIGVsZW1lbnQgdG8gbGlzdGVuIHRvIHRoZSBldmVudCBvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0by5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFPYmplY3QpfSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnRcbiAqICAgaXMgdHJpZ2dlcmVkLiBJdCB3aWxsIHJlY2VpdmUgdGhlIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0LlxuICogQHJldHVybiB7IURvbUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBvbmNlKGVsZW1lbnQsIGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcblx0dmFyIGRvbUV2ZW50SGFuZGxlID0gb24oZWxlbWVudCwgZXZlbnROYW1lLCBmdW5jdGlvbiAoKSB7XG5cdFx0ZG9tRXZlbnRIYW5kbGUucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHRyZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSk7XG5cdHJldHVybiBkb21FdmVudEhhbmRsZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBmaXJzdCBwYXJlbnQgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZFxuICogc2VsZWN0b3IsIG9yIG51bGwgaWYgbm9uZSBtYXRjaC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gcGFyZW50KGVsZW1lbnQsIHNlbGVjdG9yKSB7XG5cdHJldHVybiBjbG9zZXN0KGVsZW1lbnQucGFyZW50Tm9kZSwgc2VsZWN0b3IpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGN1c3RvbSBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGN1c3RvbSBldmVudC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gY3VzdG9tQ29uZmlnIEFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IGhvdyB0aGUgZXZlbnRcbiAqICAgc2hvdWxkIGJlIGhhbmRsZWQuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBjdXN0b21Db25maWcpIHtcblx0Y3VzdG9tRXZlbnRzW2V2ZW50TmFtZV0gPSBjdXN0b21Db25maWc7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgdGhlIGNoaWxkIG5vZGVzIG9uIGEgRE9NIG5vZGUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byByZW1vdmUgY2hpbGRyZW4gZnJvbS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hpbGRyZW4obm9kZSkge1xuXHR2YXIgY2hpbGQgPSB2b2lkIDA7XG5cdHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuXHRcdG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHR9XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgcmVxdWVzdGVkIENTUyBjbGFzc2VzIGZyb20gYW4gZWxlbWVudC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR8IU5vZGVMaXN0fSBlbGVtZW50cyBUaGUgZWxlbWVudCBvciBlbGVtZW50cyB0byByZW1vdmUgQ1NTIGNsYXNzZXMgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIENTUyBjbGFzc2VzIHRvIHJlbW92ZS5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhlbGVtZW50cywgY2xhc3Nlcykge1xuXHRpZiAoISgwLCBfbWV0YWwuaXNPYmplY3QpKGVsZW1lbnRzKSB8fCAhKDAsIF9tZXRhbC5pc1N0cmluZykoY2xhc3NlcykpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuXHRcdGVsZW1lbnRzID0gW2VsZW1lbnRzXTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoJ2NsYXNzTGlzdCcgaW4gZWxlbWVudHNbaV0pIHtcblx0XHRcdHJlbW92ZUNsYXNzZXNXaXRoTmF0aXZlXyhlbGVtZW50c1tpXSwgY2xhc3Nlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZUNsYXNzZXNXaXRob3V0TmF0aXZlXyhlbGVtZW50c1tpXSwgY2xhc3Nlcyk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgcmVxdWVzdGVkIENTUyBjbGFzc2VzIGZyb20gYW4gZWxlbWVudCB1c2luZyBjbGFzc0xpc3QuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHJlbW92ZSBDU1MgY2xhc3NlcyBmcm9tLlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzZXMgQ1NTIGNsYXNzZXMgdG8gcmVtb3ZlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3Nlc1dpdGhOYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0Y2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuXHRcdGlmIChjbGFzc05hbWUpIHtcblx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgcmVxdWVzdGVkIENTUyBjbGFzc2VzIGZyb20gYW4gZWxlbWVudCB3aXRob3V0IHVzaW5nIGNsYXNzTGlzdC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gcmVtb3ZlIENTUyBjbGFzc2VzIGZyb20uXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBDU1MgY2xhc3NlcyB0byByZW1vdmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzc2VzV2l0aG91dE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcykge1xuXHR2YXIgZWxlbWVudENsYXNzTmFtZSA9ICcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnO1xuXG5cdGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJyk7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ZWxlbWVudENsYXNzTmFtZSA9IGVsZW1lbnRDbGFzc05hbWUucmVwbGFjZSgnICcgKyBjbGFzc2VzW2ldICsgJyAnLCAnICcpO1xuXHR9XG5cblx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50Q2xhc3NOYW1lLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHRoZSBzZWNvbmQuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQyXG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG5cdGlmIChlbGVtZW50MSAmJiBlbGVtZW50MiAmJiBlbGVtZW50MSAhPT0gZWxlbWVudDIgJiYgZWxlbWVudDEucGFyZW50Tm9kZSkge1xuXHRcdGVsZW1lbnQxLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQyLCBlbGVtZW50MSk7XG5cdFx0ZWxlbWVudDEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50MSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgZnVuY3Rpb24gdGhhdCByZXBsYWNlcyBgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uX2AgZm9yIGV2ZW50cy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbl8oKSB7XG5cdHZhciBldmVudCA9IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblx0ZXZlbnQuc3RvcHBlZCA9IHRydWU7XG5cdGV2ZW50LnN0b3BwZWRJbW1lZGlhdGUgPSB0cnVlO1xuXHRFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLmNhbGwoZXZlbnQpO1xufVxuXG4vKipcbiAqIFRoZSBmdW5jdGlvbiB0aGF0IHJlcGxhY2VzIGBzdG9wUHJvcGFnYXRpb25gIGZvciBldmVudHMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb25fKCkge1xuXHR2YXIgZXZlbnQgPSB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cdGV2ZW50LnN0b3BwZWQgPSB0cnVlO1xuXHRFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uLmNhbGwoZXZlbnQpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBzdXBwb3J0cyB0aGUgZ2l2ZW4gZXZlbnQgdHlwZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR8c3RyaW5nfSBlbGVtZW50IFRoZSBET00gZWxlbWVudCBvciBlbGVtZW50IHRhZyBuYW1lIHRvIGNoZWNrLlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBzdXBwb3J0c0V2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSkge1xuXHRpZiAoY3VzdG9tRXZlbnRzW2V2ZW50TmFtZV0pIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICgoMCwgX21ldGFsLmlzU3RyaW5nKShlbGVtZW50KSkge1xuXHRcdGlmICghZWxlbWVudHNCeVRhZ19bZWxlbWVudF0pIHtcblx0XHRcdGVsZW1lbnRzQnlUYWdfW2VsZW1lbnRdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbGVtZW50KTtcblx0XHR9XG5cdFx0ZWxlbWVudCA9IGVsZW1lbnRzQnlUYWdfW2VsZW1lbnRdO1xuXHR9XG5cblx0dmFyIHRhZyA9IGVsZW1lbnQudGFnTmFtZTtcblx0aWYgKCFzdXBwb3J0Q2FjaGVfW3RhZ10gfHwgIXN1cHBvcnRDYWNoZV9bdGFnXS5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG5cdFx0c3VwcG9ydENhY2hlX1t0YWddID0gc3VwcG9ydENhY2hlX1t0YWddIHx8IHt9O1xuXHRcdHN1cHBvcnRDYWNoZV9bdGFnXVtldmVudE5hbWVdID0gJ29uJyArIGV2ZW50TmFtZSBpbiBlbGVtZW50O1xuXHR9XG5cdHJldHVybiBzdXBwb3J0Q2FjaGVfW3RhZ11bZXZlbnROYW1lXTtcbn1cblxuLyoqXG4gKiBUaGlzIHRyaWdnZXJzIGFsbCBkZWZhdWx0IG1hdGNoZWQgZGVsZWdhdGVkIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50IHR5cGUuXG4gKiBAcGFyYW0geyFBcnJheX0gZGVmYXVsdEZucyBBcnJheSB0byBjb2xsZWN0IGRlZmF1bHQgbGlzdGVuZXJzIGluLCBpbnN0ZWFkXG4gKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdHJpZ2dlcmVkIGNhbGxiYWNrcyByZXR1cm5zXG4gKiAgICAgZmFsc2UsIG9yIHRydWUgb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRlZmF1bHREZWxlZ2F0ZWRMaXN0ZW5lcnNfKGRlZkZucywgZXZlbnQpIHtcblx0dmFyIHJldCA9IHRydWU7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZWZGbnMubGVuZ3RoICYmICFldmVudC5kZWZhdWx0UHJldmVudGVkOyBpKyspIHtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IGRlZkZuc1tpXS5lbGVtZW50O1xuXHRcdHJldCAmPSBkZWZGbnNbaV0uZm4oZXZlbnQpO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBUaGlzIHRyaWdnZXJzIGFsbCBtYXRjaGVkIGRlbGVnYXRlZCBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudCB0eXBlIHdoZW4gaXRzXG4gKiBkZWxlZ2F0ZWQgdGFyZ2V0IGlzIGFibGUgdG8gaW50ZXJhY3QuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBjb250YWluZXJcbiAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICogQHBhcmFtIHshQXJyYXl9IGRlZmF1bHRGbnMgQXJyYXkgdG8gY29sbGVjdCBkZWZhdWx0IGxpc3RlbmVycyBpbiwgaW5zdGVhZFxuICogICAgIG9mIHJ1bm5pbmcgdGhlbS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdHJpZ2dlcmVkIGNhbGxiYWNrcyByZXR1cm5zXG4gKiAgICAgZmFsc2UsIG9yIHRydWUgb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckRlbGVnYXRlZExpc3RlbmVyc18oY29udGFpbmVyLCBldmVudCwgZGVmYXVsdEZucykge1xuXHR2YXIgcmV0ID0gdHJ1ZTtcblx0dmFyIGN1cnJFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuXHR2YXIgbGltaXQgPSBjb250YWluZXIucGFyZW50Tm9kZTtcblxuXHR3aGlsZSAoY3VyckVsZW1lbnQgJiYgY3VyckVsZW1lbnQgIT09IGxpbWl0ICYmICFldmVudC5zdG9wcGVkKSB7XG5cdFx0aWYgKGlzQWJsZVRvSW50ZXJhY3RXaXRoXyhjdXJyRWxlbWVudCwgZXZlbnQudHlwZSwgZXZlbnQpKSB7XG5cdFx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IGN1cnJFbGVtZW50O1xuXHRcdFx0cmV0ICY9IHRyaWdnZXJFbGVtZW50TGlzdGVuZXJzXyhjdXJyRWxlbWVudCwgZXZlbnQsIGRlZmF1bHRGbnMpO1xuXHRcdFx0cmV0ICY9IHRyaWdnZXJTZWxlY3Rvckxpc3RlbmVyc18oY29udGFpbmVyLCBjdXJyRWxlbWVudCwgZXZlbnQsIGRlZmF1bHRGbnMpO1xuXHRcdH1cblx0XHRjdXJyRWxlbWVudCA9IGN1cnJFbGVtZW50LnBhcmVudE5vZGU7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiBhcmd1bWVudCB0byBhIERPTSBlbGVtZW50LiBTdHJpbmdzIGFyZSBhc3N1bWVkIHRvXG4gKiBiZSBzZWxlY3RvcnMsIGFuZCBzbyBhIG1hdGNoZWQgZWxlbWVudCB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgYXJnXG4gKiBpcyBhbHJlYWR5IGEgRE9NIGVsZW1lbnQgaXQgd2lsbCBiZSB0aGUgcmV0dXJuIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudHxEb2N1bWVudH0gc2VsZWN0b3JPckVsZW1lbnRcbiAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBjb252ZXJ0ZWQgZWxlbWVudCwgb3IgbnVsbCBpZiBub25lIHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gdG9FbGVtZW50KHNlbGVjdG9yT3JFbGVtZW50KSB7XG5cdGlmICgoMCwgX21ldGFsLmlzRWxlbWVudCkoc2VsZWN0b3JPckVsZW1lbnQpIHx8ICgwLCBfbWV0YWwuaXNEb2N1bWVudCkoc2VsZWN0b3JPckVsZW1lbnQpIHx8ICgwLCBfbWV0YWwuaXNEb2N1bWVudEZyYWdtZW50KShzZWxlY3Rvck9yRWxlbWVudCkpIHtcblx0XHRyZXR1cm4gc2VsZWN0b3JPckVsZW1lbnQ7XG5cdH0gZWxzZSBpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoc2VsZWN0b3JPckVsZW1lbnQpKSB7XG5cdFx0aWYgKHNlbGVjdG9yT3JFbGVtZW50WzBdID09PSAnIycgJiYgc2VsZWN0b3JPckVsZW1lbnQuaW5kZXhPZignICcpID09PSAtMSkge1xuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbGVjdG9yT3JFbGVtZW50LnN1YnN0cigxKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yT3JFbGVtZW50KTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIG9yIHJlbW92ZXMgb25lIG9yIG1vcmUgY2xhc3NlcyBmcm9tIGFuIGVsZW1lbnQuIElmIGFueSBvZiB0aGUgY2xhc3Nlc1xuICogaXMgcHJlc2VudCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGVsZW1lbnQsIG9yIGFkZGVkIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd2hpY2ggY2xhc3NlcyB3aWxsIGJlIHRvZ2dsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBUaGUgY2xhc3NlcyB3aGljaCBoYXZlIHRvIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3NlcyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdGlmICghKDAsIF9tZXRhbC5pc09iamVjdCkoZWxlbWVudCkgfHwgISgwLCBfbWV0YWwuaXNTdHJpbmcpKGNsYXNzZXMpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aWYgKCdjbGFzc0xpc3QnIGluIGVsZW1lbnQpIHtcblx0XHR0b2dnbGVDbGFzc2VzV2l0aE5hdGl2ZV8oZWxlbWVudCwgY2xhc3Nlcyk7XG5cdH0gZWxzZSB7XG5cdFx0dG9nZ2xlQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIG9uZSBvciBtb3JlIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50IHVzaW5nIGNsYXNzTGlzdC5cbiAqIElmIGFueSBvZiB0aGUgY2xhc3NlcyBpcyBwcmVzZW50LCBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCxcbiAqIG9yIGFkZGVkIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgd2hpY2ggY2xhc3NlcyB3aWxsIGJlIHRvZ2dsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NlcyBUaGUgY2xhc3NlcyB3aGljaCBoYXZlIHRvIGFkZGVkIG9yIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzZXNXaXRoTmF0aXZlXyhlbGVtZW50LCBjbGFzc2VzKSB7XG5cdGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcblx0XHRlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lKTtcblx0fSk7XG59XG5cbi8qKlxuICogQWRkcyBvciByZW1vdmVzIG9uZSBvciBtb3JlIGNsYXNzZXMgZnJvbSBhbiBlbGVtZW50IHdpdGhvdXQgdXNpbmcgY2xhc3NMaXN0LlxuICogSWYgYW55IG9mIHRoZSBjbGFzc2VzIGlzIHByZXNlbnQsIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50LFxuICogb3IgYWRkZWQgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgZWxlbWVudCB3aGljaCBjbGFzc2VzIHdpbGwgYmUgdG9nZ2xlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc2VzIFRoZSBjbGFzc2VzIHdoaWNoIGhhdmUgdG8gYWRkZWQgb3IgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdG9nZ2xlQ2xhc3Nlc1dpdGhvdXROYXRpdmVfKGVsZW1lbnQsIGNsYXNzZXMpIHtcblx0dmFyIGVsZW1lbnRDbGFzc05hbWUgPSAnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJztcblxuXHRjbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgnICcpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjbGFzc05hbWUgPSAnICcgKyBjbGFzc2VzW2ldICsgJyAnO1xuXHRcdHZhciBjbGFzc0luZGV4ID0gZWxlbWVudENsYXNzTmFtZS5pbmRleE9mKGNsYXNzTmFtZSk7XG5cblx0XHRpZiAoY2xhc3NJbmRleCA9PT0gLTEpIHtcblx0XHRcdGVsZW1lbnRDbGFzc05hbWUgPSAnJyArIGVsZW1lbnRDbGFzc05hbWUgKyBjbGFzc2VzW2ldICsgJyAnO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYmVmb3JlID0gZWxlbWVudENsYXNzTmFtZS5zdWJzdHJpbmcoMCwgY2xhc3NJbmRleCk7XG5cdFx0XHR2YXIgYWZ0ZXIgPSBlbGVtZW50Q2xhc3NOYW1lLnN1YnN0cmluZyhjbGFzc0luZGV4ICsgY2xhc3NOYW1lLmxlbmd0aCk7XG5cdFx0XHRlbGVtZW50Q2xhc3NOYW1lID0gYmVmb3JlICsgJyAnICsgYWZ0ZXI7XG5cdFx0fVxuXHR9XG5cblx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50Q2xhc3NOYW1lLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBUcmlnZ2VycyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgZ2l2ZW4gZXZlbnQgdHlwZSB0aGF0IGFyZSBzdG9yZWQgaW4gdGhlXG4gKiBzcGVjaWZpZWQgZWxlbWVudC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICogQHBhcmFtIHshQXJyYXl9IGRlZmF1bHRGbnMgQXJyYXkgdG8gY29sbGVjdCBkZWZhdWx0IGxpc3RlbmVycyBpbiwgaW5zdGVhZFxuICogICAgIG9mIHJ1bm5pbmcgdGhlbS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IEZhbHNlIGlmIGF0IGxlYXN0IG9uZSBvZiB0aGUgdHJpZ2dlcmVkIGNhbGxiYWNrcyByZXR1cm5zXG4gKiAgICAgZmFsc2UsIG9yIHRydWUgb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckVsZW1lbnRMaXN0ZW5lcnNfKGVsZW1lbnQsIGV2ZW50LCBkZWZhdWx0Rm5zKSB7XG5cdHZhciBsYXN0Q29udGFpbmVyID0gZXZlbnRbTEFTVF9DT05UQUlORVJdO1xuXHRpZiAoISgwLCBfbWV0YWwuaXNEZWYpKGxhc3RDb250YWluZXIpIHx8ICFjb250YWlucyhsYXN0Q29udGFpbmVyLCBlbGVtZW50KSkge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBfZG9tRGF0YTIuZGVmYXVsdC5nZXQoZWxlbWVudCwgJ2xpc3RlbmVycycsIHt9KVtldmVudC50eXBlXTtcblx0XHRyZXR1cm4gdHJpZ2dlckxpc3RlbmVyc18obGlzdGVuZXJzLCBldmVudCwgZWxlbWVudCwgZGVmYXVsdEZucyk7XG5cdH1cblx0cmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgdGhlIHNwZWNpZmllZCBldmVudCBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAqIE5PVEU6IFRoaXMgc2hvdWxkIG1vc3RseSBiZSB1c2VkIGZvciB0ZXN0aW5nLCBub3Qgb24gcmVhbCBjb2RlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCBUaGUgbm9kZSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJlIHRyaWdncmVkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZXZlbnRPYmogQW4gb2JqZWN0IHdpdGggZGF0YSB0aGF0IHNob3VsZCBiZSBvbiB0aGVcbiAqICAgdHJpZ2dlcmVkIGV2ZW50J3MgcGF5bG9hZC5cbiAqL1xuZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGVsZW1lbnQsIGV2ZW50TmFtZSwgb3B0X2V2ZW50T2JqKSB7XG5cdGlmIChpc0FibGVUb0ludGVyYWN0V2l0aF8oZWxlbWVudCwgZXZlbnROYW1lLCBvcHRfZXZlbnRPYmopKSB7XG5cdFx0dmFyIGV2ZW50T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0XHRldmVudE9iai5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlKTtcblx0XHRfbWV0YWwub2JqZWN0Lm1peGluKGV2ZW50T2JqLCBvcHRfZXZlbnRPYmopO1xuXHRcdGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudE9iaik7XG5cdH1cbn1cblxuLyoqXG4gKiBUcmlnZ2VycyB0aGUgZ2l2ZW4gbGlzdGVuZXJzIGFycmF5LlxuICogQHBhcmFtIHtBcnJheTwhZnVuY3Rpb24oKT59IGxpc3RlbmVyc1xuICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geyFBcnJheX0gZGVmYXVsdEZucyBBcnJheSB0byBjb2xsZWN0IGRlZmF1bHQgbGlzdGVuZXJzIGluLCBpbnN0ZWFkXG4gKiAgICAgb2YgcnVubmluZyB0aGVtLlxuICogQHJldHVybiB7Ym9vbGVhbn0gRmFsc2UgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB0cmlnZ2VyZWQgY2FsbGJhY2tzIHJldHVybnNcbiAqICAgICBmYWxzZSwgb3IgdHJ1ZSBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyTGlzdGVuZXJzXyhsaXN0ZW5lcnMsIGV2ZW50LCBlbGVtZW50LCBkZWZhdWx0Rm5zKSB7XG5cdHZhciByZXQgPSB0cnVlO1xuXHRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgW107XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aCAmJiAhZXZlbnQuc3RvcHBlZEltbWVkaWF0ZTsgaSsrKSB7XG5cdFx0aWYgKGxpc3RlbmVyc1tpXS5kZWZhdWx0TGlzdGVuZXJfKSB7XG5cdFx0XHRkZWZhdWx0Rm5zLnB1c2goe1xuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRmbjogbGlzdGVuZXJzW2ldXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0ICY9IGxpc3RlbmVyc1tpXShldmVudCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVHJpZ2dlcnMgYWxsIHNlbGVjdG9yIGxpc3RlbmVycyBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICogQHBhcmFtIHshRWxlbWVudH0gY29udGFpbmVyXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7IUFycmF5fSBkZWZhdWx0Rm5zIEFycmF5IHRvIGNvbGxlY3QgZGVmYXVsdCBsaXN0ZW5lcnMgaW4sIGluc3RlYWRcbiAqICAgICBvZiBydW5uaW5nIHRoZW0uXG4gKiBAcmV0dXJuIHtib29sZWFufSBGYWxzZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRyaWdnZXJlZCBjYWxsYmFja3MgcmV0dXJuc1xuICogICAgIGZhbHNlLCBvciB0cnVlIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJTZWxlY3Rvckxpc3RlbmVyc18oY29udGFpbmVyLCBlbGVtZW50LCBldmVudCwgZGVmYXVsdEZucykge1xuXHR2YXIgcmV0ID0gdHJ1ZTtcblx0dmFyIGRhdGEgPSBfZG9tRGF0YTIuZGVmYXVsdC5nZXQoY29udGFpbmVyLCAnZGVsZWdhdGluZycsIHt9KTtcblx0dmFyIG1hcCA9IGRhdGFbZXZlbnQudHlwZV0uc2VsZWN0b3JzO1xuXHR2YXIgc2VsZWN0b3JzID0gT2JqZWN0LmtleXMobWFwKTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RvcnMubGVuZ3RoICYmICFldmVudC5zdG9wcGVkSW1tZWRpYXRlOyBpKyspIHtcblx0XHRpZiAobWF0Y2goZWxlbWVudCwgc2VsZWN0b3JzW2ldKSkge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IG1hcFtzZWxlY3RvcnNbaV1dO1xuXHRcdFx0cmV0ICY9IHRyaWdnZXJMaXN0ZW5lcnNfKGxpc3RlbmVycywgZXZlbnQsIGVsZW1lbnQsIGRlZmF1bHRGbnMpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9saWIvZG9tTmFtZWQuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5hYnN0cmFjdE1ldGhvZCA9IGFic3RyYWN0TWV0aG9kO1xuZXhwb3J0cy5kaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmVuYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSA9IGdldENvbXBhdGliaWxpdHlNb2RlRGF0YTtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuZXhwb3J0cy5nZXRTdGF0aWNQcm9wZXJ0eSA9IGdldFN0YXRpY1Byb3BlcnR5O1xuZXhwb3J0cy5nZXRVaWQgPSBnZXRVaWQ7XG5leHBvcnRzLmlkZW50aXR5RnVuY3Rpb24gPSBpZGVudGl0eUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzRGVmID0gaXNEZWY7XG5leHBvcnRzLmlzRGVmQW5kTm90TnVsbCA9IGlzRGVmQW5kTm90TnVsbDtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzRG9jdW1lbnRGcmFnbWVudCA9IGlzRG9jdW1lbnRGcmFnbWVudDtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc1dpbmRvdyA9IGlzV2luZG93O1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzU2VydmVyU2lkZSA9IGlzU2VydmVyU2lkZTtcbmV4cG9ydHMubnVsbEZ1bmN0aW9uID0gbnVsbEZ1bmN0aW9uO1xudmFyIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB2b2lkIDA7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xudmFyIFVJRF9QUk9QRVJUWSA9IGV4cG9ydHMuVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBhYnN0cmFjdE1ldGhvZCgpIHtcbiAgdGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBFbmFibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlIHdpdGggdGhlIGZvbGxvd2luZyBmZWF0dXJlcyBmcm9tIHJjXG4gKiBhbmQgMS54IHZlcnNpb25zOlxuICogICAgIC0gVXNpbmcgXCJrZXlcIiB0byByZWZlcmVuY2UgY29tcG9uZW50IGluc3RhbmNlcy4gSW4gdGhlIGN1cnJlbnQgdmVyc2lvblxuICogICAgICAgdGhpcyBzaG91bGQgYmUgZG9uZSB2aWEgXCJyZWZcIiBpbnN0ZWFkLiBUaGlzIGFsbG93cyBvbGQgY29kZSBzdGlsbFxuICogICAgICAgdXNpbmcgXCJrZXlcIiB0byBrZWVwIHdvcmtpbmcgbGlrZSBiZWZvcmUuIE5PVEU6IHRoaXMgbWF5IGNhdXNlXG4gKiAgICAgICBwcm9ibGVtcywgc2luY2UgXCJrZXlcIiBpcyBtZWFudCB0byBiZSB1c2VkIGRpZmZlcmVudGx5LiBPbmx5IHVzZSB0aGlzXG4gKiAgICAgICBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byB1cGdyYWRlIHRoZSBjb2RlIHRvIHVzZSBcInJlZlwiIGluc3RlYWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9kYXRhIE9wdGlvbmFsIG9iamVjdCB3aXRoIGRhdGEgdG8gc3BlY2lmeSBtb3JlXG4gKiAgICAgZGV0YWlscywgc3VjaCBhczpcbiAqICAgICAgICAgLSByZW5kZXJlcnMge0FycmF5fSB0aGUgdGVtcGxhdGUgcmVuZGVyZXJzIHRoYXQgc2hvdWxkIGJlIGluXG4gKiAgICAgICAgICAgY29tcGF0aWJpbGl0eSBtb2RlLCBlaXRoZXIgdGhlaXIgY29uc3RydWN0b3JzIG9yIHN0cmluZ3NcbiAqICAgICAgICAgICByZXByZXNlbnRpbmcgdGhlbSAoZS5nLiAnc295JyBvciAnanN4JykuIEJ5IGRlZmF1bHQsIGFsbCB0aGUgb25lc1xuICogICAgICAgICAgIHRoYXQgZXh0ZW5kIGZyb20gSW5jcmVtZW50YWxEb21SZW5kZXJlci5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICB2YXIgb3B0X2RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBvcHRfZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHVzZWQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZSwgb3Igbm90aGluZyBpZiBpdCBoYXNuJ3QgYmVlblxuICogZW5hYmxlZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuICAvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG4gIGlmIChjb21wYXRpYmlsaXR5TW9kZURhdGFfID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKSB7XG4gICAgICBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSh3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcGF0aWJpbGl0eU1vZGVEYXRhXztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCdzIHRydXRoeSwgb3IgdGhlIHNlY29uZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RUcnV0aHlfKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkb2Vzbid0XG4gKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICogY29udGVudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKCFmbi5uYW1lKSB7XG4gICAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG4gIH1cbiAgcmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgcHJvcGVydHkgaW4gdGhlIGdpdmVuIGNsYXNzLiBUaGUgdmFsdWUgd2lsbCBiZVxuICogaW5oZXJpdGVkIGZyb20gYW5jZXN0b3JzIGFzIGV4cGVjdGVkLCB1bmxlc3MgYSBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gaXMgZ2l2ZW4sXG4gKiB3aGljaCBjYW4gY2hhbmdlIGhvdyB0aGUgc3VwZXIgY2xhc3NlcycgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkgd2lsbCBiZSBtZXJnZWRcbiAqIHRvZ2V0aGVyLlxuICogVGhlIGZpbmFsIG1lcmdlZCB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBpbiBhbm90aGVyIHByb3BlcnR5LCBzbyB0aGF0IGl0IHdvbid0XG4gKiBiZSByZWNhbGN1bGF0ZWQgZXZlbiBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbWVyZ2VkXG4gKiAgICAgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHNvIGZhciBhbmQgdGhlIG5leHQgdmFsdWUgdG8gYmUgbWVyZ2VkIHRvIGl0LlxuICogICAgIFNob3VsZCByZXR1cm4gdGhlc2UgdHdvIG1lcmdlZCB0b2dldGhlci4gSWYgbm90IHBhc3NlZCB0aGUgZmluYWwgcHJvcGVydHlcbiAqICAgICB3aWxsIGJlIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgYW1vbmcgYW5jZXN0b3JzLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG4gIHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuICBpZiAoIWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcbiAgICB2YXIgbWVyZ2VkID0gY3Rvci5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpID8gY3Rvcltwcm9wZXJ0eU5hbWVdIDogbnVsbDtcbiAgICBpZiAoY3Rvci5fX3Byb3RvX18gJiYgIWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG4gICAgICB2YXIgbWVyZ2VGbiA9IG9wdF9tZXJnZUZuIHx8IGdldEZpcnN0VHJ1dGh5XztcbiAgICAgIG1lcmdlZCA9IG1lcmdlRm4obWVyZ2VkLCBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLl9fcHJvdG9fXywgcHJvcGVydHlOYW1lLCBtZXJnZUZuKSk7XG4gICAgfVxuICAgIGN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG4gIH1cbiAgcmV0dXJuIGN0b3JbbWVyZ2VkTmFtZV07XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcbiAgaWYgKG9wdF9vYmplY3QpIHtcbiAgICB2YXIgaWQgPSBvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV07XG4gICAgaWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KFVJRF9QUk9QRVJUWSkpIHtcbiAgICAgIGlkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV0gPSB1bmlxdWVJZENvdW50ZXJfKyspO1xuICB9XG4gIHJldHVybiB1bmlxdWVJZENvdW50ZXJfKys7XG59XG5cbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF9yZXR1cm5WYWx1ZSBUaGUgc2luZ2xlIHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcbiAgcmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRGVmKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG4gIHJldHVybiBpc0RlZih2YWwpICYmICFpc051bGwodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LWZyYWdtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3codmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsID09PSB2YWwud2luZG93O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBhcnJheXNcbiAqIGFuZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogU2V0cyB0byB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aCBleHRyYSBjaGVjayBmb3JcbiAqIGBwcm9jZXNzLmJyb3dzZXJgIHRvIHNraXAgS2FybWEgcnVubmVyIGVudmlyb25tZW50LiBLYXJtYSBlbnZpcm9ubWVudCBoYXNcbiAqIGBwcm9jZXNzYCBkZWZpbmVkIGV2ZW4gdGhvdWdoIGl0IHJ1bnMgb24gdGhlIGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmICFwcm9jZXNzLmJyb3dzZXI7XG59XG5cbi8qKlxuICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBhcnJheSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgYXJyYXkpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGFycmF5LCBudWxsLCBbe1xuXHRcdGtleTogJ2VxdWFsJyxcblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIxXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBlcXVhbChhcnIxLCBhcnIyKSB7XG5cdFx0XHRpZiAoYXJyMSA9PT0gYXJyMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgaXNuJ3QgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0geyFBcnJheX0gYXJyXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmaXJzdERlZmluZWRWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKGFycikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFycltpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dCBuZXN0ZWQgYXJyYXkgdG8gYmVjb21lIGZsYXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPCp8QXJyYXkuPCo+Pn0gYXJyIE5lc3RlZCBhcnJheSB0byBmbGF0dGVuLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gb3B0X291dHB1dCBPcHRpb25hbCBvdXRwdXQgYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5LjwqPn0gRmxhdCBhcnJheS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZsYXR0ZW4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmbGF0dGVuKGFyciwgb3B0X291dHB1dCkge1xuXHRcdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG5cdFx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG5cdFx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0XHR2YXIgcnYgPSB2b2lkIDA7XG5cdFx0XHRpZiAocnYgPSBpID49IDApIHtcblx0XHRcdFx0YXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBydjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIEFycmF5IG9yIGFycmF5IGxpa2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVBdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcnIsIGksIDEpLmxlbmd0aCA9PT0gMTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcbiAgICogaXMgZmFzdGVyIGFuZCB3b3JraW5nIG9uIGFsbCBhcnJheS1saWtlIG9iamVjdHMgKGxpa2UgYXJndW1lbnRzKS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIGluZGV4IHdoZXJlIHRoZSBzbGljZSBzaG91bGQgZW5kLCBub3RcbiAgICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuICAgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NsaWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdFx0dmFyIGVuZCA9ICgwLCBfY29yZS5pc0RlZikob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRcdHNsaWNlZC5wdXNoKGFycltpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2xpY2VkO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBhcnJheTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXJyYXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xudmFyIGFzeW5jID0ge307XG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgZXhjZXB0aW9uO1xuXHR9KTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfHVuZGVmaW5lZH0gc2NvcGVcbiAqL1xuYXN5bmMucnVuLldvcmtJdGVtXyA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHR2YXIgY2IgPSBjYWxsYmFjaztcblx0aWYgKG9wdF9jb250ZXh0KSB7XG5cdFx0Y2IgPSBjYWxsYmFjay5iaW5kKG9wdF9jb250ZXh0KTtcblx0fVxuXHRjYiA9IGFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18oY2IpO1xuXHQvLyBJbnRyb2R1Y2VkIGFuZCBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSUUxMC5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IpO1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBMb29rIGZvciBhbmQgY2FjaGUgdGhlIGN1c3RvbSBmYWxsYmFjayB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZS5cblx0aWYgKCFhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKSB7XG5cdFx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IGFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXygpO1xuXHR9XG5cdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8oY2IpO1xufTtcblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gQ3JlYXRlIGEgcHJpdmF0ZSBtZXNzYWdlIGNoYW5uZWwgYW5kIHVzZSBpdCB0byBwb3N0TWVzc2FnZSBlbXB0eSBtZXNzYWdlc1xuXHQvLyB0byBvdXJzZWx2ZXMuXG5cdHZhciBDaGFubmVsID0gdm9pZCAwO1xuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRDaGFubmVsID0gTWVzc2FnZUNoYW5uZWw7XG5cdH1cblxuXHQvLyBJZiBNZXNzYWdlQ2hhbm5lbCBpcyBub3QgYXZhaWxhYmxlIGFuZCB3ZSBhcmUgaW4gYSBicm93c2VyLCBpbXBsZW1lbnRcblx0Ly8gYW4gaWZyYW1lIGJhc2VkIHBvbHlmaWxsIGluIGJyb3dzZXJzIHRoYXQgaGF2ZSBwb3N0TWVzc2FnZSBhbmRcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci4gVGhlIGxhdHRlciBleGNsdWRlcyBJRTggYmVjYXVzZSBpdCBoYXMgYVxuXHQvLyBzeW5jaHJvbm91cyBwb3N0TWVzc2FnZSBpbXBsZW1lbnRhdGlvbi5cblx0aWYgKHR5cGVvZiBDaGFubmVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uIENoYW5uZWwoKSB7XG5cdFx0XHQvLyBNYWtlIGFuIGVtcHR5LCBpbnZpc2libGUgaWZyYW1lLlxuXHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gJyc7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcblx0XHRcdHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cdFx0XHRkb2Mub3BlbigpO1xuXHRcdFx0ZG9jLndyaXRlKCcnKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSAnY2FsbEltbWVkaWF0ZScgKyBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dmFyIG9yaWdpbiA9IHdpbi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW4ubG9jYXRpb24uaG9zdDtcblx0XHRcdHZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSgpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHRhaWwubmV4dCA9IHtcblx0XHRcdFx0Y2I6IGNiXG5cdFx0XHR9O1xuXHRcdFx0dGFpbCA9IHRhaWwubmV4dDtcblx0XHRcdGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fVxuXHQvLyBJbXBsZW1lbnRhdGlvbiBmb3IgSUU2LTg6IFNjcmlwdCBlbGVtZW50cyBmaXJlIGFuIGFzeW5jaHJvbm91c1xuXHQvLyBvbnJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG5cdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXAgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxuXHRcdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0Y2IgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdH07XG5cdH1cblx0Ly8gRmFsbCBiYWNrIHRvIHNldFRpbWVvdXQgd2l0aCAwLiBJbiBicm93c2VycyB0aGlzIGNyZWF0ZXMgYSBkZWxheSBvZiA1bXNcblx0Ly8gb3IgbW9yZS5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbiAob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhc3luYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBEaXNwb3NhYmxlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuXHRcdC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG4gICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLiBDYWxscyBgZGlzcG9zZUludGVybmFsYC5cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEaXNwb3NhYmxlLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0aWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcbiAgICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG4gICAqIGRpc3Bvc2FibGVzKS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRGlzcG9zZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcG9zZWRfO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEaXNwb3NhYmxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwb3NhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBvYmplY3QoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIG9iamVjdCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Mob2JqZWN0LCBudWxsLCBbe1xuXHRcdGtleTogJ21peGluJyxcblxuXHRcdC8qKlxuICAgKiBDb3BpZXMgYWxsIHRoZSBtZW1iZXJzIG9mIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIFRoZSBvYmplY3RzIGZyb20gd2hpY2ggdmFsdWVzIHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG5cdFx0XHR2YXIga2V5ID0gdm9pZCAwLFxuXHRcdFx0ICAgIHNvdXJjZSA9IHZvaWQgMDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gICAqICAgICA8Y29kZT53aW5kb3c8L2NvZGU+LlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgdmFsdWUgKG9iamVjdCBvciBwcmltaXRpdmUpIG9yLCBpZiBub3QgZm91bmQsIHVuZGVmaW5lZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE9iamVjdEJ5TmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHRcdHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcblx0XHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnQsIGtleSkge1xuXHRcdFx0XHRyZXR1cm4gcGFydFtrZXldO1xuXHRcdFx0fSwgc2NvcGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcbiAgICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0XHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcHBlZE9iajtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG4gICAqIGNoZWNrLCBpbmNsdWRpbmcgb25seSB0aGUga2V5cyBkaXJlY3RseSBjb250YWluZWQgYnkgdGhlIDIgb2JqZWN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NoYWxsb3dFcXVhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmoxLCBvYmoyKSB7XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRcdGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIG9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gc3RyaW5nKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdHJpbmcpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKHN0cmluZywgbnVsbCwgW3tcblx0XHRrZXk6ICdjYXNlSW5zZW5zaXRpdmVDb21wYXJlJyxcblxuXHRcdC8qKlxuICAgKiBDb21wYXJlcyB0aGUgZ2l2ZW4gc3RyaW5ncyB3aXRob3V0IHRha2luZyB0aGUgY2FzZSBpbnRvIGFjY291bnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjJcbiAgICogQHJldHVybiB7bnVtYmVyfSBFaXRoZXIgLTEsIDAgb3IgMSwgYWNjb3JkaW5nIHRvIGlmIHRoZSBmaXJzdCBzdHJpbmcgaXNcbiAgICogICAgIFwic21hbGxlclwiLCBlcXVhbCBvciBcImJpZ2dlclwiIHRoYW4gdGhlIHNlY29uZCBnaXZlbiBzdHJpbmcuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYXNlSW5zZW5zaXRpdmVDb21wYXJlKHN0cjEsIHN0cjIpIHtcblx0XHRcdHZhciB0ZXN0MSA9IFN0cmluZyhzdHIxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIHRlc3QyID0gU3RyaW5nKHN0cjIpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICh0ZXN0MSA8IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0gZWxzZSBpZiAodGVzdDEgPT09IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuICAgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gICAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb2xsYXBzZUJyZWFraW5nU3BhY2VzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG4gICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcbiAgKiAgICAgdG8gb25lLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZXNjYXBlUmVnZXgnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy0oKVxcW1xcXXt9Kz8qLiRcXF58LDojPCFcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJhbmRvbVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcbiAgICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2VcbiAgICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG4gICAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cbiAgICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNoQ29kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc2hDb2RlKHZhbCkge1xuXHRcdFx0dmFyIGhhc2ggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG4gICAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VJbnRlcnZhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gc3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9kb21EYXRhID0gcmVxdWlyZSgnLi9kb21EYXRhJyk7XG5cbnZhciBfZG9tRGF0YTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kb21EYXRhKTtcblxudmFyIF9tZXRhbEV2ZW50cyA9IHJlcXVpcmUoJ21ldGFsLWV2ZW50cycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogVGhpcyBpcyBhIHNwZWNpYWwgRXZlbnRIYW5kbGUsIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIGRvbSBkZWxlZ2F0ZWQgZXZlbnRzXG4gKiAob25seSB0aGUgb25lcyB0aGF0IHJlY2VpdmUgYSB0YXJnZXQgZWxlbWVudCwgbm90IGEgc2VsZWN0b3Igc3RyaW5nKS5cbiAqIEBleHRlbmRzIHtFdmVudEhhbmRsZX1cbiAqL1xudmFyIERvbURlbGVnYXRlZEV2ZW50SGFuZGxlID0gZnVuY3Rpb24gKF9FdmVudEhhbmRsZSkge1xuXHRfaW5oZXJpdHMoRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUsIF9FdmVudEhhbmRsZSk7XG5cblx0LyoqXG4gICogVGhlIGNvbnN0cnVjdG9yIGZvciBgRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGVgLlxuICAqIEBwYXJhbSB7IUV2ZW50fSBlbWl0dGVyIEVsZW1lbnQgdGhlIGV2ZW50IHdhcyBzdWJzY3JpYmVkIHRvLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdGhhdCB3YXMgc3Vic2NyaWJlZCB0by5cbiAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIHN1YnNjcmliZWQgdG8gdGhlIGV2ZW50LlxuICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3NlbGVjdG9yIEFuIG9wdGlvbmFsIHNlbGVjdG9yIHVzZWQgd2hlbiBkZWxlZ2F0aW5nXG4gICogICAgIHRoZSBldmVudC5cbiAgKiBAY29uc3RydWN0b3JcbiAgKi9cblx0ZnVuY3Rpb24gRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUoZW1pdHRlciwgZXZlbnQsIGxpc3RlbmVyLCBvcHRfc2VsZWN0b3IpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUpO1xuXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERvbURlbGVnYXRlZEV2ZW50SGFuZGxlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUpKS5jYWxsKHRoaXMsIGVtaXR0ZXIsIGV2ZW50LCBsaXN0ZW5lcikpO1xuXG5cdFx0X3RoaXMuc2VsZWN0b3JfID0gb3B0X3NlbGVjdG9yO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIEBpbmhlcml0RG9jXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGUsIFt7XG5cdFx0a2V5OiAncmVtb3ZlTGlzdGVuZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcblx0XHRcdHZhciBkZWxlZ2F0aW5nID0gX2RvbURhdGEyLmRlZmF1bHQuZ2V0KHRoaXMuZW1pdHRlcl8sICdkZWxlZ2F0aW5nJywge30pO1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IF9kb21EYXRhMi5kZWZhdWx0LmdldCh0aGlzLmVtaXR0ZXJfLCAnbGlzdGVuZXJzJywge30pO1xuXHRcdFx0dmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvcl87XG5cdFx0XHR2YXIgYXJyID0gKDAsIF9tZXRhbC5pc1N0cmluZykoc2VsZWN0b3IpID8gZGVsZWdhdGluZ1t0aGlzLmV2ZW50X10uc2VsZWN0b3JzIDogbGlzdGVuZXJzO1xuXHRcdFx0dmFyIGtleSA9ICgwLCBfbWV0YWwuaXNTdHJpbmcpKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogdGhpcy5ldmVudF87XG5cblx0XHRcdF9tZXRhbC5hcnJheS5yZW1vdmUoYXJyW2tleV0gfHwgW10sIHRoaXMubGlzdGVuZXJfKTtcblx0XHRcdGlmIChhcnJba2V5XSAmJiBhcnJba2V5XS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0ZGVsZXRlIGFycltrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEb21EZWxlZ2F0ZWRFdmVudEhhbmRsZTtcbn0oX21ldGFsRXZlbnRzLkV2ZW50SGFuZGxlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRG9tRGVsZWdhdGVkRXZlbnRIYW5kbGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9Eb21EZWxlZ2F0ZWRFdmVudEhhbmRsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9FdmVudEhhbmRsZSA9IHJlcXVpcmUoJy4vRXZlbnRIYW5kbGUnKTtcblxudmFyIF9FdmVudEhhbmRsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9FdmVudEhhbmRsZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIHNpbmdsZUFycmF5XyA9IFswXTtcblxuLyoqXG4gKiBFdmVudEVtaXR0ZXIgdXRpbGl0eS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Rpc3Bvc2FibGV9XG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uIChfRGlzcG9zYWJsZSkge1xuXHRfaW5oZXJpdHMoRXZlbnRFbWl0dGVyLCBfRGlzcG9zYWJsZSk7XG5cblx0ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuXG5cdFx0LyoqXG4gICAqIEhvbGRzIGV2ZW50IGxpc3RlbmVycyBzY29wZWQgYnkgZXZlbnQgdHlwZS5cbiAgICogQHR5cGUge09iamVjdDxzdHJpbmcsICFBcnJheTwhZnVuY3Rpb24oKT4+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChFdmVudEVtaXR0ZXIuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFdmVudEVtaXR0ZXIpKS5jYWxsKHRoaXMpKTtcblxuXHRcdF90aGlzLmV2ZW50c18gPSBudWxsO1xuXG5cdFx0LyoqXG4gICAqIEhhbmRsZXJzIHRoYXQgYXJlIHRyaWdnZXJlZCB3aGVuIGFuIGV2ZW50IGlzIGxpc3RlbmVkIHRvLlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqL1xuXHRcdF90aGlzLmxpc3RlbmVySGFuZGxlcnNfID0gbnVsbDtcblxuXHRcdC8qKlxuICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbiB3aGljaCBkZXRlcm1pbmVzIGlmIGFuIGV2ZW50IGZhY2FkZSBzaG91bGQgYmUgc2VudFxuICAgKiBhcyBhIHBhcmFtIG9mIGxpc3RlbmVycyB3aGVuIGVtaXR0aW5nIGV2ZW50cy4gSWYgc2V0IHRvIHRydWUsIHRoZSBmYWNhZGVcbiAgICogd2lsbCBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBsaXN0ZW5lci5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMuc2hvdWxkVXNlRmFjYWRlXyA9IGZhbHNlO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIEFkZHMgYSBoYW5kbGVyIHRvIGdpdmVuIGhvbGRlciB2YXJpYWJsZS4gSWYgdGhlIGhvbGRlciBkb2Vzbid0IGhhdmUgYVxuICAqIHZhbHVlIHlldCwgaXQgd2lsbCByZWNlaXZlIHRoZSBoYW5kbGVyIGRpcmVjdGx5LiBJZiB0aGUgaG9sZGVyIGlzIGFuIGFycmF5LFxuICAqIHRoZSB2YWx1ZSB3aWxsIGp1c3QgYmUgYWRkZWQgdG8gaXQuIE90aGVyd2lzZSwgdGhlIGhvbGRlciB3aWxsIGJlIHNldCB0byBhXG4gICogbmV3IGFycmF5IGNvbnRhaW5pbmcgaXRzIHByZXZpb3VzIHZhbHVlIHBsdXMgdGhlIG5ldyBoYW5kbGVyLlxuICAqIEBwYXJhbSB7Kn0gaG9sZGVyXG4gICogQHBhcmFtIHshZnVuY3Rpb24oKXxPYmplY3R9IGhhbmRsZXJcbiAgKiBAcmV0dXJuIHsqfSBUaGUgaG9sZGVyJ3MgbmV3IHZhbHVlLlxuICAqIEBwcm90ZWN0ZWRcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhFdmVudEVtaXR0ZXIsIFt7XG5cdFx0a2V5OiAnYWRkSGFuZGxlcl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRIYW5kbGVyXyhob2xkZXIsIGhhbmRsZXIpIHtcblx0XHRcdGlmICghaG9sZGVyKSB7XG5cdFx0XHRcdGhvbGRlciA9IGhhbmRsZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoaG9sZGVyKSkge1xuXHRcdFx0XHRcdGhvbGRlciA9IFtob2xkZXJdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvbGRlci5wdXNoKGhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhvbGRlcjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RlbmVycyBhcnJheSBmb3IgdGhlIHNwZWNpZmllZCBldmVudHMuXG4gICAqIEBwYXJhbSB7IShBcnJheXxzdHJpbmcpfSBldmVudFxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRfZGVmYXVsdCBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBsaXN0ZW5lciBpcyBhIGRlZmF1bHRcbiAgICogICBhY3Rpb24gZm9yIHRoaXMgZXZlbnQuIERlZmF1bHQgYWN0aW9ucyBhcmUgcnVuIGxhc3QsIGFuZCBvbmx5IGlmIG5vIHByZXZpb3VzXG4gICAqICAgbGlzdGVuZXIgY2FsbCBgcHJldmVudERlZmF1bHQoKWAgb24gdGhlIHJlY2VpdmVkIGV2ZW50IGZhY2FkZS5cbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYWRkTGlzdGVuZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIG9wdF9kZWZhdWx0KSB7XG5cdFx0XHR0aGlzLnZhbGlkYXRlTGlzdGVuZXJfKGxpc3RlbmVyKTtcblxuXHRcdFx0dmFyIGV2ZW50cyA9IHRoaXMudG9FdmVudHNBcnJheV8oZXZlbnQpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5hZGRTaW5nbGVMaXN0ZW5lcl8oZXZlbnRzW2ldLCBsaXN0ZW5lciwgb3B0X2RlZmF1bHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbmV3IF9FdmVudEhhbmRsZTIuZGVmYXVsdCh0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciBhIHNpbmdsZSBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF9kZWZhdWx0IEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGxpc3RlbmVyIGlzIGEgZGVmYXVsdFxuICAgKiAgIGFjdGlvbiBmb3IgdGhpcyBldmVudC4gRGVmYXVsdCBhY3Rpb25zIGFyZSBydW4gbGFzdCwgYW5kIG9ubHkgaWYgbm8gcHJldmlvdXNcbiAgICogICBsaXN0ZW5lciBjYWxsIGBwcmV2ZW50RGVmYXVsdCgpYCBvbiB0aGUgcmVjZWl2ZWQgZXZlbnQgZmFjYWRlLlxuICAgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IENhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRfb3JpZ2luIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiB0aGF0IHdhcyBhZGRlZCBhcyBhXG4gICAqICAgbGlzdGVuZXIsIGlmIHRoZXJlIGlzIGFueS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYWRkU2luZ2xlTGlzdGVuZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkU2luZ2xlTGlzdGVuZXJfKGV2ZW50LCBsaXN0ZW5lciwgb3B0X2RlZmF1bHQsIG9wdF9vcmlnaW4pIHtcblx0XHRcdHRoaXMucnVuTGlzdGVuZXJIYW5kbGVyc18oZXZlbnQpO1xuXHRcdFx0aWYgKG9wdF9kZWZhdWx0IHx8IG9wdF9vcmlnaW4pIHtcblx0XHRcdFx0bGlzdGVuZXIgPSB7XG5cdFx0XHRcdFx0ZGVmYXVsdDogb3B0X2RlZmF1bHQsXG5cdFx0XHRcdFx0Zm46IGxpc3RlbmVyLFxuXHRcdFx0XHRcdG9yaWdpbjogb3B0X29yaWdpblxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ldmVudHNfID0gdGhpcy5ldmVudHNfIHx8IHt9O1xuXHRcdFx0dGhpcy5ldmVudHNfW2V2ZW50XSA9IHRoaXMuYWRkSGFuZGxlcl8odGhpcy5ldmVudHNfW2V2ZW50XSwgbGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBCdWlsZHMgZmFjYWRlIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2J1aWxkRmFjYWRlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRmFjYWRlXyhldmVudCkge1xuXHRcdFx0aWYgKHRoaXMuZ2V0U2hvdWxkVXNlRmFjYWRlKCkpIHtcblx0XHRcdFx0dmFyIGZhY2FkZSA9IHtcblx0XHRcdFx0XHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XG5cdFx0XHRcdFx0XHRmYWNhZGUucHJldmVudGVkRGVmYXVsdCA9IHRydWU7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR0YXJnZXQ6IHRoaXMsXG5cdFx0XHRcdFx0dHlwZTogZXZlbnRcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIGZhY2FkZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHRcdHRoaXMuZXZlbnRzXyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEV4ZWN1dGUgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIGluIG9yZGVyIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7Kn0gb3B0X2FyZ3MgW2FyZzFdLCBbYXJnMl0sIFsuLi5dXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBldmVudCBoYWQgbGlzdGVuZXJzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlbWl0Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCkge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0UmF3TGlzdGVuZXJzXyhldmVudCk7XG5cdFx0XHRpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBhcmdzID0gX21ldGFsLmFycmF5LnNsaWNlKGFyZ3VtZW50cywgMSk7XG5cdFx0XHR0aGlzLnJ1bkxpc3RlbmVyc18obGlzdGVuZXJzLCBhcmdzLCB0aGlzLmJ1aWxkRmFjYWRlXyhldmVudCkpO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGxpc3RlbmVyIG9iamVjdHMgZm9yIHRoZSBnaXZlbiBldmVudCwgaWYgdGhlcmUgYXJlIGFueS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0UmF3TGlzdGVuZXJzXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJhd0xpc3RlbmVyc18oZXZlbnQpIHtcblx0XHRcdHZhciBkaXJlY3RMaXN0ZW5lcnMgPSB0b0FycmF5KHRoaXMuZXZlbnRzXyAmJiB0aGlzLmV2ZW50c19bZXZlbnRdKTtcblx0XHRcdHJldHVybiBkaXJlY3RMaXN0ZW5lcnMuY29uY2F0KHRvQXJyYXkodGhpcy5ldmVudHNfICYmIHRoaXMuZXZlbnRzX1snKiddKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHdoaWNoIGRldGVybWluZXMgaWYgYW4gZXZlbnQgZmFjYWRlIHNob3VsZFxuICAgKiBiZSBzZW50IGFzIGEgcGFyYW0gb2YgbGlzdGVuZXJzIHdoZW4gZW1pdHRpbmcgZXZlbnRzLiBJZiBzZXQgdG8gdHJ1ZSwgdGhlXG4gICAqIGZhY2FkZSB3aWxsIGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U2hvdWxkVXNlRmFjYWRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U2hvdWxkVXNlRmFjYWRlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuc2hvdWxkVXNlRmFjYWRlXztcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgbGlzdGVuZXJzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbGlzdGVuZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRSYXdMaXN0ZW5lcnNfKGV2ZW50KS5tYXAoZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0ZW5lci5mbiA/IGxpc3RlbmVyLmZuIDogbGlzdGVuZXI7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgZml4ZWQgbnVtYmVyIG9mIHRpbWVzIGZvciB0aGVcbiAgICogZXZlbnRzLiBBZnRlciBlYWNoIGV2ZW50IGlzIHRyaWdnZXJlZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lcywgdGhlXG4gICAqIGxpc3RlbmVyIGlzIHJlbW92ZWQgZm9yIGl0LlxuICAgKiBAcGFyYW0geyEoQXJyYXl8c3RyaW5nKX0gZXZlbnRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCBUaGUgYW1vdW50IG9mIHRpbWVzIHRoaXMgZXZlbnQgc2hvdWxkIGJlIGxpc3RlbmVkXG4gICAqIHRvLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFueScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hbnkoZXZlbnQsIGFtb3VudCwgbGlzdGVuZXIpIHtcblx0XHRcdHZhciBldmVudHMgPSB0aGlzLnRvRXZlbnRzQXJyYXlfKGV2ZW50KTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMubWFueV8oZXZlbnRzW2ldLCBhbW91bnQsIGxpc3RlbmVyKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG5ldyBfRXZlbnRIYW5kbGUyLmRlZmF1bHQodGhpcywgZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgZml4ZWQgbnVtYmVyIG9mIHRpbWVzIGZvciBhIHNpbmdsZVxuICAgKiBldmVudC4gQWZ0ZXIgdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lcywgdGhlXG4gICAqIGxpc3RlbmVyIGlzIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgdGltZXMgdGhpcyBldmVudCBzaG91bGQgYmUgbGlzdGVuZWRcbiAgICogdG8uXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdtYW55XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hbnlfKGV2ZW50LCBhbW91bnQsIGxpc3RlbmVyKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRcdGlmIChhbW91bnQgPD0gMCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGhhbmRsZXJJbnRlcm5hbCgpIHtcblx0XHRcdFx0aWYgKC0tYW1vdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0c2VsZi5yZW1vdmVMaXN0ZW5lcihldmVudCwgaGFuZGxlckludGVybmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0ZW5lci5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxmLmFkZFNpbmdsZUxpc3RlbmVyXyhldmVudCwgaGFuZGxlckludGVybmFsLCBmYWxzZSwgbGlzdGVuZXIpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgYSBsaXN0ZW5lciBvYmplY3QgbWF0Y2hlcyB0aGUgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24uIFRvIG1hdGNoLFxuICAgKiBpdCBuZWVkcyB0byBlaXRoZXIgcG9pbnQgdG8gdGhhdCBsaXN0ZW5lciBvciBoYXZlIGl0IGFzIGl0cyBvcmlnaW4uXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gbGlzdGVuZXJPYmpcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hdGNoZXNMaXN0ZW5lcl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBtYXRjaGVzTGlzdGVuZXJfKGxpc3RlbmVyT2JqLCBsaXN0ZW5lcikge1xuXHRcdFx0dmFyIGZuID0gbGlzdGVuZXJPYmouZm4gfHwgbGlzdGVuZXJPYmo7XG5cdFx0XHRyZXR1cm4gZm4gPT09IGxpc3RlbmVyIHx8IGxpc3RlbmVyT2JqLm9yaWdpbiAmJiBsaXN0ZW5lck9iai5vcmlnaW4gPT09IGxpc3RlbmVyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRzLlxuICAgKiBDYXV0aW9uOiBjaGFuZ2VzIGFycmF5IGluZGljZXMgaW4gdGhlIGxpc3RlbmVyIGFycmF5IGJlaGluZCB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7IShBcnJheXxzdHJpbmcpfSBldmVudHNcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgZW1pdHRlciwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdvZmYnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLnZhbGlkYXRlTGlzdGVuZXJfKGxpc3RlbmVyKTtcblx0XHRcdGlmICghdGhpcy5ldmVudHNfKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXZlbnRzID0gdGhpcy50b0V2ZW50c0FycmF5XyhldmVudCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLmV2ZW50c19bZXZlbnRzW2ldXSA9IHRoaXMucmVtb3ZlTWF0Y2hpbmdMaXN0ZW5lck9ianNfKHRvQXJyYXkodGhpcy5ldmVudHNfW2V2ZW50c1tpXV0pLCBsaXN0ZW5lcik7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50cy5cbiAgICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnb24nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgaGFuZGxlciB0aGF0IGdldHMgdHJpZ2dlcmVkIHdoZW4gYW4gZXZlbnQgaXMgbGlzdGVuZWQgdG8gb24gdGhpc1xuICAgKiBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ29uTGlzdGVuZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBvbkxpc3RlbmVyKGhhbmRsZXIpIHtcblx0XHRcdHRoaXMubGlzdGVuZXJIYW5kbGVyc18gPSB0aGlzLmFkZEhhbmRsZXJfKHRoaXMubGlzdGVuZXJIYW5kbGVyc18sIGhhbmRsZXIpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIGEgb25lIHRpbWUgbGlzdGVuZXIgZm9yIHRoZSBldmVudHMuIFRoaXMgbGlzdGVuZXIgaXMgaW52b2tlZCBvbmx5IHRoZVxuICAgKiBuZXh0IHRpbWUgZWFjaCBldmVudCBpcyBmaXJlZCwgYWZ0ZXIgd2hpY2ggaXQgaXMgcmVtb3ZlZC5cbiAgICogQHBhcmFtIHshKEFycmF5fHN0cmluZyl9IGV2ZW50c1xuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICogQHJldHVybiB7IUV2ZW50SGFuZGxlfSBDYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnb25jZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG9uY2UoZXZlbnRzLCBsaXN0ZW5lcikge1xuXHRcdFx0cmV0dXJuIHRoaXMubWFueShldmVudHMsIDEsIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50cy4gSXQncyBub3QgYSBnb29kXG4gICAqIGlkZWEgdG8gcmVtb3ZlIGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgZWxzZXdoZXJlIGluIHRoZSBjb2RlLFxuICAgKiBlc3BlY2lhbGx5IHdoZW4gaXQncyBvbiBhbiBlbWl0dGVyIHRoYXQgeW91IGRpZG4ndCBjcmVhdGUuXG4gICAqIEBwYXJhbSB7KEFycmF5fHN0cmluZyk9fSBvcHRfZXZlbnRzXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgZW1pdHRlciwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVBbGxMaXN0ZW5lcnMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMob3B0X2V2ZW50cykge1xuXHRcdFx0aWYgKHRoaXMuZXZlbnRzXykge1xuXHRcdFx0XHRpZiAob3B0X2V2ZW50cykge1xuXHRcdFx0XHRcdHZhciBldmVudHMgPSB0aGlzLnRvRXZlbnRzQXJyYXlfKG9wdF9ldmVudHMpO1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmV2ZW50c19bZXZlbnRzW2ldXSA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuZXZlbnRzXyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lciBvYmplY3RzIGZyb20gdGhlIGdpdmVuIGFycmF5IHRoYXQgbWF0Y2ggdGhlIGdpdmVuXG4gICAqIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBsaXN0ZW5lck9ianNcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEByZXR1cm4ge0FycmF5LjxPYmplY3Q+fE9iamVjdH0gVGhlIG5ldyBsaXN0ZW5lcnMgYXJyYXkgZm9yIHRoaXMgZXZlbnQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZU1hdGNoaW5nTGlzdGVuZXJPYmpzXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU1hdGNoaW5nTGlzdGVuZXJPYmpzXyhsaXN0ZW5lck9ianMsIGxpc3RlbmVyKSB7XG5cdFx0XHR2YXIgZmluYWxMaXN0ZW5lcnMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJPYmpzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICghdGhpcy5tYXRjaGVzTGlzdGVuZXJfKGxpc3RlbmVyT2Jqc1tpXSwgbGlzdGVuZXIpKSB7XG5cdFx0XHRcdFx0ZmluYWxMaXN0ZW5lcnMucHVzaChsaXN0ZW5lck9ianNbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmluYWxMaXN0ZW5lcnMubGVuZ3RoID4gMCA/IGZpbmFsTGlzdGVuZXJzIDogbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50cy5cbiAgICogQ2F1dGlvbjogY2hhbmdlcyBhcnJheSBpbmRpY2VzIGluIHRoZSBsaXN0ZW5lciBhcnJheSBiZWhpbmQgdGhlIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0geyEoQXJyYXl8c3RyaW5nKX0gZXZlbnRzXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBsaXN0ZW5lclxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBSZXR1cm5zIGVtaXR0ZXIsIHNvIGNhbGxzIGNhbiBiZSBjaGFpbmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlTGlzdGVuZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcblx0XHRcdHJldHVybiB0aGlzLm9mZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSdW5zIHRoZSBoYW5kbGVycyB3aGVuIGFuIGV2ZW50IGlzIGxpc3RlbmVkIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuTGlzdGVuZXJIYW5kbGVyc18nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5MaXN0ZW5lckhhbmRsZXJzXyhldmVudCkge1xuXHRcdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5saXN0ZW5lckhhbmRsZXJzXztcblx0XHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0XHRoYW5kbGVycyA9IHRvQXJyYXkoaGFuZGxlcnMpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnNbaV0oZXZlbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJ1bnMgdGhlIGdpdmVuIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIHshQXJyYXl9IGxpc3RlbmVyc1xuICAgKiBAcGFyYW0geyFBcnJheX0gYXJnc1xuICAgKiBAcGFyYW0gKE9iamVjdCkgZmFjYWRlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1bkxpc3RlbmVyc18nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5MaXN0ZW5lcnNfKGxpc3RlbmVycywgYXJncywgZmFjYWRlKSB7XG5cdFx0XHRpZiAoZmFjYWRlKSB7XG5cdFx0XHRcdGFyZ3MucHVzaChmYWNhZGUpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGVmYXVsdExpc3RlbmVycyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldLmZuIHx8IGxpc3RlbmVyc1tpXTtcblx0XHRcdFx0aWYgKGxpc3RlbmVyc1tpXS5kZWZhdWx0KSB7XG5cdFx0XHRcdFx0ZGVmYXVsdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFmYWNhZGUgfHwgIWZhY2FkZS5wcmV2ZW50ZWREZWZhdWx0KSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZGVmYXVsdExpc3RlbmVycy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdGRlZmF1bHRMaXN0ZW5lcnNbal0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgY29uZmlndXJhdGlvbiBvcHRpb24gd2hpY2ggZGV0ZXJtaW5lcyBpZiBhbiBldmVudCBmYWNhZGUgc2hvdWxkXG4gICAqIGJlIHNlbnQgYXMgYSBwYXJhbSBvZiBsaXN0ZW5lcnMgd2hlbiBlbWl0dGluZyBldmVudHMuIElmIHNldCB0byB0cnVlLCB0aGVcbiAgICogZmFjYWRlIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgbGlzdGVuZXIuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkVXNlRmFjYWRlXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFJldHVybnMgZW1pdHRlciwgc28gY2FsbHMgY2FuIGJlIGNoYWluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRTaG91bGRVc2VGYWNhZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXRTaG91bGRVc2VGYWNhZGUoc2hvdWxkVXNlRmFjYWRlKSB7XG5cdFx0XHR0aGlzLnNob3VsZFVzZUZhY2FkZV8gPSBzaG91bGRVc2VGYWNhZGU7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ29udmVydHMgdGhlIHBhcmFtZXRlciB0byBhbiBhcnJheSBpZiBvbmx5IG9uZSBldmVudCBpcyBnaXZlbi4gUmV1c2VzIHRoZVxuICAgKiBzYW1lIGFycmF5IGVhY2ggdGltZSB0aGlzIGNvbnZlcnNpb24gaXMgZG9uZSwgdG8gYXZvaWQgdXNpbmcgbW9yZSBtZW1vcnlcbiAgICogdGhhbiBuZWNlc3NhcnkuXG4gICAqIEBwYXJhbSAgeyEoQXJyYXl8c3RyaW5nKX0gZXZlbnRzXG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndG9FdmVudHNBcnJheV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB0b0V2ZW50c0FycmF5XyhldmVudHMpIHtcblx0XHRcdGlmICgoMCwgX21ldGFsLmlzU3RyaW5nKShldmVudHMpKSB7XG5cdFx0XHRcdHNpbmdsZUFycmF5X1swXSA9IGV2ZW50cztcblx0XHRcdFx0ZXZlbnRzID0gc2luZ2xlQXJyYXlfO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV2ZW50cztcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBsaXN0ZW5lciBpcyB2YWxpZCwgdGhyb3dpbmcgYW4gZXhjZXB0aW9uIHdoZW4gaXQncyBub3QuXG4gICAqIEBwYXJhbSAgeyp9IGxpc3RlbmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3ZhbGlkYXRlTGlzdGVuZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVMaXN0ZW5lcl8obGlzdGVuZXIpIHtcblx0XHRcdGlmICghKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShsaXN0ZW5lcikpIHtcblx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignTGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oX21ldGFsLkRpc3Bvc2FibGUpO1xuXG5mdW5jdGlvbiB0b0FycmF5KHZhbCkge1xuXHR2YWwgPSB2YWwgfHwgW107XG5cdHJldHVybiBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwgOiBbdmFsXTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRFbWl0dGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvRXZlbnRFbWl0dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuYWJzdHJhY3RNZXRob2QgPSBhYnN0cmFjdE1ldGhvZDtcbmV4cG9ydHMuZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5lbmFibGVDb21wYXRpYmlsaXR5TW9kZSA9IGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5nZXRDb21wYXRpYmlsaXR5TW9kZURhdGEgPSBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGE7XG5leHBvcnRzLmdldEZ1bmN0aW9uTmFtZSA9IGdldEZ1bmN0aW9uTmFtZTtcbmV4cG9ydHMuZ2V0U3RhdGljUHJvcGVydHkgPSBnZXRTdGF0aWNQcm9wZXJ0eTtcbmV4cG9ydHMuZ2V0VWlkID0gZ2V0VWlkO1xuZXhwb3J0cy5pZGVudGl0eUZ1bmN0aW9uID0gaWRlbnRpdHlGdW5jdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc0RlZiA9IGlzRGVmO1xuZXhwb3J0cy5pc0RlZkFuZE5vdE51bGwgPSBpc0RlZkFuZE5vdE51bGw7XG5leHBvcnRzLmlzRG9jdW1lbnQgPSBpc0RvY3VtZW50O1xuZXhwb3J0cy5pc0RvY3VtZW50RnJhZ21lbnQgPSBpc0RvY3VtZW50RnJhZ21lbnQ7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NlcnZlclNpZGUgPSBpc1NlcnZlclNpZGU7XG5leHBvcnRzLm51bGxGdW5jdGlvbiA9IG51bGxGdW5jdGlvbjtcbnZhciBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdm9pZCAwO1xuXG4vKipcbiAqIENvdW50ZXIgZm9yIHVuaXF1ZSBpZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBVSURfUFJPUEVSVFkgPSBleHBvcnRzLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAqIEZvby5wcm90b3R5cGUuYmFyID0gYWJzdHJhY3RNZXRob2RcbiAqXG4gKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiB3aGVuIGJhcigpIGlzIGludm9rZWQuXG4gKlxuICogQHR5cGUgeyFGdW5jdGlvbn1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG4gIHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIERpc2FibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRW5hYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZSB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgZnJvbSByY1xuICogYW5kIDEueCB2ZXJzaW9uczpcbiAqICAgICAtIFVzaW5nIFwia2V5XCIgdG8gcmVmZXJlbmNlIGNvbXBvbmVudCBpbnN0YW5jZXMuIEluIHRoZSBjdXJyZW50IHZlcnNpb25cbiAqICAgICAgIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFwicmVmXCIgaW5zdGVhZC4gVGhpcyBhbGxvd3Mgb2xkIGNvZGUgc3RpbGxcbiAqICAgICAgIHVzaW5nIFwia2V5XCIgdG8ga2VlcCB3b3JraW5nIGxpa2UgYmVmb3JlLiBOT1RFOiB0aGlzIG1heSBjYXVzZVxuICogICAgICAgcHJvYmxlbXMsIHNpbmNlIFwia2V5XCIgaXMgbWVhbnQgdG8gYmUgdXNlZCBkaWZmZXJlbnRseS4gT25seSB1c2UgdGhpc1xuICogICAgICAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gdXBncmFkZSB0aGUgY29kZSB0byB1c2UgXCJyZWZcIiBpbnN0ZWFkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBPcHRpb25hbCBvYmplY3Qgd2l0aCBkYXRhIHRvIHNwZWNpZnkgbW9yZVxuICogICAgIGRldGFpbHMsIHN1Y2ggYXM6XG4gKiAgICAgICAgIC0gcmVuZGVyZXJzIHtBcnJheX0gdGhlIHRlbXBsYXRlIHJlbmRlcmVycyB0aGF0IHNob3VsZCBiZSBpblxuICogICAgICAgICAgIGNvbXBhdGliaWxpdHkgbW9kZSwgZWl0aGVyIHRoZWlyIGNvbnN0cnVjdG9ycyBvciBzdHJpbmdzXG4gKiAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZW0gKGUuZy4gJ3NveScgb3IgJ2pzeCcpLiBCeSBkZWZhdWx0LCBhbGwgdGhlIG9uZXNcbiAqICAgICAgICAgICB0aGF0IGV4dGVuZCBmcm9tIEluY3JlbWVudGFsRG9tUmVuZGVyZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgdmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gb3B0X2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSB1c2VkIGZvciBjb21wYXRpYmlsaXR5IG1vZGUsIG9yIG5vdGhpbmcgaWYgaXQgaGFzbid0IGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhdGliaWxpdHlNb2RlRGF0YSgpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBtb2RlIGNhbiBiZSBzZXQgdmlhIHRoZSBfX01FVEFMX0NPTVBBVElCSUxJVFlfXyBnbG9iYWwgdmFyLlxuICBpZiAoY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXykge1xuICAgICAgZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUod2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyB0cnV0aHksIG9yIHRoZSBzZWNvbmQgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0VHJ1dGh5XyhhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24uIElmIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndFxuICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3NcbiAqIGNvbnRlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGZuLm5hbWUgPSBzdHIuc3Vic3RyaW5nKDksIHN0ci5pbmRleE9mKCcoJykpO1xuICB9XG4gIHJldHVybiBmbi5uYW1lO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIHByb3BlcnR5IGluIHRoZSBnaXZlbiBjbGFzcy4gVGhlIHZhbHVlIHdpbGwgYmVcbiAqIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyBhcyBleHBlY3RlZCwgdW5sZXNzIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICogd2hpY2ggY2FuIGNoYW5nZSBob3cgdGhlIHN1cGVyIGNsYXNzZXMnIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5IHdpbGwgYmUgbWVyZ2VkXG4gKiB0b2dldGhlci5cbiAqIFRoZSBmaW5hbCBtZXJnZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQgaW4gYW5vdGhlciBwcm9wZXJ0eSwgc28gdGhhdCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkIGV2ZW4gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG1lcmdlZFxuICogICAgIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBzbyBmYXIgYW5kIHRoZSBuZXh0IHZhbHVlIHRvIGJlIG1lcmdlZCB0byBpdC5cbiAqICAgICBTaG91bGQgcmV0dXJuIHRoZXNlIHR3byBtZXJnZWQgdG9nZXRoZXIuIElmIG5vdCBwYXNzZWQgdGhlIGZpbmFsIHByb3BlcnR5XG4gKiAgICAgd2lsbCBiZSB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIGFtb25nIGFuY2VzdG9ycy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljUHJvcGVydHkoY3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuICB2YXIgbWVyZ2VkTmFtZSA9IHByb3BlcnR5TmFtZSArICdfTUVSR0VEJztcbiAgaWYgKCFjdG9yLmhhc093blByb3BlcnR5KG1lcmdlZE5hbWUpKSB7XG4gICAgdmFyIG1lcmdlZCA9IGN0b3IuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSA/IGN0b3JbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgaWYgKGN0b3IuX19wcm90b19fICYmICFjdG9yLl9fcHJvdG9fXy5pc1Byb3RvdHlwZU9mKEZ1bmN0aW9uKSkge1xuICAgICAgdmFyIG1lcmdlRm4gPSBvcHRfbWVyZ2VGbiB8fCBnZXRGaXJzdFRydXRoeV87XG4gICAgICBtZXJnZWQgPSBtZXJnZUZuKG1lcmdlZCwgZ2V0U3RhdGljUHJvcGVydHkoY3Rvci5fX3Byb3RvX18sIHByb3BlcnR5TmFtZSwgbWVyZ2VGbikpO1xuICAgIH1cbiAgICBjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuICB9XG4gIHJldHVybiBjdG9yW21lcmdlZE5hbWVdO1xufVxuXG4vKipcbiAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gKiBtdXRhdGVkIHdpdGggYW4gdW5pcXVlIGlkLiBDb25zZWN1dGl2ZSBjYWxscyB3aXRoIHRoZSBzYW1lIG9iamVjdFxuICogcmVmZXJlbmNlIHdvbid0IG11dGF0ZSB0aGUgb2JqZWN0IGFnYWluLCBpbnN0ZWFkIHRoZSBjdXJyZW50IG9iamVjdCB1aWRcbiAqIHJldHVybnMuIFNlZSB7QGxpbmsgVUlEX1BST1BFUlRZfS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gKiAgICAgbm90IHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub0luaGVyaXRhbmNlIE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzXG4gKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG4gIGlmIChvcHRfb2JqZWN0KSB7XG4gICAgdmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuICAgIGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG4gICAgICBpZCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG4gIHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBpc0RlZih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEZWZBbmROb3ROdWxsKHZhbCkge1xuICByZXR1cm4gaXNEZWYodmFsKSAmJiAhaXNOdWxsKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC1mcmFnbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gKiBhbmQgZnVuY3Rpb25zLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICByZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIFNldHMgdG8gdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBOb2RlLmpzIGVudmlyb25tZW50IHdpdGggZXh0cmEgY2hlY2sgZm9yXG4gKiBgcHJvY2Vzcy5icm93c2VyYCB0byBza2lwIEthcm1hIHJ1bm5lciBlbnZpcm9ubWVudC4gS2FybWEgZW52aXJvbm1lbnQgaGFzXG4gKiBgcHJvY2Vzc2AgZGVmaW5lZCBldmVuIHRob3VnaCBpdCBydW5zIG9uIHRoZSBicm93c2VyLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJTaWRlKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLmVudiAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhcHJvY2Vzcy5icm93c2VyO1xufVxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBudWxsRnVuY3Rpb24oKSB7fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhhcnJheSwgbnVsbCwgW3tcblx0XHRrZXk6ICdlcXVhbCcsXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdFx0aWYgKGFycjEgPT09IGFycjIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHshQXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmlyc3REZWZpbmVkVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuICAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmbGF0dGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdFx0dmFyIHJ2ID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG4gICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzbGljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHRcdHZhciBlbmQgPSAoMCwgX2NvcmUuaXNEZWYpKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNsaWNlZDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFycmF5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbnZhciBhc3luYyA9IHt9O1xuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbCA9IHZvaWQgMDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbiBDaGFubmVsKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24gKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZXZlbnRzL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEaXNwb3NhYmxlIHV0aWxpdHkuIFdoZW4gaW5oZXJpdGVkIHByb3ZpZGVzIHRoZSBgZGlzcG9zZWAgZnVuY3Rpb24gdG8gaXRzXG4gKiBzdWJjbGFzcywgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGRpc3Bvc2luZyBvZiBhbnkgb2JqZWN0IHJlZmVyZW5jZXNcbiAqIHdoZW4gYW4gaW5zdGFuY2Ugd29uJ3QgYmUgdXNlZCBhbnltb3JlLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZVxuICogYGRpc3Bvc2VJbnRlcm5hbGAgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpYyBkaXNwb3NpbmcgbG9naWMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgRGlzcG9zYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gRGlzcG9zYWJsZSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlzcG9zYWJsZSk7XG5cblx0XHQvKipcbiAgICogRmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dGhpcy5kaXNwb3NlZF8gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy4gQ2FsbHMgYGRpc3Bvc2VJbnRlcm5hbGAuXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRGlzcG9zYWJsZSwgW3tcblx0XHRrZXk6ICdkaXNwb3NlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZSgpIHtcblx0XHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdFx0dGhpcy5kaXNwb3NlSW50ZXJuYWwoKTtcblx0XHRcdFx0dGhpcy5kaXNwb3NlZF8gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljXG4gICAqIGRpc3Bvc2luZyBsb2dpYyAobGlrZSBjbGVhcmluZyByZWZlcmVuY2VzIGFuZCBjYWxsaW5nIGBkaXNwb3NlYCBvbiBvdGhlclxuICAgKiBkaXNwb3NhYmxlcykuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc0Rpc3Bvc2VkJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcblx0XHRcdHJldHVybiB0aGlzLmRpc3Bvc2VkXztcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gRGlzcG9zYWJsZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRGlzcG9zYWJsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKG9iamVjdCwgbnVsbCwgW3tcblx0XHRrZXk6ICdtaXhpbicsXG5cblx0XHQvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdFx0dmFyIGtleSA9IHZvaWQgMCxcblx0XHRcdCAgICBzb3VyY2UgPSB2b2lkIDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPYmplY3RCeU5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeU5hbWUobmFtZSwgb3B0X29iaikge1xuXHRcdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0XHRyZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChwYXJ0LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHRcdH0sIHNjb3BlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuICAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaGFsbG93RXF1YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuXHRcdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmoxW2tleXMxW2ldXSAhPT0gb2JqMltrZXlzMVtpXV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIHN0cmluZygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgc3RyaW5nKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhzdHJpbmcsIG51bGwsIFt7XG5cdFx0a2V5OiAnY2FzZUluc2Vuc2l0aXZlQ29tcGFyZScsXG5cblx0XHQvKipcbiAgICogQ29tcGFyZXMgdGhlIGdpdmVuIHN0cmluZ3Mgd2l0aG91dCB0YWtpbmcgdGhlIGNhc2UgaW50byBhY2NvdW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjFcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIyXG4gICAqIEByZXR1cm4ge251bWJlcn0gRWl0aGVyIC0xLCAwIG9yIDEsIGFjY29yZGluZyB0byBpZiB0aGUgZmlyc3Qgc3RyaW5nIGlzXG4gICAqICAgICBcInNtYWxsZXJcIiwgZXF1YWwgb3IgXCJiaWdnZXJcIiB0aGFuIHRoZSBzZWNvbmQgZ2l2ZW4gc3RyaW5nLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FzZUluc2Vuc2l0aXZlQ29tcGFyZShzdHIxLCBzdHIyKSB7XG5cdFx0XHR2YXIgdGVzdDEgPSBTdHJpbmcoc3RyMSkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB0ZXN0MiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAodGVzdDEgPCB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRlc3QxID09PSB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBicmVha2luZyBzcGFjZXMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHN0cmluZyBhbmRcbiAgICogY29sbGFwc2VzIHRoZSBzZXF1ZW5jZXMgb2YgYnJlYWtpbmcgc3BhY2VzIGluIHRoZSBtaWRkbGUgaW50byBzaW5nbGUgc3BhY2VzLlxuICAgKiBUaGUgb3JpZ2luYWwgYW5kIHRoZSByZXN1bHQgc3RyaW5ncyByZW5kZXIgdGhlIHNhbWUgd2F5IGluIEhUTUwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgaW4gd2hpY2ggdG8gY29sbGFwc2Ugc3BhY2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvcHkgb2YgdGhlIHN0cmluZyB3aXRoIG5vcm1hbGl6ZWQgYnJlYWtpbmcgc3BhY2VzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29sbGFwc2VCcmVha2luZ1NwYWNlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbGxhcHNlQnJlYWtpbmdTcGFjZXMoc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IHNhZmUgdG8gdXNlIGluIGEgUmVnRXhwLlxuICAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gZXNjYXBlLiBJZiBub3QgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY2FzdGVkXG4gICogICAgIHRvIG9uZS5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVnRXhwIHNhZmUsIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc30uXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2VzY2FwZVJlZ2V4Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRSYW5kb21TdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGhhc2hjb2RlIGZvciBhIHN0cmluZy4gVGhlIGhhc2hjb2RlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5XG4gICAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG4gICAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuICAgKiBhIHNoaWZ0IGFuZCBhIHN1YnRyYWN0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6IDMxKmkgPT0gKGk8PDUpLWkuXG4gICAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIGhhc2hjb2RlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzaENvZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNoQ29kZSh2YWwpIHtcblx0XHRcdHZhciBoYXNoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuICAgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlSW50ZXJ2YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIHN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBFdmVudEVtaXR0ZXJQcm94eSB1dGlsaXR5LiBJdCdzIHJlc3BvbnNpYmxlIGZvciBsaW5raW5nIHR3byBFdmVudEVtaXR0ZXJcbiAqIGluc3RhbmNlcyB0b2dldGhlciwgZW1pdHRpbmcgZXZlbnRzIGZyb20gdGhlIGZpcnN0IGVtaXR0ZXIgdGhyb3VnaCB0aGVcbiAqIHNlY29uZCBvbmUuIFRoYXQgbWVhbnMgdGhhdCBsaXN0ZW5pbmcgdG8gYSBzdXBwb3J0ZWQgZXZlbnQgb24gdGhlIHRhcmdldFxuICogZW1pdHRlciB3aWxsIG1lYW4gbGlzdGVuaW5nIHRvIGl0IG9uIHRoZSBvcmlnaW4gZW1pdHRlciBhcyB3ZWxsLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IG9yaWdpbkVtaXR0ZXIgRXZlbnRzIG9yaWdpbmF0ZWQgb24gdGhpcyBlbWl0dGVyXG4gKiAgIHdpbGwgYmUgZmlyZWQgZm9yIHRoZSB0YXJnZXQgZW1pdHRlcidzIGxpc3RlbmVycyBhcyB3ZWxsLlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHRhcmdldEVtaXR0ZXIgRXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoaXMgZW1pdHRlclxuICogICB3aWxsIGFsc28gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGV2ZW50IGlzIGZpcmVkIGJ5IHRoZSBvcmlnaW4gZW1pdHRlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRfYmxhY2tsaXN0IE9wdGlvbmFsIGJsYWNrbGlzdCBvZiBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlXG4gKiAgIHByb3hpZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG52YXIgRXZlbnRFbWl0dGVyUHJveHkgPSBmdW5jdGlvbiAoX0Rpc3Bvc2FibGUpIHtcblx0X2luaGVyaXRzKEV2ZW50RW1pdHRlclByb3h5LCBfRGlzcG9zYWJsZSk7XG5cblx0ZnVuY3Rpb24gRXZlbnRFbWl0dGVyUHJveHkob3JpZ2luRW1pdHRlciwgdGFyZ2V0RW1pdHRlciwgb3B0X2JsYWNrbGlzdCwgb3B0X3doaXRlbGlzdCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmVudEVtaXR0ZXJQcm94eSk7XG5cblx0XHQvKipcbiAgICogTWFwIG9mIGV2ZW50cyB0aGF0IHNob3VsZCBub3QgYmUgcHJveGllZC5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRXZlbnRFbWl0dGVyUHJveHkuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihFdmVudEVtaXR0ZXJQcm94eSkpLmNhbGwodGhpcykpO1xuXG5cdFx0X3RoaXMuYmxhY2tsaXN0XyA9IG9wdF9ibGFja2xpc3Q7XG5cblx0XHQvKipcbiAgICogVGhlIG9yaWdpbiBlbWl0dGVyLiBUaGlzIGVtaXR0ZXIncyBldmVudHMgd2lsbCBiZSBwcm94aWVkIHRocm91Z2ggdGhlXG4gICAqIHRhcmdldCBlbWl0dGVyLlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLm9yaWdpbkVtaXR0ZXJfID0gb3JpZ2luRW1pdHRlcjtcblxuXHRcdC8qKlxuICAgKiBBIGxpc3Qgb2YgZXZlbnRzIHRoYXQgYXJlIHBlbmRpbmcgdG8gYmUgbGlzdGVuZWQgYnkgYW4gYWN0dWFsIG9yaWdpblxuICAgKiBlbWl0dGVyLiBFdmVudHMgYXJlIHN0b3JlZCBoZXJlIHdoZW4gdGhlIG9yaWdpbiBkb2Vzbid0IGV4aXN0LCBzbyB0aGV5XG4gICAqIGNhbiBiZSBzZXQgb24gYSBuZXcgb3JpZ2luIHdoZW4gb25lIGlzIHNldC5cbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLnBlbmRpbmdFdmVudHNfID0gbnVsbDtcblxuXHRcdC8qKlxuICAgKiBIb2xkcyBhIG1hcCBvZiBldmVudHMgZnJvbSB0aGUgb3JpZ2luIGVtaXR0ZXIgdGhhdCBhcmUgYWxyZWFkeSBiZWluZyBwcm94aWVkLlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgIUV2ZW50SGFuZGxlPn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5wcm94aWVkRXZlbnRzXyA9IG51bGw7XG5cblx0XHQvKipcbiAgICogVGhlIHRhcmdldCBlbWl0dGVyLiBUaGlzIGVtaXR0ZXIgd2lsbCBlbWl0IGFsbCBldmVudHMgdGhhdCBjb21lIGZyb21cbiAgICogdGhlIG9yaWdpbiBlbWl0dGVyLlxuICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdF90aGlzLnRhcmdldEVtaXR0ZXJfID0gdGFyZ2V0RW1pdHRlcjtcblxuXHRcdC8qKlxuICAgKiBNYXAgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIHByb3hpZWQuIElmIHdoaXRlbGlzdCBpcyBzZXQgYmxhY2tsaXN0IGlzIGlnbm9yZWQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMud2hpdGVsaXN0XyA9IG9wdF93aGl0ZWxpc3Q7XG5cblx0XHRfdGhpcy5zdGFydFByb3h5XygpO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIEFkZHMgdGhlIGdpdmVuIGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50XG4gICogQHBhcmFtIHshZnVuY3Rpb24oKX0gbGlzdGVuZXJcbiAgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IFRoZSBsaXN0ZW5lZCBldmVudCdzIGhhbmRsZS5cbiAgKiBAcHJvdGVjdGVkXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRXZlbnRFbWl0dGVyUHJveHksIFt7XG5cdFx0a2V5OiAnYWRkTGlzdGVuZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkTGlzdGVuZXJfKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luRW1pdHRlcl8ub24oZXZlbnQsIGxpc3RlbmVyKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHtcblx0XHRcdHRoaXMucmVtb3ZlTGlzdGVuZXJzXygpO1xuXHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzXyA9IG51bGw7XG5cdFx0XHR0aGlzLm9yaWdpbkVtaXR0ZXJfID0gbnVsbDtcblx0XHRcdHRoaXMudGFyZ2V0RW1pdHRlcl8gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFbWl0cyB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGUgb24gdGhlIHRhcmdldCBlbWl0dGVyLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlbWl0T25UYXJnZXRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZW1pdE9uVGFyZ2V0XygpIHtcblx0XHRcdHRoaXMudGFyZ2V0RW1pdHRlcl8uZW1pdC5hcHBseSh0aGlzLnRhcmdldEVtaXR0ZXJfLCBhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBQcm94aWVzIHRoZSBnaXZlbiBldmVudCBmcm9tIHRoZSBvcmlnaW4gdG8gdGhlIHRhcmdldCBlbWl0dGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Byb3h5RXZlbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBwcm94eUV2ZW50KGV2ZW50KSB7XG5cdFx0XHRpZiAodGhpcy5zaG91bGRQcm94eUV2ZW50XyhldmVudCkpIHtcblx0XHRcdFx0dGhpcy50cnlUb0FkZExpc3RlbmVyXyhldmVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIHByb3h5IGxpc3RlbmVyIGZvciBhbGwgZXZlbnRzLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVMaXN0ZW5lcnNfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzXygpIHtcblx0XHRcdGlmICh0aGlzLnByb3hpZWRFdmVudHNfKSB7XG5cdFx0XHRcdHZhciBldmVudHMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3hpZWRFdmVudHNfKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzLnByb3hpZWRFdmVudHNfW2V2ZW50c1tpXV0ucmVtb3ZlTGlzdGVuZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnByb3hpZWRFdmVudHNfID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHRoaXMucGVuZGluZ0V2ZW50c18gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBvcmlnaW4gZW1pdHRlci4gVGhpcyBhdXRvbWF0aWNhbGx5IGRldGFjaGVzIGFueSBldmVudHMgdGhhdFxuICAgKiB3ZXJlIGFscmVhZHkgYmVpbmcgcHJveGllZCBmcm9tIHRoZSBwcmV2aW91cyBlbWl0dGVyLCBhbmQgc3RhcnRzIHByb3h5aW5nXG4gICAqIHRoZW0gb24gdGhlIG5ldyBlbWl0dGVyIGluc3RlYWQuXG4gICAqIEBwYXJhbSB7IUV2ZW50RW1pdHRlcn0gb3JpZ2luRW1pdHRlclxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0T3JpZ2luRW1pdHRlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldE9yaWdpbkVtaXR0ZXIob3JpZ2luRW1pdHRlcikge1xuXHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cblx0XHRcdHZhciBldmVudHMgPSB0aGlzLm9yaWdpbkVtaXR0ZXJfICYmIHRoaXMucHJveGllZEV2ZW50c18gPyBPYmplY3Qua2V5cyh0aGlzLnByb3hpZWRFdmVudHNfKSA6IHRoaXMucGVuZGluZ0V2ZW50c187XG5cdFx0XHR0aGlzLm9yaWdpbkVtaXR0ZXJfID0gb3JpZ2luRW1pdHRlcjtcblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0dGhpcy5yZW1vdmVMaXN0ZW5lcnNfKCk7XG5cdFx0XHRcdGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0XHRcdHJldHVybiBfdGhpczIucHJveHlFdmVudChldmVudCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGV2ZW50IHNob3VsZCBiZSBwcm94aWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hvdWxkUHJveHlFdmVudF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaG91bGRQcm94eUV2ZW50XyhldmVudCkge1xuXHRcdFx0aWYgKHRoaXMud2hpdGVsaXN0XyAmJiAhdGhpcy53aGl0ZWxpc3RfW2V2ZW50XSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5ibGFja2xpc3RfICYmIHRoaXMuYmxhY2tsaXN0X1tldmVudF0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICF0aGlzLnByb3hpZWRFdmVudHNfIHx8ICF0aGlzLnByb3hpZWRFdmVudHNfW2V2ZW50XTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU3RhcnRzIHByb3h5aW5nIGFsbCBldmVudHMgZnJvbSB0aGUgb3JpZ2luIHRvIHRoZSB0YXJnZXQgZW1pdHRlci5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc3RhcnRQcm94eV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzdGFydFByb3h5XygpIHtcblx0XHRcdHRoaXMudGFyZ2V0RW1pdHRlcl8ub25MaXN0ZW5lcih0aGlzLnByb3h5RXZlbnQuYmluZCh0aGlzKSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEFkZHMgYSBsaXN0ZW5lciB0byB0aGUgb3JpZ2luIGVtaXR0ZXIsIGlmIGl0IGV4aXN0cy4gT3RoZXJ3aXNlLCBzdG9yZXNcbiAgICogdGhlIHBlbmRpbmcgbGlzdGVuZXIgc28gaXQgY2FuIGJlIHVzZWQgb24gYSBmdXR1cmUgb3JpZ2luIGVtaXR0ZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd0cnlUb0FkZExpc3RlbmVyXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHRyeVRvQWRkTGlzdGVuZXJfKGV2ZW50KSB7XG5cdFx0XHRpZiAodGhpcy5vcmlnaW5FbWl0dGVyXykge1xuXHRcdFx0XHR0aGlzLnByb3hpZWRFdmVudHNfID0gdGhpcy5wcm94aWVkRXZlbnRzXyB8fCB7fTtcblx0XHRcdFx0dGhpcy5wcm94aWVkRXZlbnRzX1tldmVudF0gPSB0aGlzLmFkZExpc3RlbmVyXyhldmVudCwgdGhpcy5lbWl0T25UYXJnZXRfLmJpbmQodGhpcywgZXZlbnQpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMucGVuZGluZ0V2ZW50c18gPSB0aGlzLnBlbmRpbmdFdmVudHNfIHx8IFtdO1xuXHRcdFx0XHR0aGlzLnBlbmRpbmdFdmVudHNfLnB1c2goZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBFdmVudEVtaXR0ZXJQcm94eTtcbn0oX21ldGFsLkRpc3Bvc2FibGUpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEVtaXR0ZXJQcm94eTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1ldmVudHMvbGliL0V2ZW50RW1pdHRlclByb3h5LmpzXG4vLyBtb2R1bGUgaWQgPSA3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogRXZlbnRIYW5kbGVyIHV0aWxpdHkuIEl0J3MgdXNlZnVsIGZvciBlYXNpbHkgcmVtb3ZpbmcgYSBncm91cCBvZlxuICogbGlzdGVuZXJzIGZyb20gZGlmZmVyZW50IEV2ZW50RW1pdHRlciBpbnN0YW5jZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEaXNwb3NhYmxlfVxuICovXG52YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gKF9EaXNwb3NhYmxlKSB7XG5cdF9pbmhlcml0cyhFdmVudEhhbmRsZXIsIF9EaXNwb3NhYmxlKTtcblxuXHRmdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50SGFuZGxlcik7XG5cblx0XHQvKipcbiAgICogQW4gYXJyYXkgdGhhdCBob2xkcyB0aGUgYWRkZWQgZXZlbnQgaGFuZGxlcywgc28gdGhlIGxpc3RlbmVycyBjYW4gYmVcbiAgICogcmVtb3ZlZCBsYXRlci5cbiAgICogQHR5cGUge0FycmF5LjxFdmVudEhhbmRsZT59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEV2ZW50SGFuZGxlci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEV2ZW50SGFuZGxlcikpLmNhbGwodGhpcykpO1xuXG5cdFx0X3RoaXMuZXZlbnRIYW5kbGVzXyA9IFtdO1xuXHRcdHJldHVybiBfdGhpcztcblx0fVxuXG5cdC8qKlxuICAqIEFkZHMgZXZlbnQgaGFuZGxlcyB0byBiZSByZW1vdmVkIGxhdGVyIHRocm91Z2ggdGhlIGByZW1vdmVBbGxMaXN0ZW5lcnNgXG4gICogbWV0aG9kLlxuICAqIEBwYXJhbSB7Li4uKCFFdmVudEhhbmRsZSl9IHZhcl9hcmdzXG4gICovXG5cblxuXHRfY3JlYXRlQ2xhc3MoRXZlbnRIYW5kbGVyLCBbe1xuXHRcdGtleTogJ2FkZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVzXy5wdXNoKGFyZ3VtZW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIERpc3Bvc2VzIG9mIHRoaXMgaW5zdGFuY2UncyBvYmplY3QgcmVmZXJlbmNlcy5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdkaXNwb3NlSW50ZXJuYWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7XG5cdFx0XHR0aGlzLmV2ZW50SGFuZGxlc18gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdGhyb3VnaCB0aGUgYGFkZGAgbWV0aG9kLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQWxsTGlzdGVuZXJzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50SGFuZGxlc18ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXNfW2ldLnJlbW92ZUxpc3RlbmVyKCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZXZlbnRIYW5kbGVzXyA9IFtdO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBFdmVudEhhbmRsZXI7XG59KF9tZXRhbC5EaXNwb3NhYmxlKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRIYW5kbGVyO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWV2ZW50cy9saWIvRXZlbnRIYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxudmFyIF9kb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG52YXIgX21ldGFsRXZlbnRzID0gcmVxdWlyZSgnbWV0YWwtZXZlbnRzJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBEb21FdmVudEVtaXR0ZXJQcm94eSB1dGlsaXR5LiBJdCBleHRlbmRzIGBFdmVudEVtaXR0ZXJQcm94eWAgdG8gYWxzbyBhY2NlcHRcbiAqIGRvbSBlbGVtZW50cyBhcyBvcmlnaW4gZW1pdHRlcnMuXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyUHJveHl9XG4gKi9cbnZhciBEb21FdmVudEVtaXR0ZXJQcm94eSA9IGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyUHJveHkpIHtcblx0X2luaGVyaXRzKERvbUV2ZW50RW1pdHRlclByb3h5LCBfRXZlbnRFbWl0dGVyUHJveHkpO1xuXG5cdGZ1bmN0aW9uIERvbUV2ZW50RW1pdHRlclByb3h5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb21FdmVudEVtaXR0ZXJQcm94eSk7XG5cblx0XHRyZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERvbUV2ZW50RW1pdHRlclByb3h5Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRG9tRXZlbnRFbWl0dGVyUHJveHkpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhEb21FdmVudEVtaXR0ZXJQcm94eSwgW3tcblx0XHRrZXk6ICdhZGRMaXN0ZW5lcl8nLFxuXG5cdFx0LyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGxpc3RlbmVyIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBsaXN0ZW5lclxuICAgKiBAcmV0dXJuIHshRXZlbnRIYW5kbGV9IFRoZSBsaXN0ZW5lZCBldmVudCdzIGhhbmRsZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVyXyhldmVudCwgbGlzdGVuZXIpIHtcblx0XHRcdGlmICh0aGlzLm9yaWdpbkVtaXR0ZXJfLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdFx0aWYgKHRoaXMuaXNEZWxlZ2F0ZUV2ZW50XyhldmVudCkpIHtcblx0XHRcdFx0XHR2YXIgaW5kZXggPSBldmVudC5pbmRleE9mKCc6JywgOSk7XG5cdFx0XHRcdFx0dmFyIGV2ZW50TmFtZSA9IGV2ZW50LnN1YnN0cmluZyg5LCBpbmRleCk7XG5cdFx0XHRcdFx0dmFyIHNlbGVjdG9yID0gZXZlbnQuc3Vic3RyaW5nKGluZGV4ICsgMSk7XG5cdFx0XHRcdFx0cmV0dXJuICgwLCBfZG9tLmRlbGVnYXRlKSh0aGlzLm9yaWdpbkVtaXR0ZXJfLCBldmVudE5hbWUsIHNlbGVjdG9yLCBsaXN0ZW5lcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuICgwLCBfZG9tLm9uKSh0aGlzLm9yaWdpbkVtaXR0ZXJfLCBldmVudCwgbGlzdGVuZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gX2dldChEb21FdmVudEVtaXR0ZXJQcm94eS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEb21FdmVudEVtaXR0ZXJQcm94eS5wcm90b3R5cGUpLCAnYWRkTGlzdGVuZXJfJywgdGhpcykuY2FsbCh0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIG9mIHRoZSBkZWxlZ2F0ZSB0eXBlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNEZWxlZ2F0ZUV2ZW50XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRGVsZWdhdGVFdmVudF8oZXZlbnQpIHtcblx0XHRcdHJldHVybiBldmVudC5zdWJzdHIoMCwgOSkgPT09ICdkZWxlZ2F0ZTonO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIHN1cHBvcnRlZCBieSB0aGUgb3JpZ2luIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpc1N1cHBvcnRlZERvbUV2ZW50XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkRG9tRXZlbnRfKGV2ZW50KSB7XG5cdFx0XHRpZiAoIXRoaXMub3JpZ2luRW1pdHRlcl8gfHwgIXRoaXMub3JpZ2luRW1pdHRlcl8uYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLmlzRGVsZWdhdGVFdmVudF8oZXZlbnQpICYmIGV2ZW50LmluZGV4T2YoJzonLCA5KSAhPT0gLTEgfHwgKDAsIF9kb20uc3VwcG9ydHNFdmVudCkodGhpcy5vcmlnaW5FbWl0dGVyXywgZXZlbnQpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGV2ZW50IHNob3VsZCBiZSBwcm94aWVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3Nob3VsZFByb3h5RXZlbnRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2hvdWxkUHJveHlFdmVudF8oZXZlbnQpIHtcblx0XHRcdHJldHVybiBfZ2V0KERvbUV2ZW50RW1pdHRlclByb3h5LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERvbUV2ZW50RW1pdHRlclByb3h5LnByb3RvdHlwZSksICdzaG91bGRQcm94eUV2ZW50XycsIHRoaXMpLmNhbGwodGhpcywgZXZlbnQpICYmIHRoaXMuaXNTdXBwb3J0ZWREb21FdmVudF8oZXZlbnQpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEb21FdmVudEVtaXR0ZXJQcm94eTtcbn0oX21ldGFsRXZlbnRzLkV2ZW50RW1pdHRlclByb3h5KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRG9tRXZlbnRFbWl0dGVyUHJveHk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9Eb21FdmVudEVtaXR0ZXJQcm94eS5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9kb20gPSByZXF1aXJlKCcuL2RvbScpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBydW5uaW5nIGphdmFzY3JpcHQgY29kZSBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICovXG52YXIgZ2xvYmFsRXZhbCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gZ2xvYmFsRXZhbCgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgZ2xvYmFsRXZhbCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoZ2xvYmFsRXZhbCwgbnVsbCwgW3tcblx0XHRrZXk6ICdydW4nLFxuXG5cdFx0LyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gc3RyaW5nIGluIHRoZSBnbG9iYWwgc2NvcGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBzY3JpcHRcbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJ1bih0ZXh0LCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC50ZXh0ID0gdGV4dDtcblx0XHRcdGlmIChvcHRfYXBwZW5kRm4pIHtcblx0XHRcdFx0b3B0X2FwcGVuZEZuKHNjcmlwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHR9XG5cdFx0XHQoMCwgX2RvbS5leGl0RG9jdW1lbnQpKHNjcmlwdCk7XG5cdFx0XHRyZXR1cm4gc2NyaXB0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIGphdmFzY3JpcHQgZmlsZSBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBmaWxlJ3MgcGF0aC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiAgIHdoZW4gdGhlIHNjcmlwdCBoYXMgYmVlbiBydW4uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBzY3JpcHRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1bkZpbGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5GaWxlKHNyYywgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5zcmMgPSBzcmM7XG5cblx0XHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuXHRcdFx0XHQoMCwgX2RvbS5leGl0RG9jdW1lbnQpKHNjcmlwdCk7XG5cdFx0XHRcdG9wdF9jYWxsYmFjayAmJiBvcHRfY2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0XHQoMCwgX2RvbS5vbmNlKShzY3JpcHQsICdsb2FkJywgY2FsbGJhY2spO1xuXHRcdFx0KDAsIF9kb20ub25jZSkoc2NyaXB0LCAnZXJyb3InLCBjYWxsYmFjayk7XG5cblx0XHRcdGlmIChvcHRfYXBwZW5kRm4pIHtcblx0XHRcdFx0b3B0X2FwcGVuZEZuKHNjcmlwdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzY3JpcHQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEV2YWx1YXRlcyB0aGUgY29kZSByZWZlcmVuY2VkIGJ5IHRoZSBnaXZlbiBzY3JpcHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gc2NyaXB0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9jYWxsYmFjayBPcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICogICB3aGVuIHRoZSBzY3JpcHQgaGFzIGJlZW4gcnVuLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk9fSBvcHRfYXBwZW5kRm4gT3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwZW5kIHRoZSBub2RlXG4gICAqICAgaW50byBkb2N1bWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gc2NyaXB0XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdydW5TY3JpcHQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5TY3JpcHQoc2NyaXB0LCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbikge1xuXHRcdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG5cdFx0XHRcdG9wdF9jYWxsYmFjayAmJiBvcHRfY2FsbGJhY2soKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoc2NyaXB0LnR5cGUgJiYgc2NyaXB0LnR5cGUgIT09ICd0ZXh0L2phdmFzY3JpcHQnKSB7XG5cdFx0XHRcdF9tZXRhbC5hc3luYy5uZXh0VGljayhjYWxsYmFjayk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdCgwLCBfZG9tLmV4aXREb2N1bWVudCkoc2NyaXB0KTtcblx0XHRcdGlmIChzY3JpcHQuc3JjKSB7XG5cdFx0XHRcdHJldHVybiBnbG9iYWxFdmFsLnJ1bkZpbGUoc2NyaXB0LnNyYywgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuIGdsb2JhbEV2YWwucnVuKHNjcmlwdC50ZXh0LCBvcHRfYXBwZW5kRm4pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFdmFsdWF0ZXMgYW55IHNjcmlwdCB0YWdzIHByZXNlbnQgaW4gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiAgIHdoZW4gdGhlIHNjcmlwdCBoYXMgYmVlbiBydW4uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuU2NyaXB0c0luRWxlbWVudCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJ1blNjcmlwdHNJbkVsZW1lbnQoZWxlbWVudCwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdHZhciBzY3JpcHRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcblx0XHRcdGlmIChzY3JpcHRzLmxlbmd0aCkge1xuXHRcdFx0XHRnbG9iYWxFdmFsLnJ1blNjcmlwdHNJbk9yZGVyKHNjcmlwdHMsIDAsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKTtcblx0XHRcdH0gZWxzZSBpZiAob3B0X2NhbGxiYWNrKSB7XG5cdFx0XHRcdF9tZXRhbC5hc3luYy5uZXh0VGljayhvcHRfY2FsbGJhY2spO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSdW5zIHRoZSBnaXZlbiBzY3JpcHRzIGVsZW1lbnRzIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgYXBwZWFyLlxuICAgKiBAcGFyYW0geyFOb2RlTGlzdH0gc2NyaXB0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiAgIHdoZW4gdGhlIHNjcmlwdCBoYXMgYmVlbiBydW4uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuU2NyaXB0c0luT3JkZXInLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5TY3JpcHRzSW5PcmRlcihzY3JpcHRzLCBpbmRleCwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdGdsb2JhbEV2YWwucnVuU2NyaXB0KHNjcmlwdHMuaXRlbShpbmRleCksIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGluZGV4IDwgc2NyaXB0cy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0Z2xvYmFsRXZhbC5ydW5TY3JpcHRzSW5PcmRlcihzY3JpcHRzLCBpbmRleCArIDEsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKTtcblx0XHRcdFx0fSBlbHNlIGlmIChvcHRfY2FsbGJhY2spIHtcblx0XHRcdFx0XHRfbWV0YWwuYXN5bmMubmV4dFRpY2sob3B0X2NhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgb3B0X2FwcGVuZEZuKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gZ2xvYmFsRXZhbDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZ2xvYmFsRXZhbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2dsb2JhbEV2YWwuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgcnVubmluZyBzdHlsZXMuXG4gKi9cbnZhciBnbG9iYWxFdmFsU3R5bGVzID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBnbG9iYWxFdmFsU3R5bGVzKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBnbG9iYWxFdmFsU3R5bGVzKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhnbG9iYWxFdmFsU3R5bGVzLCBudWxsLCBbe1xuXHRcdGtleTogJ3J1bicsXG5cblx0XHQvKipcbiAgICogRXZhbHVhdGVzIHRoZSBnaXZlbiBzdHlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuICAgKiAgIGludG8gZG9jdW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IHN0eWxlXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW4odGV4dCwgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuXHRcdFx0c3R5bGUuaW5uZXJIVE1MID0gdGV4dDtcblx0XHRcdGlmIChvcHRfYXBwZW5kRm4pIHtcblx0XHRcdFx0b3B0X2FwcGVuZEZuKHN0eWxlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0eWxlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFdmFsdWF0ZXMgdGhlIGdpdmVuIHN0eWxlIGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFRoZSBmaWxlJ3MgcGF0aC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiAgIHdoZW4gdGhlIHN0eWxlcyBoYXMgYmVlbiBydW4uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBzdHlsZVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncnVuRmlsZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJ1bkZpbGUoaHJlZiwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpO1xuXHRcdFx0bGluay5yZWwgPSAnc3R5bGVzaGVldCc7XG5cdFx0XHRsaW5rLmhyZWYgPSBocmVmO1xuXHRcdFx0Z2xvYmFsRXZhbFN0eWxlcy5ydW5TdHlsZShsaW5rLCBvcHRfY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0XHRyZXR1cm4gbGluaztcblx0XHR9XG5cblx0XHQvKipcbiAgICogRXZhbHVhdGVzIHRoZSBjb2RlIHJlZmVyZW5jZWQgYnkgdGhlIGdpdmVuIHN0eWxlL2xpbmsgZWxlbWVudC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gc3R5bGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgKiAgIHdoZW4gdGhlIHNjcmlwdCBoYXMgYmVlbiBydW4uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKT19IG9wdF9hcHBlbmRGbiBPcHRpb25hbCBmdW5jdGlvbiB0byBhcHBlbmQgdGhlIG5vZGVcbiAgICogICBpbnRvIGRvY3VtZW50LlxuICAgKiAgQHJldHVybiB7RWxlbWVudH0gc3R5bGVcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3J1blN0eWxlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcnVuU3R5bGUoc3R5bGUsIG9wdF9jYWxsYmFjaywgb3B0X2FwcGVuZEZuKSB7XG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcblx0XHRcdFx0b3B0X2NhbGxiYWNrICYmIG9wdF9jYWxsYmFjaygpO1xuXHRcdFx0fTtcblx0XHRcdGlmIChzdHlsZS5yZWwgJiYgc3R5bGUucmVsICE9PSAnc3R5bGVzaGVldCcpIHtcblx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKGNhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3R5bGUudGFnTmFtZSA9PT0gJ1NUWUxFJykge1xuXHRcdFx0XHRfbWV0YWwuYXN5bmMubmV4dFRpY2soY2FsbGJhY2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KDAsIF9kb20ub25jZSkoc3R5bGUsICdsb2FkJywgY2FsbGJhY2spO1xuXHRcdFx0XHQoMCwgX2RvbS5vbmNlKShzdHlsZSwgJ2Vycm9yJywgY2FsbGJhY2spO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0X2FwcGVuZEZuKSB7XG5cdFx0XHRcdG9wdF9hcHBlbmRGbihzdHlsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0eWxlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFdmFsdWF0ZXMgYW55IHN0eWxlIHByZXNlbnQgaW4gdGhlIGdpdmVuIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIHRoZVxuICAgKiAgIHN0eWxlIGhhcyBiZWVuIHJ1bi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2FwcGVuZEZuIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGFwcGVuZCB0aGUgbm9kZVxuICAgKiAgIGludG8gZG9jdW1lbnQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdydW5TdHlsZXNJbkVsZW1lbnQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW5TdHlsZXNJbkVsZW1lbnQoZWxlbWVudCwgb3B0X2NhbGxiYWNrLCBvcHRfYXBwZW5kRm4pIHtcblx0XHRcdHZhciBzdHlsZXMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlLGxpbmsnKTtcblx0XHRcdGlmIChzdHlsZXMubGVuZ3RoID09PSAwICYmIG9wdF9jYWxsYmFjaykge1xuXHRcdFx0XHRfbWV0YWwuYXN5bmMubmV4dFRpY2sob3B0X2NhbGxiYWNrKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbG9hZENvdW50ID0gMDtcblx0XHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuXHRcdFx0XHRpZiAob3B0X2NhbGxiYWNrICYmICsrbG9hZENvdW50ID09PSBzdHlsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKG9wdF9jYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRnbG9iYWxFdmFsU3R5bGVzLnJ1blN0eWxlKHN0eWxlc1tpXSwgY2FsbGJhY2ssIG9wdF9hcHBlbmRGbik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIGdsb2JhbEV2YWxTdHlsZXM7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbEV2YWxTdHlsZXM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtZG9tL2xpYi9nbG9iYWxFdmFsU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi9kb20nKTtcblxudmFyIF9mZWF0dXJlcyA9IHJlcXVpcmUoJy4vZmVhdHVyZXMnKTtcblxudmFyIF9mZWF0dXJlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9mZWF0dXJlcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBtb3VzZUV2ZW50TWFwID0ge1xuXHRtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcblx0bW91c2VsZWF2ZTogJ21vdXNlb3V0Jyxcblx0cG9pbnRlcmVudGVyOiAncG9pbnRlcm92ZXInLFxuXHRwb2ludGVybGVhdmU6ICdwb2ludGVyb3V0J1xufTtcbk9iamVjdC5rZXlzKG1vdXNlRXZlbnRNYXApLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQoMCwgX2RvbS5yZWdpc3RlckN1c3RvbUV2ZW50KShldmVudE5hbWUsIHtcblx0XHRkZWxlZ2F0ZTogdHJ1ZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKGNhbGxiYWNrLCBldmVudCkge1xuXHRcdFx0dmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuXHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LmRlbGVnYXRlVGFyZ2V0O1xuXHRcdFx0aWYgKCFyZWxhdGVkIHx8IHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhKDAsIF9kb20uY29udGFpbnMpKHRhcmdldCwgcmVsYXRlZCkpIHtcblx0XHRcdFx0ZXZlbnQuY3VzdG9tVHlwZSA9IGV2ZW50TmFtZTtcblx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdG9yaWdpbmFsRXZlbnQ6IG1vdXNlRXZlbnRNYXBbZXZlbnROYW1lXVxuXHR9KTtcbn0pO1xuXG52YXIgYW5pbWF0aW9uRXZlbnRNYXAgPSB7XG5cdGFuaW1hdGlvbjogJ2FuaW1hdGlvbmVuZCcsXG5cdHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xufTtcbk9iamVjdC5rZXlzKGFuaW1hdGlvbkV2ZW50TWFwKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR5cGUpIHtcblx0dmFyIGV2ZW50TmFtZSA9IGFuaW1hdGlvbkV2ZW50TWFwW2V2ZW50VHlwZV07XG5cdCgwLCBfZG9tLnJlZ2lzdGVyQ3VzdG9tRXZlbnQpKGV2ZW50TmFtZSwge1xuXHRcdGV2ZW50OiB0cnVlLFxuXHRcdGRlbGVnYXRlOiB0cnVlLFxuXHRcdGhhbmRsZXI6IGZ1bmN0aW9uIGhhbmRsZXIoY2FsbGJhY2ssIGV2ZW50KSB7XG5cdFx0XHRldmVudC5jdXN0b21UeXBlID0gZXZlbnROYW1lO1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGV2ZW50KTtcblx0XHR9LFxuXHRcdG9yaWdpbmFsRXZlbnQ6IF9mZWF0dXJlczIuZGVmYXVsdC5jaGVja0FuaW1hdGlvbkV2ZW50TmFtZSgpW2V2ZW50VHlwZV1cblx0fSk7XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1kb20vbGliL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBjb3JlIHV0aWxpdHkgZnVuY3Rpb25zLlxuICogQGNvbnN0XG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLmFic3RyYWN0TWV0aG9kID0gYWJzdHJhY3RNZXRob2Q7XG5leHBvcnRzLmRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSA9IGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBlbmFibGVDb21wYXRpYmlsaXR5TW9kZTtcbmV4cG9ydHMuZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhID0gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhO1xuZXhwb3J0cy5nZXRGdW5jdGlvbk5hbWUgPSBnZXRGdW5jdGlvbk5hbWU7XG5leHBvcnRzLmdldFN0YXRpY1Byb3BlcnR5ID0gZ2V0U3RhdGljUHJvcGVydHk7XG5leHBvcnRzLmdldFVpZCA9IGdldFVpZDtcbmV4cG9ydHMuaWRlbnRpdHlGdW5jdGlvbiA9IGlkZW50aXR5RnVuY3Rpb247XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbmV4cG9ydHMuaXNEZWYgPSBpc0RlZjtcbmV4cG9ydHMuaXNEZWZBbmROb3ROdWxsID0gaXNEZWZBbmROb3ROdWxsO1xuZXhwb3J0cy5pc0RvY3VtZW50ID0gaXNEb2N1bWVudDtcbmV4cG9ydHMuaXNEb2N1bWVudEZyYWdtZW50ID0gaXNEb2N1bWVudEZyYWdtZW50O1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5leHBvcnRzLmlzV2luZG93ID0gaXNXaW5kb3c7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcbmV4cG9ydHMuaXNTZXJ2ZXJTaWRlID0gaXNTZXJ2ZXJTaWRlO1xuZXhwb3J0cy5udWxsRnVuY3Rpb24gPSBudWxsRnVuY3Rpb247XG52YXIgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHZvaWQgMDtcblxuLyoqXG4gKiBDb3VudGVyIGZvciB1bmlxdWUgaWQuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVuaXF1ZUlkQ291bnRlcl8gPSAxO1xuXG4vKipcbiAqIFVuaXF1ZSBpZCBwcm9wZXJ0eSBwcmVmaXguXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHByb3RlY3RlZFxuICovXG52YXIgVUlEX1BST1BFUlRZID0gZXhwb3J0cy5VSURfUFJPUEVSVFkgPSAnY29yZV8nICsgKE1hdGgucmFuZG9tKCkgKiAxZTkgPj4+IDApO1xuXG4vKipcbiAqIFdoZW4gZGVmaW5pbmcgYSBjbGFzcyBGb28gd2l0aCBhbiBhYnN0cmFjdCBtZXRob2QgYmFyKCksIHlvdSBjYW4gZG86XG4gKiBGb28ucHJvdG90eXBlLmJhciA9IGFic3RyYWN0TWV0aG9kXG4gKlxuICogTm93IGlmIGEgc3ViY2xhc3Mgb2YgRm9vIGZhaWxzIHRvIG92ZXJyaWRlIGJhcigpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93blxuICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICpcbiAqIEB0eXBlIHshRnVuY3Rpb259XG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGFic3RyYWN0TWV0aG9kKCkge1xuICB0aHJvdyBFcnJvcignVW5pbXBsZW1lbnRlZCBhYnN0cmFjdCBtZXRob2QnKTtcbn1cblxuLyoqXG4gKiBEaXNhYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZS5cbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUgd2l0aCB0aGUgZm9sbG93aW5nIGZlYXR1cmVzIGZyb20gcmNcbiAqIGFuZCAxLnggdmVyc2lvbnM6XG4gKiAgICAgLSBVc2luZyBcImtleVwiIHRvIHJlZmVyZW5jZSBjb21wb25lbnQgaW5zdGFuY2VzLiBJbiB0aGUgY3VycmVudCB2ZXJzaW9uXG4gKiAgICAgICB0aGlzIHNob3VsZCBiZSBkb25lIHZpYSBcInJlZlwiIGluc3RlYWQuIFRoaXMgYWxsb3dzIG9sZCBjb2RlIHN0aWxsXG4gKiAgICAgICB1c2luZyBcImtleVwiIHRvIGtlZXAgd29ya2luZyBsaWtlIGJlZm9yZS4gTk9URTogdGhpcyBtYXkgY2F1c2VcbiAqICAgICAgIHByb2JsZW1zLCBzaW5jZSBcImtleVwiIGlzIG1lYW50IHRvIGJlIHVzZWQgZGlmZmVyZW50bHkuIE9ubHkgdXNlIHRoaXNcbiAqICAgICAgIGlmIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVwZ3JhZGUgdGhlIGNvZGUgdG8gdXNlIFwicmVmXCIgaW5zdGVhZC5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2RhdGEgT3B0aW9uYWwgb2JqZWN0IHdpdGggZGF0YSB0byBzcGVjaWZ5IG1vcmVcbiAqICAgICBkZXRhaWxzLCBzdWNoIGFzOlxuICogICAgICAgICAtIHJlbmRlcmVycyB7QXJyYXl9IHRoZSB0ZW1wbGF0ZSByZW5kZXJlcnMgdGhhdCBzaG91bGQgYmUgaW5cbiAqICAgICAgICAgICBjb21wYXRpYmlsaXR5IG1vZGUsIGVpdGhlciB0aGVpciBjb25zdHJ1Y3RvcnMgb3Igc3RyaW5nc1xuICogICAgICAgICAgIHJlcHJlc2VudGluZyB0aGVtIChlLmcuICdzb3knIG9yICdqc3gnKS4gQnkgZGVmYXVsdCwgYWxsIHRoZSBvbmVzXG4gKiAgICAgICAgICAgdGhhdCBleHRlbmQgZnJvbSBJbmNyZW1lbnRhbERvbVJlbmRlcmVyLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIHZhciBvcHRfZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IG9wdF9kYXRhO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGRhdGEgdXNlZCBmb3IgY29tcGF0aWJpbGl0eSBtb2RlLCBvciBub3RoaW5nIGlmIGl0IGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGEoKSB7XG4gIC8vIENvbXBhdGliaWxpdHkgbW9kZSBjYW4gYmUgc2V0IHZpYSB0aGUgX19NRVRBTF9DT01QQVRJQklMSVRZX18gZ2xvYmFsIHZhci5cbiAgaWYgKGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pIHtcbiAgICAgIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wYXRpYmlsaXR5TW9kZURhdGFfO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGlmIGl0J3MgdHJ1dGh5LCBvciB0aGUgc2Vjb25kIG90aGVyd2lzZS5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBnZXRGaXJzdFRydXRoeV8oYSwgYikge1xuICByZXR1cm4gYSB8fCBiO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLiBJZiB0aGUgY3VycmVudCBicm93c2VyIGRvZXNuJ3RcbiAqIHN1cHBvcnQgdGhlIGBuYW1lYCBwcm9wZXJ0eSwgdGhpcyB3aWxsIGNhbGN1bGF0ZSBpdCBmcm9tIHRoZSBmdW5jdGlvbidzXG4gKiBjb250ZW50IHN0cmluZy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGZuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuICBpZiAoIWZuLm5hbWUpIHtcbiAgICB2YXIgc3RyID0gZm4udG9TdHJpbmcoKTtcbiAgICBmbi5uYW1lID0gc3RyLnN1YnN0cmluZyg5LCBzdHIuaW5kZXhPZignKCcpKTtcbiAgfVxuICByZXR1cm4gZm4ubmFtZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHN0YXRpYyBwcm9wZXJ0eSBpbiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSB2YWx1ZSB3aWxsIGJlXG4gKiBpbmhlcml0ZWQgZnJvbSBhbmNlc3RvcnMgYXMgZXhwZWN0ZWQsIHVubGVzcyBhIGN1c3RvbSBtZXJnZSBmdW5jdGlvbiBpcyBnaXZlbixcbiAqIHdoaWNoIGNhbiBjaGFuZ2UgaG93IHRoZSBzdXBlciBjbGFzc2VzJyB2YWx1ZSBmb3IgdGhhdCBwcm9wZXJ0eSB3aWxsIGJlIG1lcmdlZFxuICogdG9nZXRoZXIuXG4gKiBUaGUgZmluYWwgbWVyZ2VkIHZhbHVlIHdpbGwgYmUgc3RvcmVkIGluIGFub3RoZXIgcHJvcGVydHksIHNvIHRoYXQgaXQgd29uJ3RcbiAqIGJlIHJlY2FsY3VsYXRlZCBldmVuIGlmIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gY3RvciBDbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgUHJvcGVydHkgbmFtZSB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosICopOio9fSBvcHRfbWVyZ2VGbiBGdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBtZXJnZWRcbiAqICAgICB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgc28gZmFyIGFuZCB0aGUgbmV4dCB2YWx1ZSB0byBiZSBtZXJnZWQgdG8gaXQuXG4gKiAgICAgU2hvdWxkIHJldHVybiB0aGVzZSB0d28gbWVyZ2VkIHRvZ2V0aGVyLiBJZiBub3QgcGFzc2VkIHRoZSBmaW5hbCBwcm9wZXJ0eVxuICogICAgIHdpbGwgYmUgdGhlIGZpcnN0IHRydXRoeSB2YWx1ZSBhbW9uZyBhbmNlc3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IsIHByb3BlcnR5TmFtZSwgb3B0X21lcmdlRm4pIHtcbiAgdmFyIG1lcmdlZE5hbWUgPSBwcm9wZXJ0eU5hbWUgKyAnX01FUkdFRCc7XG4gIGlmICghY3Rvci5oYXNPd25Qcm9wZXJ0eShtZXJnZWROYW1lKSkge1xuICAgIHZhciBtZXJnZWQgPSBjdG9yLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgPyBjdG9yW3Byb3BlcnR5TmFtZV0gOiBudWxsO1xuICAgIGlmIChjdG9yLl9fcHJvdG9fXyAmJiAhY3Rvci5fX3Byb3RvX18uaXNQcm90b3R5cGVPZihGdW5jdGlvbikpIHtcbiAgICAgIHZhciBtZXJnZUZuID0gb3B0X21lcmdlRm4gfHwgZ2V0Rmlyc3RUcnV0aHlfO1xuICAgICAgbWVyZ2VkID0gbWVyZ2VGbihtZXJnZWQsIGdldFN0YXRpY1Byb3BlcnR5KGN0b3IuX19wcm90b19fLCBwcm9wZXJ0eU5hbWUsIG1lcmdlRm4pKTtcbiAgICB9XG4gICAgY3RvclttZXJnZWROYW1lXSA9IG1lcmdlZDtcbiAgfVxuICByZXR1cm4gY3RvclttZXJnZWROYW1lXTtcbn1cblxuLyoqXG4gKiBHZXRzIGFuIHVuaXF1ZSBpZC4gSWYgYG9wdF9vYmplY3RgIGFyZ3VtZW50IGlzIHBhc3NlZCwgdGhlIG9iamVjdCBpc1xuICogbXV0YXRlZCB3aXRoIGFuIHVuaXF1ZSBpZC4gQ29uc2VjdXRpdmUgY2FsbHMgd2l0aCB0aGUgc2FtZSBvYmplY3RcbiAqIHJlZmVyZW5jZSB3b24ndCBtdXRhdGUgdGhlIG9iamVjdCBhZ2FpbiwgaW5zdGVhZCB0aGUgY3VycmVudCBvYmplY3QgdWlkXG4gKiByZXR1cm5zLiBTZWUge0BsaW5rIFVJRF9QUk9QRVJUWX0uXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3QgT3B0aW9uYWwgb2JqZWN0IHRvIGJlIG11dGF0ZWQgd2l0aCB0aGUgdWlkLiBJZlxuICogICAgIG5vdCBzcGVjaWZpZWQgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIHRoZSB1aWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfbm9Jbmhlcml0YW5jZSBPcHRpb25hbCBmbGFnIGluZGljYXRpbmcgaWYgdGhpc1xuICogICAgIG9iamVjdCdzIHVpZCBwcm9wZXJ0eSBjYW4gYmUgaW5oZXJpdGVkIGZyb20gcGFyZW50cyBvciBub3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gKi9cbmZ1bmN0aW9uIGdldFVpZChvcHRfb2JqZWN0LCBvcHRfbm9Jbmhlcml0YW5jZSkge1xuICBpZiAob3B0X29iamVjdCkge1xuICAgIHZhciBpZCA9IG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXTtcbiAgICBpZiAob3B0X25vSW5oZXJpdGFuY2UgJiYgIW9wdF9vYmplY3QuaGFzT3duUHJvcGVydHkoVUlEX1BST1BFUlRZKSkge1xuICAgICAgaWQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaWQgfHwgKG9wdF9vYmplY3RbVUlEX1BST1BFUlRZXSA9IHVuaXF1ZUlkQ291bnRlcl8rKyk7XG4gIH1cbiAgcmV0dXJuIHVuaXF1ZUlkQ291bnRlcl8rKztcbn1cblxuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uIFJldHVybnMgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqPX0gb3B0X3JldHVyblZhbHVlIFRoZSBzaW5nbGUgdmFsdWUgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7P30gVGhlIGZpcnN0IGFyZ3VtZW50LlxuICovXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKG9wdF9yZXR1cm5WYWx1ZSkge1xuICByZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGJvb2xlYW4uXG4gKi9cbmZ1bmN0aW9uIGlzQm9vbGVhbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gaXNEZWYodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbm90IHVuZGVmaW5lZCBvciBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRGVmQW5kTm90TnVsbCh2YWwpIHtcbiAgcmV0dXJuIGlzRGVmKHZhbCkgJiYgIWlzTnVsbCh2YWwpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQtZnJhZ21lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb20gZWxlbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBudWxsLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVsbCh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgbnVtYmVyLlxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHdpbmRvdy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1dpbmRvdyh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB2YWwgPT09IHZhbC53aW5kb3c7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiBUaGlzIGluY2x1ZGVzIGFycmF5c1xuICogYW5kIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcbiAgcmV0dXJuIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIFByb21pc2UuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHZhbCBpbnN0YW5jZW9mIFN0cmluZztcbn1cblxuLyoqXG4gKiBTZXRzIHRvIHRydWUgaWYgcnVubmluZyBpbnNpZGUgTm9kZS5qcyBlbnZpcm9ubWVudCB3aXRoIGV4dHJhIGNoZWNrIGZvclxuICogYHByb2Nlc3MuYnJvd3NlcmAgdG8gc2tpcCBLYXJtYSBydW5uZXIgZW52aXJvbm1lbnQuIEthcm1hIGVudmlyb25tZW50IGhhc1xuICogYHByb2Nlc3NgIGRlZmluZWQgZXZlbiB0aG91Z2ggaXQgcnVucyBvbiB0aGUgYnJvd3Nlci5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2VydmVyU2lkZSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcHJvY2Vzcy5lbnYgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiYgIXByb2Nlc3MuYnJvd3Nlcjtcbn1cblxuLyoqXG4gKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xuZnVuY3Rpb24gbnVsbEZ1bmN0aW9uKCkge31cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qc1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhhcnJheSwgbnVsbCwgW3tcblx0XHRrZXk6ICdlcXVhbCcsXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdFx0aWYgKGFycjEgPT09IGFycjIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHshQXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmlyc3REZWZpbmVkVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuICAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmbGF0dGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdFx0dmFyIHJ2ID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG4gICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzbGljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHRcdHZhciBlbmQgPSAoMCwgX2NvcmUuaXNEZWYpKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNsaWNlZDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFycmF5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXN0YXRlL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xudmFyIGFzeW5jID0ge307XG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgZXhjZXB0aW9uO1xuXHR9KTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfHVuZGVmaW5lZH0gc2NvcGVcbiAqL1xuYXN5bmMucnVuLldvcmtJdGVtXyA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHR2YXIgY2IgPSBjYWxsYmFjaztcblx0aWYgKG9wdF9jb250ZXh0KSB7XG5cdFx0Y2IgPSBjYWxsYmFjay5iaW5kKG9wdF9jb250ZXh0KTtcblx0fVxuXHRjYiA9IGFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18oY2IpO1xuXHQvLyBJbnRyb2R1Y2VkIGFuZCBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSUUxMC5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IpO1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBMb29rIGZvciBhbmQgY2FjaGUgdGhlIGN1c3RvbSBmYWxsYmFjayB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZS5cblx0aWYgKCFhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKSB7XG5cdFx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IGFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXygpO1xuXHR9XG5cdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8oY2IpO1xufTtcblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gQ3JlYXRlIGEgcHJpdmF0ZSBtZXNzYWdlIGNoYW5uZWwgYW5kIHVzZSBpdCB0byBwb3N0TWVzc2FnZSBlbXB0eSBtZXNzYWdlc1xuXHQvLyB0byBvdXJzZWx2ZXMuXG5cdHZhciBDaGFubmVsID0gdm9pZCAwO1xuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRDaGFubmVsID0gTWVzc2FnZUNoYW5uZWw7XG5cdH1cblxuXHQvLyBJZiBNZXNzYWdlQ2hhbm5lbCBpcyBub3QgYXZhaWxhYmxlIGFuZCB3ZSBhcmUgaW4gYSBicm93c2VyLCBpbXBsZW1lbnRcblx0Ly8gYW4gaWZyYW1lIGJhc2VkIHBvbHlmaWxsIGluIGJyb3dzZXJzIHRoYXQgaGF2ZSBwb3N0TWVzc2FnZSBhbmRcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci4gVGhlIGxhdHRlciBleGNsdWRlcyBJRTggYmVjYXVzZSBpdCBoYXMgYVxuXHQvLyBzeW5jaHJvbm91cyBwb3N0TWVzc2FnZSBpbXBsZW1lbnRhdGlvbi5cblx0aWYgKHR5cGVvZiBDaGFubmVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uIENoYW5uZWwoKSB7XG5cdFx0XHQvLyBNYWtlIGFuIGVtcHR5LCBpbnZpc2libGUgaWZyYW1lLlxuXHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gJyc7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcblx0XHRcdHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cdFx0XHRkb2Mub3BlbigpO1xuXHRcdFx0ZG9jLndyaXRlKCcnKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSAnY2FsbEltbWVkaWF0ZScgKyBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dmFyIG9yaWdpbiA9IHdpbi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW4ubG9jYXRpb24uaG9zdDtcblx0XHRcdHZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSgpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHRhaWwubmV4dCA9IHtcblx0XHRcdFx0Y2I6IGNiXG5cdFx0XHR9O1xuXHRcdFx0dGFpbCA9IHRhaWwubmV4dDtcblx0XHRcdGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fVxuXHQvLyBJbXBsZW1lbnRhdGlvbiBmb3IgSUU2LTg6IFNjcmlwdCBlbGVtZW50cyBmaXJlIGFuIGFzeW5jaHJvbm91c1xuXHQvLyBvbnJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG5cdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXAgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxuXHRcdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0Y2IgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdH07XG5cdH1cblx0Ly8gRmFsbCBiYWNrIHRvIHNldFRpbWVvdXQgd2l0aCAwLiBJbiBicm93c2VycyB0aGlzIGNyZWF0ZXMgYSBkZWxheSBvZiA1bXNcblx0Ly8gb3IgbW9yZS5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbiAob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhc3luYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3Bvc2FibGUpO1xuXG5cdFx0LyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHRoaXMuZGlzcG9zZWRfID0gZmFsc2U7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKERpc3Bvc2FibGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpY1xuICAgKiBkaXNwb3NpbmcgbG9naWMgKGxpa2UgY2xlYXJpbmcgcmVmZXJlbmNlcyBhbmQgY2FsbGluZyBgZGlzcG9zZWAgb24gb3RoZXJcbiAgICogZGlzcG9zYWJsZXMpLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNEaXNwb3NlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERpc3Bvc2FibGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3Bvc2FibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9kaXNwb3NhYmxlL0Rpc3Bvc2FibGUuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKG9iamVjdCwgbnVsbCwgW3tcblx0XHRrZXk6ICdtaXhpbicsXG5cblx0XHQvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBUaGUgb2JqZWN0cyBmcm9tIHdoaWNoIHZhbHVlcyB3aWxsIGJlIGNvcGllZC5cbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1peGluKHRhcmdldCkge1xuXHRcdFx0dmFyIGtleSA9IHZvaWQgMCxcblx0XHRcdCAgICBzb3VyY2UgPSB2b2lkIDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGZvciAoa2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGJhc2VkIG9uIGl0cyBmdWxseSBxdWFsaWZpZWQgZXh0ZXJuYWwgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge29iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgPGNvZGU+d2luZG93PC9jb2RlPi5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRPYmplY3RCeU5hbWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRPYmplY3RCeU5hbWUobmFtZSwgb3B0X29iaikge1xuXHRcdFx0dmFyIHNjb3BlID0gb3B0X29iaiB8fCB3aW5kb3c7XG5cdFx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0XHRyZXR1cm4gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChwYXJ0LCBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRba2V5XTtcblx0XHRcdH0sIHNjb3BlKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIHRoZSBnaXZlbiBvbmUsIGJ1dCB3aXRoXG4gICAqIHRoZWlyIHZhbHVlcyBzZXQgdG8gdGhlIHJldHVybiB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAqKX0gZm5cbiAgICogQHJldHVybiB7IU9iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ21hcCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIG1hcChvYmosIGZuKSB7XG5cdFx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXBwZWRPYmo7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdHdvIGdpdmVuIG9iamVjdHMgYXJlIGVxdWFsLiBUaGlzIGlzIGRvbmUgdmlhIGEgc2hhbGxvd1xuICAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaGFsbG93RXF1YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdFx0aWYgKG9iajEgPT09IG9iajIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuXHRcdFx0dmFyIGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG5cdFx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChvYmoxW2tleXMxW2ldXSAhPT0gb2JqMltrZXlzMVtpXV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBvYmplY3Q7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gc3RyaW5nKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdHJpbmcpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKHN0cmluZywgbnVsbCwgW3tcblx0XHRrZXk6ICdjYXNlSW5zZW5zaXRpdmVDb21wYXJlJyxcblxuXHRcdC8qKlxuICAgKiBDb21wYXJlcyB0aGUgZ2l2ZW4gc3RyaW5ncyB3aXRob3V0IHRha2luZyB0aGUgY2FzZSBpbnRvIGFjY291bnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjJcbiAgICogQHJldHVybiB7bnVtYmVyfSBFaXRoZXIgLTEsIDAgb3IgMSwgYWNjb3JkaW5nIHRvIGlmIHRoZSBmaXJzdCBzdHJpbmcgaXNcbiAgICogICAgIFwic21hbGxlclwiLCBlcXVhbCBvciBcImJpZ2dlclwiIHRoYW4gdGhlIHNlY29uZCBnaXZlbiBzdHJpbmcuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYXNlSW5zZW5zaXRpdmVDb21wYXJlKHN0cjEsIHN0cjIpIHtcblx0XHRcdHZhciB0ZXN0MSA9IFN0cmluZyhzdHIxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIHRlc3QyID0gU3RyaW5nKHN0cjIpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICh0ZXN0MSA8IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0gZWxzZSBpZiAodGVzdDEgPT09IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuICAgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gICAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb2xsYXBzZUJyZWFraW5nU3BhY2VzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG4gICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcbiAgKiAgICAgdG8gb25lLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZXNjYXBlUmVnZXgnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy0oKVxcW1xcXXt9Kz8qLiRcXF58LDojPCFcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJhbmRvbVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcbiAgICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2VcbiAgICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG4gICAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cbiAgICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNoQ29kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc2hDb2RlKHZhbCkge1xuXHRcdFx0dmFyIGhhc2ggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG4gICAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VJbnRlcnZhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gc3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX3ZhbGlkYXRvcnMgPSByZXF1aXJlKCcuL3ZhbGlkYXRvcnMnKTtcblxudmFyIF92YWxpZGF0b3JzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZhbGlkYXRvcnMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFN1Z2FyIGFwaSB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIGZvciBtYW51YWxseSBidWlsZGluZyBgU3RhdGVgXG4gKiBjb25maWd1cmF0aW9uIGluIHRoZSBleHBlY3RlZCBmb3JtYXQuIEZvciBleGFtcGxlLCBpbnN0ZWFkIG9mIGhhdmluZ1xuICogc29tZXRoaW5nIGxpa2UgdGhpczpcbiAqXG4gKiBgYGBqc1xuICogTXlDbGFzcy5TVEFURSA9IHtcbiAqICAgZm9vOiB7XG4gKiAgICAgcmVxdWlyZWQ6IHRydWUsXG4gKiAgICAgdmFsaWRhdG9yOiB2YWxpZGF0b3JzLm51bWJlcixcbiAqICAgICB2YWx1ZTogMTNcbiAqICAgfVxuICogfTtcbiAqIGBgYFxuICpcbiAqIFlvdSBjb3VsZCBpbnN0ZWFkIGRvOlxuICpcbiAqIGBgYGpzXG4gKiBNeUNsYXNzLlNUQVRFID0ge1xuICogICBmb286IENvbmZpZy5yZXF1aXJlZCgpLm51bWJlcigpLnZhbHVlKDEzKVxuICogfTtcbiAqIGBgYFxuICovXG52YXIgQ29uZmlnID0ge1xuXHQvKipcbiAqIEFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICogQHR5cGVkZWYgeyFPYmplY3R9IENvbmZpZ1dpdGhWYWxpZGF0b3JcbiAqL1xuXG5cdC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBgU3RhdGVgIG9iamVjdCB3aXRoIGFuIGBhbnlgIHZhbGlkYXRvci5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRhbnk6IHNldFByaW1pdGl2ZVZhbGlkYXRvcnMoJ2FueScpLFxuXG5cdC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBgU3RhdGVgIG9iamVjdCB3aXRoIGFuIGBhcnJheWAgdmFsaWRhdG9yLlxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdGFycmF5OiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdhcnJheScpLFxuXG5cdC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBgU3RhdGVgIG9iamVjdCB3aXRoIGFuIGBhcnJheU9mYCB2YWxpZGF0b3IuXG4gICogQHBhcmFtIHtDb25maWdXaXRoVmFsaWRhdG9yfSBzdGF0ZUNvbmZpZyBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0YXJyYXlPZjogc2V0TmVzdGVkVmFsaWRhdG9ycygnYXJyYXlPZicpLFxuXG5cdC8qKlxuICAqIEZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBgU3RhdGVgIG9iamVjdCB3aXRoIGEgYGJvb2xgIHZhbGlkYXRvci5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRib29sOiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdib29sJyksXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYSBgZnVuY2AgdmFsaWRhdG9yLlxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdGZ1bmM6IHNldFByaW1pdGl2ZVZhbGlkYXRvcnMoJ2Z1bmMnKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgaW5zdGFuY2VPZmAgdmFsaWRhdG9yLlxuICAqIEByZXR1cm4ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdGluc3RhbmNlT2Y6IHNldEV4cGxpY2l0VmFsdWVWYWxpZGF0b3JzKCdpbnN0YW5jZU9mJyksXG5cblx0LyoqXG4gICogRnVuY3Rpb24gdGhhdCBjcmVhdGVzIGBTdGF0ZWAgb2JqZWN0IHdpdGggYSBgbnVtYmVyYCB2YWxpZGF0b3IuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0bnVtYmVyOiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdudW1iZXInKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgb2JqZWN0YCB2YWxpZGF0b3IuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0b2JqZWN0OiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdvYmplY3QnKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgb2JqZWN0T2ZgIHZhbGlkYXRvci5cbiAgKiBAcGFyYW0ge0NvbmZpZ1dpdGhWYWxpZGF0b3J9IHN0YXRlQ29uZmlnIGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRvYmplY3RPZjogc2V0TmVzdGVkVmFsaWRhdG9ycygnb2JqZWN0T2YnKSxcblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgb25lT2ZgIHZhbGlkYXRvci5cbiAgKiBAcGFyYW0geyFBcnJheX0gdmFsdWVzIGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRvbmVPZjogc2V0RXhwbGljaXRWYWx1ZVZhbGlkYXRvcnMoJ29uZU9mJyksXG5cblx0LyoqXG4gICogQ3JlYXRlcyBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggYW4gYG9uZU9mVHlwZWAgdmFsaWRhdG9yLlxuICAqIEBwYXJhbSB7Q29uZmlnV2l0aFZhbGlkYXRvcltdfSB2YWxpZGF0b3JBcnJheSBBcnJheSBvZiBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRvbmVPZlR5cGU6IGZ1bmN0aW9uIG9uZU9mVHlwZSh2YWxpZGF0b3JBcnJheSkge1xuXHRcdHZhbGlkYXRvckFycmF5ID0gdmFsaWRhdG9yQXJyYXkubWFwKGZ1bmN0aW9uIChjb25maWdPYmopIHtcblx0XHRcdHJldHVybiBjb25maWdPYmouY29uZmlnLnZhbGlkYXRvcjtcblx0XHR9KTtcblxuXHRcdHJldHVybiB0aGlzLnZhbGlkYXRvcihfdmFsaWRhdG9yczIuZGVmYXVsdC5vbmVPZlR5cGUodmFsaWRhdG9yQXJyYXkpKTtcblx0fSxcblxuXG5cdC8qKlxuICAqIENyZWF0ZXMgYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdCB3aXRoIGEgYHNoYXBlT2ZgIHZhbGlkYXRvci5cbiAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywgQ29uZmlnV2l0aFZhbGlkYXRvcj59IHNoYXBlT2JqIFZhbHVlcyBiZWluZyBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAgKiBAcmV0dXJuIHtDb25maWdXaXRoVmFsaWRhdG9yfSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24gb2JqZWN0LlxuICAqL1xuXHRzaGFwZU9mOiBmdW5jdGlvbiBzaGFwZU9mKHNoYXBlT2JqKSB7XG5cdFx0c2hhcGVPYmogPSBkZXN0cnVjdFNoYXBlT2ZDb25maWdzKHNoYXBlT2JqKTtcblxuXHRcdHJldHVybiB0aGlzLnZhbGlkYXRvcihfdmFsaWRhdG9yczIuZGVmYXVsdC5zaGFwZU9mKHNoYXBlT2JqKSk7XG5cdH0sXG5cblxuXHQvKipcbiAgKiBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYFN0YXRlYCBvYmplY3Qgd2l0aCBhbiBgc3RyaW5nYCB2YWxpZGF0b3IuXG4gICogQHJldHVybiB7Q29uZmlnV2l0aFZhbGlkYXRvcn0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0c3RyaW5nOiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKCdzdHJpbmcnKSxcblxuXHQvKipcbiAgKiBBZGRzIHRoZSBgaW50ZXJuYWxgIGZsYWcgdG8gdGhlIGBTdGF0ZWAgY29uZmlndXJhdGlvbi5cbiAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlcXVpcmVkIEZsYWcgdG8gc2V0IFwiaW50ZXJuYWxcIiB0by4gVHJ1ZSBieSBkZWZhdWx0LlxuICAqIEByZXR1cm4geyFPYmplY3R9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdGludGVybmFsOiBmdW5jdGlvbiBpbnRlcm5hbCgpIHtcblx0XHR2YXIgX2ludGVybmFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG5cdFx0cmV0dXJuIG1lcmdlQ29uZmlnKHRoaXMsIHtcblx0XHRcdGludGVybmFsOiBfaW50ZXJuYWxcblx0XHR9KTtcblx0fSxcblxuXG5cdC8qKlxuICAqIEFkZHMgdGhlIGByZXF1aXJlZGAgZmxhZyB0byB0aGUgYFN0YXRlYCBjb25maWd1cmF0aW9uLlxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVxdWlyZWQgRmxhZyB0byBzZXQgXCJyZXF1aXJlZFwiIHRvLiBUcnVlIGJ5IGRlZmF1bHQuXG4gICogQHJldHVybiB7IU9iamVjdH0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0cmVxdWlyZWQ6IGZ1bmN0aW9uIHJlcXVpcmVkKCkge1xuXHRcdHZhciBfcmVxdWlyZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG5cblx0XHRyZXR1cm4gbWVyZ2VDb25maWcodGhpcywge1xuXHRcdFx0cmVxdWlyZWQ6IF9yZXF1aXJlZFxuXHRcdH0pO1xuXHR9LFxuXG5cblx0LyoqXG4gICogQWRkcyBhIHNldHRlciB0byB0aGUgYFN0YXRlYCBjb25maWd1cmF0aW9uLlxuICAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IHNldHRlclxuICAqIEByZXR1cm4geyFPYmplY3R9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdHNldHRlcjogZnVuY3Rpb24gc2V0dGVyKF9zZXR0ZXIpIHtcblx0XHRyZXR1cm4gbWVyZ2VDb25maWcodGhpcywge1xuXHRcdFx0c2V0dGVyOiBfc2V0dGVyXG5cdFx0fSk7XG5cdH0sXG5cblxuXHQvKipcbiAgKiBBZGRzIGEgdmFsaWRhdG9yIHRvIHRoZSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24uXG4gICogQHBhcmFtIHshZnVuY3Rpb24oKX0gdmFsaWRhdG9yXG4gICogQHJldHVybiB7IU9iamVjdH0gYFN0YXRlYCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgKi9cblx0dmFsaWRhdG9yOiBmdW5jdGlvbiB2YWxpZGF0b3IoX3ZhbGlkYXRvcikge1xuXHRcdHJldHVybiBtZXJnZUNvbmZpZyh0aGlzLCB7XG5cdFx0XHR2YWxpZGF0b3I6IF92YWxpZGF0b3Jcblx0XHR9KTtcblx0fSxcblxuXG5cdC8qKlxuICAqIEFkZHMgYSBkZWZhdWx0IHZhbHVlIHRvIHRoZSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24uXG4gICogQHBhcmFtIHsqfSB2YWx1ZVxuICAqIEByZXR1cm4geyFPYmplY3R9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfdmFsdWUpIHtcblx0XHRyZXR1cm4gbWVyZ2VDb25maWcodGhpcywge1xuXHRcdFx0dmFsdWU6IF92YWx1ZVxuXHRcdH0pO1xuXHR9LFxuXG5cblx0LyoqXG4gICogQWRkcyBhIHZhbHVlRm4gdGhhdCB3aWxsIHJldHVybiBhIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBgU3RhdGVgIGNvbmZpZ3VyYXRpb24uXG4gICogQHBhcmFtIHshZnVuY3Rpb24oKX0gdmFsdWVGblxuICAqIEByZXR1cm4geyFPYmplY3R9IGBTdGF0ZWAgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICovXG5cdHZhbHVlRm46IGZ1bmN0aW9uIHZhbHVlRm4oX3ZhbHVlRm4pIHtcblx0XHRyZXR1cm4gbWVyZ2VDb25maWcodGhpcywge1xuXHRcdFx0dmFsdWVGbjogX3ZhbHVlRm5cblx0XHR9KTtcblx0fVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBzZXRzIHZhbGlkYXRvcnMgZm9yIHNoYXBlT2YuXG4gKiBAcGFyYW0geyFPYmplY3R9IHNoYXBlIFRoZSBzaGFwZSBvZiBzcGVjaWZpYyB0eXBlcy5cbiAqIEByZXR1cm4geyFPYmplY3R9IFNoYXBlIG9iamVjdCB3aXRoIHZhbGlkYXRvcnMgYXMgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBkZXN0cnVjdFNoYXBlT2ZDb25maWdzKHNoYXBlKSB7XG5cdHZhciBrZXlzID0gT2JqZWN0LmtleXMoc2hhcGUpO1xuXG5cdHZhciByZXRTaGFwZSA9IHt9O1xuXG5cdGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0dmFyIHZhbHVlID0gc2hhcGVba2V5XTtcblxuXHRcdHJldFNoYXBlW2tleV0gPSB2YWx1ZS5jb25maWcgJiYgdmFsdWUuY29uZmlnLnZhbGlkYXRvciA/IHZhbHVlLmNvbmZpZy52YWxpZGF0b3IgOiBkZXN0cnVjdFNoYXBlT2ZDb25maWdzKHZhbHVlKTtcblx0fSk7XG5cblx0cmV0dXJuIHJldFNoYXBlO1xufVxuXG4vKipcbiAqIE1lcmdlcyB0aGUgZ2l2ZW4gY29uZmlnIG9iamVjdCBpbnRvIHRoZSBvbmUgdGhhdCBoYXMgYmVlbiBidWlsdCBzbyBmYXIuXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbnRleHQgVGhlIG9iamVjdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyFPYmplY3R9IGNvbmZpZyBUaGUgb2JqZWN0IHRvIG1lcmdlIHRvIHRoZSBidWlsdCBjb25maWcuXG4gKiBAcmV0dXJuIHshT2JqZWN0fSBUaGUgZmluYWwgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGJ1aWx0IGNvbmZpZy5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VDb25maWcoY29udGV4dCwgY29uZmlnKSB7XG5cdHZhciBvYmogPSBjb250ZXh0O1xuXHRpZiAob2JqID09PSBDb25maWcpIHtcblx0XHRvYmogPSBPYmplY3QuY3JlYXRlKENvbmZpZyk7XG5cdFx0b2JqLmNvbmZpZyA9IHt9O1xuXHR9XG5cdF9tZXRhbC5vYmplY3QubWl4aW4ob2JqLmNvbmZpZywgY29uZmlnKTtcblx0cmV0dXJuIG9iajtcbn1cblxuLyoqXG4qIENhbGxzIHZhbGlkYXRvcnMgd2l0aCBwcm92aWRlZCBhcmd1bWVudC5cbiogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHZhbGlkYXRvci5cbiogQHBhcmFtIHshZnVuY3Rpb24oKX1cbiovXG5mdW5jdGlvbiBzZXRFeHBsaWNpdFZhbHVlVmFsaWRhdG9ycyhuYW1lKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsaWRhdG9yKF92YWxpZGF0b3JzMi5kZWZhdWx0W25hbWVdKGFyZykpO1xuXHR9O1xufVxuXG4vKipcbiogQ2FsbHMgdmFsaWRhdG9ycyB3aXRoIGEgc2luZ2xlIG5lc3RlZCBjb25maWcuXG4qIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSB2YWxpZGF0b3IuXG4qIEByZXR1cm4geyFmdW5jdGlvbigpfVxuKi9cbmZ1bmN0aW9uIHNldE5lc3RlZFZhbGlkYXRvcnMobmFtZSkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuXHRcdHJldHVybiB0aGlzLnZhbGlkYXRvcihfdmFsaWRhdG9yczIuZGVmYXVsdFtuYW1lXShhcmcuY29uZmlnLnZhbGlkYXRvcikpO1xuXHR9O1xufVxuXG4vKipcbiogQWRkcyBwcmltaXRpdmUgdHlwZSB2YWxpZGF0b3JzIHRvIHRoZSBjb25maWcgb2JqZWN0LlxuKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdmFsaWRhdG9yLlxuKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiovXG5mdW5jdGlvbiBzZXRQcmltaXRpdmVWYWxpZGF0b3JzKG5hbWUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy52YWxpZGF0b3IoX3ZhbGlkYXRvcnMyLmRlZmF1bHRbbmFtZV0pO1xuXHR9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBDb25maWc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc3RhdGUvbGliL0NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbnZhciBfbWV0YWwgPSByZXF1aXJlKCdtZXRhbCcpO1xuXG52YXIgX21ldGFsRXZlbnRzID0gcmVxdWlyZSgnbWV0YWwtZXZlbnRzJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBTdGF0ZSBhZGRzIHN1cHBvcnQgZm9yIGhhdmluZyBvYmplY3QgcHJvcGVydGllcyB0aGF0IGNhbiBiZSB3YXRjaGVkIGZvclxuICogY2hhbmdlcywgYXMgd2VsbCBhcyBjb25maWd1cmVkIHdpdGggdmFsaWRhdG9ycywgc2V0dGVycyBhbmQgb3RoZXIgb3B0aW9ucy5cbiAqIFNlZSB0aGUgYGNvbmZpZ1N0YXRlYCBtZXRob2QgZm9yIGEgY29tcGxldGUgbGlzdCBvZiBhdmFpbGFibGUgY29uZmlndXJhdGlvblxuICogb3B0aW9ucyBmb3IgZWFjaCBzdGF0ZSBrZXkuXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICovXG52YXIgU3RhdGUgPSBmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuXHRfaW5oZXJpdHMoU3RhdGUsIF9FdmVudEVtaXR0ZXIpO1xuXG5cdC8qKlxuICAqIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciBgU3RhdGVgLlxuICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X2NvbmZpZyBPcHRpb25hbCBjb25maWcgb2JqZWN0IHdpdGggaW5pdGlhbCB2YWx1ZXMgdG9cbiAgKiAgICAgc2V0IHN0YXRlIHByb3BlcnRpZXMgdG8uXG4gICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqIE9wdGlvbmFsIG9iamVjdCB0aGF0IHNob3VsZCBob2xkIHRoZSBzdGF0ZVxuICAqICAgICBwcm9wZXJ0aWVzLiBJZiBub25lIGlzIGdpdmVuLCB0aGV5IHdpbGwgYmUgYWRkZWQgZGlyZWN0bHkgdG8gYHRoaXNgXG4gICogICAgIGluc3RlYWQuXG4gICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGNhbGwgZnVuY3Rpb25zIChsaWtlXG4gICogICAgIHZhbGlkYXRvcnMgYW5kIHNldHRlcnMpIG9uLiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICovXG5cdGZ1bmN0aW9uIFN0YXRlKG9wdF9jb25maWcsIG9wdF9vYmosIG9wdF9jb250ZXh0KSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRlKTtcblxuXHRcdC8qKlxuICAgKiBDb250ZXh0IHRvIGNhbGwgZnVuY3Rpb25zIChsaWtlIHZhbGlkYXRvcnMgYW5kIHNldHRlcnMpIG9uLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU3RhdGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdGF0ZSkpLmNhbGwodGhpcykpO1xuXG5cdFx0X3RoaXMuY29udGV4dF8gPSBvcHRfY29udGV4dCB8fCBfdGhpcztcblxuXHRcdC8qKlxuICAgKiBNYXAgb2Yga2V5cyB0aGF0IGNhbiBub3QgYmUgdXNlZCBhcyBzdGF0ZSBrZXlzLlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMua2V5c0JsYWNrbGlzdF8gPSBudWxsO1xuXG5cdFx0LyoqXG4gICAqIE9iamVjdCB0aGF0IHNob3VsZCBob2xkIHRoZSBzdGF0ZSBwcm9wZXJ0aWVzLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5vYmpfID0gb3B0X29iaiB8fCBfdGhpcztcblxuXHRcdF90aGlzLmV2ZW50RGF0YV8gPSBudWxsO1xuXG5cdFx0LyoqXG4gICAqIE9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBiYXRjaCBldmVudCB0aGF0IGlzIGN1cnJlbnRseVxuICAgKiBzY2hlZHVsZWQsIG9yIG51bGwgaWYgbm9uZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHRfdGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfID0gbnVsbDtcblxuXHRcdC8qKlxuICAgKiBPYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBhbGwgdGhpcyBpbnN0YW5jZSdzIHN0YXRlIGtleXMuXG4gICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU9iamVjdD59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cdFx0X3RoaXMuc3RhdGVJbmZvXyA9IHt9O1xuXG5cdFx0X3RoaXMuc3RhdGVDb25maWdzXyA9IHt9O1xuXG5cdFx0X3RoaXMuaW5pdGlhbFZhbHVlc18gPSBfbWV0YWwub2JqZWN0Lm1peGluKHt9LCBvcHRfY29uZmlnKTtcblxuXHRcdF90aGlzLnNldFNob3VsZFVzZUZhY2FkZSh0cnVlKTtcblx0XHRfdGhpcy5jb25maWdTdGF0ZUZyb21TdGF0aWNIaW50XygpO1xuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzLm9ial8sIFN0YXRlLlNUQVRFX1JFRl9LRVksIHtcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0dmFsdWU6IF90aGlzXG5cdFx0fSk7XG5cdFx0cmV0dXJuIF90aGlzO1xuXHR9XG5cblx0LyoqXG4gICogTG9ncyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gcHJvcGVydHkgaXMgcmVxdWlyZWQgYnV0IHdhc24ndCBnaXZlbi5cbiAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAqIEBwcm90ZWN0ZWRcbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhTdGF0ZSwgW3tcblx0XHRrZXk6ICdhc3NlcnRHaXZlbklmUmVxdWlyZWRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0R2l2ZW5JZlJlcXVpcmVkXyhuYW1lKSB7XG5cdFx0XHR2YXIgY29uZmlnID0gdGhpcy5zdGF0ZUNvbmZpZ3NfW25hbWVdO1xuXHRcdFx0aWYgKGNvbmZpZy5yZXF1aXJlZCkge1xuXHRcdFx0XHR2YXIgaW5mbyA9IHRoaXMuZ2V0U3RhdGVJbmZvKG5hbWUpO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBpbmZvLnN0YXRlID09PSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaRUQgPyB0aGlzLmdldChuYW1lKSA6IHRoaXMuaW5pdGlhbFZhbHVlc19bbmFtZV07XG5cdFx0XHRcdGlmICghKDAsIF9tZXRhbC5pc0RlZkFuZE5vdE51bGwpKHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhciBlcnJvck1lc3NhZ2UgPSAnVGhlIHByb3BlcnR5IGNhbGxlZCBcIicgKyBuYW1lICsgJ1wiIGlzIHJlcXVpcmVkIGJ1dCBkaWRuXFwndCByZWNlaXZlIGEgdmFsdWUuJztcblx0XHRcdFx0XHRpZiAodGhpcy5zaG91bGRUaHJvd1ZhbGlkYXRpb25FcnJvcigpKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBMb2dzIGFuIGVycm9yIGlmIHRoZSBgdmFsaWRhdG9yUmV0dXJuYCBpcyBpbnN0YW5jZSBvZiBgRXJyb3JgLlxuICAgKiBAcGFyYW0geyp9IHZhbGlkYXRvclJldHVyblxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdhc3NlcnRWYWxpZGF0b3JSZXR1cm5JbnN0YW5jZU9mRXJyb3JfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0VmFsaWRhdG9yUmV0dXJuSW5zdGFuY2VPZkVycm9yXyh2YWxpZGF0b3JSZXR1cm4pIHtcblx0XHRcdGlmICh2YWxpZGF0b3JSZXR1cm4gaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0XHRpZiAodGhpcy5zaG91bGRUaHJvd1ZhbGlkYXRpb25FcnJvcigpKSB7XG5cdFx0XHRcdFx0dGhyb3cgdmFsaWRhdG9yUmV0dXJuO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1dhcm5pbmc6ICcgKyB2YWxpZGF0b3JSZXR1cm4pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyB0aGF0IHRoZSBnaXZlbiBuYW1lIGlzIGEgdmFsaWQgc3RhdGUga2V5IG5hbWUuIElmIGl0J3Mgbm90LCBhbiBlcnJvclxuICAgKiB3aWxsIGJlIHRocm93bi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnYXNzZXJ0VmFsaWRTdGF0ZUtleU5hbWVfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0VmFsaWRTdGF0ZUtleU5hbWVfKG5hbWUpIHtcblx0XHRcdGlmICh0aGlzLmtleXNCbGFja2xpc3RfICYmIHRoaXMua2V5c0JsYWNrbGlzdF9bbmFtZV0pIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJdFxcJ3Mgbm90IGFsbG93ZWQgdG8gY3JlYXRlIGEgc3RhdGUga2V5IHdpdGggdGhlIG5hbWUgXCInICsgbmFtZSArICdcIi4nKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogQnVpbGRzIHRoZSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2J1aWxkS2V5UHJvcGVydHlEZWZfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gYnVpbGRLZXlQcm9wZXJ0eURlZl8obmFtZSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpc1tTdGF0ZS5TVEFURV9SRUZfS0VZXS5nZXRTdGF0ZUtleVZhbHVlXyhuYW1lKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG5cdFx0XHRcdFx0dGhpc1tTdGF0ZS5TVEFURV9SRUZfS0VZXS5zZXRTdGF0ZUtleVZhbHVlXyhuYW1lLCB2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxscyB0aGUgcmVxdWVzdGVkIGZ1bmN0aW9uLCBydW5uaW5nIHRoZSBhcHByb3ByaWF0ZSBjb2RlIGZvciB3aGVuIGl0J3NcbiAgICogcGFzc2VkIGFzIGFuIGFjdHVhbCBmdW5jdGlvbiBvYmplY3Qgb3IganVzdCB0aGUgZnVuY3Rpb24ncyBuYW1lLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbnxzdHJpbmd9IGZuIEZ1bmN0aW9uLCBvciBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBydW4uXG4gICAqIEBwYXJhbSB7IUFycmF5fSBBbiBvcHRpb25hbCBhcnJheSBvZiBwYXJhbWV0ZXJzIHRvIGJlIHBhc3NlZCB0byB0aGVcbiAgICogICBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkLlxuICAgKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBjYWxsZWQgZnVuY3Rpb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NhbGxGdW5jdGlvbl8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYWxsRnVuY3Rpb25fKGZuLCBhcmdzKSB7XG5cdFx0XHRpZiAoKDAsIF9tZXRhbC5pc1N0cmluZykoZm4pKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmNvbnRleHRfW2ZuXS5hcHBseSh0aGlzLmNvbnRleHRfLCBhcmdzKTtcblx0XHRcdH0gZWxzZSBpZiAoKDAsIF9tZXRhbC5pc0Z1bmN0aW9uKShmbikpIHtcblx0XHRcdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXMuY29udGV4dF8sIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDYWxscyB0aGUgc3RhdGUga2V5J3Mgc2V0dGVyLCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHsqfSBjdXJyZW50VmFsdWUgVGhlIGN1cnJlbnQgdmFsdWUuXG4gICAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCB2YWx1ZSB0byBiZSBzZXQuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NhbGxTZXR0ZXJfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FsbFNldHRlcl8obmFtZSwgdmFsdWUsIGN1cnJlbnRWYWx1ZSkge1xuXHRcdFx0dmFyIGNvbmZpZyA9IHRoaXMuc3RhdGVDb25maWdzX1tuYW1lXTtcblx0XHRcdGlmIChjb25maWcuc2V0dGVyKSB7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5jYWxsRnVuY3Rpb25fKGNvbmZpZy5zZXR0ZXIsIFt2YWx1ZSwgY3VycmVudFZhbHVlXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGxzIHRoZSBzdGF0ZSBrZXkncyB2YWxpZGF0b3IsIGlmIHRoZXJlIGlzIG9uZS4gRW1pdHMgY29uc29sZVxuICAgKiB3YXJuaW5nIGlmIHZhbGlkYXRvciByZXR1cm5zIGEgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IEZsYWcgaW5kaWNhdGluZyBpZiB2YWx1ZSBpcyB2YWxpZCBvciBub3QuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NhbGxWYWxpZGF0b3JfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FsbFZhbGlkYXRvcl8obmFtZSwgdmFsdWUpIHtcblx0XHRcdHZhciBjb25maWcgPSB0aGlzLnN0YXRlQ29uZmlnc19bbmFtZV07XG5cdFx0XHRpZiAoY29uZmlnLnZhbGlkYXRvcikge1xuXHRcdFx0XHR2YXIgdmFsaWRhdG9yUmV0dXJuID0gdGhpcy5jYWxsRnVuY3Rpb25fKGNvbmZpZy52YWxpZGF0b3IsIFt2YWx1ZSwgbmFtZSwgdGhpcy5jb250ZXh0X10pO1xuXHRcdFx0XHR0aGlzLmFzc2VydFZhbGlkYXRvclJldHVybkluc3RhbmNlT2ZFcnJvcl8odmFsaWRhdG9yUmV0dXJuKTtcblx0XHRcdFx0cmV0dXJuIHZhbGlkYXRvclJldHVybjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGl0J3MgYWxsb3dlZCB0byB3cml0ZSBvbiB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NhblNldFN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FuU2V0U3RhdGUobmFtZSkge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdHJldHVybiAhdGhpcy5zdGF0ZUNvbmZpZ3NfW25hbWVdLndyaXRlT25jZSB8fCAhaW5mby53cml0dGVuO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBrZXkocykgdG8gdGhlIHN0YXRlLCB0b2dldGhlciB3aXRoIGl0cyh0aGVpcikgY29uZmlncy5cbiAgICogQ29uZmlnIG9iamVjdHMgc3VwcG9ydCB0aGUgZ2l2ZW4gc2V0dGluZ3M6XG4gICAqICAgICByZXF1aXJlZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgY2F1c2VzIGVycm9ycyB0byBiZSBwcmludGVkICh2aWFcbiAgICogICAgIGBjb25zb2xlLmVycm9yYCkgaWYgbm8gdmFsdWUgaXMgZ2l2ZW4gZm9yIHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogICAgIHNldHRlciAtIEZ1bmN0aW9uIGZvciBub3JtYWxpemluZyBzdGF0ZSBrZXkgdmFsdWVzLiBJdCByZWNlaXZlcyB0aGUgbmV3XG4gICAqICAgICB2YWx1ZSB0aGF0IHdhcyBzZXQsIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSBzdG9yZWQuXG4gICAqXG4gICAqICAgICB2YWxpZGF0b3IgLSBGdW5jdGlvbiB0aGF0IHZhbGlkYXRlcyBzdGF0ZSBrZXkgdmFsdWVzLiBXaGVuIGl0IHJldHVybnNcbiAgICogICAgIGZhbHNlLCB0aGUgbmV3IHZhbHVlIGlzIGlnbm9yZWQuIFdoZW4gaXQgcmV0dXJucyBhbiBpbnN0YW5jZSBvZiBFcnJvcixcbiAgICogICAgIGl0IHdpbGwgZW1pdCB0aGUgZXJyb3IgdG8gdGhlIGNvbnNvbGUuXG4gICAqXG4gICAqICAgICB2YWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgc3RhdGUga2V5LiBOb3RlIHRoYXQgc2V0dGluZyB0aGlzIHRvXG4gICAqICAgICBhbiBvYmplY3Qgd2lsbCBjYXVzZSBhbGwgY2xhc3MgaW5zdGFuY2VzIHRvIHVzZSB0aGUgc2FtZSByZWZlcmVuY2UgdG9cbiAgICogICAgIHRoZSBvYmplY3QuIFRvIGhhdmUgZWFjaCBpbnN0YW5jZSB1c2UgYSBkaWZmZXJlbnQgcmVmZXJlbmNlIGZvciBvYmplY3RzLFxuICAgKiAgICAgdXNlIHRoZSBgdmFsdWVGbmAgb3B0aW9uIGluc3RlYWQuXG4gICAqXG4gICAqICAgICB2YWx1ZUZuIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIGEgc3RhdGUga2V5LlxuICAgKlxuICAgKiAgICAgd3JpdGVPbmNlIC0gSWdub3JlcyB3cml0ZXMgdG8gdGhlIHN0YXRlIGtleSBhZnRlciBpdCdzIGJlZW4gZmlyc3RcbiAgICogICAgIHdyaXR0ZW4gdG8uIFRoYXQgaXMsIGFsbG93cyB3cml0ZXMgb25seSB3aGVuIHNldHRpbmcgdGhlIHZhbHVlIGZvciB0aGVcbiAgICogICAgIGZpcnN0IHRpbWUuXG4gICAqIEBwYXJhbSB7IU9iamVjdC48c3RyaW5nLCAhT2JqZWN0PnxzdHJpbmd9IGNvbmZpZ3MgQW4gb2JqZWN0IHRoYXQgbWFwc1xuICAgKiAgICAgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBrZXlzIHRvIGJlIGFkZGVkIHRvIHRoZSBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufE9iamVjdHwqPX0gb3B0X2NvbnRleHQgVGhlIGNvbnRleHQgd2hlcmUgdGhlIGFkZGVkIHN0YXRlXG4gICAqICAgICBrZXlzIHdpbGwgYmUgZGVmaW5lZCAoZGVmYXVsdHMgdG8gYHRoaXNgKSwgb3IgZmFsc2UgaWYgdGhleSBzaG91bGRuJ3RcbiAgICogICAgIGJlIGRlZmluZWQgYXQgYWxsLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29uZmlnU3RhdGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjb25maWdTdGF0ZShjb25maWdzLCBvcHRfY29udGV4dCkge1xuXHRcdFx0dmFyIG5hbWVzID0gT2JqZWN0LmtleXMoY29uZmlncyk7XG5cdFx0XHRpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdF9jb250ZXh0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHR2YXIgcHJvcHMgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBuYW1lID0gbmFtZXNbaV07XG5cdFx0XHRcdFx0dGhpcy5hc3NlcnRWYWxpZFN0YXRlS2V5TmFtZV8obmFtZSk7XG5cdFx0XHRcdFx0cHJvcHNbbmFtZV0gPSB0aGlzLmJ1aWxkS2V5UHJvcGVydHlEZWZfKG5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9wdF9jb250ZXh0IHx8IHRoaXMub2JqXywgcHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnN0YXRlQ29uZmlnc18gPSBjb25maWdzO1xuXHRcdFx0Zm9yICh2YXIgX2kgPSAwOyBfaSA8IG5hbWVzLmxlbmd0aDsgX2krKykge1xuXHRcdFx0XHR2YXIgX25hbWUgPSBuYW1lc1tfaV07XG5cdFx0XHRcdGNvbmZpZ3NbX25hbWVdID0gY29uZmlnc1tfbmFtZV0uY29uZmlnID8gY29uZmlnc1tfbmFtZV0uY29uZmlnIDogY29uZmlnc1tfbmFtZV07XG5cdFx0XHRcdHRoaXMuYXNzZXJ0R2l2ZW5JZlJlcXVpcmVkXyhuYW1lc1tfaV0pO1xuXHRcdFx0XHR0aGlzLnZhbGlkYXRlSW5pdGlhbFZhbHVlXyhuYW1lc1tfaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBBZGRzIHN0YXRlIGtleXMgZnJvbSBzdXBlciBjbGFzc2VzIHN0YXRpYyBoaW50IGBNeUNsYXNzLlNUQVRFID0ge307YC5cbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgIU9iamVjdD49fSBvcHRfY29uZmlnIEFuIG9iamVjdCB0aGF0IG1hcHMgYWxsIHRoZVxuICAgKiAgICAgY29uZmlndXJhdGlvbnMgZm9yIHN0YXRlIGtleXMuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2NvbmZpZ1N0YXRlRnJvbVN0YXRpY0hpbnRfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29uZmlnU3RhdGVGcm9tU3RhdGljSGludF8oKSB7XG5cdFx0XHR2YXIgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG5cdFx0XHRpZiAoY3RvciAhPT0gU3RhdGUpIHtcblx0XHRcdFx0dmFyIGRlZmluZUNvbnRleHQgPSB2b2lkIDA7XG5cdFx0XHRcdGlmICh0aGlzLm9ial8gPT09IHRoaXMpIHtcblx0XHRcdFx0XHRkZWZpbmVDb250ZXh0ID0gY3Rvci5oYXNDb25maWd1cmVkU3RhdGVfID8gZmFsc2UgOiBjdG9yLnByb3RvdHlwZTtcblx0XHRcdFx0XHRjdG9yLmhhc0NvbmZpZ3VyZWRTdGF0ZV8gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY29uZmlnU3RhdGUoU3RhdGUuZ2V0U3RhdGVTdGF0aWMoY3RvciksIGRlZmluZUNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge1xuXHRcdFx0X2dldChTdGF0ZS5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTdGF0ZS5wcm90b3R5cGUpLCAnZGlzcG9zZUludGVybmFsJywgdGhpcykuY2FsbCh0aGlzKTtcblx0XHRcdHRoaXMuaW5pdGlhbFZhbHVlc18gPSBudWxsO1xuXHRcdFx0dGhpcy5zdGF0ZUluZm9fID0gbnVsbDtcblx0XHRcdHRoaXMuc3RhdGVDb25maWdzXyA9IG51bGw7XG5cdFx0XHR0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8gPSBudWxsO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBFbWl0cyB0aGUgc3RhdGUgY2hhbmdlIGJhdGNoIGV2ZW50LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdlbWl0QmF0Y2hFdmVudF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlbWl0QmF0Y2hFdmVudF8oKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNEaXNwb3NlZCgpKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gdGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfO1xuXHRcdFx0XHR0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8gPSBudWxsO1xuXHRcdFx0XHR0aGlzLmNvbnRleHRfLmVtaXQoJ3N0YXRlQ2hhbmdlZCcsIGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cbiAgICogTm90ZTogdGhpcyBjYW4gYW5kIHNob3VsZCBiZSBhY2NvbXBsaXNoZWQgYnkgYWNjZXNzaW5nIHRoZSB2YWx1ZSBhcyBhXG4gICAqIHJlZ3VsYXIgcHJvcGVydHkuIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbiBjYXNlcyB3aGVyZSBhIGZ1bmN0aW9uIGlzXG4gICAqIGFjdHVhbGx5IG5lZWRlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5vYmpfW25hbWVdO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IG1hcHMgc3RhdGUga2V5cyB0byB0aGVpciB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPj19IG9wdF9uYW1lcyBBIGxpc3Qgb2YgbmFtZXMgb2YgdGhlIGtleXMgdGhhdCBzaG91bGRcbiAgICogICBiZSByZXR1cm5lZC4gSWYgbm9uZSBpcyBnaXZlbiwgdGhlIHdob2xlIHN0YXRlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge09iamVjdC48c3RyaW5nLCAqPn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdGUob3B0X25hbWVzKSB7XG5cdFx0XHR2YXIgc3RhdGUgPSB7fTtcblx0XHRcdHZhciBuYW1lcyA9IG9wdF9uYW1lcyB8fCB0aGlzLmdldFN0YXRlS2V5cygpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHN0YXRlW25hbWVzW2ldXSA9IHRoaXMuZ2V0KG5hbWVzW2ldKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzcGVjaWZpZWQgc3RhdGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4geyFPYmplY3R9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdGF0ZUluZm8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUluZm8obmFtZSkge1xuXHRcdFx0aWYgKCF0aGlzLnN0YXRlSW5mb19bbmFtZV0pIHtcblx0XHRcdFx0dGhpcy5zdGF0ZUluZm9fW25hbWVdID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZUluZm9fW25hbWVdO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSBjb25maWcgb2JqZWN0IGZvciB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGtleSdzIG5hbWUuXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZ2V0U3RhdGVLZXlDb25maWcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUtleUNvbmZpZyhuYW1lKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZUNvbmZpZ3NfID8gdGhpcy5zdGF0ZUNvbmZpZ3NfW25hbWVdIDogbnVsbDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCBzdGF0ZSBrZXlzLlxuICAgKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZz59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdGF0ZUtleXMnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZUtleXMoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5zdGF0ZUNvbmZpZ3NfID8gT2JqZWN0LmtleXModGhpcy5zdGF0ZUNvbmZpZ3NfKSA6IFtdO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIHN0YXRlIGtleS4gVGhpcyBpcyBwYXNzZWQgYXMgdGhhdCBrZXknc1xuICAgKiBnZXR0ZXIgdG8gdGhlIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIGNhbGwgaW5zaWRlIHRoZSBgYWRkS2V5VG9TdGF0ZWAgbWV0aG9kLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRTdGF0ZUtleVZhbHVlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlS2V5VmFsdWVfKG5hbWUpIHtcblx0XHRcdGlmICghdGhpcy53YXJuSWZEaXNwb3NlZF8obmFtZSkpIHtcblx0XHRcdFx0dGhpcy5pbml0U3RhdGVLZXlfKG5hbWUpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5nZXRTdGF0ZUluZm8obmFtZSkudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE1lcmdlcyB0aGUgU1RBVEUgc3RhdGljIHZhcmlhYmxlIGZvciB0aGUgZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSAgeyFGdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIG1lcmdlIGhhcHBlbnMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzQmVlblNldCcsXG5cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIG9mIHRoZSBzdGF0ZSBrZXkgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBoYXMgYWxyZWFkeSBiZWVuXG4gICAqIHNldC4gTm90ZSB0aGF0IHRoaXMgZG9lc24ndCBydW4gdGhlIGtleSdzIGdldHRlci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc0JlZW5TZXQobmFtZSkge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdHJldHVybiBpbmZvLnN0YXRlID09PSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaRUQgfHwgdGhpcy5oYXNJbml0aWFsVmFsdWVfKG5hbWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgYW4gaW5pdGlhbCB2YWx1ZSB3YXMgZ2l2ZW4gdG8gdGhlIHNwZWNpZmllZCBzdGF0ZSBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzSW5pdGlhbFZhbHVlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc0luaXRpYWxWYWx1ZV8obmFtZSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlc18uaGFzT3duUHJvcGVydHkobmFtZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4ga2V5IGlzIHByZXNlbnQgaW4gdGhpcyBpbnN0YW5jZSdzIHN0YXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNTdGF0ZUtleScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc1N0YXRlS2V5KGtleSkge1xuXHRcdFx0aWYgKCF0aGlzLndhcm5JZkRpc3Bvc2VkXyhrZXkpKSB7XG5cdFx0XHRcdHJldHVybiAhIXRoaXMuc3RhdGVDb25maWdzX1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBJbmZvcm1zIG9mIGNoYW5nZXMgdG8gYSBzdGF0ZSBrZXkncyB2YWx1ZSB0aHJvdWdoIGFuIGV2ZW50LiBXb24ndCB0cmlnZ2VyXG4gICAqIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQgb3IgaWYgaXQncyBiZWluZyBpbml0aWFsaXplZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHBhcmFtIHsqfSBwcmV2VmFsIFRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpbmZvcm1DaGFuZ2VfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaW5mb3JtQ2hhbmdlXyhuYW1lLCBwcmV2VmFsKSB7XG5cdFx0XHRpZiAodGhpcy5zaG91bGRJbmZvcm1DaGFuZ2VfKG5hbWUsIHByZXZWYWwpKSB7XG5cdFx0XHRcdHZhciBkYXRhID0gX21ldGFsLm9iamVjdC5taXhpbih7XG5cdFx0XHRcdFx0a2V5OiBuYW1lLFxuXHRcdFx0XHRcdG5ld1ZhbDogdGhpcy5nZXQobmFtZSksXG5cdFx0XHRcdFx0cHJldlZhbDogcHJldlZhbFxuXHRcdFx0XHR9LCB0aGlzLmV2ZW50RGF0YV8pO1xuXHRcdFx0XHR0aGlzLmNvbnRleHRfLmVtaXQobmFtZSArICdDaGFuZ2VkJywgZGF0YSk7XG5cdFx0XHRcdHRoaXMuY29udGV4dF8uZW1pdCgnc3RhdGVLZXlDaGFuZ2VkJywgZGF0YSk7XG5cdFx0XHRcdHRoaXMuc2NoZWR1bGVCYXRjaEV2ZW50XyhkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXksIGdpdmluZyBpdCBhIGZpcnN0IHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdpbml0U3RhdGVLZXlfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdFN0YXRlS2V5XyhuYW1lKSB7XG5cdFx0XHR2YXIgaW5mbyA9IHRoaXMuZ2V0U3RhdGVJbmZvKG5hbWUpO1xuXHRcdFx0aWYgKGluZm8uc3RhdGUgIT09IFN0YXRlLktleVN0YXRlcy5VTklOSVRJQUxJWkVEKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aW5mby5zdGF0ZSA9IFN0YXRlLktleVN0YXRlcy5JTklUSUFMSVpJTkc7XG5cdFx0XHR0aGlzLnNldEluaXRpYWxWYWx1ZV8obmFtZSk7XG5cdFx0XHRpZiAoIWluZm8ud3JpdHRlbikge1xuXHRcdFx0XHR0aGlzLnNldERlZmF1bHRWYWx1ZShuYW1lKTtcblx0XHRcdH1cblx0XHRcdGluZm8uc3RhdGUgPSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaRUQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIE1lcmdlcyB0d28gdmFsdWVzIGZvciB0aGUgU1RBVEUgcHJvcGVydHkgaW50byBhIHNpbmdsZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXJnZWRWYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGN1cnJWYWxcbiAgICogQHJldHVybiB7IU9iamVjdH0gVGhlIG1lcmdlZCB2YWx1ZS5cbiAgICogQHN0YXRpY1xuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlU3RhdGVLZXknLFxuXG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgcmVxdWVzdGVkIHN0YXRlIGtleS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVN0YXRlS2V5KG5hbWUpIHtcblx0XHRcdHRoaXMuc3RhdGVJbmZvX1tuYW1lXSA9IG51bGw7XG5cdFx0XHR0aGlzLnN0YXRlQ29uZmlnc19bbmFtZV0gPSBudWxsO1xuXHRcdFx0ZGVsZXRlIHRoaXMub2JqX1tuYW1lXTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2NoZWR1bGVzIGEgc3RhdGUgY2hhbmdlIGJhdGNoIGV2ZW50IHRvIGJlIGVtaXR0ZWQgYXN5bmNocm9ub3VzbHkuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlRGF0YSBJbmZvcm1hdGlvbiBhYm91dCBhIHN0YXRlIGtleSdzIHVwZGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2NoZWR1bGVCYXRjaEV2ZW50XycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlQmF0Y2hFdmVudF8oY2hhbmdlRGF0YSkge1xuXHRcdFx0aWYgKCF0aGlzLnNjaGVkdWxlZEJhdGNoRGF0YV8pIHtcblx0XHRcdFx0X21ldGFsLmFzeW5jLm5leHRUaWNrKHRoaXMuZW1pdEJhdGNoRXZlbnRfLCB0aGlzKTtcblx0XHRcdFx0dGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfID0gX21ldGFsLm9iamVjdC5taXhpbih7XG5cdFx0XHRcdFx0Y2hhbmdlczoge31cblx0XHRcdFx0fSwgdGhpcy5ldmVudERhdGFfKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIG5hbWUgPSBjaGFuZ2VEYXRhLmtleTtcblx0XHRcdHZhciBjaGFuZ2VzID0gdGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfLmNoYW5nZXM7XG5cdFx0XHRpZiAoY2hhbmdlc1tuYW1lXSkge1xuXHRcdFx0XHRjaGFuZ2VzW25hbWVdLm5ld1ZhbCA9IGNoYW5nZURhdGEubmV3VmFsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hhbmdlc1tuYW1lXSA9IGNoYW5nZURhdGE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgc3RhdGUga2V5LlxuICAgKiBOb3RlOiB0aGlzIGNhbiBhbmQgc2hvdWxkIGJlIGFjY29tcGxpc2hlZCBieSBzZXR0aW5nIHRoZSBzdGF0ZSBrZXkgYXMgYVxuICAgKiByZWd1bGFyIHByb3BlcnR5LiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBmdW5jdGlvbiBpc1xuICAgKiBhY3R1YWxseSBuZWVkZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7Kn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuXHRcdFx0aWYgKHRoaXMuaGFzU3RhdGVLZXkobmFtZSkpIHtcblx0XHRcdFx0dGhpcy5vYmpfW25hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgdmFsdWUgb2YgdGhlIHJlcXVlc3RlZCBzdGF0ZSBrZXkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXREZWZhdWx0VmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobmFtZSkge1xuXHRcdFx0dmFyIGNvbmZpZyA9IHRoaXMuc3RhdGVDb25maWdzX1tuYW1lXTtcblxuXHRcdFx0aWYgKGNvbmZpZy52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuc2V0KG5hbWUsIGNvbmZpZy52YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldChuYW1lLCB0aGlzLmNhbGxGdW5jdGlvbl8oY29uZmlnLnZhbHVlRm4pKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyBkYXRhIHRvIGJlIHNlbnQgd2l0aCBhbGwgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge09iamVjdH1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldEV2ZW50RGF0YScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldEV2ZW50RGF0YShkYXRhKSB7XG5cdFx0XHR0aGlzLmV2ZW50RGF0YV8gPSBkYXRhO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSByZXF1ZXN0ZWQgc3RhdGUga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUga2V5LlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRJbml0aWFsVmFsdWVfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0SW5pdGlhbFZhbHVlXyhuYW1lKSB7XG5cdFx0XHRpZiAodGhpcy5oYXNJbml0aWFsVmFsdWVfKG5hbWUpKSB7XG5cdFx0XHRcdHRoaXMuc2V0KG5hbWUsIHRoaXMuaW5pdGlhbFZhbHVlc19bbmFtZV0pO1xuXHRcdFx0XHR0aGlzLmluaXRpYWxWYWx1ZXNfW25hbWVdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIGEgbWFwIG9mIGtleXMgdGhhdCBhcmUgbm90IHZhbGlkIHN0YXRlIGtleXMuXG4gICAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2V0S2V5c0JsYWNrbGlzdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldEtleXNCbGFja2xpc3QoYmxhY2tsaXN0KSB7XG5cdFx0XHR0aGlzLmtleXNCbGFja2xpc3RfID0gYmxhY2tsaXN0O1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhbGwgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXlzLlxuICAgKiBAcGFyYW0geyFPYmplY3QuPHN0cmluZywqPn0gdmFsdWVzIEEgbWFwIG9mIHN0YXRlIGtleXMgdG8gdGhlIHZhbHVlcyB0aGV5XG4gICAqICAgc2hvdWxkIGJlIHNldCB0by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpPX0gb3B0X2NhbGxiYWNrIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBydW5cbiAgICogICBhZnRlciB0aGUgbmV4dCBiYXRjaGVkIHVwZGF0ZSBpcyB0cmlnZ2VyZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzZXRTdGF0ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHZhbHVlcywgb3B0X2NhbGxiYWNrKSB7XG5cdFx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdFx0T2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdHJldHVybiBfdGhpczIuc2V0KG5hbWUsIHZhbHVlc1tuYW1lXSk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChvcHRfY2FsbGJhY2sgJiYgdGhpcy5zY2hlZHVsZWRCYXRjaERhdGFfKSB7XG5cdFx0XHRcdHRoaXMuY29udGV4dF8ub25jZSgnc3RhdGVDaGFuZ2VkJywgb3B0X2NhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBzdGF0ZSBrZXkuIFRoaXMgaXMgcGFzc2VkIGFzIHRoYXQga2V5J3NcbiAgICogc2V0dGVyIHRvIHRoZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBjYWxsIGluc2lkZSB0aGUgYGFkZEtleVRvU3RhdGVgXG4gICAqIG1ldGhvZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGtleS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgbmV3IHZhbHVlIG9mIHRoZSBrZXkuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFN0YXRlS2V5VmFsdWVfJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGVLZXlWYWx1ZV8obmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0aGlzLndhcm5JZkRpc3Bvc2VkXyhuYW1lKSB8fCAhdGhpcy5jYW5TZXRTdGF0ZShuYW1lKSB8fCAhdGhpcy52YWxpZGF0ZUtleVZhbHVlXyhuYW1lLCB2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcHJldlZhbCA9IHRoaXMuZ2V0KG5hbWUpO1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdGluZm8udmFsdWUgPSB0aGlzLmNhbGxTZXR0ZXJfKG5hbWUsIHZhbHVlLCBwcmV2VmFsKTtcblx0XHRcdHRoaXMuYXNzZXJ0R2l2ZW5JZlJlcXVpcmVkXyhuYW1lKTtcblx0XHRcdGluZm8ud3JpdHRlbiA9IHRydWU7XG5cdFx0XHR0aGlzLmluZm9ybUNoYW5nZV8obmFtZSwgcHJldlZhbCk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENoZWNrcyBpZiB3ZSBzaG91bGQgaW5mb3JtIGFib3V0IGEgc3RhdGUgdXBkYXRlLiBVcGRhdGVzIGFyZSBpZ25vcmVkIGR1cmluZ1xuICAgKiBzdGF0ZSBpbml0aWFsaXphdGlvbi4gT3RoZXJ3aXNlLCB1cGRhdGVzIHRvIHByaW1pdGl2ZSB2YWx1ZXMgYXJlIG9ubHlcbiAgICogaW5mb3JtZWQgd2hlbiB0aGUgbmV3IHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBwcmV2aW91cyBvbmUuIFVwZGF0ZXMgdG9cbiAgICogb2JqZWN0cyAod2hpY2ggaW5jbHVkZXMgZnVuY3Rpb25zIGFuZCBhcnJheXMpIGFyZSBhbHdheXMgaW5mb3JtZWQgb3V0c2lkZVxuICAgKiBpbml0aWFsaXphdGlvbiB0aG91Z2gsIHNpbmNlIHdlIGNhbid0IGJlIHN1cmUgaWYgYWxsIG9mIHRoZSBpbnRlcm5hbCBkYXRhXG4gICAqIGhhcyBzdGF5ZWQgdGhlIHNhbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7Kn0gcHJldlZhbCBUaGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnc2hvdWxkSW5mb3JtQ2hhbmdlXycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNob3VsZEluZm9ybUNoYW5nZV8obmFtZSwgcHJldlZhbCkge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdHJldHVybiBpbmZvLnN0YXRlID09PSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaRUQgJiYgKCgwLCBfbWV0YWwuaXNPYmplY3QpKHByZXZWYWwpIHx8IHByZXZWYWwgIT09IHRoaXMuZ2V0KG5hbWUpKTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHNob3VsZCB0aHJvdyBlcnJvciB3aGVuXG4gICAqIHZhaWxkYXRvciBmdW5jdGlvbnMgcmV0dXJucyBhbiBgRXJyb3JgIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBCeSBkZWZhdWx0IHJldHVybnMgZmFsc2UuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzaG91bGRUaHJvd1ZhbGlkYXRpb25FcnJvcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNob3VsZFRocm93VmFsaWRhdGlvbkVycm9yKCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBzdGF0ZSBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd2YWxpZGF0ZUluaXRpYWxWYWx1ZV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUluaXRpYWxWYWx1ZV8obmFtZSkge1xuXHRcdFx0aWYgKHRoaXMuaGFzSW5pdGlhbFZhbHVlXyhuYW1lKSAmJiAhdGhpcy5jYWxsVmFsaWRhdG9yXyhuYW1lLCB0aGlzLmluaXRpYWxWYWx1ZXNfW25hbWVdKSkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5pbml0aWFsVmFsdWVzX1tuYW1lXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVmFsaWRhdGVzIHRoZSBzdGF0ZSBrZXkncyB2YWx1ZSwgd2hpY2ggaW5jbHVkZXMgY2FsbGluZyB0aGUgdmFsaWRhdG9yXG4gICAqIGRlZmluZWQgaW4gdGhlIGtleSdzIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBpZiB0aGVyZSBpcyBvbmUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBrZXkuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gRmxhZyBpbmRpY2F0aW5nIGlmIHZhbHVlIGlzIHZhbGlkIG9yIG5vdC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAndmFsaWRhdGVLZXlWYWx1ZV8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZUtleVZhbHVlXyhuYW1lLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmdldFN0YXRlSW5mbyhuYW1lKTtcblx0XHRcdHJldHVybiBpbmZvLnN0YXRlID09PSBTdGF0ZS5LZXlTdGF0ZXMuSU5JVElBTElaSU5HIHx8IHRoaXMuY2FsbFZhbGlkYXRvcl8obmFtZSwgdmFsdWUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBXYXJucyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGJlIGFjY2Vzc2VkIGlmIG5vdCBkaXNwb3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBkaXNwb3NlZCwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICd3YXJuSWZEaXNwb3NlZF8nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB3YXJuSWZEaXNwb3NlZF8obmFtZSkge1xuXHRcdFx0dmFyIGRpc3Bvc2VkID0gdGhpcy5pc0Rpc3Bvc2VkKCk7XG5cdFx0XHRpZiAoZGlzcG9zZWQpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdFcnJvci4gVHJ5aW5nIHRvIGFjY2VzcyBwcm9wZXJ0eSBcIicgKyBuYW1lICsgJ1wiIG9uIGRpc3Bvc2VkIGluc3RhbmNlJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGlzcG9zZWQ7XG5cdFx0fVxuXHR9XSwgW3tcblx0XHRrZXk6ICdnZXRTdGF0ZVN0YXRpYycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlU3RhdGljKGN0b3IpIHtcblx0XHRcdHJldHVybiAoMCwgX21ldGFsLmdldFN0YXRpY1Byb3BlcnR5KShjdG9yLCAnU1RBVEUnLCBTdGF0ZS5tZXJnZVN0YXRlKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdtZXJnZVN0YXRlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWVyZ2VTdGF0ZShtZXJnZWRWYWwsIGN1cnJWYWwpIHtcblx0XHRcdHJldHVybiBfbWV0YWwub2JqZWN0Lm1peGluKHt9LCBjdXJyVmFsLCBtZXJnZWRWYWwpO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBTdGF0ZTtcbn0oX21ldGFsRXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cblN0YXRlLlNUQVRFX1JFRl9LRVkgPSAnX19NRVRBTF9TVEFURV9SRUZfS0VZX18nO1xuXG4vKipcbiAqIENvbnN0YW50cyB0aGF0IHJlcHJlc2VudCB0aGUgc3RhdGVzIHRoYXQgYSBzdGF0ZSBrZXkgY2FuIGJlIGluLlxuICogQHR5cGUgeyFPYmplY3R9XG4gKi9cblN0YXRlLktleVN0YXRlcyA9IHtcblx0VU5JTklUSUFMSVpFRDogdW5kZWZpbmVkLFxuXHRJTklUSUFMSVpJTkc6IDEsXG5cdElOSVRJQUxJWkVEOiAyXG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zdGF0ZS9saWIvU3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9tZXRhbCA9IHJlcXVpcmUoJ21ldGFsJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogVGhlIGNvbXBvbmVudCByZWdpc3RyeSBpcyB1c2VkIHRvIHJlZ2lzdGVyIGNvbXBvbmVudHMsIHNvIHRoZXkgY2FuXG4gKiBiZSBhY2Nlc3NpYmxlIGJ5IG5hbWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgQ29tcG9uZW50UmVnaXN0cnkgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIENvbXBvbmVudFJlZ2lzdHJ5KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb25lbnRSZWdpc3RyeSk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3MoQ29tcG9uZW50UmVnaXN0cnksIG51bGwsIFt7XG5cdFx0a2V5OiAnZ2V0Q29uc3RydWN0b3InLFxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gY29tcG9uZW50IG5hbWUsIG9yXG4gICAqIHVuZGVmaW5lZCBpZiBpdCBoYXNuJ3QgYmVlbiByZWdpc3RlcmVkIHlldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGNvbXBvbmVudCdzIG5hbWUuXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbigpfVxuICAgKiBAc3RhdGljXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRDb25zdHJ1Y3RvcihuYW1lKSB7XG5cdFx0XHR2YXIgY29uc3RydWN0b3JGbiA9IENvbXBvbmVudFJlZ2lzdHJ5LmNvbXBvbmVudHNfW25hbWVdO1xuXHRcdFx0aWYgKCFjb25zdHJ1Y3RvckZuKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1RoZXJlXFwncyBubyBjb25zdHJ1Y3RvciByZWdpc3RlcmVkIGZvciB0aGUgY29tcG9uZW50IG5hbWVkICcgKyBuYW1lICsgJy5cXG5cXHRcXHRcXHRcXHRDb21wb25lbnRzIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCB2aWEgQ29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXIuJyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29uc3RydWN0b3JGbjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVnaXN0ZXJzIGEgY29tcG9uZW50LCBzbyBpdCBjYW4gYmUgZm91bmQgYnkgaXRzIG5hbWUuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvckZuIFRoZSBjb21wb25lbnQncyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbmFtZSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGNvbXBvbmVudC4gSWYgbm9uZSBpcyBnaXZlblxuICAgKiAgIHRoZSBuYW1lIGRlZmluZWQgYnkgdGhlIE5BTUUgc3RhdGljIHZhcmlhYmxlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLiBJZiB0aGF0XG4gICAqICAgaXNuJ3Qgc2V0IGFzIHdlbGwsIHRoZSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB3aWxsIGJlIHVzZWQuXG4gICAqIEBzdGF0aWNcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlZ2lzdGVyJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoY29uc3RydWN0b3JGbiwgb3B0X25hbWUpIHtcblx0XHRcdHZhciBuYW1lID0gb3B0X25hbWU7XG5cdFx0XHRpZiAoIW5hbWUpIHtcblx0XHRcdFx0aWYgKGNvbnN0cnVjdG9yRm4uaGFzT3duUHJvcGVydHkoJ05BTUUnKSkge1xuXHRcdFx0XHRcdG5hbWUgPSBjb25zdHJ1Y3RvckZuLk5BTUU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmFtZSA9ICgwLCBfbWV0YWwuZ2V0RnVuY3Rpb25OYW1lKShjb25zdHJ1Y3RvckZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uc3RydWN0b3JGbi5OQU1FID0gbmFtZTtcblx0XHRcdENvbXBvbmVudFJlZ2lzdHJ5LmNvbXBvbmVudHNfW25hbWVdID0gY29uc3RydWN0b3JGbjtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gQ29tcG9uZW50UmVnaXN0cnk7XG59KCk7XG5cbi8qKlxuICogSG9sZHMgYWxsIHJlZ2lzdGVyZWQgY29tcG9uZW50cywgaW5kZXhlZCBieSB0aGVpciBuYW1lcy5cbiAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgZnVuY3Rpb24oKT59XG4gKiBAcHJvdGVjdGVkXG4gKiBAc3RhdGljXG4gKi9cblxuXG5Db21wb25lbnRSZWdpc3RyeS5jb21wb25lbnRzXyA9IHt9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb25lbnRSZWdpc3RyeTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1jb21wb25lbnQvbGliL0NvbXBvbmVudFJlZ2lzdHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxucmVxdWlyZSgnbWV0YWwtaW5jcmVtZW50YWwtZG9tJyk7XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRoaXMuQ0xPU1VSRV9OT19ERVBTID0gdHJ1ZTtcbiAgdGhpcy5nb29nID0gdGhpcy5nb29nIHx8IHt9O1xuXG4gIC8vIENvcHlyaWdodCAyMDA2IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgLy9cbiAgLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAvLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgLy9cbiAgLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgLy9cbiAgLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAvLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gIC8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAvLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gIC8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gIC8qKlxuICAgKiBAZmlsZW92ZXJ2aWV3IEJvb3RzdHJhcCBmb3IgdGhlIEdvb2dsZSBKUyBMaWJyYXJ5IChDbG9zdXJlKS5cbiAgICpcbiAgICogSW4gdW5jb21waWxlZCBtb2RlIGJhc2UuanMgd2lsbCB3cml0ZSBvdXQgQ2xvc3VyZSdzIGRlcHMgZmlsZSwgdW5sZXNzIHRoZVxuICAgKiBnbG9iYWwgPGNvZGU+Q0xPU1VSRV9OT19ERVBTPC9jb2RlPiBpcyBzZXQgdG8gdHJ1ZS4gIFRoaXMgYWxsb3dzIHByb2plY3RzIHRvXG4gICAqIGluY2x1ZGUgdGhlaXIgb3duIGRlcHMgZmlsZShzKSBmcm9tIGRpZmZlcmVudCBsb2NhdGlvbnMuXG4gICAqXG4gICAqIEBhdXRob3IgYXJ2QGdvb2dsZS5jb20gKEVyaWsgQXJ2aWRzc29uKVxuICAgKlxuICAgKiBAcHJvdmlkZUdvb2dcbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IE92ZXJyaWRkZW4gdG8gdHJ1ZSBieSB0aGUgY29tcGlsZXIgd2hlblxuICAgKiAgICAgLS1wcm9jZXNzX2Nsb3N1cmVfcHJpbWl0aXZlcyBpcyBzcGVjaWZpZWQuXG4gICAqL1xuICB2YXIgQ09NUElMRUQgPSBmYWxzZTtcblxuICAvKipcbiAgICogQmFzZSBuYW1lc3BhY2UgZm9yIHRoZSBDbG9zdXJlIGxpYnJhcnkuICBDaGVja3MgdG8gc2VlIGdvb2cgaXMgYWxyZWFkeVxuICAgKiBkZWZpbmVkIGluIHRoZSBjdXJyZW50IHNjb3BlIGJlZm9yZSBhc3NpZ25pbmcgdG8gcHJldmVudCBjbG9iYmVyaW5nIGlmXG4gICAqIGJhc2UuanMgaXMgbG9hZGVkIG1vcmUgdGhhbiBvbmNlLlxuICAgKlxuICAgKiBAY29uc3RcbiAgICovXG4gIHZhciBnb29nID0gdGhpcy5nb29nIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBjb250ZXh0LiAgSW4gbW9zdCBjYXNlcyB0aGlzIHdpbGwgYmUgJ3dpbmRvdycuXG4gICAqL1xuICBnb29nLmdsb2JhbCA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIEEgaG9vayBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmaW5lIHZhbHVlcyBpbiB1bmNvbXBpbGVkIG1vZGUuXG4gICAqXG4gICAqIEluIHVuY29tcGlsZWQgbW9kZSwge0Bjb2RlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTfSBtYXkgYmUgZGVmaW5lZCBiZWZvcmVcbiAgICogbG9hZGluZyBiYXNlLmpzLiAgSWYgYSBrZXkgaXMgZGVmaW5lZCBpbiB7QGNvZGUgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVN9LFxuICAgKiB7QGNvZGUgZ29vZy5kZWZpbmV9IHdpbGwgdXNlIHRoZSB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IHZhbHVlLiAgVGhpc1xuICAgKiBhbGxvd3MgZmxhZ3MgdG8gYmUgb3ZlcndyaXR0ZW4gd2l0aG91dCBjb21waWxhdGlvbiAodGhpcyBpcyBub3JtYWxseVxuICAgKiBhY2NvbXBsaXNoZWQgd2l0aCB0aGUgY29tcGlsZXIncyBcImRlZmluZVwiIGZsYWcpLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiA8cHJlPlxuICAgKiAgIHZhciBDTE9TVVJFX1VOQ09NUElMRURfREVGSU5FUyA9IHsnZ29vZy5ERUJVRyc6IGZhbHNlfTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAoc3RyaW5nfG51bWJlcnxib29sZWFuKT58dW5kZWZpbmVkfVxuICAgKi9cbiAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVM7XG5cbiAgLyoqXG4gICAqIEEgaG9vayBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmaW5lIHZhbHVlcyBpbiB1bmNvbXBpbGVkIG9yIGNvbXBpbGVkIG1vZGUsXG4gICAqIGxpa2UgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgYnV0IGVmZmVjdGl2ZSBpbiBjb21waWxlZCBjb2RlLiAgSW5cbiAgICogdW5jb21waWxlZCBjb2RlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTIHRha2VzIHByZWNlZGVuY2UuXG4gICAqXG4gICAqIEFsc28gdW5saWtlIENMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTIHRoZSB2YWx1ZXMgbXVzdCBiZSBudW1iZXIsIGJvb2xlYW4gb3JcbiAgICogc3RyaW5nIGxpdGVyYWxzIG9yIHRoZSBjb21waWxlciB3aWxsIGVtaXQgYW4gZXJyb3IuXG4gICAqXG4gICAqIFdoaWxlIGFueSBAZGVmaW5lIHZhbHVlIG1heSBiZSBzZXQsIG9ubHkgdGhvc2Ugc2V0IHdpdGggZ29vZy5kZWZpbmUgd2lsbCBiZVxuICAgKiBlZmZlY3RpdmUgZm9yIHVuY29tcGlsZWQgY29kZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogPHByZT5cbiAgICogICB2YXIgQ0xPU1VSRV9ERUZJTkVTID0geydnb29nLkRFQlVHJzogZmFsc2V9IDtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCAoc3RyaW5nfG51bWJlcnxib29sZWFuKT58dW5kZWZpbmVkfVxuICAgKi9cbiAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9ERUZJTkVTO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkLlxuICAgKiBXQVJOSU5HOiBEbyBub3QgdXNlIHRoaXMgdG8gdGVzdCBpZiBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuIFVzZSB0aGUgaW5cbiAgICogb3BlcmF0b3IgaW5zdGVhZC5cbiAgICpcbiAgICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICAgKi9cbiAgZ29vZy5pc0RlZiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyB2b2lkIDAgYWx3YXlzIGV2YWx1YXRlcyB0byB1bmRlZmluZWQgYW5kIGhlbmNlIHdlIGRvIG5vdCBuZWVkIHRvIGRlcGVuZCBvblxuICAgIC8vIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBnbG9iYWwgdmFyaWFibGUgbmFtZWQgJ3VuZGVmaW5lZCcuXG4gICAgcmV0dXJuIHZhbCAhPT0gdm9pZCAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgYW4gb2JqZWN0IHN0cnVjdHVyZSBmb3IgdGhlIHByb3ZpZGVkIG5hbWVzcGFjZSBwYXRoLCBlbnN1cmluZyB0aGF0XG4gICAqIG5hbWVzIHRoYXQgYWxyZWFkeSBleGlzdCBhcmUgbm90IG92ZXJ3cml0dGVuLiBGb3IgZXhhbXBsZTpcbiAgICogXCJhLmIuY1wiIC0+IGEgPSB7fTthLmI9e307YS5iLmM9e307XG4gICAqIFVzZWQgYnkgZ29vZy5wcm92aWRlIGFuZCBnb29nLmV4cG9ydFN5bWJvbC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgb2JqZWN0IHRoYXQgdGhpcyBmaWxlIGRlZmluZXMuXG4gICAqIEBwYXJhbSB7Kj19IG9wdF9vYmplY3QgdGhlIG9iamVjdCB0byBleHBvc2UgYXQgdGhlIGVuZCBvZiB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0VG9FeHBvcnRUbyBUaGUgb2JqZWN0IHRvIGFkZCB0aGUgcGF0aCB0bzsgZGVmYXVsdFxuICAgKiAgICAgaXMgfGdvb2cuZ2xvYmFsfC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuZXhwb3J0UGF0aF8gPSBmdW5jdGlvbiAobmFtZSwgb3B0X29iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIGN1ciA9IG9wdF9vYmplY3RUb0V4cG9ydFRvIHx8IGdvb2cuZ2xvYmFsO1xuXG4gICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZXhoaWJpdHMgc3RyYW5nZSBiZWhhdmlvciB3aGVuIHRocm93aW5nIGVycm9ycyBmcm9tXG4gICAgLy8gbWV0aG9kcyBleHRlcm5lZCBpbiB0aGlzIG1hbm5lci4gIFNlZSB0aGUgdGVzdEV4cG9ydFN5bWJvbEV4Y2VwdGlvbnMgaW5cbiAgICAvLyBiYXNlX3Rlc3QuaHRtbCBmb3IgYW4gZXhhbXBsZS5cbiAgICBpZiAoIShwYXJ0c1swXSBpbiBjdXIpICYmIGN1ci5leGVjU2NyaXB0KSB7XG4gICAgICBjdXIuZXhlY1NjcmlwdCgndmFyICcgKyBwYXJ0c1swXSk7XG4gICAgfVxuXG4gICAgLy8gQ2VydGFpbiBicm93c2VycyBjYW5ub3QgcGFyc2UgY29kZSBpbiB0aGUgZm9ybSBmb3IoKGEgaW4gYik7IGM7KTtcbiAgICAvLyBUaGlzIHBhdHRlcm4gaXMgcHJvZHVjZWQgYnkgdGhlIEpTQ29tcGlsZXIgd2hlbiBpdCBjb2xsYXBzZXMgdGhlXG4gICAgLy8gc3RhdGVtZW50IGFib3ZlIGludG8gdGhlIGNvbmRpdGlvbmFsIGxvb3AgYmVsb3cuIFRvIHByZXZlbnQgdGhpcyBmcm9tXG4gICAgLy8gaGFwcGVuaW5nLCB1c2UgYSBmb3ItbG9vcCBhbmQgcmVzZXJ2ZSB0aGUgaW5pdCBsb2dpYyBhcyBiZWxvdy5cblxuICAgIC8vIFBhcmVudGhlc2VzIGFkZGVkIHRvIGVsaW1pbmF0ZSBzdHJpY3QgSlMgd2FybmluZyBpbiBGaXJlZm94LlxuICAgIGZvciAodmFyIHBhcnQ7IHBhcnRzLmxlbmd0aCAmJiAocGFydCA9IHBhcnRzLnNoaWZ0KCkpOykge1xuICAgICAgaWYgKCFwYXJ0cy5sZW5ndGggJiYgZ29vZy5pc0RlZihvcHRfb2JqZWN0KSkge1xuICAgICAgICAvLyBsYXN0IHBhcnQgYW5kIHdlIGhhdmUgYW4gb2JqZWN0OyB1c2UgaXRcbiAgICAgICAgY3VyW3BhcnRdID0gb3B0X29iamVjdDtcbiAgICAgIH0gZWxzZSBpZiAoY3VyW3BhcnRdKSB7XG4gICAgICAgIGN1ciA9IGN1cltwYXJ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ciA9IGN1cltwYXJ0XSA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGVmaW5lcyBhIG5hbWVkIHZhbHVlLiBJbiB1bmNvbXBpbGVkIG1vZGUsIHRoZSB2YWx1ZSBpcyByZXRyaWV2ZWQgZnJvbVxuICAgKiBDTE9TVVJFX0RFRklORVMgb3IgQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgaWYgdGhlIG9iamVjdCBpcyBkZWZpbmVkIGFuZFxuICAgKiBoYXMgdGhlIHByb3BlcnR5IHNwZWNpZmllZCwgYW5kIG90aGVyd2lzZSB1c2VkIHRoZSBkZWZpbmVkIGRlZmF1bHRWYWx1ZS5cbiAgICogV2hlbiBjb21waWxlZCB0aGUgZGVmYXVsdCBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgY29tcGlsZXJcbiAgICogb3B0aW9ucyBvciB0aGUgdmFsdWUgc2V0IGluIHRoZSBDTE9TVVJFX0RFRklORVMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZGlzdGluZ3Vpc2hlZCBuYW1lIHRvIHByb3ZpZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufSBkZWZhdWx0VmFsdWVcbiAgICovXG4gIGdvb2cuZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHZhciB2YWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgICBpZiAoZ29vZy5nbG9iYWwuQ0xPU1VSRV9VTkNPTVBJTEVEX0RFRklORVMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGdvb2cuZ2xvYmFsLkNMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTLCBuYW1lKSkge1xuICAgICAgICB2YWx1ZSA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfVU5DT01QSUxFRF9ERUZJTkVTW25hbWVdO1xuICAgICAgfSBlbHNlIGlmIChnb29nLmdsb2JhbC5DTE9TVVJFX0RFRklORVMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGdvb2cuZ2xvYmFsLkNMT1NVUkVfREVGSU5FUywgbmFtZSkpIHtcbiAgICAgICAgdmFsdWUgPSBnb29nLmdsb2JhbC5DTE9TVVJFX0RFRklORVNbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIGdvb2cuZXhwb3J0UGF0aF8obmFtZSwgdmFsdWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBERUJVRyBpcyBwcm92aWRlZCBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgZGVidWdnaW5nIGNvZGVcbiAgICogdGhhdCBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIGEgcHJvZHVjdGlvbiBqc19iaW5hcnkgY2FuIGJlIGVhc2lseSBzdHJpcHBlZFxuICAgKiBieSBzcGVjaWZ5aW5nIC0tZGVmaW5lIGdvb2cuREVCVUc9ZmFsc2UgdG8gdGhlIEpTQ29tcGlsZXIuIEZvciBleGFtcGxlLCBtb3N0XG4gICAqIHRvU3RyaW5nKCkgbWV0aG9kcyBzaG91bGQgYmUgZGVjbGFyZWQgaW5zaWRlIGFuIFwiaWYgKGdvb2cuREVCVUcpXCIgY29uZGl0aW9uYWxcbiAgICogYmVjYXVzZSB0aGV5IGFyZSBnZW5lcmFsbHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIGFuZCBpdCBpcyBkaWZmaWN1bHRcbiAgICogZm9yIHRoZSBKU0NvbXBpbGVyIHRvIHN0YXRpY2FsbHkgZGV0ZXJtaW5lIHdoZXRoZXIgdGhleSBhcmUgdXNlZC5cbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLkRFQlVHJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge3N0cmluZ30gTE9DQUxFIGRlZmluZXMgdGhlIGxvY2FsZSBiZWluZyB1c2VkIGZvciBjb21waWxhdGlvbi4gSXQgaXNcbiAgICogdXNlZCB0byBzZWxlY3QgbG9jYWxlIHNwZWNpZmljIGRhdGEgdG8gYmUgY29tcGlsZWQgaW4ganMgYmluYXJ5LiBCVUlMRCBydWxlXG4gICAqIGNhbiBzcGVjaWZ5IHRoaXMgdmFsdWUgYnkgXCItLWRlZmluZSBnb29nLkxPQ0FMRT08bG9jYWxlX25hbWU+XCIgYXMgSlNDb21waWxlclxuICAgKiBvcHRpb24uXG4gICAqXG4gICAqIFRha2UgaW50byBhY2NvdW50IHRoYXQgdGhlIGxvY2FsZSBjb2RlIGZvcm1hdCBpcyBpbXBvcnRhbnQuIFlvdSBzaG91bGQgdXNlXG4gICAqIHRoZSBjYW5vbmljYWwgVW5pY29kZSBmb3JtYXQgd2l0aCBoeXBoZW4gYXMgYSBkZWxpbWl0ZXIuIExhbmd1YWdlIG11c3QgYmVcbiAgICogbG93ZXJjYXNlLCBMYW5ndWFnZSBTY3JpcHQgLSBDYXBpdGFsaXplZCwgUmVnaW9uIC0gVVBQRVJDQVNFLlxuICAgKiBUaGVyZSBhcmUgZmV3IGV4YW1wbGVzOiBwdC1CUiwgZW4sIGVuLVVTLCBzci1MYXRpbi1CTywgemgtSGFucy1DTi5cbiAgICpcbiAgICogU2VlIG1vcmUgaW5mbyBhYm91dCBsb2NhbGUgY29kZXMgaGVyZTpcbiAgICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI1VuaWNvZGVfTGFuZ3VhZ2VfYW5kX0xvY2FsZV9JZGVudGlmaWVyc1xuICAgKlxuICAgKiBGb3IgbGFuZ3VhZ2UgY29kZXMgeW91IHNob3VsZCB1c2UgdmFsdWVzIGRlZmluZWQgYnkgSVNPIDY5My0xLiBTZWUgaXQgaGVyZVxuICAgKiBodHRwOi8vd3d3LnczLm9yZy9XQUkvRVIvSUcvZXJ0L2lzbzYzOS5odG0uIFRoZXJlIGlzIG9ubHkgb25lIGV4Y2VwdGlvbiBmcm9tXG4gICAqIHRoaXMgcnVsZTogdGhlIEhlYnJldyBsYW5ndWFnZS4gRm9yIGxlZ2FjeSByZWFzb25zIHRoZSBvbGQgY29kZSAoaXcpIHNob3VsZFxuICAgKiBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIG5ldyBjb2RlIChoZSksIHNlZSBodHRwOi8vd2lraS9NYWluL0lJSVN5bm9ueW1zLlxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuTE9DQUxFJywgJ2VuJyk7IC8vIGRlZmF1bHQgdG8gZW5cblxuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRoaXMgY29kZSBpcyBydW5uaW5nIG9uIHRydXN0ZWQgc2l0ZXMuXG4gICAqXG4gICAqIE9uIHVudHJ1c3RlZCBzaXRlcywgc2V2ZXJhbCBuYXRpdmUgZnVuY3Rpb25zIGNhbiBiZSBkZWZpbmVkIG9yIG92ZXJyaWRkZW4gYnlcbiAgICogZXh0ZXJuYWwgbGlicmFyaWVzIGxpa2UgUHJvdG90eXBlLCBEYXRlanMsIGFuZCBKUXVlcnkgYW5kIHNldHRpbmcgdGhpcyBmbGFnXG4gICAqIHRvIGZhbHNlIGZvcmNlcyBjbG9zdXJlIHRvIHVzZSBpdHMgb3duIGltcGxlbWVudGF0aW9ucyB3aGVuIHBvc3NpYmxlLlxuICAgKlxuICAgKiBJZiB5b3VyIEphdmFTY3JpcHQgY2FuIGJlIGxvYWRlZCBieSBhIHRoaXJkIHBhcnR5IHNpdGUgYW5kIHlvdSBhcmUgd2FyeSBhYm91dFxuICAgKiByZWx5aW5nIG9uIG5vbi1zdGFuZGFyZCBpbXBsZW1lbnRhdGlvbnMsIHNwZWNpZnlcbiAgICogXCItLWRlZmluZSBnb29nLlRSVVNURURfU0lURT1mYWxzZVwiIHRvIHRoZSBKU0NvbXBpbGVyLlxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuVFJVU1RFRF9TSVRFJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgYSBwcm9qZWN0IGlzIGV4cGVjdGVkIHRvIGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUuXG4gICAqXG4gICAqIFRoaXMgZGVmaW5lIGNhbiBiZSB1c2VkIHRvIHRyaWdnZXIgYWx0ZXJuYXRlIGltcGxlbWVudGF0aW9ucyBjb21wYXRpYmxlIHdpdGhcbiAgICogcnVubmluZyBpbiBFY21hU2NyaXB0IFN0cmljdCBtb2RlIG9yIHdhcm4gYWJvdXQgdW5hdmFpbGFibGUgZnVuY3Rpb25hbGl0eS5cbiAgICogQHNlZSBodHRwczovL2dvby5nbC9nNUVvSElcbiAgICpcbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLlNUUklDVF9NT0RFX0NPTVBBVElCTEUnLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgY29kZSB0aGF0IGNhbGxzIHtAbGluayBnb29nLnNldFRlc3RPbmx5fSBzaG91bGRcbiAgICogICAgIGJlIGRpc2FsbG93ZWQgaW4gdGhlIGNvbXBpbGF0aW9uIHVuaXQuXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5ESVNBTExPV19URVNUX09OTFlfQ09ERScsIENPTVBJTEVEICYmICFnb29nLkRFQlVHKTtcblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0byB1c2UgYSBDaHJvbWUgYXBwIENTUC1jb21wbGlhbnQgbWV0aG9kIGZvclxuICAgKiAgICAgbG9hZGluZyBzY3JpcHRzIHZpYSBnb29nLnJlcXVpcmUuIEBzZWUgYXBwZW5kU2NyaXB0U3JjTm9kZV8uXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5FTkFCTEVfQ0hST01FX0FQUF9TQUZFX1NDUklQVF9MT0FESU5HJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIGEgbmFtZXNwYWNlIGluIENsb3N1cmUuXG4gICAqXG4gICAqIEEgbmFtZXNwYWNlIG1heSBvbmx5IGJlIGRlZmluZWQgb25jZSBpbiBhIGNvZGViYXNlLiBJdCBtYXkgYmUgZGVmaW5lZCB1c2luZ1xuICAgKiBnb29nLnByb3ZpZGUoKSBvciBnb29nLm1vZHVsZSgpLlxuICAgKlxuICAgKiBUaGUgcHJlc2VuY2Ugb2Ygb25lIG9yIG1vcmUgZ29vZy5wcm92aWRlKCkgY2FsbHMgaW4gYSBmaWxlIGluZGljYXRlc1xuICAgKiB0aGF0IHRoZSBmaWxlIGRlZmluZXMgdGhlIGdpdmVuIG9iamVjdHMvbmFtZXNwYWNlcy5cbiAgICogUHJvdmlkZWQgc3ltYm9scyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICpcbiAgICogSW4gYWRkaXRpb24sIGdvb2cucHJvdmlkZSgpIGNyZWF0ZXMgdGhlIG9iamVjdCBzdHVicyBmb3IgYSBuYW1lc3BhY2VcbiAgICogKGZvciBleGFtcGxlLCBnb29nLnByb3ZpZGUoXCJnb29nLmZvby5iYXJcIikgd2lsbCBjcmVhdGUgdGhlIG9iamVjdFxuICAgKiBnb29nLmZvby5iYXIgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBleGlzdCkuXG4gICAqXG4gICAqIEJ1aWxkIHRvb2xzIGFsc28gc2NhbiBmb3IgcHJvdmlkZS9yZXF1aXJlL21vZHVsZSBzdGF0ZW1lbnRzXG4gICAqIHRvIGRpc2Nlcm4gZGVwZW5kZW5jaWVzLCBidWlsZCBkZXBlbmRlbmN5IGZpbGVzIChzZWUgZGVwcy5qcyksIGV0Yy5cbiAgICpcbiAgICogQHNlZSBnb29nLnJlcXVpcmVcbiAgICogQHNlZSBnb29nLm1vZHVsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgcHJvdmlkZWQgYnkgdGhpcyBmaWxlIGluIHRoZSBmb3JtXG4gICAqICAgICBcImdvb2cucGFja2FnZS5wYXJ0XCIuXG4gICAqL1xuICBnb29nLnByb3ZpZGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICghQ09NUElMRUQpIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBzYW1lIG5hbWVzcGFjZSBpc24ndCBwcm92aWRlZCB0d2ljZS5cbiAgICAgIC8vIEEgZ29vZy5tb2R1bGUvZ29vZy5wcm92aWRlIG1hcHMgYSBnb29nLnJlcXVpcmUgdG8gYSBzcGVjaWZpYyBmaWxlXG4gICAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTmFtZXNwYWNlIFwiJyArIG5hbWUgKyAnXCIgYWxyZWFkeSBkZWNsYXJlZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnb29nLmNvbnN0cnVjdE5hbWVzcGFjZV8obmFtZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBwcm92aWRlZCBieSB0aGlzIGZpbGUgaW4gdGhlIGZvcm1cbiAgICogICAgIFwiZ29vZy5wYWNrYWdlLnBhcnRcIi5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqIFRoZSBvYmplY3QgdG8gZW1iZWQgaW4gdGhlIG5hbWVzcGFjZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuY29uc3RydWN0TmFtZXNwYWNlXyA9IGZ1bmN0aW9uIChuYW1lLCBvcHRfb2JqKSB7XG4gICAgaWYgKCFDT01QSUxFRCkge1xuICAgICAgZGVsZXRlIGdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lXTtcblxuICAgICAgdmFyIG5hbWVzcGFjZSA9IG5hbWU7XG4gICAgICB3aGlsZSAobmFtZXNwYWNlID0gbmFtZXNwYWNlLnN1YnN0cmluZygwLCBuYW1lc3BhY2UubGFzdEluZGV4T2YoJy4nKSkpIHtcbiAgICAgICAgaWYgKGdvb2cuZ2V0T2JqZWN0QnlOYW1lKG5hbWVzcGFjZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBnb29nLmltcGxpY2l0TmFtZXNwYWNlc19bbmFtZXNwYWNlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZ29vZy5leHBvcnRQYXRoXyhuYW1lLCBvcHRfb2JqKTtcbiAgfTtcblxuICAvKipcbiAgICogTW9kdWxlIGlkZW50aWZpZXIgdmFsaWRhdGlvbiByZWdleHAuXG4gICAqIE5vdGU6IFRoaXMgaXMgYSBjb25zZXJ2YXRpdmUgY2hlY2ssIGl0IGlzIHZlcnkgcG9zc2libGUgdG8gYmUgbW9yZSBsZW5pZW50LFxuICAgKiAgIHRoZSBwcmltYXJ5IGV4Y2x1c2lvbiBoZXJlIGlzIFwiL1wiIGFuZCBcIlxcXCIgYW5kIGEgbGVhZGluZyBcIi5cIiwgdGhlc2VcbiAgICogICByZXN0cmljdGlvbnMgYXJlIGludGVuZGVkIHRvIGxlYXZlIHRoZSBkb29yIG9wZW4gZm9yIHVzaW5nIGdvb2cucmVxdWlyZVxuICAgKiAgIHdpdGggcmVsYXRpdmUgZmlsZSBwYXRocyByYXRoZXIgdGhhbiBtb2R1bGUgaWRlbnRpZmllcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLlZBTElEX01PRFVMRV9SRV8gPSAvXlthLXpBLVpfJF1bYS16QS1aMC05Ll8kXSokLztcblxuICAvKipcbiAgICogRGVmaW5lcyBhIG1vZHVsZSBpbiBDbG9zdXJlLlxuICAgKlxuICAgKiBNYXJrcyB0aGF0IHRoaXMgZmlsZSBtdXN0IGJlIGxvYWRlZCBhcyBhIG1vZHVsZSBhbmQgY2xhaW1zIHRoZSBuYW1lc3BhY2UuXG4gICAqXG4gICAqIEEgbmFtZXNwYWNlIG1heSBvbmx5IGJlIGRlZmluZWQgb25jZSBpbiBhIGNvZGViYXNlLiBJdCBtYXkgYmUgZGVmaW5lZCB1c2luZ1xuICAgKiBnb29nLnByb3ZpZGUoKSBvciBnb29nLm1vZHVsZSgpLlxuICAgKlxuICAgKiBnb29nLm1vZHVsZSgpIGhhcyB0aHJlZSByZXF1aXJlbWVudHM6XG4gICAqIC0gZ29vZy5tb2R1bGUgbWF5IG5vdCBiZSB1c2VkIGluIHRoZSBzYW1lIGZpbGUgYXMgZ29vZy5wcm92aWRlLlxuICAgKiAtIGdvb2cubW9kdWxlIG11c3QgYmUgdGhlIGZpcnN0IHN0YXRlbWVudCBpbiB0aGUgZmlsZS5cbiAgICogLSBvbmx5IG9uZSBnb29nLm1vZHVsZSBpcyBhbGxvd2VkIHBlciBmaWxlLlxuICAgKlxuICAgKiBXaGVuIGEgZ29vZy5tb2R1bGUgYW5ub3RhdGVkIGZpbGUgaXMgbG9hZGVkLCBpdCBpcyBlbmNsb3NlZCBpblxuICAgKiBhIHN0cmljdCBmdW5jdGlvbiBjbG9zdXJlLiBUaGlzIG1lYW5zIHRoYXQ6XG4gICAqIC0gYW55IHZhcmlhYmxlcyBkZWNsYXJlZCBpbiBhIGdvb2cubW9kdWxlIGZpbGUgYXJlIHByaXZhdGUgdG8gdGhlIGZpbGVcbiAgICogKG5vdCBnbG9iYWwpLCB0aG91Z2ggdGhlIGNvbXBpbGVyIGlzIGV4cGVjdGVkIHRvIGlubGluZSB0aGUgbW9kdWxlLlxuICAgKiAtIFRoZSBjb2RlIG11c3Qgb2JleSBhbGwgdGhlIHJ1bGVzIG9mIFwic3RyaWN0XCIgSmF2YVNjcmlwdC5cbiAgICogLSB0aGUgZmlsZSB3aWxsIGJlIG1hcmtlZCBhcyBcInVzZSBzdHJpY3RcIlxuICAgKlxuICAgKiBOT1RFOiB1bmxpa2UgZ29vZy5wcm92aWRlLCBnb29nLm1vZHVsZSBkb2VzIG5vdCBkZWNsYXJlIGFueSBzeW1ib2xzIGJ5XG4gICAqIGl0c2VsZi4gSWYgZGVjbGFyZWQgc3ltYm9scyBhcmUgZGVzaXJlZCwgdXNlXG4gICAqIGdvb2cubW9kdWxlLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UoKS5cbiAgICpcbiAgICpcbiAgICogU2VlIHRoZSBwdWJsaWMgZ29vZy5tb2R1bGUgcHJvcG9zYWw6IGh0dHA6Ly9nb28uZ2wvVmExaGluXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBwcm92aWRlZCBieSB0aGlzIGZpbGUgaW4gdGhlIGZvcm1cbiAgICogICAgIFwiZ29vZy5wYWNrYWdlLnBhcnRcIiwgaXMgZXhwZWN0ZWQgYnV0IG5vdCByZXF1aXJlZC5cbiAgICovXG4gIGdvb2cubW9kdWxlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIWdvb2cuaXNTdHJpbmcobmFtZSkgfHwgIW5hbWUgfHwgbmFtZS5zZWFyY2goZ29vZy5WQUxJRF9NT0RVTEVfUkVfKSA9PSAtMSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgbW9kdWxlIGlkZW50aWZpZXInKTtcbiAgICB9XG4gICAgaWYgKCFnb29nLmlzSW5Nb2R1bGVMb2FkZXJfKCkpIHtcbiAgICAgIHRocm93IEVycm9yKCdNb2R1bGUgJyArIG5hbWUgKyAnIGhhcyBiZWVuIGxvYWRlZCBpbmNvcnJlY3RseS4nKTtcbiAgICB9XG4gICAgaWYgKGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLm1vZHVsZU5hbWUpIHtcbiAgICAgIHRocm93IEVycm9yKCdnb29nLm1vZHVsZSBtYXkgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgbW9kdWxlLicpO1xuICAgIH1cblxuICAgIC8vIFN0b3JlIHRoZSBtb2R1bGUgbmFtZSBmb3IgdGhlIGxvYWRlci5cbiAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXy5tb2R1bGVOYW1lID0gbmFtZTtcbiAgICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2FtZSBuYW1lc3BhY2UgaXNuJ3QgcHJvdmlkZWQgdHdpY2UuXG4gICAgICAvLyBBIGdvb2cubW9kdWxlL2dvb2cucHJvdmlkZSBtYXBzIGEgZ29vZy5yZXF1aXJlIHRvIGEgc3BlY2lmaWMgZmlsZVxuICAgICAgaWYgKGdvb2cuaXNQcm92aWRlZF8obmFtZSkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05hbWVzcGFjZSBcIicgKyBuYW1lICsgJ1wiIGFscmVhZHkgZGVjbGFyZWQuJyk7XG4gICAgICB9XG4gICAgICBkZWxldGUgZ29vZy5pbXBsaWNpdE5hbWVzcGFjZXNfW25hbWVdO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG1vZHVsZSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgbW9kdWxlIGV4cG9ydHMgZm9yIGFuIGFscmVhZHkgbG9hZGVkIG1vZHVsZSBvciBudWxsLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIG5vdCBhbiBhbHRlcm5hdGl2ZSB0byBnb29nLnJlcXVpcmUsIGl0IGRvZXMgbm90XG4gICAqIGluZGljYXRlIGEgaGFyZCBkZXBlbmRlbmN5LCBpbnN0ZWFkIGl0IGlzIHVzZWQgdG8gaW5kaWNhdGVcbiAgICogYW4gb3B0aW9uYWwgZGVwZW5kZW5jeSBvciB0byBhY2Nlc3MgdGhlIGV4cG9ydHMgb2YgYSBtb2R1bGVcbiAgICogdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGxvYWRlZC5cbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvdmlkZX1cbiAgICovXG4gIGdvb2cubW9kdWxlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIGdvb2cubW9kdWxlLmdldEludGVybmFsXyhuYW1lKTtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG1vZHVsZSBpZGVudGlmaWVyLlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgbW9kdWxlIGV4cG9ydHMgZm9yIGFuIGFscmVhZHkgbG9hZGVkIG1vZHVsZSBvciBudWxsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5tb2R1bGUuZ2V0SW50ZXJuYWxfID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIUNPTVBJTEVEKSB7XG4gICAgICBpZiAoZ29vZy5pc1Byb3ZpZGVkXyhuYW1lKSkge1xuICAgICAgICAvLyBnb29nLnJlcXVpcmUgb25seSByZXR1cm4gYSB2YWx1ZSB3aXRoLWluIGdvb2cubW9kdWxlIGZpbGVzLlxuICAgICAgICByZXR1cm4gbmFtZSBpbiBnb29nLmxvYWRlZE1vZHVsZXNfID8gZ29vZy5sb2FkZWRNb2R1bGVzX1tuYW1lXSA6IGdvb2cuZ2V0T2JqZWN0QnlOYW1lKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZSB7P3ttb2R1bGVOYW1lOiAoc3RyaW5nfHVuZGVmaW5lZCksIGRlY2xhcmVMZWdhY3lOYW1lc3BhY2U6Ym9vbGVhbn19XG4gICAqL1xuICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgYSBnb29nLm1vZHVsZSBpcyBjdXJyZW50bHkgYmVpbmcgaW5pdGlhbGl6ZWQuXG4gICAqL1xuICBnb29nLmlzSW5Nb2R1bGVMb2FkZXJfID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyAhPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIHRoZSBtb2R1bGUncyBleHBvcnRzIGFzIGEgZ2xvYmFsbHkgYWNjZXNzaWJsZSBvYmplY3QgdW5kZXIgdGhlXG4gICAqIG1vZHVsZSdzIGRlY2xhcmVkIG5hbWUuICBUaGlzIGlzIGludGVuZGVkIHRvIGVhc2UgbWlncmF0aW9uIHRvIGdvb2cubW9kdWxlXG4gICAqIGZvciBmaWxlcyB0aGF0IGhhdmUgZXhpc3RpbmcgdXNhZ2VzLlxuICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm92aWRlfVxuICAgKi9cbiAgZ29vZy5tb2R1bGUuZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUNPTVBJTEVEICYmICFnb29nLmlzSW5Nb2R1bGVMb2FkZXJfKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ29vZy5tb2R1bGUuZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZSBtdXN0IGJlIGNhbGxlZCBmcm9tICcgKyAnd2l0aGluIGEgZ29vZy5tb2R1bGUnKTtcbiAgICB9XG4gICAgaWYgKCFDT01QSUxFRCAmJiAhZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8ubW9kdWxlTmFtZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ2dvb2cubW9kdWxlIG11c3QgYmUgY2FsbGVkIHByaW9yIHRvICcgKyAnZ29vZy5tb2R1bGUuZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZS4nKTtcbiAgICB9XG4gICAgZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV8uZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZSA9IHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hcmtzIHRoYXQgdGhlIGN1cnJlbnQgZmlsZSBzaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLCBhbmQgbmV2ZXIgZm9yXG4gICAqIGxpdmUgY29kZSBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBJbiB0aGUgY2FzZSBvZiB1bml0IHRlc3RzLCB0aGUgbWVzc2FnZSBtYXkgb3B0aW9uYWxseSBiZSBhbiBleGFjdCBuYW1lc3BhY2VcbiAgICogZm9yIHRoZSB0ZXN0IChlLmcuICdnb29nLnN0cmluZ1Rlc3QnKS4gVGhlIGxpbnRlciB3aWxsIHRoZW4gaWdub3JlIHRoZSBleHRyYVxuICAgKiBwcm92aWRlIChpZiBub3QgZXhwbGljaXRseSBkZWZpbmVkIGluIHRoZSBjb2RlKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlIHRvIGFkZCB0byB0aGUgZXJyb3IgdGhhdCdzXG4gICAqICAgICByYWlzZWQgd2hlbiB1c2VkIGluIHByb2R1Y3Rpb24gY29kZS5cbiAgICovXG4gIGdvb2cuc2V0VGVzdE9ubHkgPSBmdW5jdGlvbiAob3B0X21lc3NhZ2UpIHtcbiAgICBpZiAoZ29vZy5ESVNBTExPV19URVNUX09OTFlfQ09ERSkge1xuICAgICAgb3B0X21lc3NhZ2UgPSBvcHRfbWVzc2FnZSB8fCAnJztcbiAgICAgIHRocm93IEVycm9yKCdJbXBvcnRpbmcgdGVzdC1vbmx5IGNvZGUgaW50byBub24tZGVidWcgZW52aXJvbm1lbnQnICsgKG9wdF9tZXNzYWdlID8gJzogJyArIG9wdF9tZXNzYWdlIDogJy4nKSk7XG4gICAgfVxuICB9O1xuXG4gIGlmICghQ09NUElMRUQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gbmFtZSBoYXMgYmVlbiBnb29nLnByb3ZpZGVkLiBUaGlzIHdpbGwgcmV0dXJuIGZhbHNlIGZvclxuICAgICAqIG5hbWVzIHRoYXQgYXJlIGF2YWlsYWJsZSBvbmx5IGFzIGltcGxpY2l0IG5hbWVzcGFjZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiB0aGUgb2JqZWN0IHRvIGxvb2sgZm9yLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5hbWUgaGFzIGJlZW4gcHJvdmlkZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLmlzUHJvdmlkZWRfID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBuYW1lIGluIGdvb2cubG9hZGVkTW9kdWxlc18gfHwgIWdvb2cuaW1wbGljaXROYW1lc3BhY2VzX1tuYW1lXSAmJiBnb29nLmlzRGVmQW5kTm90TnVsbChnb29nLmdldE9iamVjdEJ5TmFtZShuYW1lKSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5hbWVzcGFjZXMgaW1wbGljaXRseSBkZWZpbmVkIGJ5IGdvb2cucHJvdmlkZS4gRm9yIGV4YW1wbGUsXG4gICAgICogZ29vZy5wcm92aWRlKCdnb29nLmV2ZW50cy5FdmVudCcpIGltcGxpY2l0bHkgZGVjbGFyZXMgdGhhdCAnZ29vZycgYW5kXG4gICAgICogJ2dvb2cuZXZlbnRzJyBtdXN0IGJlIG5hbWVzcGFjZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsIChib29sZWFufHVuZGVmaW5lZCk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5pbXBsaWNpdE5hbWVzcGFjZXNfID0geyAnZ29vZy5tb2R1bGUnOiB0cnVlIH07XG5cbiAgICAvLyBOT1RFOiBXZSBhZGQgZ29vZy5tb2R1bGUgYXMgYW4gaW1wbGljaXQgbmFtZXNwYWNlIGFzIGdvb2cubW9kdWxlIGlzIGRlZmluZWRcbiAgICAvLyBoZXJlIGFuZCBiZWNhdXNlIHRoZSBleGlzdGluZyBtb2R1bGUgcGFja2FnZSBoYXMgbm90IGJlZW4gbW92ZWQgeWV0IG91dCBvZlxuICAgIC8vIHRoZSBnb29nLm1vZHVsZSBuYW1lc3BhY2UuIFRoaXMgc2F0aXNpZmllcyBib3RoIHRoZSBkZWJ1ZyBsb2FkZXIgYW5kXG4gICAgLy8gYWhlYWQtb2YtdGltZSBkZXBlbmRlbmN5IG1hbmFnZW1lbnQuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLiAgVGhlIG9iamVjdFxuICAgKiBpcyBub3QgZm91bmQgaWYgbnVsbCBvciB1bmRlZmluZWQuICBJZiB5b3UgYXJlIHVzaW5nIGEgY29tcGlsYXRpb24gcGFzcyB0aGF0XG4gICAqIHJlbmFtZXMgcHJvcGVydHkgbmFtZXMgYmV3YXJlIHRoYXQgdXNpbmcgdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBmaW5kIHJlbmFtZWRcbiAgICogcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmogVGhlIG9iamVjdCB3aXRoaW4gd2hpY2ggdG8gbG9vazsgZGVmYXVsdCBpc1xuICAgKiAgICAgfGdvb2cuZ2xvYmFsfC5cbiAgICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCBudWxsLlxuICAgKi9cbiAgZ29vZy5nZXRPYmplY3RCeU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgb3B0X29iaikge1xuICAgIHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgY3VyID0gb3B0X29iaiB8fCBnb29nLmdsb2JhbDtcbiAgICBmb3IgKHZhciBwYXJ0OyBwYXJ0ID0gcGFydHMuc2hpZnQoKTspIHtcbiAgICAgIGlmIChnb29nLmlzRGVmQW5kTm90TnVsbChjdXJbcGFydF0pKSB7XG4gICAgICAgIGN1ciA9IGN1cltwYXJ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHbG9iYWxpemVzIGEgd2hvbGUgbmFtZXNwYWNlLCBzdWNoIGFzIGdvb2cgb3IgZ29vZy5sYW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9iaiBUaGUgbmFtZXNwYWNlIHRvIGdsb2JhbGl6ZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZ2xvYmFsIFRoZSBvYmplY3QgdG8gYWRkIHRoZSBwcm9wZXJ0aWVzIHRvLlxuICAgKiBAZGVwcmVjYXRlZCBQcm9wZXJ0aWVzIG1heSBiZSBleHBsaWNpdGx5IGV4cG9ydGVkIHRvIHRoZSBnbG9iYWwgc2NvcGUsIGJ1dFxuICAgKiAgICAgdGhpcyBzaG91bGQgbm8gbG9uZ2VyIGJlIGRvbmUgaW4gYnVsay5cbiAgICovXG4gIGdvb2cuZ2xvYmFsaXplID0gZnVuY3Rpb24gKG9iaiwgb3B0X2dsb2JhbCkge1xuICAgIHZhciBnbG9iYWwgPSBvcHRfZ2xvYmFsIHx8IGdvb2cuZ2xvYmFsO1xuICAgIGZvciAodmFyIHggaW4gb2JqKSB7XG4gICAgICBnbG9iYWxbeF0gPSBvYmpbeF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGEgZGVwZW5kZW5jeSBmcm9tIGEgZmlsZSB0byB0aGUgZmlsZXMgaXQgcmVxdWlyZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWxQYXRoIFRoZSBwYXRoIHRvIHRoZSBqcyBmaWxlLlxuICAgKiBAcGFyYW0geyFBcnJheTxzdHJpbmc+fSBwcm92aWRlcyBBbiBhcnJheSBvZiBzdHJpbmdzIHdpdGhcbiAgICogICAgIHRoZSBuYW1lcyBvZiB0aGUgb2JqZWN0cyB0aGlzIGZpbGUgcHJvdmlkZXMuXG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IHJlcXVpcmVzIEFuIGFycmF5IG9mIHN0cmluZ3Mgd2l0aFxuICAgKiAgICAgdGhlIG5hbWVzIG9mIHRoZSBvYmplY3RzIHRoaXMgZmlsZSByZXF1aXJlcy5cbiAgICogQHBhcmFtIHtib29sZWFufCFPYmplY3Q8c3RyaW5nPj19IG9wdF9sb2FkRmxhZ3MgUGFyYW1ldGVycyBpbmRpY2F0aW5nXG4gICAqICAgICBob3cgdGhlIGZpbGUgbXVzdCBiZSBsb2FkZWQuICBUaGUgYm9vbGVhbiAndHJ1ZScgaXMgZXF1aXZhbGVudFxuICAgKiAgICAgdG8geydtb2R1bGUnOiAnZ29vZyd9IGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS4gIFZhbGlkIHByb3BlcnRpZXNcbiAgICogICAgIGFuZCB2YWx1ZXMgaW5jbHVkZSB7J21vZHVsZSc6ICdnb29nJ30gYW5kIHsnbGFuZyc6ICdlczYnfS5cbiAgICovXG4gIGdvb2cuYWRkRGVwZW5kZW5jeSA9IGZ1bmN0aW9uIChyZWxQYXRoLCBwcm92aWRlcywgcmVxdWlyZXMsIG9wdF9sb2FkRmxhZ3MpIHtcbiAgICBpZiAoZ29vZy5ERVBFTkRFTkNJRVNfRU5BQkxFRCkge1xuICAgICAgdmFyIHByb3ZpZGUsIHJlcXVpcmU7XG4gICAgICB2YXIgcGF0aCA9IHJlbFBhdGgucmVwbGFjZSgvXFxcXC9nLCAnLycpO1xuICAgICAgdmFyIGRlcHMgPSBnb29nLmRlcGVuZGVuY2llc187XG4gICAgICBpZiAoIW9wdF9sb2FkRmxhZ3MgfHwgdHlwZW9mIG9wdF9sb2FkRmxhZ3MgPT09ICdib29sZWFuJykge1xuICAgICAgICBvcHRfbG9hZEZsYWdzID0gb3B0X2xvYWRGbGFncyA/IHsgJ21vZHVsZSc6ICdnb29nJyB9IDoge307XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgcHJvdmlkZSA9IHByb3ZpZGVzW2ldOyBpKyspIHtcbiAgICAgICAgZGVwcy5uYW1lVG9QYXRoW3Byb3ZpZGVdID0gcGF0aDtcbiAgICAgICAgZGVwcy5wYXRoSXNNb2R1bGVbcGF0aF0gPSBvcHRfbG9hZEZsYWdzWydtb2R1bGUnXSA9PSAnZ29vZyc7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqID0gMDsgcmVxdWlyZSA9IHJlcXVpcmVzW2pdOyBqKyspIHtcbiAgICAgICAgaWYgKCEocGF0aCBpbiBkZXBzLnJlcXVpcmVzKSkge1xuICAgICAgICAgIGRlcHMucmVxdWlyZXNbcGF0aF0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkZXBzLnJlcXVpcmVzW3BhdGhdW3JlcXVpcmVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTk9URShubmF6ZSk6IFRoZSBkZWJ1ZyBET00gbG9hZGVyIHdhcyBpbmNsdWRlZCBpbiBiYXNlLmpzIGFzIGFuIG9yaWdpbmFsIHdheVxuICAvLyB0byBkbyBcImRlYnVnLW1vZGVcIiBkZXZlbG9wbWVudC4gIFRoZSBkZXBlbmRlbmN5IHN5c3RlbSBjYW4gc29tZXRpbWVzIGJlXG4gIC8vIGNvbmZ1c2luZywgYXMgY2FuIHRoZSBkZWJ1ZyBET00gbG9hZGVyJ3MgYXN5bmNocm9ub3VzIG5hdHVyZS5cbiAgLy9cbiAgLy8gV2l0aCB0aGUgRE9NIGxvYWRlciwgYSBjYWxsIHRvIGdvb2cucmVxdWlyZSgpIGlzIG5vdCBibG9ja2luZyAtLSB0aGUgc2NyaXB0XG4gIC8vIHdpbGwgbm90IGxvYWQgdW50aWwgc29tZSBwb2ludCBhZnRlciB0aGUgY3VycmVudCBzY3JpcHQuICBJZiBhIG5hbWVzcGFjZSBpc1xuICAvLyBuZWVkZWQgYXQgcnVudGltZSwgaXQgbmVlZHMgdG8gYmUgZGVmaW5lZCBpbiBhIHByZXZpb3VzIHNjcmlwdCwgb3IgbG9hZGVkIHZpYVxuICAvLyByZXF1aXJlKCkgd2l0aCBpdHMgcmVnaXN0ZXJlZCBkZXBlbmRlbmNpZXMuXG4gIC8vXG4gIC8vIFVzZXItZGVmaW5lZCBuYW1lc3BhY2VzIG1heSBuZWVkIHRoZWlyIG93biBkZXBzIGZpbGUuIEZvciBhIHJlZmVyZW5jZSBvblxuICAvLyBjcmVhdGluZyBhIGRlcHMgZmlsZSwgc2VlOlxuICAvLyBFeHRlcm5hbGx5OiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9jbG9zdXJlL2xpYnJhcnkvZG9jcy9kZXBzd3JpdGVyXG4gIC8vXG4gIC8vIEJlY2F1c2Ugb2YgbGVnYWN5IGNsaWVudHMsIHRoZSBET00gbG9hZGVyIGNhbid0IGJlIGVhc2lseSByZW1vdmVkIGZyb21cbiAgLy8gYmFzZS5qcy4gIFdvcmsgaXMgYmVpbmcgZG9uZSB0byBtYWtlIGl0IGRpc2FibGVhYmxlIG9yIHJlcGxhY2VhYmxlIGZvclxuICAvLyBkaWZmZXJlbnQgZW52aXJvbm1lbnRzIChET00tbGVzcyBKYXZhU2NyaXB0IGludGVycHJldGVycyBsaWtlIFJoaW5vIG9yIFY4LFxuICAvLyBmb3IgZXhhbXBsZSkuIFNlZSBib290c3RyYXAvIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG5cbiAgLyoqXG4gICAqIEBkZWZpbmUge2Jvb2xlYW59IFdoZXRoZXIgdG8gZW5hYmxlIHRoZSBkZWJ1ZyBsb2FkZXIuXG4gICAqXG4gICAqIElmIGVuYWJsZWQsIGEgY2FsbCB0byBnb29nLnJlcXVpcmUoKSB3aWxsIGF0dGVtcHQgdG8gbG9hZCB0aGUgbmFtZXNwYWNlIGJ5XG4gICAqIGFwcGVuZGluZyBhIHNjcmlwdCB0YWcgdG8gdGhlIERPTSAoaWYgdGhlIG5hbWVzcGFjZSBoYXMgYmVlbiByZWdpc3RlcmVkKS5cbiAgICpcbiAgICogSWYgZGlzYWJsZWQsIGdvb2cucmVxdWlyZSgpIHdpbGwgc2ltcGx5IGFzc2VydCB0aGF0IHRoZSBuYW1lc3BhY2UgaGFzIGJlZW5cbiAgICogcHJvdmlkZWQgKGFuZCBkZXBlbmQgb24gdGhlIGZhY3QgdGhhdCBzb21lIG91dHNpZGUgdG9vbCBjb3JyZWN0bHkgb3JkZXJlZFxuICAgKiB0aGUgc2NyaXB0KS5cbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLkVOQUJMRV9ERUJVR19MT0FERVInLCB0cnVlKTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5sb2dUb0NvbnNvbGVfID0gZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChnb29nLmdsb2JhbC5jb25zb2xlKSB7XG4gICAgICBnb29nLmdsb2JhbC5jb25zb2xlWydlcnJvciddKG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGEgc3lzdGVtIGZvciB0aGUgZHluYW1pYyByZXNvbHV0aW9uIG9mIGRlcGVuZGVuY2llcyB0aGF0IHdvcmtzIGluXG4gICAqIHBhcmFsbGVsIHdpdGggdGhlIEJVSUxEIHN5c3RlbS4gTm90ZSB0aGF0IGFsbCBjYWxscyB0byBnb29nLnJlcXVpcmUgd2lsbCBiZVxuICAgKiBzdHJpcHBlZCBieSB0aGUgSlNDb21waWxlciB3aGVuIHRoZSAtLXByb2Nlc3NfY2xvc3VyZV9wcmltaXRpdmVzIG9wdGlvbiBpc1xuICAgKiB1c2VkLlxuICAgKiBAc2VlIGdvb2cucHJvdmlkZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgdG8gaW5jbHVkZSAoYXMgd2FzIGdpdmVuIGluIGdvb2cucHJvdmlkZSgpKSBpblxuICAgKiAgICAgdGhlIGZvcm0gXCJnb29nLnBhY2thZ2UucGFydFwiLlxuICAgKiBAcmV0dXJuIHs/fSBJZiBjYWxsZWQgd2l0aGluIGEgZ29vZy5tb2R1bGUgZmlsZSwgdGhlIGFzc29jaWF0ZWQgbmFtZXNwYWNlIG9yXG4gICAqICAgICBtb2R1bGUgb3RoZXJ3aXNlIG51bGwuXG4gICAqL1xuICBnb29nLnJlcXVpcmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgYWxyZWFkeSBleGlzdHMgd2UgZG8gbm90IG5lZWQgZG8gZG8gYW55dGhpbmcuXG4gICAgaWYgKCFDT01QSUxFRCkge1xuICAgICAgaWYgKGdvb2cuRU5BQkxFX0RFQlVHX0xPQURFUiAmJiBnb29nLklTX09MRF9JRV8pIHtcbiAgICAgICAgZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZERlcF8obmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnb29nLmlzUHJvdmlkZWRfKG5hbWUpKSB7XG4gICAgICAgIGlmIChnb29nLmlzSW5Nb2R1bGVMb2FkZXJfKCkpIHtcbiAgICAgICAgICByZXR1cm4gZ29vZy5tb2R1bGUuZ2V0SW50ZXJuYWxfKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnb29nLkVOQUJMRV9ERUJVR19MT0FERVIpIHtcbiAgICAgICAgdmFyIHBhdGggPSBnb29nLmdldFBhdGhGcm9tRGVwc18obmFtZSk7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgZ29vZy53cml0ZVNjcmlwdHNfKHBhdGgpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnZ29vZy5yZXF1aXJlIGNvdWxkIG5vdCBmaW5kOiAnICsgbmFtZTtcbiAgICAgIGdvb2cubG9nVG9Db25zb2xlXyhlcnJvck1lc3NhZ2UpO1xuXG4gICAgICB0aHJvdyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUGF0aCBmb3IgaW5jbHVkZWQgc2NyaXB0cy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdvb2cuYmFzZVBhdGggPSAnJztcblxuICAvKipcbiAgICogQSBob29rIGZvciBvdmVycmlkaW5nIHRoZSBiYXNlIHBhdGguXG4gICAqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9CQVNFX1BBVEg7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gd3JpdGUgb3V0IENsb3N1cmUncyBkZXBzIGZpbGUuIEJ5IGRlZmF1bHQsIHRoZSBkZXBzIGFyZSB3cml0dGVuLlxuICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAqL1xuICBnb29nLmdsb2JhbC5DTE9TVVJFX05PX0RFUFM7XG5cbiAgLyoqXG4gICAqIEEgZnVuY3Rpb24gdG8gaW1wb3J0IGEgc2luZ2xlIHNjcmlwdC4gVGhpcyBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIHdoZW5cbiAgICogQ2xvc3VyZSBpcyBiZWluZyBydW4gaW4gbm9uLUhUTUwgY29udGV4dHMsIHN1Y2ggYXMgd2ViIHdvcmtlcnMuIEl0J3MgZGVmaW5lZFxuICAgKiBpbiB0aGUgZ2xvYmFsIHNjb3BlIHNvIHRoYXQgaXQgY2FuIGJlIHNldCBiZWZvcmUgYmFzZS5qcyBpcyBsb2FkZWQsIHdoaWNoXG4gICAqIGFsbG93cyBkZXBzLmpzIHRvIGJlIGltcG9ydGVkIHByb3Blcmx5LlxuICAgKlxuICAgKiBUaGUgZnVuY3Rpb24gaXMgcGFzc2VkIHRoZSBzY3JpcHQgc291cmNlLCB3aGljaCBpcyBhIHJlbGF0aXZlIFVSSS4gSXQgc2hvdWxkXG4gICAqIHJldHVybiB0cnVlIGlmIHRoZSBzY3JpcHQgd2FzIGltcG9ydGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEB0eXBlIHsoZnVuY3Rpb24oc3RyaW5nKTogYm9vbGVhbil8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ29vZy5nbG9iYWwuQ0xPU1VSRV9JTVBPUlRfU0NSSVBUO1xuXG4gIC8qKlxuICAgKiBOdWxsIGZ1bmN0aW9uIHVzZWQgZm9yIGRlZmF1bHQgdmFsdWVzIG9mIGNhbGxiYWNrcywgZXRjLlxuICAgKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICAgKi9cbiAgZ29vZy5udWxsRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAgICogRm9vLnByb3RvdHlwZS5iYXIgPSBnb29nLmFic3RyYWN0TWV0aG9kXG4gICAqXG4gICAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAgICogd2hlbiBiYXIoKSBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGRvZXMgbm90IHRha2UgdGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGFzIGFuIGFyZ3VtZW50XG4gICAqIGJlY2F1c2UgdGhhdCB3b3VsZCBtYWtlIGl0IG1vcmUgZGlmZmljdWx0IHRvIG9iZnVzY2F0ZSBvdXIgSmF2YVNjcmlwdCBjb2RlLlxuICAgKlxuICAgKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gd2hlbiBpbnZva2VkIHRvIGluZGljYXRlIHRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4uXG4gICAqL1xuICBnb29nLmFic3RyYWN0TWV0aG9kID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IEVycm9yKCd1bmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGEge0Bjb2RlIGdldEluc3RhbmNlfSBzdGF0aWMgbWV0aG9kIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWVcbiAgICogaW5zdGFuY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY3RvciBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBjbGFzcyB0byBhZGQgdGhlIHN0YXRpY1xuICAgKiAgICAgbWV0aG9kIHRvLlxuICAgKi9cbiAgZ29vZy5hZGRTaW5nbGV0b25HZXR0ZXIgPSBmdW5jdGlvbiAoY3Rvcikge1xuICAgIGN0b3IuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY3Rvci5pbnN0YW5jZV8pIHtcbiAgICAgICAgcmV0dXJuIGN0b3IuaW5zdGFuY2VfO1xuICAgICAgfVxuICAgICAgaWYgKGdvb2cuREVCVUcpIHtcbiAgICAgICAgLy8gTk9URTogSlNDb21waWxlciBjYW4ndCBvcHRpbWl6ZSBhd2F5IEFycmF5I3B1c2guXG4gICAgICAgIGdvb2cuaW5zdGFudGlhdGVkU2luZ2xldG9uc19bZ29vZy5pbnN0YW50aWF0ZWRTaW5nbGV0b25zXy5sZW5ndGhdID0gY3RvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdG9yLmluc3RhbmNlXyA9IG5ldyBjdG9yKCk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQWxsIHNpbmdsZXRvbiBjbGFzc2VzIHRoYXQgaGF2ZSBiZWVuIGluc3RhbnRpYXRlZCwgZm9yIHRlc3RpbmcuIERvbid0IHJlYWRcbiAgICogaXQgZGlyZWN0bHksIHVzZSB0aGUge0Bjb2RlIGdvb2cudGVzdGluZy5zaW5nbGV0b259IG1vZHVsZS4gVGhlIGNvbXBpbGVyXG4gICAqIHJlbW92ZXMgdGhpcyB2YXJpYWJsZSBpZiB1bnVzZWQuXG4gICAqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaW5zdGFudGlhdGVkU2luZ2xldG9uc18gPSBbXTtcblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0byBsb2FkIGdvb2cubW9kdWxlcyB1c2luZyB7QGNvZGUgZXZhbH0gd2hlbiB1c2luZ1xuICAgKiB0aGUgZGVidWcgbG9hZGVyLiAgVGhpcyBwcm92aWRlcyBhIGJldHRlciBkZWJ1Z2dpbmcgZXhwZXJpZW5jZSBhcyB0aGVcbiAgICogc291cmNlIGlzIHVubW9kaWZpZWQgYW5kIGNhbiBiZSBlZGl0ZWQgdXNpbmcgQ2hyb21lIFdvcmtzcGFjZXMgb3Igc2ltaWxhci5cbiAgICogSG93ZXZlciBpbiBzb21lIGVudmlyb25tZW50cyB0aGUgdXNlIG9mIHtAY29kZSBldmFsfSBpcyBiYW5uZWRcbiAgICogc28gd2UgcHJvdmlkZSBhbiBhbHRlcm5hdGl2ZS5cbiAgICovXG4gIGdvb2cuZGVmaW5lKCdnb29nLkxPQURfTU9EVUxFX1VTSU5HX0VWQUwnLCB0cnVlKTtcblxuICAvKipcbiAgICogQGRlZmluZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZXhwb3J0cyBvZiBnb29nLm1vZHVsZXMgc2hvdWxkIGJlIHNlYWxlZCB3aGVuXG4gICAqIHBvc3NpYmxlLlxuICAgKi9cbiAgZ29vZy5kZWZpbmUoJ2dvb2cuU0VBTF9NT0RVTEVfRVhQT1JUUycsIGdvb2cuREVCVUcpO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVnaXN0cnkgb2YgaW5pdGlhbGl6ZWQgbW9kdWxlczpcbiAgICogdGhlIG1vZHVsZSBpZGVudGlmaWVyIHRvIG1vZHVsZSBleHBvcnRzIG1hcC5cbiAgICogQHByaXZhdGUgQGNvbnN0IHshT2JqZWN0PHN0cmluZywgPz59XG4gICAqL1xuICBnb29nLmxvYWRlZE1vZHVsZXNfID0ge307XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgZ29vZy5kZXBlbmRlbmNpZXNfIGlzIGF2YWlsYWJsZS5cbiAgICogQGNvbnN0IHtib29sZWFufVxuICAgKi9cbiAgZ29vZy5ERVBFTkRFTkNJRVNfRU5BQkxFRCA9ICFDT01QSUxFRCAmJiBnb29nLkVOQUJMRV9ERUJVR19MT0FERVI7XG5cbiAgaWYgKGdvb2cuREVQRU5ERU5DSUVTX0VOQUJMRUQpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgZGVwZW5kZW5jaWVzIGFuZCBvdGhlciBkYXRhIHRoYXQgaXNcbiAgICAgKiB1c2VkIGZvciBsb2FkaW5nIHNjcmlwdHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7e1xuICAgICAqICAgcGF0aElzTW9kdWxlOiAhT2JqZWN0PHN0cmluZywgYm9vbGVhbj4sXG4gICAgICogICBuYW1lVG9QYXRoOiAhT2JqZWN0PHN0cmluZywgc3RyaW5nPixcbiAgICAgKiAgIHJlcXVpcmVzOiAhT2JqZWN0PHN0cmluZywgIU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+PixcbiAgICAgKiAgIHZpc2l0ZWQ6ICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPixcbiAgICAgKiAgIHdyaXR0ZW46ICFPYmplY3Q8c3RyaW5nLCBib29sZWFuPixcbiAgICAgKiAgIGRlZmVycmVkOiAhT2JqZWN0PHN0cmluZywgc3RyaW5nPlxuICAgICAqIH19XG4gICAgICovXG4gICAgZ29vZy5kZXBlbmRlbmNpZXNfID0ge1xuICAgICAgcGF0aElzTW9kdWxlOiB7fSwgLy8gMSB0byAxXG5cbiAgICAgIG5hbWVUb1BhdGg6IHt9LCAvLyAxIHRvIDFcblxuICAgICAgcmVxdWlyZXM6IHt9LCAvLyAxIHRvIG1hbnlcblxuICAgICAgLy8gVXNlZCB3aGVuIHJlc29sdmluZyBkZXBlbmRlbmNpZXMgdG8gcHJldmVudCB1cyBmcm9tIHZpc2l0aW5nIGZpbGUgdHdpY2UuXG4gICAgICB2aXNpdGVkOiB7fSxcblxuICAgICAgd3JpdHRlbjoge30sIC8vIFVzZWQgdG8ga2VlcCB0cmFjayBvZiBzY3JpcHQgZmlsZXMgd2UgaGF2ZSB3cml0dGVuLlxuXG4gICAgICBkZWZlcnJlZDoge30gLy8gVXNlZCB0byB0cmFjayBkZWZlcnJlZCBtb2R1bGUgZXZhbHVhdGlvbnMgaW4gb2xkIElFc1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUcmllcyB0byBkZXRlY3Qgd2hldGhlciBpcyBpbiB0aGUgY29udGV4dCBvZiBhbiBIVE1MIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgaXQgbG9va3MgbGlrZSBIVE1MIGRvY3VtZW50LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5pbkh0bWxEb2N1bWVudF8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuICAgICAgcmV0dXJuIGRvYyAhPSBudWxsICYmICd3cml0ZScgaW4gZG9jOyAvLyBYVUxEb2N1bWVudCBtaXNzZXMgd3JpdGUuXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyaWVzIHRvIGRldGVjdCB0aGUgYmFzZSBwYXRoIG9mIGJhc2UuanMgc2NyaXB0IHRoYXQgYm9vdHN0cmFwcyBDbG9zdXJlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5maW5kQmFzZVBhdGhfID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdvb2cuaXNEZWYoZ29vZy5nbG9iYWwuQ0xPU1VSRV9CQVNFX1BBVEgpKSB7XG4gICAgICAgIGdvb2cuYmFzZVBhdGggPSBnb29nLmdsb2JhbC5DTE9TVVJFX0JBU0VfUEFUSDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghZ29vZy5pbkh0bWxEb2N1bWVudF8oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuICAgICAgdmFyIHNjcmlwdHMgPSBkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NDUklQVCcpO1xuICAgICAgLy8gU2VhcmNoIGJhY2t3YXJkcyBzaW5jZSB0aGUgY3VycmVudCBzY3JpcHQgaXMgaW4gYWxtb3N0IGFsbCBjYXNlcyB0aGUgb25lXG4gICAgICAvLyB0aGF0IGhhcyBiYXNlLmpzLlxuICAgICAgZm9yICh2YXIgaSA9IHNjcmlwdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIHNjcmlwdCA9IC8qKiBAdHlwZSB7IUhUTUxTY3JpcHRFbGVtZW50fSAqL3NjcmlwdHNbaV07XG4gICAgICAgIHZhciBzcmMgPSBzY3JpcHQuc3JjO1xuICAgICAgICB2YXIgcW1hcmsgPSBzcmMubGFzdEluZGV4T2YoJz8nKTtcbiAgICAgICAgdmFyIGwgPSBxbWFyayA9PSAtMSA/IHNyYy5sZW5ndGggOiBxbWFyaztcbiAgICAgICAgaWYgKHNyYy5zdWJzdHIobCAtIDcsIDcpID09ICdiYXNlLmpzJykge1xuICAgICAgICAgIGdvb2cuYmFzZVBhdGggPSBzcmMuc3Vic3RyKDAsIGwgLSA3KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSW1wb3J0cyBhIHNjcmlwdCBpZiwgYW5kIG9ubHkgaWYsIHRoYXQgc2NyaXB0IGhhc24ndCBhbHJlYWR5IGJlZW4gaW1wb3J0ZWQuXG4gICAgICogKE11c3QgYmUgY2FsbGVkIGF0IGV4ZWN1dGlvbiB0aW1lKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU2NyaXB0IHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zb3VyY2VUZXh0IFRoZSBvcHRpb25hbGx5IHNvdXJjZSB0ZXh0IHRvIGV2YWx1YXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLmltcG9ydFNjcmlwdF8gPSBmdW5jdGlvbiAoc3JjLCBvcHRfc291cmNlVGV4dCkge1xuICAgICAgdmFyIGltcG9ydFNjcmlwdCA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfSU1QT1JUX1NDUklQVCB8fCBnb29nLndyaXRlU2NyaXB0VGFnXztcbiAgICAgIGlmIChpbXBvcnRTY3JpcHQoc3JjLCBvcHRfc291cmNlVGV4dCkpIHtcbiAgICAgICAgZ29vZy5kZXBlbmRlbmNpZXNfLndyaXR0ZW5bc3JjXSA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKiBAY29uc3QgQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgZ29vZy5JU19PTERfSUVfID0gISEoIWdvb2cuZ2xvYmFsLmF0b2IgJiYgZ29vZy5nbG9iYWwuZG9jdW1lbnQgJiYgZ29vZy5nbG9iYWwuZG9jdW1lbnQuYWxsKTtcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgVVJMIGluaXRpYXRlIHJldHJpZXZhbCBhbmQgZXhlY3V0aW9uIG9mIHRoZSBtb2R1bGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBTY3JpcHQgc291cmNlIFVSTC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuaW1wb3J0TW9kdWxlXyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgIC8vIEluIGFuIGF0dGVtcHQgdG8ga2VlcCBicm93c2VycyBmcm9tIHRpbWluZyBvdXQgbG9hZGluZyBzY3JpcHRzIHVzaW5nXG4gICAgICAvLyBzeW5jaHJvbm91cyBYSFJzLCBwdXQgZWFjaCBsb2FkIGluIGl0cyBvd24gc2NyaXB0IGJsb2NrLlxuICAgICAgdmFyIGJvb3RzdHJhcCA9ICdnb29nLnJldHJpZXZlQW5kRXhlY01vZHVsZV8oXCInICsgc3JjICsgJ1wiKTsnO1xuXG4gICAgICBpZiAoZ29vZy5pbXBvcnRTY3JpcHRfKCcnLCBib290c3RyYXApKSB7XG4gICAgICAgIGdvb2cuZGVwZW5kZW5jaWVzXy53cml0dGVuW3NyY10gPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUgeyFBcnJheTxzdHJpbmc+fSAqL1xuICAgIGdvb2cucXVldWVkTW9kdWxlc18gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcHByb3ByaWF0ZSBtb2R1bGUgdGV4dC4gU3VpdGFibGUgdG8gaW5zZXJ0IGludG9cbiAgICAgKiBhIHNjcmlwdCB0YWcgKHRoYXQgaXMgdW5lc2NhcGVkKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjVXJsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmlwdFRleHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLndyYXBNb2R1bGVfID0gZnVuY3Rpb24gKHNyY1VybCwgc2NyaXB0VGV4dCkge1xuICAgICAgaWYgKCFnb29nLkxPQURfTU9EVUxFX1VTSU5HX0VWQUwgfHwgIWdvb2cuaXNEZWYoZ29vZy5nbG9iYWwuSlNPTikpIHtcbiAgICAgICAgcmV0dXJuICcnICsgJ2dvb2cubG9hZE1vZHVsZShmdW5jdGlvbihleHBvcnRzKSB7JyArICdcInVzZSBzdHJpY3RcIjsnICsgc2NyaXB0VGV4dCArICdcXG4nICsgLy8gdGVybWluYXRlIGFueSB0cmFpbGluZyBzaW5nbGUgbGluZSBjb21tZW50LlxuICAgICAgICAnO3JldHVybiBleHBvcnRzJyArICd9KTsnICsgJ1xcbi8vIyBzb3VyY2VVUkw9JyArIHNyY1VybCArICdcXG4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnICsgJ2dvb2cubG9hZE1vZHVsZSgnICsgZ29vZy5nbG9iYWwuSlNPTi5zdHJpbmdpZnkoc2NyaXB0VGV4dCArICdcXG4vLyMgc291cmNlVVJMPScgKyBzcmNVcmwgKyAnXFxuJykgKyAnKTsnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBPbiBJRTkgYW5kIGVhcmxpZXIsIGl0IGlzIG5lY2Vzc2FyeSB0byBoYW5kbGVcbiAgICAvLyBkZWZlcnJlZCBtb2R1bGUgbG9hZHMuIEluIGxhdGVyIGJyb3dzZXJzLCB0aGVcbiAgICAvLyBjb2RlIHRvIGJlIGV2YWx1YXRlZCBpcyBzaW1wbHkgaW5zZXJ0ZWQgYXMgYSBzY3JpcHRcbiAgICAvLyBibG9jayBpbiB0aGUgY29ycmVjdCBvcmRlci4gVG8gZXZhbCBkZWZlcnJlZFxuICAgIC8vIGNvZGUgYXQgdGhlIHJpZ2h0IHRpbWUsIHdlIHBpZ2d5IGJhY2sgb24gZ29vZy5yZXF1aXJlIHRvIGNhbGxcbiAgICAvLyBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkRGVwXy5cbiAgICAvL1xuICAgIC8vIFRoZSBnb29nLnJlcXVpcmVzIGFyZSB1c2VkIGJvdGggdG8gYm9vdHN0cmFwXG4gICAgLy8gdGhlIGxvYWRpbmcgcHJvY2VzcyAod2hlbiBubyBkZXBzIGFyZSBhdmFpbGFibGUpIGFuZFxuICAgIC8vIGRlY2xhcmUgdGhhdCB0aGV5IHNob3VsZCBiZSBhdmFpbGFibGUuXG4gICAgLy9cbiAgICAvLyBIZXJlIHdlIGV2YWwgdGhlIHNvdXJjZXMsIGlmIGFsbCB0aGUgZGVwcyBhcmUgYXZhaWxhYmxlXG4gICAgLy8gZWl0aGVyIGFscmVhZHkgZXZhbCdkIG9yIGdvb2cucmVxdWlyZSdkLiAgVGhpcyB3aWxsXG4gICAgLy8gYmUgdGhlIGNhc2Ugd2hlbiBhbGwgdGhlIGRlcGVuZGVuY2llcyBoYXZlIGFscmVhZHlcbiAgICAvLyBiZWVuIGxvYWRlZCwgYW5kIHRoZSBkZXBlbmRlbnQgbW9kdWxlIGlzIGxvYWRlZC5cbiAgICAvL1xuICAgIC8vIEJ1dCB0aGlzIGFsb25lIGlzbid0IHN1ZmZpY2llbnQgYmVjYXVzZSBpdCBpcyBhbHNvXG4gICAgLy8gbmVjZXNzYXJ5IHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGVyZSBpcyBubyByb290XG4gICAgLy8gdGhhdCBpcyBub3QgZGVmZXJyZWQuICBGb3IgdGhhdCB0aGVyZSB3ZSByZWdpc3RlciBmb3IgYW4gZXZlbnRcbiAgICAvLyBhbmQgdHJpZ2dlciBnb29nLmxvYWRRdWV1ZWRNb2R1bGVzXyBoYW5kbGUgYW55IHJlbWFpbmluZyBkZWZlcnJlZFxuICAgIC8vIGV2YWx1YXRpb25zLlxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIGFueSByZW1haW5pbmcgZGVmZXJyZWQgZ29vZy5tb2R1bGUgZXZhbHMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLmxvYWRRdWV1ZWRNb2R1bGVzXyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjb3VudCA9IGdvb2cucXVldWVkTW9kdWxlc18ubGVuZ3RoO1xuICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICB2YXIgcXVldWUgPSBnb29nLnF1ZXVlZE1vZHVsZXNfO1xuICAgICAgICBnb29nLnF1ZXVlZE1vZHVsZXNfID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIHZhciBwYXRoID0gcXVldWVbaV07XG4gICAgICAgICAgZ29vZy5tYXliZVByb2Nlc3NEZWZlcnJlZFBhdGhfKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV2YWwgdGhlIG5hbWVkIG1vZHVsZSBpZiBpdHMgZGVwZW5kZW5jaWVzIGFyZVxuICAgICAqIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIHRvIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkRGVwXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAoZ29vZy5pc0RlZmVycmVkTW9kdWxlXyhuYW1lKSAmJiBnb29nLmFsbERlcHNBcmVBdmFpbGFibGVfKG5hbWUpKSB7XG4gICAgICAgIHZhciBwYXRoID0gZ29vZy5nZXRQYXRoRnJvbURlcHNfKG5hbWUpO1xuICAgICAgICBnb29nLm1heWJlUHJvY2Vzc0RlZmVycmVkUGF0aF8oZ29vZy5iYXNlUGF0aCArIHBhdGgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5hbWUgcmVwcmVzZW50cyBhXG4gICAgICogICAgIG1vZHVsZSB3aG9zZSBldmFsdWF0aW9uIGhhcyBiZWVuIGRlZmVycmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5pc0RlZmVycmVkTW9kdWxlXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcGF0aCA9IGdvb2cuZ2V0UGF0aEZyb21EZXBzXyhuYW1lKTtcbiAgICAgIGlmIChwYXRoICYmIGdvb2cuZGVwZW5kZW5jaWVzXy5wYXRoSXNNb2R1bGVbcGF0aF0pIHtcbiAgICAgICAgdmFyIGFic3BhdGggPSBnb29nLmJhc2VQYXRoICsgcGF0aDtcbiAgICAgICAgcmV0dXJuIGFic3BhdGggaW4gZ29vZy5kZXBlbmRlbmNpZXNfLmRlZmVycmVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbW9kdWxlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5hbWUgcmVwcmVzZW50cyBhXG4gICAgICogICAgIG1vZHVsZSB3aG9zZSBkZWNsYXJlZCBkZXBlbmRlbmNpZXMgaGF2ZSBhbGwgYmVlbiBsb2FkZWRcbiAgICAgKiAgICAgKGV2YWwnZCBvciBhIGRlZmVycmVkIG1vZHVsZSBsb2FkKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5hbGxEZXBzQXJlQXZhaWxhYmxlXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgcGF0aCA9IGdvb2cuZ2V0UGF0aEZyb21EZXBzXyhuYW1lKTtcbiAgICAgIGlmIChwYXRoICYmIHBhdGggaW4gZ29vZy5kZXBlbmRlbmNpZXNfLnJlcXVpcmVzKSB7XG4gICAgICAgIGZvciAodmFyIHJlcXVpcmVOYW1lIGluIGdvb2cuZGVwZW5kZW5jaWVzXy5yZXF1aXJlc1twYXRoXSkge1xuICAgICAgICAgIGlmICghZ29vZy5pc1Byb3ZpZGVkXyhyZXF1aXJlTmFtZSkgJiYgIWdvb2cuaXNEZWZlcnJlZE1vZHVsZV8ocmVxdWlyZU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFic3BhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cubWF5YmVQcm9jZXNzRGVmZXJyZWRQYXRoXyA9IGZ1bmN0aW9uIChhYnNwYXRoKSB7XG4gICAgICBpZiAoYWJzcGF0aCBpbiBnb29nLmRlcGVuZGVuY2llc18uZGVmZXJyZWQpIHtcbiAgICAgICAgdmFyIHNyYyA9IGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZFthYnNwYXRoXTtcbiAgICAgICAgZGVsZXRlIGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZFthYnNwYXRoXTtcbiAgICAgICAgZ29vZy5nbG9iYWxFdmFsKHNyYyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvYWQgYSBnb29nLm1vZHVsZSBmcm9tIHRoZSBwcm92aWRlZCBVUkwuICBUaGlzIGlzIG5vdCBhIGdlbmVyYWwgcHVycG9zZVxuICAgICAqIGNvZGUgbG9hZGVyIGFuZCBkb2VzIG5vdCBzdXBwb3J0IGxhdGUgbG9hZGluZyBjb2RlLCB0aGF0IGlzIGl0IHNob3VsZCBvbmx5XG4gICAgICogYmUgdXNlZCBkdXJpbmcgcGFnZSBsb2FkLiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gc3VwcG9ydCB1bml0IHRlc3RzIGFuZFxuICAgICAqIFwiZGVidWdcIiBsb2FkZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGhhdmUgaW5zZXJ0ZWQgc2NyaXB0IHRhZ3MuIFVuZGVyIHRoZVxuICAgICAqIGhvb2QgdGhpcyBuZWVkcyB0byB1c2UgYSBzeW5jaHJvbm91cyBYSFIgYW5kIGlzIG5vdCByZWNvbW1lbmVkZWQgZm9yXG4gICAgICogcHJvZHVjdGlvbiBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIG1vZHVsZSdzIGdvb2cucmVxdWlyZXMgbXVzdCBoYXZlIGFscmVhZHkgYmVlbiBzYXRpc2lmaWVkOyBhbiBleGNlcHRpb25cbiAgICAgKiB3aWxsIGJlIHRocm93biBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZS4gVGhpcyBhc3N1bXB0aW9uIGlzIHRoYXQgbm9cbiAgICAgKiBcImRlcHMuanNcIiBmaWxlIGV4aXN0cywgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGRpc2NvdmVyIGFuZCBsb2NhdGUgdGhlXG4gICAgICogbW9kdWxlLXRvLWJlLWxvYWRlZCdzIGRlcGVuZGVuY2llcyBhbmQgbm8gYXR0ZW1wdCBpcyBtYWRlIHRvIGRvIHNvLlxuICAgICAqXG4gICAgICogVGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIGF0dGVtcHQgdG8gbG9hZCBhIG1vZHVsZS4gIElmXG4gICAgICogXCJnb29nLmxvYWRNb2R1bGVGcm9tVXJsXCIgaXMgY2FsbGVkIGZvciBhbiBhbHJlYWR5IGxvYWRlZCBtb2R1bGUsIGFuXG4gICAgICogZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgZnJvbSB3aGljaCB0byBhdHRlbXB0IHRvIGxvYWQgdGhlIGdvb2cubW9kdWxlLlxuICAgICAqL1xuICAgIGdvb2cubG9hZE1vZHVsZUZyb21VcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAvLyBCZWNhdXNlIHRoaXMgZXhlY3V0ZXMgc3luY2hyb25vdXNseSwgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgYWRkaXRpb25hbFxuICAgICAgLy8gYm9va2tlZXBpbmcuIFdoZW4gXCJnb29nLmxvYWRNb2R1bGVcIiB0aGUgbmFtZXNwYWNlIHdpbGwgYmUgbWFya2VkIGFzXG4gICAgICAvLyBoYXZpbmcgYmVlbiBwcm92aWRlZCB3aGljaCBpcyBzdWZmaWNpZW50LlxuICAgICAgZ29vZy5yZXRyaWV2ZUFuZEV4ZWNNb2R1bGVfKHVybCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyk6P3xzdHJpbmd9IG1vZHVsZURlZiBUaGUgbW9kdWxlIGRlZmluaXRpb24uXG4gICAgICovXG4gICAgZ29vZy5sb2FkTW9kdWxlID0gZnVuY3Rpb24gKG1vZHVsZURlZikge1xuICAgICAgLy8gTk9URTogd2UgYWxsb3cgZnVuY3Rpb24gZGVmaW5pdGlvbnMgdG8gYmUgZWl0aGVyIGluIHRoZSBmcm9tXG4gICAgICAvLyBvZiBhIHN0cmluZyB0byBldmFsICh3aGljaCBrZWVwcyB0aGUgb3JpZ2luYWwgc291cmNlIGludGFjdCkgb3JcbiAgICAgIC8vIGluIGEgZXZhbCBmb3JiaWRkZW4gZW52aXJvbm1lbnQgKENTUCkgd2UgYWxsb3cgYSBmdW5jdGlvbiBkZWZpbml0aW9uXG4gICAgICAvLyB3aGljaCBpbiBpdHMgYm9keSBtdXN0IGNhbGwge0Bjb2RlIGdvb2cubW9kdWxlfSwgYW5kIHJldHVybiB0aGUgZXhwb3J0c1xuICAgICAgLy8gb2YgdGhlIG1vZHVsZS5cbiAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gZ29vZy5tb2R1bGVMb2FkZXJTdGF0ZV87XG4gICAgICB0cnkge1xuICAgICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IHtcbiAgICAgICAgICBtb2R1bGVOYW1lOiB1bmRlZmluZWQsXG4gICAgICAgICAgZGVjbGFyZUxlZ2FjeU5hbWVzcGFjZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV4cG9ydHM7XG4gICAgICAgIGlmIChnb29nLmlzRnVuY3Rpb24obW9kdWxlRGVmKSkge1xuICAgICAgICAgIGV4cG9ydHMgPSBtb2R1bGVEZWYuY2FsbChnb29nLmdsb2JhbCwge30pO1xuICAgICAgICB9IGVsc2UgaWYgKGdvb2cuaXNTdHJpbmcobW9kdWxlRGVmKSkge1xuICAgICAgICAgIGV4cG9ydHMgPSBnb29nLmxvYWRNb2R1bGVGcm9tU291cmNlXy5jYWxsKGdvb2cuZ2xvYmFsLCBtb2R1bGVEZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG1vZHVsZSBkZWZpbml0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kdWxlTmFtZSA9IGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLm1vZHVsZU5hbWU7XG4gICAgICAgIGlmICghZ29vZy5pc1N0cmluZyhtb2R1bGVOYW1lKSB8fCAhbW9kdWxlTmFtZSkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIG1vZHVsZSBuYW1lIFxcXCInICsgbW9kdWxlTmFtZSArICdcXFwiJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBzZWFsIGxlZ2FjeSBuYW1lc3BhY2VzIGFzIHRoZXkgbWF5IGJlIHVzZXMgYXMgYSBwYXJlbnQgb2ZcbiAgICAgICAgLy8gYW5vdGhlciBuYW1lc3BhY2VcbiAgICAgICAgaWYgKGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfLmRlY2xhcmVMZWdhY3lOYW1lc3BhY2UpIHtcbiAgICAgICAgICBnb29nLmNvbnN0cnVjdE5hbWVzcGFjZV8obW9kdWxlTmFtZSwgZXhwb3J0cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ29vZy5TRUFMX01PRFVMRV9FWFBPUlRTICYmIE9iamVjdC5zZWFsKSB7XG4gICAgICAgICAgT2JqZWN0LnNlYWwoZXhwb3J0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBnb29nLmxvYWRlZE1vZHVsZXNfW21vZHVsZU5hbWVdID0gZXhwb3J0cztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfID0gcHJldmlvdXNTdGF0ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGUgQGNvbnN0IHtmdW5jdGlvbihzdHJpbmcpOj99XG4gICAgICpcbiAgICAgKiBUaGUgbmV3IHR5cGUgaW5mZXJlbmNlIHdhcm5zIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBoYXMgbm8gZm9ybWFsXG4gICAgICogcGFyYW1ldGVycywgYnV0IGl0cyBqc2RvYyBzYXlzIHRoYXQgaXQgdGFrZXMgb25lIGFyZ3VtZW50LlxuICAgICAqIChUaGUgYXJndW1lbnQgaXMgdXNlZCB2aWEgYXJndW1lbnRzWzBdLCBidXQgTlRJIGRvZXMgbm90IGRldGVjdCB0aGlzLilcbiAgICAgKiBAc3VwcHJlc3Mge25ld0NoZWNrVHlwZXN9XG4gICAgICovXG4gICAgZ29vZy5sb2FkTW9kdWxlRnJvbVNvdXJjZV8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBOT1RFOiB3ZSBhdm9pZCBkZWNsYXJpbmcgcGFyYW1ldGVycyBvciBsb2NhbCB2YXJpYWJsZXMgaGVyZSB0byBhdm9pZFxuICAgICAgLy8gbWFza2luZyBnbG9iYWxzIG9yIGxlYWtpbmcgdmFsdWVzIGludG8gdGhlIG1vZHVsZSBkZWZpbml0aW9uLlxuICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgICB2YXIgZXhwb3J0cyA9IHt9O1xuICAgICAgZXZhbChhcmd1bWVudHNbMF0pO1xuICAgICAgcmV0dXJuIGV4cG9ydHM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIG5ldyBzY3JpcHQgcG9pbnRpbmcgdG8ge0Bjb2RlIHNyY30gZGlyZWN0bHkgaW50byB0aGUgRE9NLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IENTUC1jb21wbGlhbnQuIEBzZWUgZ29vZy5hcHBlbmRTY3JpcHRTcmNOb2RlXyBmb3JcbiAgICAgKiB0aGUgZmFsbGJhY2sgbWVjaGFuaXNtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgc2NyaXB0IFVSTC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cud3JpdGVTY3JpcHRTcmNOb2RlXyA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgIGdvb2cuZ2xvYmFsLmRvY3VtZW50LndyaXRlKCc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCInICsgc3JjICsgJ1wiPjwvJyArICdzY3JpcHQ+Jyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBuZXcgc2NyaXB0IG5vZGUgdG8gdGhlIERPTSB1c2luZyBhIENTUC1jb21wbGlhbnQgbWVjaGFuaXNtLiBUaGlzXG4gICAgICogbWV0aG9kIGV4aXN0cyBhcyBhIGZhbGxiYWNrIGZvciBkb2N1bWVudC53cml0ZSAod2hpY2ggaXMgbm90IGFsbG93ZWQgaW4gYVxuICAgICAqIHN0cmljdCBDU1AgY29udGV4dCwgZS5nLiwgQ2hyb21lIGFwcHMpLlxuICAgICAqXG4gICAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGFuYWxvZ291cyB0byB1c2luZyBkb2N1bWVudC53cml0ZSB0byBpbnNlcnQgYVxuICAgICAqIDxzY3JpcHQ+IHRhZzsgc3BlY2lmaWNhbGx5LCB0aGUgdXNlciBhZ2VudCB3aWxsIGV4ZWN1dGUgYSBzY3JpcHQgYWRkZWQgYnlcbiAgICAgKiBkb2N1bWVudC53cml0ZSBpbW1lZGlhdGVseSBhZnRlciB0aGUgY3VycmVudCBzY3JpcHQgYmxvY2sgZmluaXNoZXNcbiAgICAgKiBleGVjdXRpbmcsIHdoZXJlYXMgdGhlIERPTS1hcHBlbmRlZCBzY3JpcHQgbm9kZSB3aWxsIG5vdCBiZSBleGVjdXRlZCB1bnRpbFxuICAgICAqIHRoZSBlbnRpcmUgZG9jdW1lbnQgaXMgcGFyc2VkIGFuZCBleGVjdXRlZC4gVGhhdCBpcyB0byBzYXksIHRoaXMgc2NyaXB0IGlzXG4gICAgICogYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgc2NyaXB0IGV4ZWN1dGlvbiBxdWV1ZS5cbiAgICAgKlxuICAgICAqIFRoZSBwYWdlIG11c3Qgbm90IGF0dGVtcHQgdG8gY2FsbCBnb29nLnJlcXVpcmVkIGVudGl0aWVzIHVudGlsIGFmdGVyIHRoZVxuICAgICAqIGRvY3VtZW50IGhhcyBsb2FkZWQsIGUuZy4sIGluIG9yIGFmdGVyIHRoZSB3aW5kb3cub25sb2FkIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNyYyBUaGUgc2NyaXB0IFVSTC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuYXBwZW5kU2NyaXB0U3JjTm9kZV8gPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAvKiogQHR5cGUge0RvY3VtZW50fSAqL1xuICAgICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuICAgICAgdmFyIHNjcmlwdEVsID1cbiAgICAgIC8qKiBAdHlwZSB7SFRNTFNjcmlwdEVsZW1lbnR9ICovZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgc2NyaXB0RWwuc3JjID0gc3JjO1xuICAgICAgc2NyaXB0RWwuZGVmZXIgPSBmYWxzZTtcbiAgICAgIHNjcmlwdEVsLmFzeW5jID0gZmFsc2U7XG4gICAgICBkb2MuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBpbXBvcnQgZnVuY3Rpb24uIFdyaXRlcyBhIHNjcmlwdCB0YWcgdG9cbiAgICAgKiBpbXBvcnQgdGhlIHNjcmlwdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVGhlIHNjcmlwdCB1cmwuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfc291cmNlVGV4dCBUaGUgb3B0aW9uYWxseSBzb3VyY2UgdGV4dCB0byBldmFsdWF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNjcmlwdCB3YXMgaW1wb3J0ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cud3JpdGVTY3JpcHRUYWdfID0gZnVuY3Rpb24gKHNyYywgb3B0X3NvdXJjZVRleHQpIHtcbiAgICAgIGlmIChnb29nLmluSHRtbERvY3VtZW50XygpKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7IUhUTUxEb2N1bWVudH0gKi9cbiAgICAgICAgdmFyIGRvYyA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50O1xuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHRyaWVzIHRvIHJlcXVpcmUgYSBuZXcgc3ltYm9sIGFmdGVyIGRvY3VtZW50IGxvYWQsXG4gICAgICAgIC8vIHNvbWV0aGluZyBoYXMgZ29uZSB0ZXJyaWJseSB3cm9uZy4gRG9pbmcgYSBkb2N1bWVudC53cml0ZSB3b3VsZFxuICAgICAgICAvLyB3aXBlIG91dCB0aGUgcGFnZS4gVGhpcyBkb2VzIG5vdCBhcHBseSB0byB0aGUgQ1NQLWNvbXBsaWFudCBtZXRob2RcbiAgICAgICAgLy8gb2Ygd3JpdGluZyBzY3JpcHQgdGFncy5cbiAgICAgICAgaWYgKCFnb29nLkVOQUJMRV9DSFJPTUVfQVBQX1NBRkVfU0NSSVBUX0xPQURJTkcgJiYgZG9jLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIC8vIENlcnRhaW4gdGVzdCBmcmFtZXdvcmtzIGxvYWQgYmFzZS5qcyBtdWx0aXBsZSB0aW1lcywgd2hpY2ggdHJpZXNcbiAgICAgICAgICAvLyB0byB3cml0ZSBkZXBzLmpzIGVhY2ggdGltZS4gSWYgdGhhdCBoYXBwZW5zLCBqdXN0IGZhaWwgc2lsZW50bHkuXG4gICAgICAgICAgLy8gVGhlc2UgZnJhbWV3b3JrcyB3aXBlIHRoZSBwYWdlIGJldHdlZW4gZWFjaCBsb2FkIG9mIGJhc2UuanMsIHNvIHRoaXNcbiAgICAgICAgICAvLyBpcyBPSy5cbiAgICAgICAgICB2YXIgaXNEZXBzID0gL1xcYmRlcHMuanMkLy50ZXN0KHNyYyk7XG4gICAgICAgICAgaWYgKGlzRGVwcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IHdyaXRlIFwiJyArIHNyYyArICdcIiBhZnRlciBkb2N1bWVudCBsb2FkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzT2xkSUUgPSBnb29nLklTX09MRF9JRV87XG5cbiAgICAgICAgaWYgKG9wdF9zb3VyY2VUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoIWlzT2xkSUUpIHtcbiAgICAgICAgICAgIGlmIChnb29nLkVOQUJMRV9DSFJPTUVfQVBQX1NBRkVfU0NSSVBUX0xPQURJTkcpIHtcbiAgICAgICAgICAgICAgZ29vZy5hcHBlbmRTY3JpcHRTcmNOb2RlXyhzcmMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZ29vZy53cml0ZVNjcmlwdFNyY05vZGVfKHNyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IFwiIG9ucmVhZHlzdGF0ZWNoYW5nZT0nZ29vZy5vblNjcmlwdExvYWRfKHRoaXMsIFwiICsgKytnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gKyBcIiknIFwiO1xuICAgICAgICAgICAgZG9jLndyaXRlKCc8c2NyaXB0IHR5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIiBzcmM9XCInICsgc3JjICsgJ1wiJyArIHN0YXRlICsgJz48LycgKyAnc2NyaXB0PicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2Mud3JpdGUoJzxzY3JpcHQgdHlwZT1cInRleHQvamF2YXNjcmlwdFwiPicgKyBvcHRfc291cmNlVGV4dCArICc8LycgKyAnc2NyaXB0PicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICBnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQSByZWFkeXN0YXRlY2hhbmdlIGhhbmRsZXIgZm9yIGxlZ2FjeSBJRVxuICAgICAqIEBwYXJhbSB7IUhUTUxTY3JpcHRFbGVtZW50fSBzY3JpcHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NyaXB0SW5kZXhcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZ29vZy5vblNjcmlwdExvYWRfID0gZnVuY3Rpb24gKHNjcmlwdCwgc2NyaXB0SW5kZXgpIHtcbiAgICAgIC8vIGZvciBub3cgbG9hZCB0aGUgbW9kdWxlcyB3aGVuIHdlIHJlYWNoIHRoZSBsYXN0IHNjcmlwdCxcbiAgICAgIC8vIGxhdGVyIGFsbG93IG1vcmUgaW50ZXItbWluZ2xpbmcuXG4gICAgICBpZiAoc2NyaXB0LnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJyAmJiBnb29nLmxhc3ROb25Nb2R1bGVTY3JpcHRJbmRleF8gPT0gc2NyaXB0SW5kZXgpIHtcbiAgICAgICAgZ29vZy5sb2FkUXVldWVkTW9kdWxlc18oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBkZXBlbmRlbmNpZXMgYmFzZWQgb24gdGhlIGRlcGVuZGVuY2llcyBhZGRlZCB1c2luZyBhZGREZXBlbmRlbmN5XG4gICAgICogYW5kIGNhbGxzIGltcG9ydFNjcmlwdF8gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhUb0xvYWQgVGhlIHBhdGggZnJvbSB3aGljaCB0byBzdGFydCBkaXNjb3ZlcmluZ1xuICAgICAqICAgICBkZXBlbmRlbmNpZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnb29nLndyaXRlU2NyaXB0c18gPSBmdW5jdGlvbiAocGF0aFRvTG9hZCkge1xuICAgICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gVGhlIHNjcmlwdHMgd2UgbmVlZCB0byB3cml0ZSB0aGlzIHRpbWUuICovXG4gICAgICB2YXIgc2NyaXB0cyA9IFtdO1xuICAgICAgdmFyIHNlZW5TY3JpcHQgPSB7fTtcbiAgICAgIHZhciBkZXBzID0gZ29vZy5kZXBlbmRlbmNpZXNfO1xuXG4gICAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHBhdGggKi9cbiAgICAgIGZ1bmN0aW9uIHZpc2l0Tm9kZShwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoIGluIGRlcHMud3JpdHRlbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgb25lLiBXZSBjYW4gZ2V0IGhlcmUgaWYgd2UgaGF2ZSBjeWNsaWNcbiAgICAgICAgLy8gZGVwZW5kZW5jaWVzLlxuICAgICAgICBpZiAocGF0aCBpbiBkZXBzLnZpc2l0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkZXBzLnZpc2l0ZWRbcGF0aF0gPSB0cnVlO1xuXG4gICAgICAgIGlmIChwYXRoIGluIGRlcHMucmVxdWlyZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciByZXF1aXJlTmFtZSBpbiBkZXBzLnJlcXVpcmVzW3BhdGhdKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWlyZWQgbmFtZSBpcyBkZWZpbmVkLCB3ZSBhc3N1bWUgdGhhdCBpdCB3YXMgYWxyZWFkeVxuICAgICAgICAgICAgLy8gYm9vdHN0cmFwcGVkIGJ5IG90aGVyIG1lYW5zLlxuICAgICAgICAgICAgaWYgKCFnb29nLmlzUHJvdmlkZWRfKHJlcXVpcmVOYW1lKSkge1xuICAgICAgICAgICAgICBpZiAocmVxdWlyZU5hbWUgaW4gZGVwcy5uYW1lVG9QYXRoKSB7XG4gICAgICAgICAgICAgICAgdmlzaXROb2RlKGRlcHMubmFtZVRvUGF0aFtyZXF1aXJlTmFtZV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdVbmRlZmluZWQgbmFtZVRvUGF0aCBmb3IgJyArIHJlcXVpcmVOYW1lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHBhdGggaW4gc2VlblNjcmlwdCkpIHtcbiAgICAgICAgICBzZWVuU2NyaXB0W3BhdGhdID0gdHJ1ZTtcbiAgICAgICAgICBzY3JpcHRzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmlzaXROb2RlKHBhdGhUb0xvYWQpO1xuXG4gICAgICAvLyByZWNvcmQgdGhhdCB3ZSBhcmUgZ29pbmcgdG8gbG9hZCBhbGwgdGhlc2Ugc2NyaXB0cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHNjcmlwdHNbaV07XG4gICAgICAgIGdvb2cuZGVwZW5kZW5jaWVzXy53cml0dGVuW3BhdGhdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSBtb2R1bGUgaXMgbG9hZGVkIHN5bmNocm9ub3VzbHkgdGhlbiB3ZSBuZWVkIHRvXG4gICAgICAvLyBjbGVhciB0aGUgY3VycmVudCBpbk1vZHVsZUxvYWRlciB2YWx1ZSwgYW5kIHJlc3RvcmUgaXQgd2hlbiB3ZSBhcmVcbiAgICAgIC8vIGRvbmUgbG9hZGluZyB0aGUgY3VycmVudCBcInJlcXVpcmVzXCIuXG4gICAgICB2YXIgbW9kdWxlU3RhdGUgPSBnb29nLm1vZHVsZUxvYWRlclN0YXRlXztcbiAgICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfID0gbnVsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gc2NyaXB0c1tpXTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICBpZiAoIWRlcHMucGF0aElzTW9kdWxlW3BhdGhdKSB7XG4gICAgICAgICAgICBnb29nLmltcG9ydFNjcmlwdF8oZ29vZy5iYXNlUGF0aCArIHBhdGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnb29nLmltcG9ydE1vZHVsZV8oZ29vZy5iYXNlUGF0aCArIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnb29nLm1vZHVsZUxvYWRlclN0YXRlXyA9IG1vZHVsZVN0YXRlO1xuICAgICAgICAgIHRocm93IEVycm9yKCdVbmRlZmluZWQgc2NyaXB0IGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVzdG9yZSB0aGUgY3VycmVudCBcIm1vZHVsZSBsb2FkaW5nIHN0YXRlXCJcbiAgICAgIGdvb2cubW9kdWxlTG9hZGVyU3RhdGVfID0gbW9kdWxlU3RhdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIExvb2tzIGF0IHRoZSBkZXBlbmRlbmN5IHJ1bGVzIGFuZCB0cmllcyB0byBkZXRlcm1pbmUgdGhlIHNjcmlwdCBmaWxlIHRoYXRcbiAgICAgKiBmdWxmaWxscyBhIHBhcnRpY3VsYXIgcnVsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVsZSBJbiB0aGUgZm9ybSBnb29nLm5hbWVzcGFjZS5DbGFzcyBvciBwcm9qZWN0LnNjcmlwdC5cbiAgICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBVcmwgY29ycmVzcG9uZGluZyB0byB0aGUgcnVsZSwgb3IgbnVsbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdvb2cuZ2V0UGF0aEZyb21EZXBzXyA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICBpZiAocnVsZSBpbiBnb29nLmRlcGVuZGVuY2llc18ubmFtZVRvUGF0aCkge1xuICAgICAgICByZXR1cm4gZ29vZy5kZXBlbmRlbmNpZXNfLm5hbWVUb1BhdGhbcnVsZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZ29vZy5maW5kQmFzZVBhdGhfKCk7XG5cbiAgICAvLyBBbGxvdyBwcm9qZWN0cyB0byBtYW5hZ2UgdGhlIGRlcHMgZmlsZXMgdGhlbXNlbHZlcy5cbiAgICBpZiAoIWdvb2cuZ2xvYmFsLkNMT1NVUkVfTk9fREVQUykge1xuICAgICAgZ29vZy5pbXBvcnRTY3JpcHRfKGdvb2cuYmFzZVBhdGggKyAnZGVwcy5qcycpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSBmaWxlIHBhdGggYnkgcmVtb3ZpbmcgcmVkdW5kYW50IFwiLi5cIiBhbmQgZXh0cmFuZW91cyBcIi5cIiBmaWxlXG4gICAqIHBhdGggY29tcG9uZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5ub3JtYWxpemVQYXRoXyA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmIChjb21wb25lbnRzW2ldID09ICcuJykge1xuICAgICAgICBjb21wb25lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaSAmJiBjb21wb25lbnRzW2ldID09ICcuLicgJiYgY29tcG9uZW50c1tpIC0gMV0gJiYgY29tcG9uZW50c1tpIC0gMV0gIT0gJy4uJykge1xuICAgICAgICBjb21wb25lbnRzLnNwbGljZSgtLWksIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50cy5qb2luKCcvJyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWRzIGZpbGUgYnkgc3luY2hyb25vdXMgWEhSLiBTaG91bGQgbm90IGJlIHVzZWQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU291cmNlIFVSTC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBGaWxlIGNvbnRlbnRzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5sb2FkRmlsZVN5bmNfID0gZnVuY3Rpb24gKHNyYykge1xuICAgIGlmIChnb29nLmdsb2JhbC5DTE9TVVJFX0xPQURfRklMRV9TWU5DKSB7XG4gICAgICByZXR1cm4gZ29vZy5nbG9iYWwuQ0xPU1VSRV9MT0FEX0ZJTEVfU1lOQyhzcmMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge1hNTEh0dHBSZXF1ZXN0fSAqL1xuICAgICAgdmFyIHhociA9IG5ldyBnb29nLmdsb2JhbFsnWE1MSHR0cFJlcXVlc3QnXSgpO1xuICAgICAgeGhyLm9wZW4oJ2dldCcsIHNyYywgZmFsc2UpO1xuICAgICAgeGhyLnNlbmQoKTtcbiAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmUgYW5kIGV4ZWN1dGUgYSBtb2R1bGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgU2NyaXB0IHNvdXJjZSBVUkwuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnJldHJpZXZlQW5kRXhlY01vZHVsZV8gPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgaWYgKCFDT01QSUxFRCkge1xuICAgICAgLy8gVGhlIGZ1bGwgYnV0IG5vbi1jYW5vbmljYWxpemVkIFVSTCBmb3IgbGF0ZXIgdXNlLlxuICAgICAgdmFyIG9yaWdpbmFsUGF0aCA9IHNyYztcbiAgICAgIC8vIENhbm9uaWNhbGl6ZSB0aGUgcGF0aCwgcmVtb3ZpbmcgYW55IC8uLyBvciAvLi4vIHNpbmNlIENocm9tZSdzIGRlYnVnZ2luZ1xuICAgICAgLy8gY29uc29sZSBkb2Vzbid0IGF1dG8tY2Fub25pY2FsaXplIFhIUiBsb2FkcyBhcyBpdCBkb2VzIDxzY3JpcHQ+IHNyY3MuXG4gICAgICBzcmMgPSBnb29nLm5vcm1hbGl6ZVBhdGhfKHNyYyk7XG5cbiAgICAgIHZhciBpbXBvcnRTY3JpcHQgPSBnb29nLmdsb2JhbC5DTE9TVVJFX0lNUE9SVF9TQ1JJUFQgfHwgZ29vZy53cml0ZVNjcmlwdFRhZ187XG5cbiAgICAgIHZhciBzY3JpcHRUZXh0ID0gZ29vZy5sb2FkRmlsZVN5bmNfKHNyYyk7XG5cbiAgICAgIGlmIChzY3JpcHRUZXh0ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGV4ZWNNb2R1bGVTY3JpcHQgPSBnb29nLndyYXBNb2R1bGVfKHNyYywgc2NyaXB0VGV4dCk7XG4gICAgICAgIHZhciBpc09sZElFID0gZ29vZy5JU19PTERfSUVfO1xuICAgICAgICBpZiAoaXNPbGRJRSkge1xuICAgICAgICAgIGdvb2cuZGVwZW5kZW5jaWVzXy5kZWZlcnJlZFtvcmlnaW5hbFBhdGhdID0gZXhlY01vZHVsZVNjcmlwdDtcbiAgICAgICAgICBnb29nLnF1ZXVlZE1vZHVsZXNfLnB1c2gob3JpZ2luYWxQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbXBvcnRTY3JpcHQoc3JjLCBleGVjTW9kdWxlU2NyaXB0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2FkIG9mICcgKyBzcmMgKyAnZmFpbGVkJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIExhbmd1YWdlIEVuaGFuY2VtZW50c1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBcImZpeGVkXCIgdmVyc2lvbiBvZiB0aGUgdHlwZW9mIG9wZXJhdG9yLiAgSXQgZGlmZmVycyBmcm9tIHRoZSB0eXBlb2ZcbiAgICogb3BlcmF0b3IgaW4gc3VjaCBhIHdheSB0aGF0IG51bGwgcmV0dXJucyAnbnVsbCcgYW5kIGFycmF5cyByZXR1cm4gJ2FycmF5Jy5cbiAgICogQHBhcmFtIHs/fSB2YWx1ZSBUaGUgdmFsdWUgdG8gZ2V0IHRoZSB0eXBlIG9mLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9mIHRoZSB0eXBlLlxuICAgKi9cbiAgZ29vZy50eXBlT2YgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpO1xuICAgIGlmIChzID09ICdvYmplY3QnKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlc2UgZmlyc3QsIHNvIHdlIGNhbiBhdm9pZCBjYWxsaW5nIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgaWZcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIElFIGltcHJvcGVybHkgbWFyc2hhbHMgdHlwZW9mIGFjcm9zcyBleGVjdXRpb24gY29udGV4dHMsIGJ1dCBhXG4gICAgICAgIC8vIGNyb3NzLWNvbnRleHQgb2JqZWN0IHdpbGwgc3RpbGwgcmV0dXJuIGZhbHNlIGZvciBcImluc3RhbmNlb2YgT2JqZWN0XCIuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBQ0s6IEluIG9yZGVyIHRvIHVzZSBhbiBPYmplY3QgcHJvdG90eXBlIG1ldGhvZCBvbiB0aGUgYXJiaXRyYXJ5XG4gICAgICAgIC8vICAgdmFsdWUsIHRoZSBjb21waWxlciByZXF1aXJlcyB0aGUgdmFsdWUgYmUgY2FzdCB0byB0eXBlIE9iamVjdCxcbiAgICAgICAgLy8gICBldmVuIHRob3VnaCB0aGUgRUNNQSBzcGVjIGV4cGxpY2l0bHkgYWxsb3dzIGl0LlxuICAgICAgICB2YXIgY2xhc3NOYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFxuICAgICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovdmFsdWUpO1xuICAgICAgICAvLyBJbiBGaXJlZm94IDMuNiwgYXR0ZW1wdGluZyB0byBhY2Nlc3MgaWZyYW1lIHdpbmRvdyBvYmplY3RzJyBsZW5ndGhcbiAgICAgICAgLy8gcHJvcGVydHkgdGhyb3dzIGFuIE5TX0VSUk9SX0ZBSUxVUkUsIHNvIHdlIG5lZWQgdG8gc3BlY2lhbC1jYXNlIGl0XG4gICAgICAgIC8vIGhlcmUuXG4gICAgICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBjYW5ub3QgYWx3YXlzIHVzZSBjb25zdHJ1Y3RvciA9PSBBcnJheSBvciBpbnN0YW5jZW9mIEFycmF5IGJlY2F1c2VcbiAgICAgICAgLy8gZGlmZmVyZW50IGZyYW1lcyBoYXZlIGRpZmZlcmVudCBBcnJheSBvYmplY3RzLiBJbiBJRTYsIGlmIHRoZSBpZnJhbWVcbiAgICAgICAgLy8gd2hlcmUgdGhlIGFycmF5IHdhcyBjcmVhdGVkIGlzIGRlc3Ryb3llZCwgdGhlIGFycmF5IGxvc2VzIGl0c1xuICAgICAgICAvLyBwcm90b3R5cGUuIFRoZW4gZGVyZWZlcmVuY2luZyB2YWwuc3BsaWNlIGhlcmUgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgc29cbiAgICAgICAgLy8gd2UgY2FuJ3QgdXNlIGdvb2cuaXNGdW5jdGlvbi4gQ2FsbGluZyB0eXBlb2YgZGlyZWN0bHkgcmV0dXJucyAndW5rbm93bidcbiAgICAgICAgLy8gc28gdGhhdCB3aWxsIHdvcmsuIEluIHRoaXMgY2FzZSwgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZSBhbmRcbiAgICAgICAgLy8gbW9zdCBhcnJheSBmdW5jdGlvbnMgd2lsbCBzdGlsbCB3b3JrIGJlY2F1c2UgdGhlIGFycmF5IGlzIHN0aWxsXG4gICAgICAgIC8vIGFycmF5LWxpa2UgKHN1cHBvcnRzIGxlbmd0aCBhbmQgW10pIGV2ZW4gdGhvdWdoIGl0IGhhcyBsb3N0IGl0c1xuICAgICAgICAvLyBwcm90b3R5cGUuXG4gICAgICAgIC8vIE1hcmsgTWlsbGVyIG5vdGljZWQgdGhhdCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG4gICAgICAgIC8vIGFsbG93cyBhY2Nlc3MgdG8gdGhlIHVuZm9yZ2VhYmxlIFtbQ2xhc3NdXSBwcm9wZXJ0eS5cbiAgICAgICAgLy8gIDE1LjIuNC4yIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKCApXG4gICAgICAgIC8vICBXaGVuIHRoZSB0b1N0cmluZyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgLy8gICAgICAxLiBHZXQgdGhlIFtbQ2xhc3NdXSBwcm9wZXJ0eSBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgLy8gICAgICAyLiBDb21wdXRlIGEgc3RyaW5nIHZhbHVlIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHRocmVlIHN0cmluZ3NcbiAgICAgICAgLy8gICAgICAgICBcIltvYmplY3QgXCIsIFJlc3VsdCgxKSwgYW5kIFwiXVwiLlxuICAgICAgICAvLyAgICAgIDMuIFJldHVybiBSZXN1bHQoMikuXG4gICAgICAgIC8vIGFuZCB0aGlzIGJlaGF2aW9yIHN1cnZpdmVzIHRoZSBkZXN0cnVjdGlvbiBvZiB0aGUgZXhlY3V0aW9uIGNvbnRleHQuXG4gICAgICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJyB8fFxuICAgICAgICAvLyBJbiBJRSBhbGwgbm9uIHZhbHVlIHR5cGVzIGFyZSB3cmFwcGVkIGFzIG9iamVjdHMgYWNyb3NzIHdpbmRvd1xuICAgICAgICAvLyBib3VuZGFyaWVzIChub3QgaWZyYW1lIHRob3VnaCkgc28gd2UgaGF2ZSB0byBkbyBvYmplY3QgZGV0ZWN0aW9uXG4gICAgICAgIC8vIGZvciB0aGlzIGVkZ2UgY2FzZS5cbiAgICAgICAgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUuc3BsaWNlICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB2YWx1ZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAhPSAndW5kZWZpbmVkJyAmJiAhdmFsdWUucHJvcGVydHlJc0VudW1lcmFibGUoJ3NwbGljZScpKSB7XG4gICAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSEFDSzogVGhlcmUgaXMgc3RpbGwgYW4gYXJyYXkgY2FzZSB0aGF0IGZhaWxzLlxuICAgICAgICAvLyAgICAgZnVuY3Rpb24gQXJyYXlJbXBvc3RvcigpIHt9XG4gICAgICAgIC8vICAgICBBcnJheUltcG9zdG9yLnByb3RvdHlwZSA9IFtdO1xuICAgICAgICAvLyAgICAgdmFyIGltcG9zdG9yID0gbmV3IEFycmF5SW1wb3N0b3I7XG4gICAgICAgIC8vIHRoaXMgY2FuIGJlIGZpeGVkIGJ5IGdldHRpbmcgcmlkIG9mIHRoZSBmYXN0IHBhdGhcbiAgICAgICAgLy8gKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIGFuZCBzb2xlbHkgcmVseWluZyBvblxuICAgICAgICAvLyAodmFsdWUgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy52YWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGQgcmVxdWlyZSBtYW55IG1vcmUgZnVuY3Rpb24gY2FsbHMgYW5kIGlzIG5vdCB3YXJyYW50ZWRcbiAgICAgICAgLy8gdW5sZXNzIGNsb3N1cmUgY29kZSBpcyByZWNlaXZpbmcgb2JqZWN0cyBmcm9tIHVudHJ1c3RlZCBzb3VyY2VzLlxuXG4gICAgICAgIC8vIElFIGluIGNyb3NzLXdpbmRvdyBjYWxscyBkb2VzIG5vdCBjb3JyZWN0bHkgbWFyc2hhbCB0aGUgZnVuY3Rpb24gdHlwZVxuICAgICAgICAvLyAoaXQgYXBwZWFycyBqdXN0IGFzIGFuIG9iamVjdCkgc28gd2UgY2Fubm90IHVzZSBqdXN0IHR5cGVvZiB2YWwgPT1cbiAgICAgICAgLy8gJ2Z1bmN0aW9uJy4gSG93ZXZlciwgaWYgdGhlIG9iamVjdCBoYXMgYSBjYWxsIHByb3BlcnR5LCBpdCBpcyBhXG4gICAgICAgIC8vIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY2xhc3NOYW1lID09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHwgdHlwZW9mIHZhbHVlLmNhbGwgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHZhbHVlLnByb3BlcnR5SXNFbnVtZXJhYmxlICE9ICd1bmRlZmluZWQnICYmICF2YWx1ZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgnY2FsbCcpKSB7XG4gICAgICAgICAgcmV0dXJuICdmdW5jdGlvbic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmNhbGwgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIEluIFNhZmFyaSB0eXBlb2Ygbm9kZUxpc3QgcmV0dXJucyAnZnVuY3Rpb24nLCBhbmQgb24gRmlyZWZveCB0eXBlb2ZcbiAgICAgIC8vIGJlaGF2ZXMgc2ltaWxhcmx5IGZvciBIVE1Me0FwcGxldCxFbWJlZCxPYmplY3R9LCBFbGVtZW50cyBhbmQgUmVnRXhwcy4gV2VcbiAgICAgIC8vIHdvdWxkIGxpa2UgdG8gcmV0dXJuIG9iamVjdCBmb3IgdGhvc2UgYW5kIHdlIGNhbiBkZXRlY3QgYW4gaW52YWxpZFxuICAgICAgLy8gZnVuY3Rpb24gYnkgbWFraW5nIHN1cmUgdGhhdCB0aGUgZnVuY3Rpb24gb2JqZWN0IGhhcyBhIGNhbGwgbWV0aG9kLlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbnVsbC5cbiAgICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBudWxsLlxuICAgKi9cbiAgZ29vZy5pc051bGwgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PT0gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgZGVmaW5lZCBhbmQgbm90IG51bGwuXG4gICAqL1xuICBnb29nLmlzRGVmQW5kTm90TnVsbCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBOb3RlIHRoYXQgdW5kZWZpbmVkID09IG51bGwuXG4gICAgcmV0dXJuIHZhbCAhPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBhcnJheS5cbiAgICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBhcnJheS5cbiAgICovXG4gIGdvb2cuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gZ29vZy50eXBlT2YodmFsKSA9PSAnYXJyYXknO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGFuIGFycmF5LiBUbyBxdWFsaWZ5IGFzIGFycmF5IGxpa2VcbiAgICogdGhlIHZhbHVlIG5lZWRzIHRvIGJlIGVpdGhlciBhIE5vZGVMaXN0IG9yIGFuIG9iamVjdCB3aXRoIGEgTnVtYmVyIGxlbmd0aFxuICAgKiBwcm9wZXJ0eS4gQXMgYSBzcGVjaWFsIGNhc2UsIGEgZnVuY3Rpb24gdmFsdWUgaXMgbm90IGFycmF5IGxpa2UsIGJlY2F1c2UgaXRzXG4gICAqIGxlbmd0aCBwcm9wZXJ0eSBpcyBmaXhlZCB0byBjb3JyZXNwb25kIHRvIHRoZSBudW1iZXIgb2YgZXhwZWN0ZWQgYXJndW1lbnRzLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGFuIGFycmF5LlxuICAgKi9cbiAgZ29vZy5pc0FycmF5TGlrZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB2YXIgdHlwZSA9IGdvb2cudHlwZU9mKHZhbCk7XG4gICAgLy8gV2UgZG8gbm90IHVzZSBnb29nLmlzT2JqZWN0IGhlcmUgaW4gb3JkZXIgdG8gZXhjbHVkZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAgcmV0dXJuIHR5cGUgPT0gJ2FycmF5JyB8fCB0eXBlID09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwubGVuZ3RoID09ICdudW1iZXInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgRGF0ZS4gVG8gcXVhbGlmeSBhcyBEYXRlLWxpa2UgdGhlXG4gICAqIHZhbHVlIG5lZWRzIHRvIGJlIGFuIG9iamVjdCBhbmQgaGF2ZSBhIGdldEZ1bGxZZWFyKCkgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBsaWtlIGEgRGF0ZS5cbiAgICovXG4gIGdvb2cuaXNEYXRlTGlrZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gZ29vZy5pc09iamVjdCh2YWwpICYmIHR5cGVvZiB2YWwuZ2V0RnVsbFllYXIgPT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBzdHJpbmcuXG4gICAqL1xuICBnb29nLmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09ICdzdHJpbmcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAgICovXG4gIGdvb2cuaXNCb29sZWFuID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09ICdib29sZWFuJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gICAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gICAqL1xuICBnb29nLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09ICdudW1iZXInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb24uXG4gICAqL1xuICBnb29nLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIGdvb2cudHlwZU9mKHZhbCkgPT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gb2JqZWN0LiAgVGhpcyBpbmNsdWRlcyBhcnJheXMgYW5kXG4gICAqIGZ1bmN0aW9ucy5cbiAgICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gICAqL1xuICBnb29nLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKTtcbiAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0JyAmJiB2YWwgIT0gbnVsbCB8fCB0eXBlID09ICdmdW5jdGlvbic7XG4gICAgLy8gcmV0dXJuIE9iamVjdCh2YWwpID09PSB2YWwgYWxzbyB3b3JrcywgYnV0IGlzIHNsb3dlciwgZXNwZWNpYWxseSBpZiB2YWwgaXNcbiAgICAvLyBub3QgYW4gb2JqZWN0LlxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIGEgdW5pcXVlIElEIGZvciBhbiBvYmplY3QuIFRoaXMgbXV0YXRlcyB0aGUgb2JqZWN0IHNvIHRoYXQgZnVydGhlciBjYWxsc1xuICAgKiB3aXRoIHRoZSBzYW1lIG9iamVjdCBhcyBhIHBhcmFtZXRlciByZXR1cm5zIHRoZSBzYW1lIHZhbHVlLiBUaGUgdW5pcXVlIElEIGlzXG4gICAqIGd1YXJhbnRlZWQgdG8gYmUgdW5pcXVlIGFjcm9zcyB0aGUgY3VycmVudCBzZXNzaW9uIGFtb25nc3Qgb2JqZWN0cyB0aGF0IGFyZVxuICAgKiBwYXNzZWQgaW50byB7QGNvZGUgZ2V0VWlkfS4gVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIElEIGlzIHVuaXF1ZSBvclxuICAgKiBjb25zaXN0ZW50IGFjcm9zcyBzZXNzaW9ucy4gSXQgaXMgdW5zYWZlIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRCBmb3IgZnVuY3Rpb25cbiAgICogcHJvdG90eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgdW5pcXVlIElEIGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdW5pcXVlIElEIGZvciB0aGUgb2JqZWN0LlxuICAgKi9cbiAgZ29vZy5nZXRVaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgLy8gVE9ETyhhcnYpOiBNYWtlIHRoZSB0eXBlIHN0cmljdGVyLCBkbyBub3QgYWNjZXB0IG51bGwuXG5cbiAgICAvLyBJbiBPcGVyYSB3aW5kb3cuaGFzT3duUHJvcGVydHkgZXhpc3RzIGJ1dCBhbHdheXMgcmV0dXJucyBmYWxzZSBzbyB3ZSBhdm9pZFxuICAgIC8vIHVzaW5nIGl0LiBBcyBhIGNvbnNlcXVlbmNlIHRoZSB1bmlxdWUgSUQgZ2VuZXJhdGVkIGZvciBCYXNlQ2xhc3MucHJvdG90eXBlXG4gICAgLy8gYW5kIFN1YkNsYXNzLnByb3RvdHlwZSB3aWxsIGJlIHRoZSBzYW1lLlxuICAgIHJldHVybiBvYmpbZ29vZy5VSURfUFJPUEVSVFlfXSB8fCAob2JqW2dvb2cuVUlEX1BST1BFUlRZX10gPSArK2dvb2cudWlkQ291bnRlcl8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYWxyZWFkeSBhc3NpZ25lZCBhIHVuaXF1ZSBJRC5cbiAgICpcbiAgICogVGhpcyBkb2VzIG5vdCBtb2RpZnkgdGhlIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHshT2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjaGVjay5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGVyZSBpcyBhbiBhc3NpZ25lZCB1bmlxdWUgaWQgZm9yIHRoZSBvYmplY3QuXG4gICAqL1xuICBnb29nLmhhc1VpZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gISFvYmpbZ29vZy5VSURfUFJPUEVSVFlfXTtcbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgdW5pcXVlIElEIGZyb20gYW4gb2JqZWN0LiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgb2JqZWN0IHdhc1xuICAgKiBwcmV2aW91c2x5IG11dGF0ZWQgdXNpbmcge0Bjb2RlIGdvb2cuZ2V0VWlkfSBpbiB3aGljaCBjYXNlIHRoZSBtdXRhdGlvbiBpc1xuICAgKiB1bmRvbmUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZW1vdmUgdGhlIHVuaXF1ZSBJRCBmaWVsZCBmcm9tLlxuICAgKi9cbiAgZ29vZy5yZW1vdmVVaWQgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgLy8gVE9ETyhhcnYpOiBNYWtlIHRoZSB0eXBlIHN0cmljdGVyLCBkbyBub3QgYWNjZXB0IG51bGwuXG5cbiAgICAvLyBJbiBJRSwgRE9NIG5vZGVzIGFyZSBub3QgaW5zdGFuY2VzIG9mIE9iamVjdCBhbmQgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIHdlXG4gICAgLy8gdHJ5IHRvIGRlbGV0ZS4gIEluc3RlYWQgd2UgdHJ5IHRvIHVzZSByZW1vdmVBdHRyaWJ1dGUuXG4gICAgaWYgKG9iaiAhPT0gbnVsbCAmJiAncmVtb3ZlQXR0cmlidXRlJyBpbiBvYmopIHtcbiAgICAgIG9iai5yZW1vdmVBdHRyaWJ1dGUoZ29vZy5VSURfUFJPUEVSVFlfKTtcbiAgICB9XG4gICAgLyoqIEBwcmVzZXJ2ZVRyeSAqL1xuICAgIHRyeSB7XG4gICAgICBkZWxldGUgb2JqW2dvb2cuVUlEX1BST1BFUlRZX107XG4gICAgfSBjYXRjaCAoZXgpIHt9XG4gIH07XG5cbiAgLyoqXG4gICAqIE5hbWUgZm9yIHVuaXF1ZSBJRCBwcm9wZXJ0eS4gSW5pdGlhbGl6ZWQgaW4gYSB3YXkgdG8gaGVscCBhdm9pZCBjb2xsaXNpb25zXG4gICAqIHdpdGggb3RoZXIgY2xvc3VyZSBKYXZhU2NyaXB0IG9uIHRoZSBzYW1lIHBhZ2UuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLlVJRF9QUk9QRVJUWV8gPSAnY2xvc3VyZV91aWRfJyArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKTtcblxuICAvKipcbiAgICogQ291bnRlciBmb3IgVUlELlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy51aWRDb3VudGVyXyA9IDA7XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBoYXNoIGNvZGUgZmllbGQgdG8gYW4gb2JqZWN0LiBUaGUgaGFzaCBjb2RlIGlzIHVuaXF1ZSBmb3IgdGhlXG4gICAqIGdpdmVuIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGdldCB0aGUgaGFzaCBjb2RlIGZvci5cbiAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaGFzaCBjb2RlIGZvciB0aGUgb2JqZWN0LlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ29vZy5nZXRVaWQgaW5zdGVhZC5cbiAgICovXG4gIGdvb2cuZ2V0SGFzaENvZGUgPSBnb29nLmdldFVpZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgaGFzaCBjb2RlIGZpZWxkIGZyb20gYW4gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBmaWVsZCBmcm9tLlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZ29vZy5yZW1vdmVVaWQgaW5zdGVhZC5cbiAgICovXG4gIGdvb2cucmVtb3ZlSGFzaENvZGUgPSBnb29nLnJlbW92ZVVpZDtcblxuICAvKipcbiAgICogQ2xvbmVzIGEgdmFsdWUuIFRoZSBpbnB1dCBtYXkgYmUgYW4gT2JqZWN0LCBBcnJheSwgb3IgYmFzaWMgdHlwZS4gT2JqZWN0cyBhbmRcbiAgICogYXJyYXlzIHdpbGwgYmUgY2xvbmVkIHJlY3Vyc2l2ZWx5LlxuICAgKlxuICAgKiBXQVJOSU5HUzpcbiAgICogPGNvZGU+Z29vZy5jbG9uZU9iamVjdDwvY29kZT4gZG9lcyBub3QgZGV0ZWN0IHJlZmVyZW5jZSBsb29wcy4gT2JqZWN0cyB0aGF0XG4gICAqIHJlZmVyIHRvIHRoZW1zZWx2ZXMgd2lsbCBjYXVzZSBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAqXG4gICAqIDxjb2RlPmdvb2cuY2xvbmVPYmplY3Q8L2NvZGU+IGlzIHVuYXdhcmUgb2YgdW5pcXVlIGlkZW50aWZpZXJzLCBhbmQgY29waWVzXG4gICAqIFVJRHMgY3JlYXRlZCBieSA8Y29kZT5nZXRVaWQ8L2NvZGU+IGludG8gY2xvbmVkIHJlc3VsdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb2JqIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAgICogQHJldHVybiB7Kn0gQSBjbG9uZSBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gICAqIEBkZXByZWNhdGVkIGdvb2cuY2xvbmVPYmplY3QgaXMgdW5zYWZlLiBQcmVmZXIgdGhlIGdvb2cub2JqZWN0IG1ldGhvZHMuXG4gICAqL1xuICBnb29nLmNsb25lT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciB0eXBlID0gZ29vZy50eXBlT2Yob2JqKTtcbiAgICBpZiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdhcnJheScpIHtcbiAgICAgIGlmIChvYmouY2xvbmUpIHtcbiAgICAgICAgcmV0dXJuIG9iai5jbG9uZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGNsb25lID0gdHlwZSA9PSAnYXJyYXknID8gW10gOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgY2xvbmVba2V5XSA9IGdvb2cuY2xvbmVPYmplY3Qob2JqW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH1cblxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgbmF0aXZlIGltcGxlbWVudGF0aW9uIG9mIGdvb2cuYmluZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fHVuZGVmaW5lZH0gc2VsZk9iaiBTcGVjaWZpZXMgdGhlIG9iamVjdCB3aGljaCB0aGlzIHNob3VsZFxuICAgKiAgICAgcG9pbnQgdG8gd2hlbiB0aGUgZnVuY3Rpb24gaXMgcnVuLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgYXJlIHBhcnRpYWxseSBhcHBsaWVkIHRvIHRoZVxuICAgKiAgICAgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBiaW5kKCkgd2FzXG4gICAqICAgICBpbnZva2VkIGFzIGEgbWV0aG9kIG9mLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc3VwcHJlc3Mge2RlcHJlY2F0ZWR9IFRoZSBjb21waWxlciB0aGlua3MgdGhhdCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBpc1xuICAgKiAgICAgZGVwcmVjYXRlZCBiZWNhdXNlIHNvbWUgcGVvcGxlIGhhdmUgZGVjbGFyZWQgYSBwdXJlLUpTIHZlcnNpb24uXG4gICAqICAgICBPbmx5IHRoZSBwdXJlLUpTIHZlcnNpb24gaXMgdHJ1bHkgZGVwcmVjYXRlZC5cbiAgICovXG4gIGdvb2cuYmluZE5hdGl2ZV8gPSBmdW5jdGlvbiAoZm4sIHNlbGZPYmosIHZhcl9hcmdzKSB7XG4gICAgcmV0dXJuICgvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi9mbi5jYWxsLmFwcGx5KGZuLmJpbmQsIGFyZ3VtZW50cylcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIHB1cmUtSlMgaW1wbGVtZW50YXRpb24gb2YgZ29vZy5iaW5kLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseS5cbiAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBzZWxmT2JqIFNwZWNpZmllcyB0aGUgb2JqZWN0IHdoaWNoIHRoaXMgc2hvdWxkXG4gICAqICAgICBwb2ludCB0byB3aGVuIHRoZSBmdW5jdGlvbiBpcyBydW4uXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBhcmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqICAgICBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGJpbmQoKSB3YXNcbiAgICogICAgIGludm9rZWQgYXMgYSBtZXRob2Qgb2YuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmJpbmRKc18gPSBmdW5jdGlvbiAoZm4sIHNlbGZPYmosIHZhcl9hcmdzKSB7XG4gICAgaWYgKCFmbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICB2YXIgYm91bmRBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByZXBlbmQgdGhlIGJvdW5kIGFyZ3VtZW50cyB0byB0aGUgY3VycmVudCBhcmd1bWVudHMuXG4gICAgICAgIHZhciBuZXdBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkobmV3QXJncywgYm91bmRBcmdzKTtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNlbGZPYmosIG5ld0FyZ3MpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHNlbGZPYmosIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUGFydGlhbGx5IGFwcGxpZXMgdGhpcyBmdW5jdGlvbiB0byBhIHBhcnRpY3VsYXIgJ3RoaXMgb2JqZWN0JyBhbmQgemVybyBvclxuICAgKiBtb3JlIGFyZ3VtZW50cy4gVGhlIHJlc3VsdCBpcyBhIG5ldyBmdW5jdGlvbiB3aXRoIHNvbWUgYXJndW1lbnRzIG9mIHRoZSBmaXJzdFxuICAgKiBmdW5jdGlvbiBwcmUtZmlsbGVkIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyAncHJlLXNwZWNpZmllZCcuXG4gICAqXG4gICAqIFJlbWFpbmluZyBhcmd1bWVudHMgc3BlY2lmaWVkIGF0IGNhbGwtdGltZSBhcmUgYXBwZW5kZWQgdG8gdGhlIHByZS1zcGVjaWZpZWRcbiAgICogb25lcy5cbiAgICpcbiAgICogQWxzbyBzZWU6IHtAbGluayAjcGFydGlhbH0uXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiA8cHJlPnZhciBiYXJNZXRoQm91bmQgPSBnb29nLmJpbmQobXlGdW5jdGlvbiwgbXlPYmosICdhcmcxJywgJ2FyZzInKTtcbiAgICogYmFyTWV0aEJvdW5kKCdhcmczJywgJ2FyZzQnKTs8L3ByZT5cbiAgICpcbiAgICogQHBhcmFtIHs/ZnVuY3Rpb24odGhpczpULCAuLi4pfSBmbiBBIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseS5cbiAgICogQHBhcmFtIHtUfSBzZWxmT2JqIFNwZWNpZmllcyB0aGUgb2JqZWN0IHdoaWNoIHRoaXMgc2hvdWxkIHBvaW50IHRvIHdoZW4gdGhlXG4gICAqICAgICBmdW5jdGlvbiBpcyBydW4uXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBhcmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqICAgICBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7IUZ1bmN0aW9ufSBBIHBhcnRpYWxseS1hcHBsaWVkIGZvcm0gb2YgdGhlIGZ1bmN0aW9uIGdvb2cuYmluZCgpIHdhc1xuICAgKiAgICAgaW52b2tlZCBhcyBhIG1ldGhvZCBvZi5cbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHN1cHByZXNzIHtkZXByZWNhdGVkfSBTZWUgYWJvdmUuXG4gICAqL1xuICBnb29nLmJpbmQgPSBmdW5jdGlvbiAoZm4sIHNlbGZPYmosIHZhcl9hcmdzKSB7XG4gICAgLy8gVE9ETyhuaWNrc2FudG9zKTogbmFycm93IHRoZSB0eXBlIHNpZ25hdHVyZS5cbiAgICBpZiAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiZcbiAgICAvLyBOT1RFKG5pY2tzYW50b3MpOiBTb21lYm9keSBwdWxsZWQgYmFzZS5qcyBpbnRvIHRoZSBkZWZhdWx0IENocm9tZVxuICAgIC8vIGV4dGVuc2lvbiBlbnZpcm9ubWVudC4gVGhpcyBtZWFucyB0aGF0IGZvciBDaHJvbWUgZXh0ZW5zaW9ucywgdGhleSBnZXRcbiAgICAvLyB0aGUgaW1wbGVtZW50YXRpb24gb2YgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgdGhhdCBjYWxscyBnb29nLmJpbmRcbiAgICAvLyBpbnN0ZWFkIG9mIHRoZSBuYXRpdmUgb25lLiBFdmVuIHdvcnNlLCB3ZSBkb24ndCB3YW50IHRvIGludHJvZHVjZSBhXG4gICAgLy8gY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIGdvb2cuYmluZCBhbmQgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQsIHNvXG4gICAgLy8gd2UgaGF2ZSB0byBoYWNrIHRoaXMgdG8gbWFrZSBzdXJlIGl0IHdvcmtzIGNvcnJlY3RseS5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC50b1N0cmluZygpLmluZGV4T2YoJ25hdGl2ZSBjb2RlJykgIT0gLTEpIHtcbiAgICAgIGdvb2cuYmluZCA9IGdvb2cuYmluZE5hdGl2ZV87XG4gICAgfSBlbHNlIHtcbiAgICAgIGdvb2cuYmluZCA9IGdvb2cuYmluZEpzXztcbiAgICB9XG4gICAgcmV0dXJuIGdvb2cuYmluZC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaWtlIGdvb2cuYmluZCgpLCBleGNlcHQgdGhhdCBhICd0aGlzIG9iamVjdCcgaXMgbm90IHJlcXVpcmVkLiBVc2VmdWwgd2hlblxuICAgKiB0aGUgdGFyZ2V0IGZ1bmN0aW9uIGlzIGFscmVhZHkgYm91bmQuXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiB2YXIgZyA9IGdvb2cucGFydGlhbChmLCBhcmcxLCBhcmcyKTtcbiAgICogZyhhcmczLCBhcmc0KTtcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBhcmUgcGFydGlhbGx5IGFwcGxpZWQgdG8gZm4uXG4gICAqIEByZXR1cm4geyFGdW5jdGlvbn0gQSBwYXJ0aWFsbHktYXBwbGllZCBmb3JtIG9mIHRoZSBmdW5jdGlvbiBnb29nLnBhcnRpYWwoKVxuICAgKiAgICAgd2FzIGludm9rZWQgYXMgYSBtZXRob2Qgb2YuXG4gICAqL1xuICBnb29nLnBhcnRpYWwgPSBmdW5jdGlvbiAoZm4sIHZhcl9hcmdzKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBDbG9uZSB0aGUgYXJyYXkgKHdpdGggc2xpY2UoKSkgYW5kIGFwcGVuZCBhZGRpdGlvbmFsIGFyZ3VtZW50c1xuICAgICAgLy8gdG8gdGhlIGV4aXN0aW5nIGFyZ3VtZW50cy5cbiAgICAgIHZhciBuZXdBcmdzID0gYXJncy5zbGljZSgpO1xuICAgICAgbmV3QXJncy5wdXNoLmFwcGx5KG5ld0FyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LiBUaGlzIG1ldGhvZFxuICAgKiBkb2VzIG5vdCB3b3JrIG9uIGFsbCBicm93c2VycyBmb3IgYWxsIG9iamVjdHMgdGhhdCBjb250YWluIGtleXMgc3VjaCBhc1xuICAgKiB0b1N0cmluZyBvciBoYXNPd25Qcm9wZXJ0eS4gVXNlIGdvb2cub2JqZWN0LmV4dGVuZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2UuXG4gICAqL1xuICBnb29nLm1peGluID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIgeCBpbiBzb3VyY2UpIHtcbiAgICAgIHRhcmdldFt4XSA9IHNvdXJjZVt4XTtcbiAgICB9XG5cbiAgICAvLyBGb3IgSUU3IG9yIGxvd2VyLCB0aGUgZm9yLWluLWxvb3AgZG9lcyBub3QgY29udGFpbiBhbnkgcHJvcGVydGllcyB0aGF0IGFyZVxuICAgIC8vIG5vdCBlbnVtZXJhYmxlIG9uIHRoZSBwcm90b3R5cGUgb2JqZWN0IChmb3IgZXhhbXBsZSwgaXNQcm90b3R5cGVPZiBmcm9tXG4gICAgLy8gT2JqZWN0LnByb3RvdHlwZSkgYnV0IGFsc28gaXQgd2lsbCBub3QgaW5jbHVkZSAncmVwbGFjZScgb24gb2JqZWN0cyB0aGF0XG4gICAgLy8gZXh0ZW5kIFN0cmluZyBhbmQgY2hhbmdlICdyZXBsYWNlJyAobm90IHRoYXQgaXQgaXMgY29tbW9uIGZvciBhbnlvbmUgdG9cbiAgICAvLyBleHRlbmQgYW55dGhpbmcgZXhjZXB0IE9iamVjdCkuXG4gIH07XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gQW4gaW50ZWdlciB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICogICAgIGJldHdlZW4gbWlkbmlnaHQsIEphbnVhcnkgMSwgMTk3MCBhbmQgdGhlIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIGdvb2cubm93ID0gZ29vZy5UUlVTVEVEX1NJVEUgJiYgRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICAgIC8vIFVuYXJ5IHBsdXMgb3BlcmF0b3IgY29udmVydHMgaXRzIG9wZXJhbmQgdG8gYSBudW1iZXIgd2hpY2ggaW5cbiAgICAvLyB0aGUgY2FzZSBvZlxuICAgIC8vIGEgZGF0ZSBpcyBkb25lIGJ5IGNhbGxpbmcgZ2V0VGltZSgpLlxuICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogRXZhbHMgSmF2YVNjcmlwdCBpbiB0aGUgZ2xvYmFsIHNjb3BlLiAgSW4gSUUgdGhpcyB1c2VzIGV4ZWNTY3JpcHQsIG90aGVyXG4gICAqIGJyb3dzZXJzIHVzZSBnb29nLmdsb2JhbC5ldmFsLiBJZiBnb29nLmdsb2JhbC5ldmFsIGRvZXMgbm90IGV2YWx1YXRlIGluIHRoZVxuICAgKiBnbG9iYWwgc2NvcGUgKGZvciBleGFtcGxlLCBpbiBTYWZhcmkpLCBhcHBlbmRzIGEgc2NyaXB0IHRhZyBpbnN0ZWFkLlxuICAgKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIG5laXRoZXIgZXhlY1NjcmlwdCBvciBldmFsIGlzIGRlZmluZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY3JpcHQgSmF2YVNjcmlwdCBzdHJpbmcuXG4gICAqL1xuICBnb29nLmdsb2JhbEV2YWwgPSBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgaWYgKGdvb2cuZ2xvYmFsLmV4ZWNTY3JpcHQpIHtcbiAgICAgIGdvb2cuZ2xvYmFsLmV4ZWNTY3JpcHQoc2NyaXB0LCAnSmF2YVNjcmlwdCcpO1xuICAgIH0gZWxzZSBpZiAoZ29vZy5nbG9iYWwuZXZhbCkge1xuICAgICAgLy8gVGVzdCB0byBzZWUgaWYgZXZhbCB3b3Jrc1xuICAgICAgaWYgKGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPT0gbnVsbCkge1xuICAgICAgICBnb29nLmdsb2JhbC5ldmFsKCd2YXIgX2V2YWxUZXN0XyA9IDE7Jyk7XG4gICAgICAgIGlmICh0eXBlb2YgZ29vZy5nbG9iYWxbJ19ldmFsVGVzdF8nXSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWxldGUgZ29vZy5nbG9iYWxbJ19ldmFsVGVzdF8nXTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgICAgICAgIC8vIE1pY3Jvc29mdCBlZGdlIGZhaWxzIHRoZSBkZWxldGlvbiBhYm92ZSBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICB9XG4gICAgICAgICAgZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ29vZy5ldmFsV29ya3NGb3JHbG9iYWxzXyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChnb29nLmV2YWxXb3Jrc0Zvckdsb2JhbHNfKSB7XG4gICAgICAgIGdvb2cuZ2xvYmFsLmV2YWwoc2NyaXB0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovXG4gICAgICAgIHZhciBkb2MgPSBnb29nLmdsb2JhbC5kb2N1bWVudDtcbiAgICAgICAgdmFyIHNjcmlwdEVsdCA9XG4gICAgICAgIC8qKiBAdHlwZSB7IUhUTUxTY3JpcHRFbGVtZW50fSAqL2RvYy5jcmVhdGVFbGVtZW50KCdTQ1JJUFQnKTtcbiAgICAgICAgc2NyaXB0RWx0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0RWx0LmRlZmVyID0gZmFsc2U7XG4gICAgICAgIC8vIE5vdGUodXNlcik6IGNhbid0IHVzZSAuaW5uZXJIVE1MIHNpbmNlIFwidCgnPHRlc3Q+JylcIiB3aWxsIGZhaWwgYW5kXG4gICAgICAgIC8vIC50ZXh0IGRvZXNuJ3Qgd29yayBpbiBTYWZhcmkgMi4gIFRoZXJlZm9yZSB3ZSBhcHBlbmQgYSB0ZXh0IG5vZGUuXG4gICAgICAgIHNjcmlwdEVsdC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUoc2NyaXB0KSk7XG4gICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdEVsdCk7XG4gICAgICAgIGRvYy5ib2R5LnJlbW92ZUNoaWxkKHNjcmlwdEVsdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdnb29nLmdsb2JhbEV2YWwgbm90IGF2YWlsYWJsZScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHdlIGNhbiBjYWxsICdldmFsJyBkaXJlY3RseSB0byBldmFsIGNvZGUgaW4gdGhlXG4gICAqIGdsb2JhbCBzY29wZS4gU2V0IHRvIGEgQm9vbGVhbiBieSB0aGUgZmlyc3QgY2FsbCB0byBnb29nLmdsb2JhbEV2YWwgKHdoaWNoXG4gICAqIGVtcGlyaWNhbGx5IHRlc3RzIHdoZXRoZXIgZXZhbCB3b3JrcyBmb3IgZ2xvYmFscykuIEBzZWUgZ29vZy5nbG9iYWxFdmFsXG4gICAqIEB0eXBlIHs/Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuZXZhbFdvcmtzRm9yR2xvYmFsc18gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBtYXAgb2YgQ1NTIGNsYXNzIG5hbWVzIHRvIG9iZnVzY2F0ZWQgbmFtZXMgdXNlZCB3aXRoXG4gICAqIGdvb2cuZ2V0Q3NzTmFtZSgpLlxuICAgKiBAcHJpdmF0ZSB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz58dW5kZWZpbmVkfVxuICAgKiBAc2VlIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmdcbiAgICovXG4gIGdvb2cuY3NzTmFtZU1hcHBpbmdfO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBvYmZ1c2NhdGlvbiBzdHlsZSBmb3IgQ1NTIGNsYXNzIG5hbWVzLiBTaG91bGQgYmUgc2V0IHRvIGVpdGhlclxuICAgKiAnQllfV0hPTEUnIG9yICdCWV9QQVJUJyBpZiBkZWZpbmVkLlxuICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICogQHNlZSBnb29nLnNldENzc05hbWVNYXBwaW5nXG4gICAqL1xuICBnb29nLmNzc05hbWVNYXBwaW5nU3R5bGVfO1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHN0cmluZ3MgdGhhdCBhcmUgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBDU1MgY2xhc3MgbmFtZXMuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd29ya3MgaW4gdGFuZGVtIHdpdGggQHNlZSBnb29nLnNldENzc05hbWVNYXBwaW5nLlxuICAgKlxuICAgKiBXaXRob3V0IGFueSBtYXBwaW5nIHNldCwgdGhlIGFyZ3VtZW50cyBhcmUgc2ltcGxlIGpvaW5lZCB3aXRoIGEgaHlwaGVuIGFuZFxuICAgKiBwYXNzZWQgdGhyb3VnaCB1bmFsdGVyZWQuXG4gICAqXG4gICAqIFdoZW4gdGhlcmUgaXMgYSBtYXBwaW5nLCB0aGVyZSBhcmUgdHdvIHBvc3NpYmxlIHN0eWxlcyBpbiB3aGljaCB0aGVzZVxuICAgKiBtYXBwaW5ncyBhcmUgdXNlZC4gSW4gdGhlIEJZX1BBUlQgc3R5bGUsIGVhY2ggcGFydCAoaS5lLiBpbiBiZXR3ZWVuIGh5cGhlbnMpXG4gICAqIG9mIHRoZSBwYXNzZWQgaW4gY3NzIG5hbWUgaXMgcmV3cml0dGVuIGFjY29yZGluZyB0byB0aGUgbWFwLiBJbiB0aGUgQllfV0hPTEVcbiAgICogc3R5bGUsIHRoZSBmdWxsIGNzcyBuYW1lIGlzIGxvb2tlZCB1cCBpbiB0aGUgbWFwIGRpcmVjdGx5LiBJZiBhIHJld3JpdGUgaXNcbiAgICogbm90IHNwZWNpZmllZCBieSB0aGUgbWFwLCB0aGUgY29tcGlsZXIgd2lsbCBvdXRwdXQgYSB3YXJuaW5nLlxuICAgKlxuICAgKiBXaGVuIHRoZSBtYXBwaW5nIGlzIHBhc3NlZCB0byB0aGUgY29tcGlsZXIsIGl0IHdpbGwgcmVwbGFjZSBjYWxscyB0b1xuICAgKiBnb29nLmdldENzc05hbWUgd2l0aCB0aGUgc3RyaW5ncyBmcm9tIHRoZSBtYXBwaW5nLCBlLmcuXG4gICAqICAgICB2YXIgeCA9IGdvb2cuZ2V0Q3NzTmFtZSgnZm9vJyk7XG4gICAqICAgICB2YXIgeSA9IGdvb2cuZ2V0Q3NzTmFtZSh0aGlzLmJhc2VDbGFzcywgJ2FjdGl2ZScpO1xuICAgKiAgYmVjb21lczpcbiAgICogICAgIHZhciB4ID0gJ2Zvbyc7XG4gICAqICAgICB2YXIgeSA9IHRoaXMuYmFzZUNsYXNzICsgJy1hY3RpdmUnO1xuICAgKlxuICAgKiBJZiBvbmUgYXJndW1lbnQgaXMgcGFzc2VkIGl0IHdpbGwgYmUgcHJvY2Vzc2VkLCBpZiB0d28gYXJlIHBhc3NlZCBvbmx5IHRoZVxuICAgKiBtb2RpZmllciB3aWxsIGJlIHByb2Nlc3NlZCwgYXMgaXQgaXMgYXNzdW1lZCB0aGUgZmlyc3QgYXJndW1lbnQgd2FzIGdlbmVyYXRlZFxuICAgKiBhcyBhIHJlc3VsdCBvZiBjYWxsaW5nIGdvb2cuZ2V0Q3NzTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbW9kaWZpZXIgQSBtb2RpZmllciB0byBiZSBhcHBlbmRlZCB0byB0aGUgY2xhc3MgbmFtZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY2xhc3MgbmFtZSBvciB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgY2xhc3MgbmFtZSBhbmRcbiAgICogICAgIHRoZSBtb2RpZmllci5cbiAgICovXG4gIGdvb2cuZ2V0Q3NzTmFtZSA9IGZ1bmN0aW9uIChjbGFzc05hbWUsIG9wdF9tb2RpZmllcikge1xuICAgIHZhciBnZXRNYXBwaW5nID0gZnVuY3Rpb24gZ2V0TWFwcGluZyhjc3NOYW1lKSB7XG4gICAgICByZXR1cm4gZ29vZy5jc3NOYW1lTWFwcGluZ19bY3NzTmFtZV0gfHwgY3NzTmFtZTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmFtZUJ5UGFydHMgPSBmdW5jdGlvbiByZW5hbWVCeVBhcnRzKGNzc05hbWUpIHtcbiAgICAgIC8vIFJlbWFwIGFsbCB0aGUgcGFydHMgaW5kaXZpZHVhbGx5LlxuICAgICAgdmFyIHBhcnRzID0gY3NzTmFtZS5zcGxpdCgnLScpO1xuICAgICAgdmFyIG1hcHBlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXBwZWQucHVzaChnZXRNYXBwaW5nKHBhcnRzW2ldKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwcGVkLmpvaW4oJy0nKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlbmFtZTtcbiAgICBpZiAoZ29vZy5jc3NOYW1lTWFwcGluZ18pIHtcbiAgICAgIHJlbmFtZSA9IGdvb2cuY3NzTmFtZU1hcHBpbmdTdHlsZV8gPT0gJ0JZX1dIT0xFJyA/IGdldE1hcHBpbmcgOiByZW5hbWVCeVBhcnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZW5hbWUgPSBmdW5jdGlvbiByZW5hbWUoYSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdF9tb2RpZmllcikge1xuICAgICAgcmV0dXJuIGNsYXNzTmFtZSArICctJyArIHJlbmFtZShvcHRfbW9kaWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVuYW1lKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBtYXAgdG8gY2hlY2sgd2hlbiByZXR1cm5pbmcgYSB2YWx1ZSBmcm9tIGdvb2cuZ2V0Q3NzTmFtZSgpLiBFeGFtcGxlOlxuICAgKiA8cHJlPlxuICAgKiBnb29nLnNldENzc05hbWVNYXBwaW5nKHtcbiAgICogICBcImdvb2dcIjogXCJhXCIsXG4gICAqICAgXCJkaXNhYmxlZFwiOiBcImJcIixcbiAgICogfSk7XG4gICAqXG4gICAqIHZhciB4ID0gZ29vZy5nZXRDc3NOYW1lKCdnb29nJyk7XG4gICAqIC8vIFRoZSBmb2xsb3dpbmcgZXZhbHVhdGVzIHRvOiBcImEgYS1iXCIuXG4gICAqIGdvb2cuZ2V0Q3NzTmFtZSgnZ29vZycpICsgJyAnICsgZ29vZy5nZXRDc3NOYW1lKHgsICdkaXNhYmxlZCcpXG4gICAqIDwvcHJlPlxuICAgKiBXaGVuIGRlY2xhcmVkIGFzIGEgbWFwIG9mIHN0cmluZyBsaXRlcmFscyB0byBzdHJpbmcgbGl0ZXJhbHMsIHRoZSBKU0NvbXBpbGVyXG4gICAqIHdpbGwgcmVwbGFjZSBhbGwgY2FsbHMgdG8gZ29vZy5nZXRDc3NOYW1lKCkgdXNpbmcgdGhlIHN1cHBsaWVkIG1hcCBpZiB0aGVcbiAgICogLS1wcm9jZXNzX2Nsb3N1cmVfcHJpbWl0aXZlcyBmbGFnIGlzIHNldC5cbiAgICpcbiAgICogQHBhcmFtIHshT2JqZWN0fSBtYXBwaW5nIEEgbWFwIG9mIHN0cmluZ3MgdG8gc3RyaW5ncyB3aGVyZSBrZXlzIGFyZSBwb3NzaWJsZVxuICAgKiAgICAgYXJndW1lbnRzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpIGFuZCB2YWx1ZXMgYXJlIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlc1xuICAgKiAgICAgdGhhdCBzaG91bGQgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X3N0eWxlIFRoZSBzdHlsZSBvZiBjc3MgbmFtZSBtYXBwaW5nLiBUaGVyZSBhcmUgdHdvIHZhbGlkXG4gICAqICAgICBvcHRpb25zOiAnQllfUEFSVCcsIGFuZCAnQllfV0hPTEUnLlxuICAgKiBAc2VlIGdvb2cuZ2V0Q3NzTmFtZSBmb3IgYSBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcgPSBmdW5jdGlvbiAobWFwcGluZywgb3B0X3N0eWxlKSB7XG4gICAgZ29vZy5jc3NOYW1lTWFwcGluZ18gPSBtYXBwaW5nO1xuICAgIGdvb2cuY3NzTmFtZU1hcHBpbmdTdHlsZV8gPSBvcHRfc3R5bGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRvIHVzZSBDU1MgcmVuYW1pbmcgaW4gY29tcGlsZWQgbW9kZSwgb25lIG9mIHRoZSBpbnB1dCBmaWxlcyBzaG91bGQgaGF2ZSBhXG4gICAqIGNhbGwgdG8gZ29vZy5zZXRDc3NOYW1lTWFwcGluZygpIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwgdGhhdCB0aGUgSlNDb21waWxlclxuICAgKiBjYW4gZXh0cmFjdCBhbmQgdXNlIHRvIHJlcGxhY2UgYWxsIGNhbGxzIHRvIGdvb2cuZ2V0Q3NzTmFtZSgpLiBJbiB1bmNvbXBpbGVkXG4gICAqIG1vZGUsIEphdmFTY3JpcHQgY29kZSBzaG91bGQgYmUgbG9hZGVkIGJlZm9yZSB0aGlzIGJhc2UuanMgZmlsZSB0aGF0IGRlY2xhcmVzXG4gICAqIGEgZ2xvYmFsIHZhcmlhYmxlLCBDTE9TVVJFX0NTU19OQU1FX01BUFBJTkcsIHdoaWNoIGlzIHVzZWQgYmVsb3cuIFRoaXMgaXNcbiAgICogdG8gZW5zdXJlIHRoYXQgdGhlIG1hcHBpbmcgaXMgbG9hZGVkIGJlZm9yZSBhbnkgY2FsbHMgdG8gZ29vZy5nZXRDc3NOYW1lKClcbiAgICogYXJlIG1hZGUgaW4gdW5jb21waWxlZCBtb2RlLlxuICAgKlxuICAgKiBBIGhvb2sgZm9yIG92ZXJyaWRpbmcgdGhlIENTUyBuYW1lIG1hcHBpbmcuXG4gICAqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPnx1bmRlZmluZWR9XG4gICAqL1xuICBnb29nLmdsb2JhbC5DTE9TVVJFX0NTU19OQU1FX01BUFBJTkc7XG5cbiAgaWYgKCFDT01QSUxFRCAmJiBnb29nLmdsb2JhbC5DTE9TVVJFX0NTU19OQU1FX01BUFBJTkcpIHtcbiAgICAvLyBUaGlzIGRvZXMgbm90IGNhbGwgZ29vZy5zZXRDc3NOYW1lTWFwcGluZygpIGJlY2F1c2UgdGhlIEpTQ29tcGlsZXJcbiAgICAvLyByZXF1aXJlcyB0aGF0IGdvb2cuc2V0Q3NzTmFtZU1hcHBpbmcoKSBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3QgbGl0ZXJhbC5cbiAgICBnb29nLmNzc05hbWVNYXBwaW5nXyA9IGdvb2cuZ2xvYmFsLkNMT1NVUkVfQ1NTX05BTUVfTUFQUElORztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgbG9jYWxpemVkIG1lc3NhZ2UuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb21waWxlciBwcmltaXRpdmUuIElmIHlvdSBnaXZlIHRoZSBjb21waWxlciBhIGxvY2FsaXplZFxuICAgKiBtZXNzYWdlIGJ1bmRsZSwgaXQgd2lsbCByZXBsYWNlIHRoZSBzdHJpbmcgYXQgY29tcGlsZS10aW1lIHdpdGggYSBsb2NhbGl6ZWRcbiAgICogdmVyc2lvbiwgYW5kIGV4cGFuZCBnb29nLmdldE1zZyBjYWxsIHRvIGEgY29uY2F0ZW5hdGVkIHN0cmluZy5cbiAgICpcbiAgICogTWVzc2FnZXMgbXVzdCBiZSBpbml0aWFsaXplZCBpbiB0aGUgZm9ybTpcbiAgICogPGNvZGU+XG4gICAqIHZhciBNU0dfTkFNRSA9IGdvb2cuZ2V0TXNnKCdIZWxsbyB7JHBsYWNlaG9sZGVyfScsIHsncGxhY2Vob2xkZXInOiAnd29ybGQnfSk7XG4gICAqIDwvY29kZT5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUcmFuc2xhdGFibGUgc3RyaW5nLCBwbGFjZXMgaG9sZGVycyBpbiB0aGUgZm9ybSB7JGZvb30uXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPj19IG9wdF92YWx1ZXMgTWFwcyBwbGFjZSBob2xkZXIgbmFtZSB0byB2YWx1ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBtZXNzYWdlIHdpdGggcGxhY2Vob2xkZXJzIGZpbGxlZC5cbiAgICovXG4gIGdvb2cuZ2V0TXNnID0gZnVuY3Rpb24gKHN0ciwgb3B0X3ZhbHVlcykge1xuICAgIGlmIChvcHRfdmFsdWVzKSB7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFx7XFwkKFtefV0rKX0vZywgZnVuY3Rpb24gKG1hdGNoLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdF92YWx1ZXMgIT0gbnVsbCAmJiBrZXkgaW4gb3B0X3ZhbHVlcyA/IG9wdF92YWx1ZXNba2V5XSA6IG1hdGNoO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgYSBsb2NhbGl6ZWQgbWVzc2FnZS4gSWYgdGhlIG1lc3NhZ2UgZG9lcyBub3QgaGF2ZSBhIHRyYW5zbGF0aW9uLCBnaXZlcyBhXG4gICAqIGZhbGxiYWNrIG1lc3NhZ2UuXG4gICAqXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gaW50cm9kdWNpbmcgYSBuZXcgbWVzc2FnZSB0aGF0IGhhcyBub3QgeWV0IGJlZW5cbiAgICogdHJhbnNsYXRlZCBpbnRvIGFsbCBsYW5ndWFnZXMuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb21waWxlciBwcmltaXRpdmUuIE11c3QgYmUgdXNlZCBpbiB0aGUgZm9ybTpcbiAgICogPGNvZGU+dmFyIHggPSBnb29nLmdldE1zZ1dpdGhGYWxsYmFjayhNU0dfQSwgTVNHX0IpOzwvY29kZT5cbiAgICogd2hlcmUgTVNHX0EgYW5kIE1TR19CIHdlcmUgaW5pdGlhbGl6ZWQgd2l0aCBnb29nLmdldE1zZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGEgVGhlIHByZWZlcnJlZCBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYiBUaGUgZmFsbGJhY2sgbWVzc2FnZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmVzdCB0cmFuc2xhdGVkIG1lc3NhZ2UuXG4gICAqL1xuICBnb29nLmdldE1zZ1dpdGhGYWxsYmFjayA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4cG9zZXMgYW4gdW5vYmZ1c2NhdGVkIGdsb2JhbCBuYW1lc3BhY2UgcGF0aCBmb3IgdGhlIGdpdmVuIG9iamVjdC5cbiAgICogTm90ZSB0aGF0IGZpZWxkcyBvZiB0aGUgZXhwb3J0ZWQgb2JqZWN0ICp3aWxsKiBiZSBvYmZ1c2NhdGVkLCB1bmxlc3MgdGhleSBhcmVcbiAgICogZXhwb3J0ZWQgaW4gdHVybiB2aWEgdGhpcyBmdW5jdGlvbiBvciBnb29nLmV4cG9ydFByb3BlcnR5LlxuICAgKlxuICAgKiBBbHNvIGhhbmR5IGZvciBtYWtpbmcgcHVibGljIGl0ZW1zIHRoYXQgYXJlIGRlZmluZWQgaW4gYW5vbnltb3VzIGNsb3N1cmVzLlxuICAgKlxuICAgKiBleC4gZ29vZy5leHBvcnRTeW1ib2woJ3B1YmxpYy5wYXRoLkZvbycsIEZvbyk7XG4gICAqXG4gICAqIGV4LiBnb29nLmV4cG9ydFN5bWJvbCgncHVibGljLnBhdGguRm9vLnN0YXRpY0Z1bmN0aW9uJywgRm9vLnN0YXRpY0Z1bmN0aW9uKTtcbiAgICogICAgIHB1YmxpYy5wYXRoLkZvby5zdGF0aWNGdW5jdGlvbigpO1xuICAgKlxuICAgKiBleC4gZ29vZy5leHBvcnRTeW1ib2woJ3B1YmxpYy5wYXRoLkZvby5wcm90b3R5cGUubXlNZXRob2QnLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgRm9vLnByb3RvdHlwZS5teU1ldGhvZCk7XG4gICAqICAgICBuZXcgcHVibGljLnBhdGguRm9vKCkubXlNZXRob2QoKTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHB1YmxpY1BhdGggVW5vYmZ1c2NhdGVkIG5hbWUgdG8gZXhwb3J0LlxuICAgKiBAcGFyYW0geyp9IG9iamVjdCBPYmplY3QgdGhlIG5hbWUgc2hvdWxkIHBvaW50IHRvLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdF9vYmplY3RUb0V4cG9ydFRvIFRoZSBvYmplY3QgdG8gYWRkIHRoZSBwYXRoIHRvOyBkZWZhdWx0XG4gICAqICAgICBpcyBnb29nLmdsb2JhbC5cbiAgICovXG4gIGdvb2cuZXhwb3J0U3ltYm9sID0gZnVuY3Rpb24gKHB1YmxpY1BhdGgsIG9iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pIHtcbiAgICBnb29nLmV4cG9ydFBhdGhfKHB1YmxpY1BhdGgsIG9iamVjdCwgb3B0X29iamVjdFRvRXhwb3J0VG8pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeHBvcnRzIGEgcHJvcGVydHkgdW5vYmZ1c2NhdGVkIGludG8gdGhlIG9iamVjdCdzIG5hbWVzcGFjZS5cbiAgICogZXguIGdvb2cuZXhwb3J0UHJvcGVydHkoRm9vLCAnc3RhdGljRnVuY3Rpb24nLCBGb28uc3RhdGljRnVuY3Rpb24pO1xuICAgKiBleC4gZ29vZy5leHBvcnRQcm9wZXJ0eShGb28ucHJvdG90eXBlLCAnbXlNZXRob2QnLCBGb28ucHJvdG90eXBlLm15TWV0aG9kKTtcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBPYmplY3Qgd2hvc2Ugc3RhdGljIHByb3BlcnR5IGlzIGJlaW5nIGV4cG9ydGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHVibGljTmFtZSBVbm9iZnVzY2F0ZWQgbmFtZSB0byBleHBvcnQuXG4gICAqIEBwYXJhbSB7Kn0gc3ltYm9sIE9iamVjdCB0aGUgbmFtZSBzaG91bGQgcG9pbnQgdG8uXG4gICAqL1xuICBnb29nLmV4cG9ydFByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgcHVibGljTmFtZSwgc3ltYm9sKSB7XG4gICAgb2JqZWN0W3B1YmxpY05hbWVdID0gc3ltYm9sO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gICAqXG4gICAqIFVzYWdlOlxuICAgKiA8cHJlPlxuICAgKiBmdW5jdGlvbiBQYXJlbnRDbGFzcyhhLCBiKSB7IH1cbiAgICogUGFyZW50Q2xhc3MucHJvdG90eXBlLmZvbyA9IGZ1bmN0aW9uKGEpIHsgfTtcbiAgICpcbiAgICogZnVuY3Rpb24gQ2hpbGRDbGFzcyhhLCBiLCBjKSB7XG4gICAqICAgQ2hpbGRDbGFzcy5iYXNlKHRoaXMsICdjb25zdHJ1Y3RvcicsIGEsIGIpO1xuICAgKiB9XG4gICAqIGdvb2cuaW5oZXJpdHMoQ2hpbGRDbGFzcywgUGFyZW50Q2xhc3MpO1xuICAgKlxuICAgKiB2YXIgY2hpbGQgPSBuZXcgQ2hpbGRDbGFzcygnYScsICdiJywgJ3NlZScpO1xuICAgKiBjaGlsZC5mb28oKTsgLy8gVGhpcyB3b3Jrcy5cbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjaGlsZEN0b3IgQ2hpbGQgY2xhc3MuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBwYXJlbnRDdG9yIFBhcmVudCBjbGFzcy5cbiAgICovXG4gIGdvb2cuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY2hpbGRDdG9yLCBwYXJlbnRDdG9yKSB7XG4gICAgLyoqIEBjb25zdHJ1Y3RvciAqL1xuICAgIGZ1bmN0aW9uIHRlbXBDdG9yKCkge31cbiAgICB0ZW1wQ3Rvci5wcm90b3R5cGUgPSBwYXJlbnRDdG9yLnByb3RvdHlwZTtcbiAgICBjaGlsZEN0b3Iuc3VwZXJDbGFzc18gPSBwYXJlbnRDdG9yLnByb3RvdHlwZTtcbiAgICBjaGlsZEN0b3IucHJvdG90eXBlID0gbmV3IHRlbXBDdG9yKCk7XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGNoaWxkQ3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZEN0b3I7XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yL21ldGhvZC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgb25seSBhdmFpbGFibGUgaWYgeW91IHVzZSBnb29nLmluaGVyaXRzIHRvXG4gICAgICogZXhwcmVzcyBpbmhlcml0YW5jZSByZWxhdGlvbnNoaXBzIGJldHdlZW4gY2xhc3Nlcy5cbiAgICAgKlxuICAgICAqIE5PVEU6IFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgZ29vZy5iYXNlIGFuZCBmb3Igc3VwZXJDbGFzc19cbiAgICAgKiBwcm9wZXJ0eSBkZWZpbmVkIGluIGNoaWxkQ3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gbWUgU2hvdWxkIGFsd2F5cyBiZSBcInRoaXNcIi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbWV0aG9kIG5hbWUgdG8gY2FsbC4gQ2FsbGluZ1xuICAgICAqICAgICBzdXBlcmNsYXNzIGNvbnN0cnVjdG9yIGNhbiBiZSBkb25lIHdpdGggdGhlIHNwZWNpYWwgc3RyaW5nXG4gICAgICogICAgICdjb25zdHJ1Y3RvcicuXG4gICAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gc3VwZXJjbGFzc1xuICAgICAqICAgICBtZXRob2QvY29uc3RydWN0b3IuXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QvY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY2hpbGRDdG9yLmJhc2UgPSBmdW5jdGlvbiAobWUsIG1ldGhvZE5hbWUsIHZhcl9hcmdzKSB7XG4gICAgICAvLyBDb3B5aW5nIHVzaW5nIGxvb3AgdG8gYXZvaWQgZGVvcCBkdWUgdG8gcGFzc2luZyBhcmd1bWVudHMgb2JqZWN0IHRvXG4gICAgICAvLyBmdW5jdGlvbi4gVGhpcyBpcyBmYXN0ZXIgaW4gbWFueSBKUyBlbmdpbmVzIGFzIG9mIGxhdGUgMjAxNC5cbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaSAtIDJdID0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudEN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdLmFwcGx5KG1lLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsIHVwIHRvIHRoZSBzdXBlcmNsYXNzLlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGNhbGxlZCBmcm9tIGEgY29uc3RydWN0b3IsIHRoZW4gdGhpcyBjYWxscyB0aGUgc3VwZXJjbGFzc1xuICAgKiBjb25zdHJ1Y3RvciB3aXRoIGFyZ3VtZW50cyAxLU4uXG4gICAqXG4gICAqIElmIHRoaXMgaXMgY2FsbGVkIGZyb20gYSBwcm90b3R5cGUgbWV0aG9kLCB0aGVuIHlvdSBtdXN0IHBhc3MgdGhlIG5hbWUgb2YgdGhlXG4gICAqIG1ldGhvZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb24uIElmIHlvdSBkbyBub3QsIHlvdSB3aWxsIGdldCBhXG4gICAqIHJ1bnRpbWUgZXJyb3IuIFRoaXMgY2FsbHMgdGhlIHN1cGVyY2xhc3MnIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyAyLU4uXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyBpZiB5b3UgdXNlIGdvb2cuaW5oZXJpdHMgdG8gZXhwcmVzcyBpbmhlcml0YW5jZVxuICAgKiByZWxhdGlvbnNoaXBzIGJldHdlZW4geW91ciBjbGFzc2VzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGEgY29tcGlsZXIgcHJpbWl0aXZlLiBBdCBjb21waWxlLXRpbWUsIHRoZSBjb21waWxlciB3aWxsIGRvXG4gICAqIG1hY3JvIGV4cGFuc2lvbiB0byByZW1vdmUgYSBsb3Qgb2YgdGhlIGV4dHJhIG92ZXJoZWFkIHRoYXQgdGhpcyBmdW5jdGlvblxuICAgKiBpbnRyb2R1Y2VzLiBUaGUgY29tcGlsZXIgd2lsbCBhbHNvIGVuZm9yY2UgYSBsb3Qgb2YgdGhlIGFzc3VtcHRpb25zIHRoYXQgdGhpc1xuICAgKiBmdW5jdGlvbiBtYWtlcywgYW5kIHRyZWF0IGl0IGFzIGEgY29tcGlsZXIgZXJyb3IgaWYgeW91IGJyZWFrIHRoZW0uXG4gICAqXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gbWUgU2hvdWxkIGFsd2F5cyBiZSBcInRoaXNcIi5cbiAgICogQHBhcmFtIHsqPX0gb3B0X21ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lIGlmIGNhbGxpbmcgYSBzdXBlciBtZXRob2QuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIHJlc3Qgb2YgdGhlIGFyZ3VtZW50cy5cbiAgICogQHJldHVybiB7Kn0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgc3VwZXJjbGFzcyBtZXRob2QuXG4gICAqIEBzdXBwcmVzcyB7ZXM1U3RyaWN0fSBUaGlzIG1ldGhvZCBjYW4gbm90IGJlIHVzZWQgaW4gc3RyaWN0IG1vZGUsIGJ1dFxuICAgKiAgICAgYWxsIENsb3N1cmUgTGlicmFyeSBjb25zdW1lcnMgbXVzdCBkZXBlbmQgb24gdGhpcyBmaWxlLlxuICAgKi9cbiAgZ29vZy5iYXNlID0gZnVuY3Rpb24gKG1lLCBvcHRfbWV0aG9kTmFtZSwgdmFyX2FyZ3MpIHtcbiAgICB2YXIgY2FsbGVyID0gYXJndW1lbnRzLmNhbGxlZS5jYWxsZXI7XG5cbiAgICBpZiAoZ29vZy5TVFJJQ1RfTU9ERV9DT01QQVRJQkxFIHx8IGdvb2cuREVCVUcgJiYgIWNhbGxlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2FyZ3VtZW50cy5jYWxsZXIgbm90IGRlZmluZWQuICBnb29nLmJhc2UoKSBjYW5ub3QgYmUgdXNlZCAnICsgJ3dpdGggc3RyaWN0IG1vZGUgY29kZS4gU2VlICcgKyAnaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzUuMS8jc2VjLUMnKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGVyLnN1cGVyQ2xhc3NfKSB7XG4gICAgICAvLyBDb3B5aW5nIHVzaW5nIGxvb3AgdG8gYXZvaWQgZGVvcCBkdWUgdG8gcGFzc2luZyBhcmd1bWVudHMgb2JqZWN0IHRvXG4gICAgICAvLyBmdW5jdGlvbi4gVGhpcyBpcyBmYXN0ZXIgaW4gbWFueSBKUyBlbmdpbmVzIGFzIG9mIGxhdGUgMjAxNC5cbiAgICAgIHZhciBjdG9yQXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdG9yQXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGlzIGEgY29uc3RydWN0b3IuIENhbGwgdGhlIHN1cGVyY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICByZXR1cm4gY2FsbGVyLnN1cGVyQ2xhc3NfLmNvbnN0cnVjdG9yLmFwcGx5KG1lLCBjdG9yQXJncyk7XG4gICAgfVxuXG4gICAgLy8gQ29weWluZyB1c2luZyBsb29wIHRvIGF2b2lkIGRlb3AgZHVlIHRvIHBhc3NpbmcgYXJndW1lbnRzIG9iamVjdCB0b1xuICAgIC8vIGZ1bmN0aW9uLiBUaGlzIGlzIGZhc3RlciBpbiBtYW55IEpTIGVuZ2luZXMgYXMgb2YgbGF0ZSAyMDE0LlxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAyKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpIC0gMl0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHZhciBmb3VuZENhbGxlciA9IGZhbHNlO1xuICAgIGZvciAodmFyIGN0b3IgPSBtZS5jb25zdHJ1Y3RvcjsgY3RvcjsgY3RvciA9IGN0b3Iuc3VwZXJDbGFzc18gJiYgY3Rvci5zdXBlckNsYXNzXy5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlW29wdF9tZXRob2ROYW1lXSA9PT0gY2FsbGVyKSB7XG4gICAgICAgIGZvdW5kQ2FsbGVyID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZm91bmRDYWxsZXIpIHtcbiAgICAgICAgcmV0dXJuIGN0b3IucHJvdG90eXBlW29wdF9tZXRob2ROYW1lXS5hcHBseShtZSwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZGlkIG5vdCBmaW5kIHRoZSBjYWxsZXIgaW4gdGhlIHByb3RvdHlwZSBjaGFpbiwgdGhlbiBvbmUgb2YgdHdvXG4gICAgLy8gdGhpbmdzIGhhcHBlbmVkOlxuICAgIC8vIDEpIFRoZSBjYWxsZXIgaXMgYW4gaW5zdGFuY2UgbWV0aG9kLlxuICAgIC8vIDIpIFRoaXMgbWV0aG9kIHdhcyBub3QgY2FsbGVkIGJ5IHRoZSByaWdodCBjYWxsZXIuXG4gICAgaWYgKG1lW29wdF9tZXRob2ROYW1lXSA9PT0gY2FsbGVyKSB7XG4gICAgICByZXR1cm4gbWUuY29uc3RydWN0b3IucHJvdG90eXBlW29wdF9tZXRob2ROYW1lXS5hcHBseShtZSwgYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdnb29nLmJhc2UgY2FsbGVkIGZyb20gYSBtZXRob2Qgb2Ygb25lIG5hbWUgJyArICd0byBhIG1ldGhvZCBvZiBhIGRpZmZlcmVudCBuYW1lJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBbGxvdyBmb3IgYWxpYXNpbmcgd2l0aGluIHNjb3BlIGZ1bmN0aW9ucy4gIFRoaXMgZnVuY3Rpb24gZXhpc3RzIGZvclxuICAgKiB1bmNvbXBpbGVkIGNvZGUgLSBpbiBjb21waWxlZCBjb2RlIHRoZSBjYWxscyB3aWxsIGJlIGlubGluZWQgYW5kIHRoZSBhbGlhc2VzXG4gICAqIGFwcGxpZWQuICBJbiB1bmNvbXBpbGVkIGNvZGUgdGhlIGZ1bmN0aW9uIGlzIHNpbXBseSBydW4gc2luY2UgdGhlIGFsaWFzZXMgYXNcbiAgICogd3JpdHRlbiBhcmUgdmFsaWQgSmF2YVNjcmlwdC5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBmbiBGdW5jdGlvbiB0byBjYWxsLiAgVGhpcyBmdW5jdGlvbiBjYW4gY29udGFpbiBhbGlhc2VzXG4gICAqICAgICB0byBuYW1lc3BhY2VzIChlLmcuIFwidmFyIGRvbSA9IGdvb2cuZG9tXCIpIG9yIGNsYXNzZXNcbiAgICogICAgIChlLmcuIFwidmFyIFRpbWVyID0gZ29vZy5UaW1lclwiKS5cbiAgICovXG4gIGdvb2cuc2NvcGUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBmbi5jYWxsKGdvb2cuZ2xvYmFsKTtcbiAgfTtcblxuICAvKlxuICAgKiBUbyBzdXBwb3J0IHVuY29tcGlsZWQsIHN0cmljdCBtb2RlIGJ1bmRsZXMgdGhhdCB1c2UgZXZhbCB0byBkaXZpZGUgc291cmNlXG4gICAqIGxpa2Ugc286XG4gICAqICAgIGV2YWwoJ3NvbWVTb3VyY2U7Ly8jIHNvdXJjZVVybCBzb3VyY2VmaWxlLmpzJyk7XG4gICAqIFdlIG5lZWQgdG8gZXhwb3J0IHRoZSBnbG9iYWxseSBkZWZpbmVkIHN5bWJvbHMgXCJnb29nXCIgYW5kIFwiQ09NUElMRURcIi5cbiAgICogRXhwb3J0aW5nIFwiZ29vZ1wiIGJyZWFrcyB0aGUgY29tcGlsZXIgb3B0aW1pemF0aW9ucywgc28gd2UgcmVxdWlyZWQgdGhhdFxuICAgKiBiZSBkZWZpbmVkIGV4dGVybmFsbHkuXG4gICAqIE5PVEU6IFdlIGRvbid0IHVzZSBnb29nLmV4cG9ydFN5bWJvbCBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byB0cmlnZ2VyXG4gICAqIGV4dGVybiBnZW5lcmF0aW9uIHdoZW4gdGhhdCBjb21waWxlciBvcHRpb24gaXMgZW5hYmxlZC5cbiAgICovXG4gIGlmICghQ09NUElMRUQpIHtcbiAgICBnb29nLmdsb2JhbFsnQ09NUElMRUQnXSA9IENPTVBJTEVEO1xuICB9XG5cbiAgZ29vZy5wcm92aWRlKCdnb29nLnN0cmluZycpO1xuXG4gIC8qKlxuICAgKiBEb2VzIHNpbXBsZSBweXRob24tc3R5bGUgc3RyaW5nIHN1YnN0aXR1dGlvbi5cbiAgICogc3VicyhcImZvbyVzIGhvdCVzXCIsIFwiYmFyXCIsIFwiZG9nXCIpIGJlY29tZXMgXCJmb29iYXIgaG90ZG9nXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyBjb250YWluaW5nIHRoZSBwYXR0ZXJuLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIHBhdHRlcm4uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQSBjb3B5IG9mIHtAY29kZSBzdHJ9IGluIHdoaWNoIGVhY2ggb2NjdXJyZW5jZSBvZlxuICAgKiAgICAge0Bjb2RlICVzfSBoYXMgYmVlbiByZXBsYWNlZCBhbiBhcmd1bWVudCBmcm9tIHtAY29kZSB2YXJfYXJnc30uXG4gICAqL1xuICBnb29nLnN0cmluZy5zdWJzID0gZnVuY3Rpb24gKHN0ciwgdmFyX2FyZ3MpIHtcbiAgICB2YXIgc3BsaXRQYXJ0cyA9IHN0ci5zcGxpdCgnJXMnKTtcbiAgICB2YXIgcmV0dXJuU3RyaW5nID0gJyc7XG5cbiAgICB2YXIgc3Vic0FyZ3VtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgd2hpbGUgKHN1YnNBcmd1bWVudHMubGVuZ3RoICYmXG4gICAgLy8gUmVwbGFjZSB1cCB0byB0aGUgbGFzdCBzcGxpdCBwYXJ0LiBXZSBhcmUgaW5zZXJ0aW5nIGluIHRoZVxuICAgIC8vIHBvc2l0aW9ucyBiZXR3ZWVuIHNwbGl0IHBhcnRzLlxuICAgIHNwbGl0UGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuU3RyaW5nICs9IHNwbGl0UGFydHMuc2hpZnQoKSArIHN1YnNBcmd1bWVudHMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0dXJuU3RyaW5nICsgc3BsaXRQYXJ0cy5qb2luKCclcycpOyAvLyBKb2luIHVudXNlZCAnJXMnXG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYW4gYW1wZXJzYW5kLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5BTVBfUkVfID0gLyYvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhIGxlc3MgdGhhbiBzaWduLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5MVF9SRV8gPSAvPC9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgZ3JlYXRlciB0aGFuIHNpZ24sIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gICAqIEBjb25zdCB7IVJlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuc3RyaW5nLkdUX1JFXyA9IC8+L2c7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYSBkb3VibGUgcXVvdGUsIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gICAqIEBjb25zdCB7IVJlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuc3RyaW5nLlFVT1RfUkVfID0gL1wiL2c7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0aGF0IG1hdGNoZXMgYSBzaW5nbGUgcXVvdGUsIGZvciB1c2UgaW4gZXNjYXBpbmcuXG4gICAqIEBjb25zdCB7IVJlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuc3RyaW5nLlNJTkdMRV9RVU9URV9SRV8gPSAvJy9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIG51bGwgY2hhcmFjdGVyLCBmb3IgdXNlIGluIGVzY2FwaW5nLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5OVUxMX1JFXyA9IC9cXHgwMC9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGEgbG93ZXJjYXNlIGxldHRlciBcImVcIiwgZm9yIHVzZSBpbiBlc2NhcGluZy5cbiAgICogQGNvbnN0IHshUmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5zdHJpbmcuRV9SRV8gPSAvZS9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFueSBjaGFyYWN0ZXIgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkLlxuICAgKiBAY29uc3QgeyFSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5BTExfUkVfID0gZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORyA/IC9bXFx4MDAmPD5cIidlXS8gOiAvW1xceDAwJjw+XCInXS87XG5cbiAgLyoqXG4gICAqIFVuZXNjYXBlcyBhbiBIVE1MIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEFuIHVuZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzdHJ9LlxuICAgKi9cbiAgZ29vZy5zdHJpbmcudW5lc2NhcGVFbnRpdGllcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoZ29vZy5zdHJpbmcuY29udGFpbnMoc3RyLCAnJicpKSB7XG4gICAgICAvLyBXZSBhcmUgY2FyZWZ1bCBub3QgdG8gdXNlIGEgRE9NIGlmIHdlIGRvIG5vdCBoYXZlIG9uZSBvciB3ZSBleHBsaWNpdGx5XG4gICAgICAvLyByZXF1ZXN0ZWQgbm9uLURPTSBodG1sIHVuZXNjYXBpbmcuXG4gICAgICBpZiAoIWdvb2cuc3RyaW5nLkZPUkNFX05PTl9ET01fSFRNTF9VTkVTQ0FQSU5HICYmICdkb2N1bWVudCcgaW4gZ29vZy5nbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuIGdvb2cuc3RyaW5nLnVuZXNjYXBlRW50aXRpZXNVc2luZ0RvbV8oc3RyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayBvbiBwdXJlIFhNTCBlbnRpdGllc1xuICAgICAgICByZXR1cm4gZ29vZy5zdHJpbmcudW5lc2NhcGVQdXJlWG1sRW50aXRpZXNfKHN0cik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFVuZXNjYXBlcyBhbiBIVE1MIHN0cmluZyB1c2luZyBhIERPTSB0byByZXNvbHZlIG5vbi1YTUwsIG5vbi1udW1lcmljXG4gICAqIGVudGl0aWVzLiBUaGlzIGZ1bmN0aW9uIGlzIFhTUy1zYWZlIGFuZCB3aGl0ZXNwYWNlLXByZXNlcnZpbmcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAgICogQHBhcmFtIHtEb2N1bWVudD19IG9wdF9kb2N1bWVudCBBbiBvcHRpb25hbCBkb2N1bWVudCB0byB1c2UgZm9yIGNyZWF0aW5nXG4gICAqICAgICBlbGVtZW50cy4gSWYgdGhpcyBpcyBub3Qgc3BlY2lmaWVkIHRoZW4gdGhlIGRlZmF1bHQgd2luZG93LmRvY3VtZW50XG4gICAqICAgICB3aWxsIGJlIHVzZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuZXNjYXBlZCB7QGNvZGUgc3RyfSBzdHJpbmcuXG4gICAqL1xuICBnb29nLnN0cmluZy51bmVzY2FwZUVudGl0aWVzVXNpbmdEb21fID0gZnVuY3Rpb24gKHN0ciwgb3B0X2RvY3VtZW50KSB7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICB2YXIgc2VlbiA9IHsgJyZhbXA7JzogJyYnLCAnJmx0Oyc6ICc8JywgJyZndDsnOiAnPicsICcmcXVvdDsnOiAnXCInIH07XG4gICAgdmFyIGRpdjtcbiAgICBpZiAob3B0X2RvY3VtZW50KSB7XG4gICAgICBkaXYgPSBvcHRfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpdiA9IGdvb2cuZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIH1cbiAgICAvLyBNYXRjaCBhcyBtYW55IHZhbGlkIGVudGl0eSBjaGFyYWN0ZXJzIGFzIHBvc3NpYmxlLiBJZiB0aGUgYWN0dWFsIGVudGl0eVxuICAgIC8vIGhhcHBlbnMgdG8gYmUgc2hvcnRlciwgaXQgd2lsbCBzdGlsbCB3b3JrIGFzIGlubmVySFRNTCB3aWxsIHJldHVybiB0aGVcbiAgICAvLyB0cmFpbGluZyBjaGFyYWN0ZXJzIHVuY2hhbmdlZC4gU2luY2UgdGhlIGVudGl0eSBjaGFyYWN0ZXJzIGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gb3BlbiBhbmdsZSBicmFja2V0LCB0aGVyZSBpcyBubyBjaGFuY2Ugb2YgWFNTIGZyb20gdGhlIGlubmVySFRNTCB1c2UuXG4gICAgLy8gU2luY2Ugbm8gd2hpdGVzcGFjZSBpcyBwYXNzZWQgdG8gaW5uZXJIVE1MLCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZC5cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuSFRNTF9FTlRJVFlfUEFUVEVSTl8sIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgIC8vIENoZWNrIGZvciBjYWNoZWQgZW50aXR5LlxuICAgICAgdmFyIHZhbHVlID0gc2VlbltzXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBmb3IgbnVtZXJpYyBlbnRpdHkuXG4gICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PSAnIycpIHtcbiAgICAgICAgLy8gUHJlZml4IHdpdGggMCBzbyB0aGF0IGhleCBlbnRpdGllcyAoZS5nLiAmI3gxMCkgcGFyc2UgYXMgaGV4IG51bWJlcnMuXG4gICAgICAgIHZhciBuID0gTnVtYmVyKCcwJyArIGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgICBpZiAoIWlzTmFOKG4pKSB7XG4gICAgICAgICAgdmFsdWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBGYWxsIGJhY2sgdG8gaW5uZXJIVE1MIG90aGVyd2lzZS5cbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgLy8gQXBwZW5kIGEgbm9uLWVudGl0eSBjaGFyYWN0ZXIgdG8gYXZvaWQgYSBidWcgaW4gV2Via2l0IHRoYXQgcGFyc2VzXG4gICAgICAgIC8vIGFuIGludmFsaWQgZW50aXR5IGF0IHRoZSBlbmQgb2YgaW5uZXJIVE1MIHRleHQgYXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgZGl2LmlubmVySFRNTCA9IHMgKyAnICc7XG4gICAgICAgIC8vIFRoZW4gcmVtb3ZlIHRoZSB0cmFpbGluZyBjaGFyYWN0ZXIgZnJvbSB0aGUgcmVzdWx0LlxuICAgICAgICB2YWx1ZSA9IGRpdi5maXJzdENoaWxkLm5vZGVWYWx1ZS5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgICAvLyBDYWNoZSBhbmQgcmV0dXJuLlxuICAgICAgcmV0dXJuIHNlZW5bc10gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogVW5lc2NhcGVzIFhNTCBlbnRpdGllcy5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEFuIHVuZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzdHJ9LlxuICAgKi9cbiAgZ29vZy5zdHJpbmcudW5lc2NhcGVQdXJlWG1sRW50aXRpZXNfID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJihbXjtdKyk7L2csIGZ1bmN0aW9uIChzLCBlbnRpdHkpIHtcbiAgICAgIHN3aXRjaCAoZW50aXR5KSB7XG4gICAgICAgIGNhc2UgJ2FtcCc6XG4gICAgICAgICAgcmV0dXJuICcmJztcbiAgICAgICAgY2FzZSAnbHQnOlxuICAgICAgICAgIHJldHVybiAnPCc7XG4gICAgICAgIGNhc2UgJ2d0JzpcbiAgICAgICAgICByZXR1cm4gJz4nO1xuICAgICAgICBjYXNlICdxdW90JzpcbiAgICAgICAgICByZXR1cm4gJ1wiJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PSAnIycpIHtcbiAgICAgICAgICAgIC8vIFByZWZpeCB3aXRoIDAgc28gdGhhdCBoZXggZW50aXRpZXMgKGUuZy4gJiN4MTApIHBhcnNlIGFzIGhleC5cbiAgICAgICAgICAgIHZhciBuID0gTnVtYmVyKCcwJyArIGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRm9yIGludmFsaWQgZW50aXRpZXMgd2UganVzdCByZXR1cm4gdGhlIGVudGl0eVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIGFuIEhUTUwgZW50aXR5LlxuICAgKiBTZWUgYWxzbyBIVE1MNTogVG9rZW5pemF0aW9uIC8gVG9rZW5pemluZyBjaGFyYWN0ZXIgcmVmZXJlbmNlcy5cbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUgeyFSZWdFeHB9XG4gICAqL1xuICBnb29nLnN0cmluZy5IVE1MX0VOVElUWV9QQVRURVJOXyA9IC8mKFteO1xcczwmXSspOz8vZztcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGNvbnRhaW5zIGEgc3Vic3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3ViU3RyaW5nIFRoZSBzdWJzdHJpbmcgdG8gc2VhcmNoIGZvci5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB7QGNvZGUgc3RyfSBjb250YWlucyB7QGNvZGUgc3ViU3RyaW5nfS5cbiAgICovXG4gIGdvb2cuc3RyaW5nLmNvbnRhaW5zID0gZnVuY3Rpb24gKHN0ciwgc3ViU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHN1YlN0cmluZykgIT0gLTE7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVzY2FwZXMgZG91YmxlIHF1b3RlICdcIicgYW5kIHNpbmdsZSBxdW90ZSAnXFwnJyBjaGFyYWN0ZXJzIGluIGFkZGl0aW9uIHRvXG4gICAqICcmJywgJzwnLCBhbmQgJz4nIHNvIHRoYXQgYSBzdHJpbmcgY2FuIGJlIGluY2x1ZGVkIGluIGFuIEhUTUwgdGFnIGF0dHJpYnV0ZVxuICAgKiB2YWx1ZSB3aXRoaW4gZG91YmxlIG9yIHNpbmdsZSBxdW90ZXMuXG4gICAqXG4gICAqIEl0IHNob3VsZCBiZSBub3RlZCB0aGF0ID4gZG9lc24ndCBuZWVkIHRvIGJlIGVzY2FwZWQgZm9yIHRoZSBIVE1MIG9yIFhNTCB0b1xuICAgKiBiZSB2YWxpZCwgYnV0IGl0IGhhcyBiZWVuIGRlY2lkZWQgdG8gZXNjYXBlIGl0IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyXG4gICAqIGltcGxlbWVudGF0aW9ucy5cbiAgICpcbiAgICogV2l0aCBnb29nLnN0cmluZy5ERVRFQ1RfRE9VQkxFX0VTQ0FQSU5HLCB0aGlzIGZ1bmN0aW9uIGVzY2FwZXMgYWxzbyB0aGVcbiAgICogbG93ZXJjYXNlIGxldHRlciBcImVcIi5cbiAgICpcbiAgICogTk9URSh1c2VyKTpcbiAgICogSHRtbEVzY2FwZSBpcyBvZnRlbiBjYWxsZWQgZHVyaW5nIHRoZSBnZW5lcmF0aW9uIG9mIGxhcmdlIGJsb2NrcyBvZiBIVE1MLlxuICAgKiBVc2luZyBzdGF0aWNzIGZvciB0aGUgcmVndWxhciBleHByZXNzaW9ucyBhbmQgc3RyaW5ncyBpcyBhbiBvcHRpbWl6YXRpb25cbiAgICogdGhhdCBjYW4gbW9yZSB0aGFuIGhhbGYgdGhlIGFtb3VudCBvZiB0aW1lIElFIHNwZW5kcyBpbiB0aGlzIGZ1bmN0aW9uIGZvclxuICAgKiBsYXJnZSBhcHBzLCBzaW5jZSBzdHJpbmdzIGFuZCByZWdleGVzIGJvdGggY29udHJpYnV0ZSB0byBHQyBhbGxvY2F0aW9ucy5cbiAgICpcbiAgICogVGVzdGluZyBmb3IgdGhlIHByZXNlbmNlIG9mIGEgY2hhcmFjdGVyIGJlZm9yZSBlc2NhcGluZyBpbmNyZWFzZXMgdGhlIG51bWJlclxuICAgKiBvZiBmdW5jdGlvbiBjYWxscywgYnV0IGFjdHVhbGx5IHByb3ZpZGVzIGEgc3BlZWQgaW5jcmVhc2UgZm9yIHRoZSBhdmVyYWdlXG4gICAqIGNhc2UgLS0gc2luY2UgdGhlIGF2ZXJhZ2UgY2FzZSBvZnRlbiBkb2Vzbid0IHJlcXVpcmUgdGhlIGVzY2FwaW5nIG9mIGFsbCA0XG4gICAqIGNoYXJhY3RlcnMgYW5kIGluZGV4T2YoKSBpcyBtdWNoIGNoZWFwZXIgdGhhbiByZXBsYWNlKCkuXG4gICAqIFRoZSB3b3JzdCBjYXNlIGRvZXMgc3VmZmVyIHNsaWdodGx5IGZyb20gdGhlIGFkZGl0aW9uYWwgY2FsbHMsIHRoZXJlZm9yZSB0aGVcbiAgICogb3B0X2lzTGlrZWx5VG9Db250YWluSHRtbENoYXJzIG9wdGlvbiBoYXMgYmVlbiBpbmNsdWRlZCBmb3Igc2l0dWF0aW9uc1xuICAgKiB3aGVyZSBhbGwgNCBIVE1MIGVudGl0aWVzIGFyZSB2ZXJ5IGxpa2VseSB0byBiZSBwcmVzZW50IGFuZCBuZWVkIGVzY2FwaW5nLlxuICAgKlxuICAgKiBTb21lIGJlbmNobWFya3MgKHRpbWVzIHRlbmRlZCB0byBmbHVjdHVhdGUgKy0wLjA1bXMpOlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlRm94ICAgICAgICAgICAgICAgICAgICAgSUU2XG4gICAqIChubyBjaGFycyAvIGF2ZXJhZ2UgKG1peCBvZiBjYXNlcykgLyBhbGwgNCBjaGFycylcbiAgICogbm8gY2hlY2tzICAgICAgICAgICAgICAgICAgICAgMC4xMyAvIDAuMjIgLyAwLjIyICAgICAgICAgMC4yMyAvIDAuNTMgLyAwLjgwXG4gICAqIGluZGV4T2YgICAgICAgICAgICAgICAgICAgICAgIDAuMDggLyAwLjE3IC8gMC4yNiAgICAgICAgIDAuMjIgLyAwLjU0IC8gMC44NFxuICAgKiBpbmRleE9mICsgcmUgdGVzdCAgICAgICAgICAgICAwLjA3IC8gMC4xNyAvIDAuMjggICAgICAgICAwLjE5IC8gMC41MCAvIDAuODVcbiAgICpcbiAgICogQW4gYWRkaXRpb25hbCBhZHZhbnRhZ2Ugb2YgY2hlY2tpbmcgaWYgcmVwbGFjZSBhY3R1YWxseSBuZWVkcyB0byBiZSBjYWxsZWRcbiAgICogaXMgYSByZWR1Y3Rpb24gaW4gdGhlIG51bWJlciBvZiBvYmplY3QgYWxsb2NhdGlvbnMsIHNvIGFzIHRoZSBzaXplIG9mIHRoZVxuICAgKiBhcHBsaWNhdGlvbiBncm93cyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB2YXJpb3VzIG1ldGhvZHMgd291bGQgaW5jcmVhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgc3RyaW5nIHRvIGJlIGVzY2FwZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0xpa2VseVRvQ29udGFpbkh0bWxDaGFycyBEb24ndCBwZXJmb3JtIGEgY2hlY2sgdG8gc2VlXG4gICAqICAgICBpZiB0aGUgY2hhcmFjdGVyIG5lZWRzIHJlcGxhY2luZyAtIHVzZSB0aGlzIG9wdGlvbiBpZiB5b3UgZXhwZWN0IGVhY2ggb2ZcbiAgICogICAgIHRoZSBjaGFyYWN0ZXJzIHRvIGFwcGVhciBvZnRlbi4gTGVhdmUgZmFsc2UgaWYgeW91IGV4cGVjdCBmZXcgaHRtbFxuICAgKiAgICAgY2hhcmFjdGVycyB0byBvY2N1ciBpbiB5b3VyIHN0cmluZ3MsIHN1Y2ggYXMgaWYgeW91IGFyZSBlc2NhcGluZyBIVE1MLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc3RyfS5cbiAgICovXG4gIGdvb2cuc3RyaW5nLmh0bWxFc2NhcGUgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMpIHtcblxuICAgIGlmIChvcHRfaXNMaWtlbHlUb0NvbnRhaW5IdG1sQ2hhcnMpIHtcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkFNUF9SRV8sICcmYW1wOycpLnJlcGxhY2UoZ29vZy5zdHJpbmcuTFRfUkVfLCAnJmx0OycpLnJlcGxhY2UoZ29vZy5zdHJpbmcuR1RfUkVfLCAnJmd0OycpLnJlcGxhY2UoZ29vZy5zdHJpbmcuUVVPVF9SRV8sICcmcXVvdDsnKS5yZXBsYWNlKGdvb2cuc3RyaW5nLlNJTkdMRV9RVU9URV9SRV8sICcmIzM5OycpLnJlcGxhY2UoZ29vZy5zdHJpbmcuTlVMTF9SRV8sICcmIzA7Jyk7XG4gICAgICBpZiAoZ29vZy5zdHJpbmcuREVURUNUX0RPVUJMRV9FU0NBUElORykge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5FX1JFXywgJyYjMTAxOycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcXVpY2sgdGVzdCBoZWxwcyBpbiB0aGUgY2FzZSB3aGVuIHRoZXJlIGFyZSBubyBjaGFycyB0byByZXBsYWNlLCBpblxuICAgICAgLy8gd29yc3QgY2FzZSB0aGlzIG1ha2VzIGJhcmVseSBhIGRpZmZlcmVuY2UgdG8gdGhlIHRpbWUgdGFrZW5cbiAgICAgIGlmICghZ29vZy5zdHJpbmcuQUxMX1JFXy50ZXN0KHN0cikpIHJldHVybiBzdHI7XG5cbiAgICAgIC8vIHN0ci5pbmRleE9mIGlzIGZhc3RlciB0aGFuIHJlZ2V4LnRlc3QgaW4gdGhpcyBjYXNlXG4gICAgICBpZiAoc3RyLmluZGV4T2YoJyYnKSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5BTVBfUkVfLCAnJmFtcDsnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignPCcpICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkxUX1JFXywgJyZsdDsnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignPicpICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKGdvb2cuc3RyaW5nLkdUX1JFXywgJyZndDsnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXCInKSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5RVU9UX1JFXywgJyZxdW90OycpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXCcnKSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5TSU5HTEVfUVVPVEVfUkVfLCAnJiMzOTsnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFx4MDAnKSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShnb29nLnN0cmluZy5OVUxMX1JFXywgJyYjMDsnKTtcbiAgICAgIH1cbiAgICAgIGlmIChnb29nLnN0cmluZy5ERVRFQ1RfRE9VQkxFX0VTQ0FQSU5HICYmIHN0ci5pbmRleE9mKCdlJykgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoZ29vZy5zdHJpbmcuRV9SRV8sICcmIzEwMTsnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9O1xuXG4gIGdvb2cuZGVidWcgPSB7fTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBvZiBhIHZhbHVlLiBJZiBhIGNvbnN0cnVjdG9yIGlzIHBhc3NlZCwgYW5kIGEgc3VpdGFibGVcbiAgICogc3RyaW5nIGNhbm5vdCBiZSBmb3VuZCwgJ3Vua25vd24gdHlwZSBuYW1lJyB3aWxsIGJlIHJldHVybmVkLlxuICAgKlxuICAgKiA8cD5Gb3JrZWQgcmF0aGVyIHRoYW4gbW92ZWQgZnJvbSB7QGxpbmsgZ29vZy5hc3NlcnRzLmdldFR5cGVffVxuICAgKiB0byBhdm9pZCBhZGRpbmcgYSBkZXBlbmRlbmN5IHRvIGdvb2cuYXNzZXJ0cy5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBIGNvbnN0cnVjdG9yLCBvYmplY3QsIG9yIHByaW1pdGl2ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmVzdCBkaXNwbGF5IG5hbWUgZm9yIHRoZSB2YWx1ZSwgb3IgJ3Vua25vd24gdHlwZSBuYW1lJy5cbiAgICovXG4gIGdvb2cuZGVidWcucnVudGltZVR5cGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgcmV0dXJuIHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWUgfHwgJ3Vua25vd24gdHlwZSBuYW1lJztcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ29weXJpZ2h0IDIwMDkgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAvL1xuICAvLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAvLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gIC8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICAvL1xuICAvLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAvL1xuICAvLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIC8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMtSVNcIiBCQVNJUyxcbiAgLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIC8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiAgLyoqXG4gICAqIEBmaWxlb3ZlcnZpZXcgUHJvdmlkZXMgYSBiYXNlIGNsYXNzIGZvciBjdXN0b20gRXJyb3Igb2JqZWN0cyBzdWNoIHRoYXQgdGhlXG4gICAqIHN0YWNrIGlzIGNvcnJlY3RseSBtYWludGFpbmVkLlxuICAgKlxuICAgKiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gdGhyb3cgZ29vZy5kZWJ1Zy5FcnJvcihtc2cpIGRpcmVjdGx5LCBFcnJvcihtc2cpIGlzXG4gICAqIHN1ZmZpY2llbnQuXG4gICAqXG4gICAqL1xuXG4gIC8qKlxuICAgKiBCYXNlIGNsYXNzIGZvciBjdXN0b20gZXJyb3Igb2JqZWN0cy5cbiAgICogQHBhcmFtIHsqPX0gb3B0X21zZyBUaGUgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge0Vycm9yfVxuICAgKi9cbiAgZ29vZy5kZWJ1Zy5FcnJvciA9IGZ1bmN0aW9uIChvcHRfbXNnKSB7XG5cbiAgICAvLyBBdHRlbXB0IHRvIGVuc3VyZSB0aGVyZSBpcyBhIHN0YWNrIHRyYWNlLlxuICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgZ29vZy5kZWJ1Zy5FcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xuICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0X21zZykge1xuICAgICAgdGhpcy5tZXNzYWdlID0gU3RyaW5nKG9wdF9tc2cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcmVwb3J0IHRoaXMgZXJyb3IgdG8gdGhlIHNlcnZlci4gU2V0dGluZyB0aGlzIHRvIGZhbHNlIHdpbGxcbiAgICAgKiBjYXVzZSB0aGUgZXJyb3IgcmVwb3J0ZXIgdG8gbm90IHJlcG9ydCB0aGUgZXJyb3IgYmFjayB0byB0aGUgc2VydmVyLFxuICAgICAqIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgdGhlIGNsaWVudCBrbm93cyB0aGF0IHRoZSBlcnJvciBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICogbG9nZ2VkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXBvcnRFcnJvclRvU2VydmVyID0gdHJ1ZTtcbiAgfTtcbiAgZ29vZy5pbmhlcml0cyhnb29nLmRlYnVnLkVycm9yLCBFcnJvcik7XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBnb29nLmRlYnVnLkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0N1c3RvbUVycm9yJztcblxuICAvKipcbiAgICogQGZpbGVvdmVydmlldyBEZWZpbml0aW9uIG9mIGdvb2cuZG9tLk5vZGVUeXBlLlxuICAgKi9cblxuICBnb29nLmRvbSA9IHt9O1xuXG4gIC8qKlxuICAgKiBDb25zdGFudHMgZm9yIHRoZSBub2RlVHlwZSBhdHRyaWJ1dGUgaW4gdGhlIE5vZGUgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBUaGVzZSBjb25zdGFudHMgbWF0Y2ggdGhvc2Ugc3BlY2lmaWVkIGluIHRoZSBOb2RlIGludGVyZmFjZS4gVGhlc2UgYXJlXG4gICAqIHVzdWFsbHkgcHJlc2VudCBvbiB0aGUgTm9kZSBvYmplY3QgaW4gcmVjZW50IGJyb3dzZXJzLCBidXQgbm90IGluIG9sZGVyXG4gICAqIGJyb3dzZXJzIChzcGVjaWZpY2FsbHksIGVhcmx5IElFcykgYW5kIHRodXMgYXJlIGdpdmVuIGhlcmUuXG4gICAqXG4gICAqIEluIHNvbWUgYnJvd3NlcnMgKGVhcmx5IElFcyksIHRoZXNlIGFyZSBub3QgZGVmaW5lZCBvbiB0aGUgTm9kZSBvYmplY3QsXG4gICAqIHNvIHRoZXkgYXJlIHByb3ZpZGVkIGhlcmUuXG4gICAqXG4gICAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1Db3JlL2NvcmUuaHRtbCNJRC0xOTUwNjQxMjQ3XG4gICAqIEBlbnVtIHtudW1iZXJ9XG4gICAqL1xuICBnb29nLmRvbS5Ob2RlVHlwZSA9IHtcbiAgICBFTEVNRU5UOiAxLFxuICAgIEFUVFJJQlVURTogMixcbiAgICBURVhUOiAzLFxuICAgIENEQVRBX1NFQ1RJT046IDQsXG4gICAgRU5USVRZX1JFRkVSRU5DRTogNSxcbiAgICBFTlRJVFk6IDYsXG4gICAgUFJPQ0VTU0lOR19JTlNUUlVDVElPTjogNyxcbiAgICBDT01NRU5UOiA4LFxuICAgIERPQ1VNRU5UOiA5LFxuICAgIERPQ1VNRU5UX1RZUEU6IDEwLFxuICAgIERPQ1VNRU5UX0ZSQUdNRU5UOiAxMSxcbiAgICBOT1RBVElPTjogMTJcbiAgfTtcblxuICAvLyBDb3B5cmlnaHQgMjAwNyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gIC8vXG4gIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIC8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gIC8vXG4gIC8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gIC8vXG4gIC8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICAvLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAvLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAvKipcbiAgICogQGZpbGVvdmVydmlldyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3Igc3VwcG9ydGluZyBCaWRpIGlzc3Vlcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIE5hbWVzcGFjZSBmb3IgYmlkaSBzdXBwb3J0aW5nIGZ1bmN0aW9ucy5cbiAgICovXG4gIGdvb2cucHJvdmlkZSgnZ29vZy5pMThuLmJpZGknKTtcbiAgZ29vZy5wcm92aWRlKCdnb29nLmkxOG4uYmlkaS5EaXInKTtcbiAgZ29vZy5wcm92aWRlKCdnb29nLmkxOG4uYmlkaS5EaXJlY3Rpb25hbFN0cmluZycpO1xuICBnb29nLnByb3ZpZGUoJ2dvb2cuaTE4bi5iaWRpLkZvcm1hdCcpO1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBGT1JDRV9SVEwgZm9yY2VzIHRoZSB7QGxpbmsgZ29vZy5pMThuLmJpZGkuSVNfUlRMfSBjb25zdGFudFxuICAgKiB0byBzYXkgdGhhdCB0aGUgY3VycmVudCBsb2NhbGUgaXMgYSBSVEwgbG9jYWxlLiAgVGhpcyBzaG91bGQgb25seSBiZSB1c2VkXG4gICAqIGlmIHlvdSB3YW50IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGZvciBkZWNpZGluZyB3aGV0aGVyIHRoZVxuICAgKiBjdXJyZW50IGxvY2FsZSBpcyBSVEwgb3Igbm90LlxuICAgKlxuICAgKiB7QHNlZSBnb29nLmkxOG4uYmlkaS5JU19SVEx9XG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5pMThuLmJpZGkuRk9SQ0VfUlRMJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBDb25zdGFudCB0aGF0IGRlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgbG9jYWxlIGlzIGEgUlRMIGxvY2FsZS5cbiAgICogSWYge0BsaW5rIGdvb2cuaTE4bi5iaWRpLkZPUkNFX1JUTH0gaXMgbm90IHRydWUsIHRoaXMgY29uc3RhbnQgd2lsbCBkZWZhdWx0XG4gICAqIHRvIGNoZWNrIHRoYXQge0BsaW5rIGdvb2cuTE9DQUxFfSBpcyBvbmUgb2YgYSBmZXcgbWFqb3IgUlRMIGxvY2FsZXMuXG4gICAqXG4gICAqIDxwPlRoaXMgaXMgZGVzaWduZWQgdG8gYmUgYSBtYXhpbWFsbHkgZWZmaWNpZW50IGNvbXBpbGUtdGltZSBjb25zdGFudC4gRm9yXG4gICAqIGV4YW1wbGUsIGZvciB0aGUgZGVmYXVsdCBnb29nLkxPQ0FMRSwgY29tcGlsaW5nXG4gICAqIFwiaWYgKGdvb2cuaTE4bi5iaWRpLklTX1JUTCkgYWxlcnQoJ3J0bCcpIGVsc2Uge31cIiBzaG91bGQgcHJvZHVjZSBubyBjb2RlLiBJdFxuICAgKiBpcyB0aGlzIGRlc2lnbiBjb25zaWRlcmF0aW9uIHRoYXQgbGltaXRzIHRoZSBpbXBsZW1lbnRhdGlvbiB0byBvbmx5XG4gICAqIHN1cHBvcnRpbmcgYSBmZXcgbWFqb3IgUlRMIGxvY2FsZXMsIGFzIG9wcG9zZWQgdG8gdGhlIGJyb2FkZXIgcmVwZXJ0b2lyZSBvZlxuICAgKiBzb21ldGhpbmcgbGlrZSBnb29nLmkxOG4uYmlkaS5pc1J0bExhbmd1YWdlLlxuICAgKlxuICAgKiA8cD5TaW5jZSB0aGlzIGNvbnN0YW50IHJlZmVycyB0byB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgdGhlIGxvY2FsZSwgaXQgaXMgdXBcbiAgICogdG8gdGhlIGNhbGxlciB0byBkZXRlcm1pbmUgaWYgdGhpcyBjb25zdGFudCBzaG91bGQgYWxzbyBiZSB1c2VkIGZvciB0aGVcbiAgICogZGlyZWN0aW9uIG9mIHRoZSBVSS5cbiAgICpcbiAgICoge0BzZWUgZ29vZy5MT0NBTEV9XG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKlxuICAgKiBUT0RPKHVzZXIpOiB3cml0ZSBhIHRlc3QgdGhhdCBjaGVja3MgdGhhdCB0aGlzIGlzIGEgY29tcGlsZS10aW1lIGNvbnN0YW50LlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuSVNfUlRMID0gZ29vZy5pMThuLmJpZGkuRk9SQ0VfUlRMIHx8IChnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMCwgMikudG9Mb3dlckNhc2UoKSA9PSAnYXInIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdmYScgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT0gJ2hlJyB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMCwgMikudG9Mb3dlckNhc2UoKSA9PSAnaXcnIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICdwcycgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT0gJ3NkJyB8fCBnb29nLkxPQ0FMRS5zdWJzdHJpbmcoMCwgMikudG9Mb3dlckNhc2UoKSA9PSAndWcnIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygwLCAyKS50b0xvd2VyQ2FzZSgpID09ICd1cicgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDIpLnRvTG93ZXJDYXNlKCkgPT0gJ3lpJykgJiYgKGdvb2cuTE9DQUxFLmxlbmd0aCA9PSAyIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygyLCAzKSA9PSAnLScgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDIsIDMpID09ICdfJykgfHwgZ29vZy5MT0NBTEUubGVuZ3RoID49IDMgJiYgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDAsIDMpLnRvTG93ZXJDYXNlKCkgPT0gJ2NrYicgJiYgKGdvb2cuTE9DQUxFLmxlbmd0aCA9PSAzIHx8IGdvb2cuTE9DQUxFLnN1YnN0cmluZygzLCA0KSA9PSAnLScgfHwgZ29vZy5MT0NBTEUuc3Vic3RyaW5nKDMsIDQpID09ICdfJyk7XG5cbiAgLyoqXG4gICAqIFVuaWNvZGUgZm9ybWF0dGluZyBjaGFyYWN0ZXJzIGFuZCBkaXJlY3Rpb25hbGl0eSBzdHJpbmcgY29uc3RhbnRzLlxuICAgKiBAZW51bSB7c3RyaW5nfVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuRm9ybWF0ID0ge1xuICAgIC8qKiBVbmljb2RlIFwiTGVmdC1Uby1SaWdodCBFbWJlZGRpbmdcIiAoTFJFKSBjaGFyYWN0ZXIuICovXG4gICAgTFJFOiAnXFx1MjAyQScsXG4gICAgLyoqIFVuaWNvZGUgXCJSaWdodC1Uby1MZWZ0IEVtYmVkZGluZ1wiIChSTEUpIGNoYXJhY3Rlci4gKi9cbiAgICBSTEU6ICdcXHUyMDJCJyxcbiAgICAvKiogVW5pY29kZSBcIlBvcCBEaXJlY3Rpb25hbCBGb3JtYXR0aW5nXCIgKFBERikgY2hhcmFjdGVyLiAqL1xuICAgIFBERjogJ1xcdTIwMkMnLFxuICAgIC8qKiBVbmljb2RlIFwiTGVmdC1Uby1SaWdodCBNYXJrXCIgKExSTSkgY2hhcmFjdGVyLiAqL1xuICAgIExSTTogJ1xcdTIwMEUnLFxuICAgIC8qKiBVbmljb2RlIFwiUmlnaHQtVG8tTGVmdCBNYXJrXCIgKFJMTSkgY2hhcmFjdGVyLiAqL1xuICAgIFJMTTogJ1xcdTIwMEYnXG4gIH07XG5cbiAgLyoqXG4gICAqIERpcmVjdGlvbmFsaXR5IGVudW0uXG4gICAqIEBlbnVtIHtudW1iZXJ9XG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5EaXIgPSB7XG4gICAgLyoqXG4gICAgICogTGVmdC10by1yaWdodC5cbiAgICAgKi9cbiAgICBMVFI6IDEsXG5cbiAgICAvKipcbiAgICAgKiBSaWdodC10by1sZWZ0LlxuICAgICAqL1xuICAgIFJUTDogLTEsXG5cbiAgICAvKipcbiAgICAgKiBOZWl0aGVyIGxlZnQtdG8tcmlnaHQgbm9yIHJpZ2h0LXRvLWxlZnQuXG4gICAgICovXG4gICAgTkVVVFJBTDogMFxuICB9O1xuXG4gIC8qKlxuICAgKiAncmlnaHQnIHN0cmluZyBjb25zdGFudC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLlJJR0hUID0gJ3JpZ2h0JztcblxuICAvKipcbiAgICogJ2xlZnQnIHN0cmluZyBjb25zdGFudC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLkxFRlQgPSAnbGVmdCc7XG5cbiAgLyoqXG4gICAqICdsZWZ0JyBpZiBsb2NhbGUgaXMgUlRMLCAncmlnaHQnIGlmIG5vdC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLkkxOE5fUklHSFQgPSBnb29nLmkxOG4uYmlkaS5JU19SVEwgPyBnb29nLmkxOG4uYmlkaS5MRUZUIDogZ29vZy5pMThuLmJpZGkuUklHSFQ7XG5cbiAgLyoqXG4gICAqICdyaWdodCcgaWYgbG9jYWxlIGlzIFJUTCwgJ2xlZnQnIGlmIG5vdC5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLkkxOE5fTEVGVCA9IGdvb2cuaTE4bi5iaWRpLklTX1JUTCA/IGdvb2cuaTE4bi5iaWRpLlJJR0hUIDogZ29vZy5pMThuLmJpZGkuTEVGVDtcblxuICAvKipcbiAgICogQ29udmVydCBhIGRpcmVjdGlvbmFsaXR5IGdpdmVuIGluIHZhcmlvdXMgZm9ybWF0cyB0byBhIGdvb2cuaTE4bi5iaWRpLkRpclxuICAgKiBjb25zdGFudC4gVXNlZnVsIGZvciBpbnRlcmFjdGlvbiB3aXRoIGRpZmZlcmVudCBzdGFuZGFyZHMgb2YgZGlyZWN0aW9uYWxpdHlcbiAgICogcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7Z29vZy5pMThuLmJpZGkuRGlyfG51bWJlcnxib29sZWFufG51bGx9IGdpdmVuRGlyIERpcmVjdGlvbmFsaXR5IGdpdmVuXG4gICAqICAgICBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICAgKiAgICAgMS4gQSBnb29nLmkxOG4uYmlkaS5EaXIgY29uc3RhbnQuXG4gICAqICAgICAyLiBBIG51bWJlciAocG9zaXRpdmUgPSBMVFIsIG5lZ2F0aXZlID0gUlRMLCAwID0gbmV1dHJhbCkuXG4gICAqICAgICAzLiBBIGJvb2xlYW4gKHRydWUgPSBSVEwsIGZhbHNlID0gTFRSKS5cbiAgICogICAgIDQuIEEgbnVsbCBmb3IgdW5rbm93biBkaXJlY3Rpb25hbGl0eS5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vTmV1dHJhbCBXaGV0aGVyIGEgZ2l2ZW5EaXIgb2YgemVybyBvclxuICAgKiAgICAgZ29vZy5pMThuLmJpZGkuRGlyLk5FVVRSQUwgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgbnVsbCwgaS5lLiB1bmtub3duLCBpblxuICAgKiAgICAgb3JkZXIgdG8gcHJlc2VydmUgbGVnYWN5IGJlaGF2aW9yLlxuICAgKiBAcmV0dXJuIHs/Z29vZy5pMThuLmJpZGkuRGlyfSBBIGdvb2cuaTE4bi5iaWRpLkRpciBjb25zdGFudCBtYXRjaGluZyB0aGVcbiAgICogICAgIGdpdmVuIGRpcmVjdGlvbmFsaXR5LiBJZiBnaXZlbiBudWxsLCByZXR1cm5zIG51bGwgKGkuZS4gdW5rbm93bikuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS50b0RpciA9IGZ1bmN0aW9uIChnaXZlbkRpciwgb3B0X25vTmV1dHJhbCkge1xuICAgIGlmICh0eXBlb2YgZ2l2ZW5EaXIgPT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhlIG5vbi1udWxsIGdvb2cuaTE4bi5iaWRpLkRpciBjYXNlLlxuICAgICAgcmV0dXJuIGdpdmVuRGlyID4gMCA/IGdvb2cuaTE4bi5iaWRpLkRpci5MVFIgOiBnaXZlbkRpciA8IDAgPyBnb29nLmkxOG4uYmlkaS5EaXIuUlRMIDogb3B0X25vTmV1dHJhbCA/IG51bGwgOiBnb29nLmkxOG4uYmlkaS5EaXIuTkVVVFJBTDtcbiAgICB9IGVsc2UgaWYgKGdpdmVuRGlyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNdXN0IGJlIHR5cGVvZiBnaXZlbkRpciA9PSAnYm9vbGVhbicuXG4gICAgICByZXR1cm4gZ2l2ZW5EaXIgPyBnb29nLmkxOG4uYmlkaS5EaXIuUlRMIDogZ29vZy5pMThuLmJpZGkuRGlyLkxUUjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcHJhY3RpY2FsIHBhdHRlcm4gdG8gaWRlbnRpZnkgc3Ryb25nIExUUiBjaGFyYWN0ZXJzLiBUaGlzIHBhdHRlcm4gaXMgbm90XG4gICAqIHRoZW9yZXRpY2FsbHkgY29ycmVjdCBhY2NvcmRpbmcgdG8gdGhlIFVuaWNvZGUgc3RhbmRhcmQuIEl0IGlzIHNpbXBsaWZpZWQgZm9yXG4gICAqIHBlcmZvcm1hbmNlIGFuZCBzbWFsbCBjb2RlIHNpemUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gPSAnQS1aYS16XFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkYnICsgJ1xcdTIwMEVcXHUyQzAwLVxcdUZCMUNcXHVGRTAwLVxcdUZFNkZcXHVGRUZELVxcdUZGRkYnO1xuXG4gIC8qKlxuICAgKiBBIHByYWN0aWNhbCBwYXR0ZXJuIHRvIGlkZW50aWZ5IHN0cm9uZyBSVEwgY2hhcmFjdGVyLiBUaGlzIHBhdHRlcm4gaXMgbm90XG4gICAqIHRoZW9yZXRpY2FsbHkgY29ycmVjdCBhY2NvcmRpbmcgdG8gdGhlIFVuaWNvZGUgc3RhbmRhcmQuIEl0IGlzIHNpbXBsaWZpZWRcbiAgICogZm9yIHBlcmZvcm1hbmNlIGFuZCBzbWFsbCBjb2RlIHNpemUuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gPSAnXFx1MDU5MS1cXHUwNkVGXFx1MDZGQS1cXHUwN0ZGXFx1MjAwRlxcdUZCMUQtXFx1RkRGRlxcdUZFNzAtXFx1RkVGQyc7XG5cbiAgLyoqXG4gICAqIFNpbXBsaWZpZWQgcmVndWxhciBleHByZXNzaW9uIGZvciBhbiBIVE1MIHRhZyAob3BlbmluZyBvciBjbG9zaW5nKSBvciBhbiBIVE1MXG4gICAqIGVzY2FwZS4gV2UgbWlnaHQgd2FudCB0byBza2lwIG92ZXIgc3VjaCBleHByZXNzaW9ucyB3aGVuIGVzdGltYXRpbmcgdGhlIHRleHRcbiAgICogZGlyZWN0aW9uYWxpdHkuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5odG1sU2tpcFJlZ18gPSAvPFtePl0qPnwmW147XSs7L2c7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlucHV0IHRleHQgd2l0aCBzcGFjZXMgaW5zdGVhZCBvZiBIVE1MIHRhZ3Mgb3IgSFRNTCBlc2NhcGVzLCBpZlxuICAgKiBvcHRfaXNTdHJpcE5lZWRlZCBpcyB0cnVlLiBFbHNlIHJldHVybnMgdGhlIGlucHV0IGFzIGlzLlxuICAgKiBVc2VmdWwgZm9yIHRleHQgZGlyZWN0aW9uYWxpdHkgZXN0aW1hdGlvbi5cbiAgICogTm90ZTogdGhlIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgdXNlZCBpbiBvdGhlciBjb250ZXh0czsgaXQgaXMgbm90IDEwMCVcbiAgICogY29ycmVjdCwgYnV0IHJhdGhlciBhIGdvb2QtZW5vdWdoIGltcGxlbWVudGF0aW9uIGZvciBkaXJlY3Rpb25hbGl0eVxuICAgKiBlc3RpbWF0aW9uIHB1cnBvc2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc1N0cmlwTmVlZGVkIFdoZXRoZXIgdG8gcGVyZm9ybSB0aGUgc3RyaXBwaW5nLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UgKHRvIHJldGFpbiBjb25zaXN0ZW5jeSB3aXRoIGNhbGxpbmcgZnVuY3Rpb25zKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZ2l2ZW4gc3RyaW5nIGNsZWFuZWQgb2YgSFRNTCB0YWdzIC8gZXNjYXBlcy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnN0cmlwSHRtbElmTmVlZGVkXyA9IGZ1bmN0aW9uIChzdHIsIG9wdF9pc1N0cmlwTmVlZGVkKSB7XG4gICAgcmV0dXJuIG9wdF9pc1N0cmlwTmVlZGVkID8gc3RyLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkuaHRtbFNraXBSZWdfLCAnJykgOiBzdHI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBjaGVjayBmb3IgUlRMIGNoYXJhY3RlcnMuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5ydGxDaGFyUmVnXyA9IG5ldyBSZWdFeHAoJ1snICsgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfICsgJ10nKTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRvIGNoZWNrIGZvciBMVFIgY2hhcmFjdGVycy5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmx0ckNoYXJSZWdfID0gbmV3IFJlZ0V4cCgnWycgKyBnb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gKyAnXScpO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBoYXMgYW55IFJUTCBjaGFyYWN0ZXJzIGluIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHN0cmluZyBjb250YWlucyBSVEwgY2hhcmFjdGVycy5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmhhc0FueVJ0bCA9IGZ1bmN0aW9uIChzdHIsIG9wdF9pc0h0bWwpIHtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkucnRsQ2hhclJlZ18udGVzdChnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc3RyaW5nIGhhcyBhbnkgUlRMIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBzdHJpbmcgY29udGFpbnMgUlRMIGNoYXJhY3RlcnMuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBoYXNBbnlSdGwuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5oYXNSdGxDaGFyID0gZ29vZy5pMThuLmJpZGkuaGFzQW55UnRsO1xuXG4gIC8qKlxuICAgKiBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBoYXMgYW55IExUUiBjaGFyYWN0ZXJzIGluIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBnaXZlbiBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHRlc3RlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHN0cmluZyBjb250YWlucyBMVFIgY2hhcmFjdGVycy5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmhhc0FueUx0ciA9IGZ1bmN0aW9uIChzdHIsIG9wdF9pc0h0bWwpIHtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkubHRyQ2hhclJlZ18udGVzdChnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIGNoZWNrIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZ1xuICAgKiBpcyBMVFIuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5sdHJSZV8gPSBuZXcgUmVnRXhwKCdeWycgKyBnb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gKyAnXScpO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBjaGVjayBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmdcbiAgICogaXMgUlRMLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsUmVfID0gbmV3IFJlZ0V4cCgnXlsnICsgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfICsgJ10nKTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIFJUTCBvciBub3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGdpdmVuIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgdGVzdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gc3RyIGlzIGFuIFJUTCBjaGFyLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNSdGxDaGFyID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5ydGxSZV8udGVzdChzdHIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcgaXMgTFRSIG9yIG5vdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZ2l2ZW4gc3RyaW5nIHRoYXQgbmVlZCB0byBiZSB0ZXN0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBzdHIgaXMgYW4gTFRSIGNoYXIuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5pc0x0ckNoYXIgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmx0clJlXy50ZXN0KHN0cik7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBuZXV0cmFsIG9yIG5vdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgZ2l2ZW4gc3RyaW5nIHRoYXQgbmVlZCB0byBiZSB0ZXN0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBzdHIgaXMgYSBuZXV0cmFsIGNoYXIuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5pc05ldXRyYWxDaGFyID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiAhZ29vZy5pMThuLmJpZGkuaXNMdHJDaGFyKHN0cikgJiYgIWdvb2cuaTE4bi5iaWRpLmlzUnRsQ2hhcihzdHIpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIGNoZWNrIGlmIGEgcGllY2Ugb2YgdGV4dCBpcyBvZiBMVFIgZGlyZWN0aW9uYWxpdHlcbiAgICogb24gZmlyc3QgY2hhcmFjdGVyIHdpdGggc3Ryb25nIGRpcmVjdGlvbmFsaXR5LlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkubHRyRGlyQ2hlY2tSZV8gPSBuZXcgUmVnRXhwKCdeW14nICsgZ29vZy5pMThuLmJpZGkucnRsQ2hhcnNfICsgJ10qWycgKyBnb29nLmkxOG4uYmlkaS5sdHJDaGFyc18gKyAnXScpO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb25zIHRvIGNoZWNrIGlmIGEgcGllY2Ugb2YgdGV4dCBpcyBvZiBSVEwgZGlyZWN0aW9uYWxpdHlcbiAgICogb24gZmlyc3QgY2hhcmFjdGVyIHdpdGggc3Ryb25nIGRpcmVjdGlvbmFsaXR5LlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsRGlyQ2hlY2tSZV8gPSBuZXcgUmVnRXhwKCdeW14nICsgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfICsgJ10qWycgKyBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gKyAnXScpO1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBmaXJzdCBzdHJvbmdseSBkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgKGlmIGFueSkgaXMgUlRMLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyBiZWluZyBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBSVEwgZGlyZWN0aW9uYWxpdHkgaXMgZGV0ZWN0ZWQgdXNpbmcgdGhlIGZpcnN0XG4gICAqICAgICBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgbWV0aG9kLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuc3RhcnRzV2l0aFJ0bCA9IGZ1bmN0aW9uIChzdHIsIG9wdF9pc0h0bWwpIHtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkucnRsRGlyQ2hlY2tSZV8udGVzdChnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGZpcnN0IHN0cm9uZ2x5IGRpcmVjdGlvbmFsIGNoYXJhY3RlciAoaWYgYW55KSBpcyBSVEwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIFJUTCBkaXJlY3Rpb25hbGl0eSBpcyBkZXRlY3RlZCB1c2luZyB0aGUgZmlyc3RcbiAgICogICAgIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBtZXRob2QuXG4gICAqIEBkZXByZWNhdGVkIFVzZSBzdGFydHNXaXRoUnRsLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNSdGxUZXh0ID0gZ29vZy5pMThuLmJpZGkuc3RhcnRzV2l0aFJ0bDtcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZmlyc3Qgc3Ryb25nbHkgZGlyZWN0aW9uYWwgY2hhcmFjdGVyIChpZiBhbnkpIGlzIExUUi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgTFRSIGRpcmVjdGlvbmFsaXR5IGlzIGRldGVjdGVkIHVzaW5nIHRoZSBmaXJzdFxuICAgKiAgICAgc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIG1ldGhvZC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhMdHIgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmx0ckRpckNoZWNrUmVfLnRlc3QoZ29vZy5pMThuLmJpZGkuc3RyaXBIdG1sSWZOZWVkZWRfKHN0ciwgb3B0X2lzSHRtbCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIHRoZSBmaXJzdCBzdHJvbmdseSBkaXJlY3Rpb25hbCBjaGFyYWN0ZXIgKGlmIGFueSkgaXMgTFRSLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyBiZWluZyBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBMVFIgZGlyZWN0aW9uYWxpdHkgaXMgZGV0ZWN0ZWQgdXNpbmcgdGhlIGZpcnN0XG4gICAqICAgICBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgbWV0aG9kLlxuICAgKiBAZGVwcmVjYXRlZCBVc2Ugc3RhcnRzV2l0aEx0ci5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmlzTHRyVGV4dCA9IGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhMdHI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB0byBjaGVjayBpZiBhIHN0cmluZyBsb29rcyBsaWtlIHNvbWV0aGluZyB0aGF0IG11c3RcbiAgICogYWx3YXlzIGJlIExUUiBldmVuIGluIFJUTCB0ZXh0LCBlLmcuIGEgVVJMLiBXaGVuIGVzdGltYXRpbmcgdGhlXG4gICAqIGRpcmVjdGlvbmFsaXR5IG9mIHRleHQgY29udGFpbmluZyB0aGVzZSwgd2UgdHJlYXQgdGhlc2UgYXMgd2Vha2x5IExUUixcbiAgICogbGlrZSBudW1iZXJzLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNSZXF1aXJlZEx0clJlXyA9IC9eaHR0cDpcXC9cXC8uKi87XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGlucHV0IHN0cmluZyBlaXRoZXIgY29udGFpbnMgbm8gc3Ryb25nbHkgZGlyZWN0aW9uYWxcbiAgICogY2hhcmFjdGVycyBvciBsb29rcyBsaWtlIGEgdXJsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyBiZWluZyBjaGVja2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfaXNIdG1sIFdoZXRoZXIgc3RyIGlzIEhUTUwgLyBIVE1MLWVzY2FwZWQuXG4gICAqICAgICBEZWZhdWx0OiBmYWxzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBuZXV0cmFsIGRpcmVjdGlvbmFsaXR5IGlzIGRldGVjdGVkLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNOZXV0cmFsVGV4dCA9IGZ1bmN0aW9uIChzdHIsIG9wdF9pc0h0bWwpIHtcbiAgICBzdHIgPSBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKTtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkuaXNSZXF1aXJlZEx0clJlXy50ZXN0KHN0cikgfHwgIWdvb2cuaTE4bi5iaWRpLmhhc0FueUx0cihzdHIpICYmICFnb29nLmkxOG4uYmlkaS5oYXNBbnlSdGwoc3RyKTtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9ucyB0byBjaGVjayBpZiB0aGUgbGFzdCBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgaW4gYVxuICAgKiBwaWVjZSBvZiB0ZXh0IGlzIExUUi5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmx0ckV4aXREaXJDaGVja1JlXyA9IG5ldyBSZWdFeHAoJ1snICsgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfICsgJ11bXicgKyBnb29nLmkxOG4uYmlkaS5ydGxDaGFyc18gKyAnXSokJyk7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gY2hlY2sgaWYgdGhlIGxhc3Qgc3Ryb25nbHktZGlyZWN0aW9uYWwgY2hhcmFjdGVyIGluIGFcbiAgICogcGllY2Ugb2YgdGV4dCBpcyBSVEwuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5ydGxFeGl0RGlyQ2hlY2tSZV8gPSBuZXcgUmVnRXhwKCdbJyArIGdvb2cuaTE4bi5iaWRpLnJ0bENoYXJzXyArICddW14nICsgZ29vZy5pMThuLmJpZGkubHRyQ2hhcnNfICsgJ10qJCcpO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZXhpdCBkaXJlY3Rpb25hbGl0eSBhIHBpZWNlIG9mIHRleHQgaXMgTFRSLCBpLmUuIGlmIHRoZSBsYXN0XG4gICAqIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIExUUi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgTFRSIGV4aXQgZGlyZWN0aW9uYWxpdHkgd2FzIGRldGVjdGVkLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZW5kc1dpdGhMdHIgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmx0ckV4aXREaXJDaGVja1JlXy50ZXN0KGdvb2cuaTE4bi5iaWRpLnN0cmlwSHRtbElmTmVlZGVkXyhzdHIsIG9wdF9pc0h0bWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV4aXQgZGlyZWN0aW9uYWxpdHkgYSBwaWVjZSBvZiB0ZXh0IGlzIExUUiwgaS5lLiBpZiB0aGUgbGFzdFxuICAgKiBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBMVFIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIExUUiBleGl0IGRpcmVjdGlvbmFsaXR5IHdhcyBkZXRlY3RlZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuZHNXaXRoTHRyLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNMdHJFeGl0VGV4dCA9IGdvb2cuaTE4bi5iaWRpLmVuZHNXaXRoTHRyO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZXhpdCBkaXJlY3Rpb25hbGl0eSBhIHBpZWNlIG9mIHRleHQgaXMgUlRMLCBpLmUuIGlmIHRoZSBsYXN0XG4gICAqIHN0cm9uZ2x5LWRpcmVjdGlvbmFsIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nIGlzIFJUTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgYmVpbmcgY2hlY2tlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzSHRtbCBXaGV0aGVyIHN0ciBpcyBIVE1MIC8gSFRNTC1lc2NhcGVkLlxuICAgKiAgICAgRGVmYXVsdDogZmFsc2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgUlRMIGV4aXQgZGlyZWN0aW9uYWxpdHkgd2FzIGRldGVjdGVkLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZW5kc1dpdGhSdGwgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLnJ0bEV4aXREaXJDaGVja1JlXy50ZXN0KGdvb2cuaTE4bi5iaWRpLnN0cmlwSHRtbElmTmVlZGVkXyhzdHIsIG9wdF9pc0h0bWwpKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIGV4aXQgZGlyZWN0aW9uYWxpdHkgYSBwaWVjZSBvZiB0ZXh0IGlzIFJUTCwgaS5lLiBpZiB0aGUgbGFzdFxuICAgKiBzdHJvbmdseS1kaXJlY3Rpb25hbCBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZyBpcyBSVEwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIGJlaW5nIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIFJUTCBleGl0IGRpcmVjdGlvbmFsaXR5IHdhcyBkZXRlY3RlZC5cbiAgICogQGRlcHJlY2F0ZWQgVXNlIGVuZHNXaXRoUnRsLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuaXNSdGxFeGl0VGV4dCA9IGdvb2cuaTE4bi5iaWRpLmVuZHNXaXRoUnRsO1xuXG4gIC8qKlxuICAgKiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgbWF0Y2hpbmcgcmlnaHQtdG8tbGVmdCBsYW5ndWFnZSBjb2Rlcy5cbiAgICogU2VlIHtAbGluayAjaXNSdGxMYW5ndWFnZX0gZm9yIHRoZSBkZXNpZ24uXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5ydGxMb2NhbGVzUmVfID0gbmV3IFJlZ0V4cCgnXihhcnxja2J8ZHZ8aGV8aXd8ZmF8bnFvfHBzfHNkfHVnfHVyfHlpfCcgKyAnLipbLV9dKEFyYWJ8SGVicnxUaGFhfE5rb298VGZuZykpJyArICcoPyEuKlstX10oTGF0bnxDeXJsKSgkfC18XykpKCR8LXxfKScsICdpJyk7XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgQkNQIDQ3IC8gSUlJIGxhbmd1YWdlIGNvZGUgaW5kaWNhdGVzIGFuIFJUTCBsYW5ndWFnZSwgaS5lLiBlaXRoZXI6XG4gICAqIC0gYSBsYW5ndWFnZSBjb2RlIGV4cGxpY2l0bHkgc3BlY2lmeWluZyBvbmUgb2YgdGhlIHJpZ2h0LXRvLWxlZnQgc2NyaXB0cyxcbiAgICogICBlLmcuIFwiYXotQXJhYlwiLCBvcjxwPlxuICAgKiAtIGEgbGFuZ3VhZ2UgY29kZSBzcGVjaWZ5aW5nIG9uZSBvZiB0aGUgbGFuZ3VhZ2VzIG5vcm1hbGx5IHdyaXR0ZW4gaW4gYVxuICAgKiAgIHJpZ2h0LXRvLWxlZnQgc2NyaXB0LCBlLmcuIFwiZmFcIiAoRmFyc2kpLCBleGNlcHQgb25lcyBleHBsaWNpdGx5IHNwZWNpZnlpbmdcbiAgICogICBMYXRpbiBvciBDeXJpbGxpYyBzY3JpcHQgKHdoaWNoIGFyZSB0aGUgdXN1YWwgTFRSIGFsdGVybmF0aXZlcykuPHA+XG4gICAqIFRoZSBsaXN0IG9mIHJpZ2h0LXRvLWxlZnQgc2NyaXB0cyBhcHBlYXJzIGluIHRoZSAxMDAtMTk5IHJhbmdlIGluXG4gICAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvaXNvMTU5MjQvaXNvMTU5MjQtbnVtLmh0bWwsIG9mIHdoaWNoIEFyYWJpYyBhbmRcbiAgICogSGVicmV3IGFyZSBieSBmYXIgdGhlIG1vc3Qgd2lkZWx5IHVzZWQuIFdlIGFsc28gcmVjb2duaXplIFRoYWFuYSwgTidLbywgYW5kXG4gICAqIFRpZmluYWdoLCB3aGljaCBhbHNvIGhhdmUgc2lnbmlmaWNhbnQgbW9kZXJuIHVzYWdlLiBUaGUgcmVzdCAoU3lyaWFjLFxuICAgKiBTYW1hcml0YW4sIE1hbmRhaWMsIGV0Yy4pIHNlZW0gdG8gaGF2ZSBleHRyZW1lbHkgbGltaXRlZCBvciBubyBtb2Rlcm4gdXNhZ2VcbiAgICogYW5kIGFyZSBub3QgcmVjb2duaXplZCB0byBzYXZlIG9uIGNvZGUgc2l6ZS5cbiAgICogVGhlIGxhbmd1YWdlcyB1c3VhbGx5IHdyaXR0ZW4gaW4gYSByaWdodC10by1sZWZ0IHNjcmlwdCBhcmUgdGFrZW4gYXMgdGhvc2VcbiAgICogd2l0aCBTdXBwcmVzcy1TY3JpcHQ6IEhlYnJ8QXJhYnxUaGFhfE5rb298VGZuZyAgaW5cbiAgICogaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnksXG4gICAqIGFzIHdlbGwgYXMgQ2VudHJhbCAob3IgU29yYW5pKSBLdXJkaXNoIChja2IpLCBTaW5kaGkgKHNkKSBhbmQgVXlnaHVyICh1ZykuXG4gICAqIE90aGVyIHN1YnRhZ3Mgb2YgdGhlIGxhbmd1YWdlIGNvZGUsIGUuZy4gcmVnaW9ucyBsaWtlIEVHIChFZ3lwdCksIGFyZVxuICAgKiBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBCQ1AgNDcgKGEuay5hIElJSSkgbGFuZ3VhZ2UgY29kZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbGFuZ3VhZ2UgY29kZSBpcyBhbiBSVEwgbGFuZ3VhZ2UuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5pc1J0bExhbmd1YWdlID0gZnVuY3Rpb24gKGxhbmcpIHtcbiAgICByZXR1cm4gZ29vZy5pMThuLmJpZGkucnRsTG9jYWxlc1JlXy50ZXN0KGxhbmcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIGJyYWNrZXQgZ3VhcmQgcmVwbGFjZW1lbnQgaW4gdGV4dC5cbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmJyYWNrZXRHdWFyZFRleHRSZV8gPSAvKFxcKC4qP1xcKSspfChcXFsuKj9cXF0rKXwoXFx7Lio/XFx9Kyl8KDwuKj8+KykvZztcblxuICAvKipcbiAgICogQXBwbHkgYnJhY2tldCBndWFyZCB1c2luZyBMUk0gYW5kIFJMTS4gVGhpcyBpcyB0byBhZGRyZXNzIHRoZSBwcm9ibGVtIG9mXG4gICAqIG1lc3N5IGJyYWNrZXQgZGlzcGxheSBmcmVxdWVudGx5IGhhcHBlbnMgaW4gUlRMIGxheW91dC5cbiAgICogVGhpcyBmdW5jdGlvbiB3b3JrcyBmb3IgcGxhaW4gdGV4dCwgbm90IGZvciBIVE1MLiBJbiBIVE1MLCB0aGUgb3BlbmluZ1xuICAgKiBicmFja2V0IG1pZ2h0IGJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQgdGhhbiB0aGUgY2xvc2luZyBicmFja2V0IChzdWNoIGFzXG4gICAqIGFuIGF0dHJpYnV0ZSB2YWx1ZSkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIFRoZSBzdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHByb2Nlc3NlZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3B0X2lzUnRsQ29udGV4dCBzcGVjaWZpZXMgZGVmYXVsdCBkaXJlY3Rpb24gKHVzdWFsbHlcbiAgICogICAgIGRpcmVjdGlvbiBvZiB0aGUgVUkpLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgc3RyaW5nLCB3aXRoIGFsbCBicmFja2V0IGd1YXJkZWQuXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5ndWFyZEJyYWNrZXRJblRleHQgPSBmdW5jdGlvbiAocywgb3B0X2lzUnRsQ29udGV4dCkge1xuICAgIHZhciB1c2VSdGwgPSBvcHRfaXNSdGxDb250ZXh0ID09PSB1bmRlZmluZWQgPyBnb29nLmkxOG4uYmlkaS5oYXNBbnlSdGwocykgOiBvcHRfaXNSdGxDb250ZXh0O1xuICAgIHZhciBtYXJrID0gdXNlUnRsID8gZ29vZy5pMThuLmJpZGkuRm9ybWF0LlJMTSA6IGdvb2cuaTE4bi5iaWRpLkZvcm1hdC5MUk07XG4gICAgcmV0dXJuIHMucmVwbGFjZShnb29nLmkxOG4uYmlkaS5icmFja2V0R3VhcmRUZXh0UmVfLCBtYXJrICsgJyQmJyArIG1hcmspO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmZvcmNlIHRoZSBodG1sIHNuaXBwZXQgaW4gUlRMIGRpcmVjdGlvbmFsaXR5IHJlZ2FyZGxlc3Mgb3ZlcmFsbCBjb250ZXh0LlxuICAgKiBJZiB0aGUgaHRtbCBwaWVjZSB3YXMgZW5jbG9zZWQgYnkgdGFnLCBkaXIgd2lsbCBiZSBhcHBsaWVkIHRvIGV4aXN0aW5nXG4gICAqIHRhZywgb3RoZXJ3aXNlIGEgc3BhbiB0YWcgd2lsbCBiZSBhZGRlZCBhcyB3cmFwcGVyLiBGb3IgdGhpcyByZWFzb24sIGlmXG4gICAqIGh0bWwgc25pcHBldCBzdGFydCB3aXRoIHdpdGggdGFnLCB0aGlzIHRhZyBtdXN0IGVuY2xvc2UgdGhlIHdob2xlIHBpZWNlLiBJZlxuICAgKiB0aGUgdGFnIGFscmVhZHkgaGFzIGEgZGlyIHNwZWNpZmllZCwgdGhpcyBuZXcgb25lIHdpbGwgb3ZlcnJpZGUgZXhpc3RpbmdcbiAgICogb25lIGluIGJlaGF2aW9yICh0ZXN0ZWQgb24gRkYgYW5kIElFKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGh0bWwgVGhlIHN0cmluZyB0aGF0IG5lZWQgdG8gYmUgcHJvY2Vzc2VkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwcm9jZXNzZWQgc3RyaW5nLCB3aXRoIGRpcmVjdGlvbmFsaXR5IGVuZm9yY2VkIHRvIFJUTC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVuZm9yY2VSdGxJbkh0bWwgPSBmdW5jdGlvbiAoaHRtbCkge1xuICAgIGlmIChodG1sLmNoYXJBdCgwKSA9PSAnPCcpIHtcbiAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoLzxcXHcrLywgJyQmIGRpcj1ydGwnKTtcbiAgICB9XG4gICAgLy8gJ1xcbicgaXMgaW1wb3J0YW50IGZvciBGRiBzbyB0aGF0IGl0IHdvbid0IGluY29ycmVjdGx5IG1lcmdlIHNwYW4gZ3JvdXBzXG4gICAgcmV0dXJuICdcXG48c3BhbiBkaXI9cnRsPicgKyBodG1sICsgJzwvc3Bhbj4nO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmZvcmNlIFJUTCBvbiBib3RoIGVuZCBvZiB0aGUgZ2l2ZW4gdGV4dCBwaWVjZSB1c2luZyB1bmljb2RlIEJpRGkgZm9ybWF0dGluZ1xuICAgKiBjaGFyYWN0ZXJzIFJMRSBhbmQgUERGLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgcGllY2Ugb2YgdGV4dCB0aGF0IG5lZWQgdG8gYmUgd3JhcHBlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgd3JhcHBlZCBzdHJpbmcgYWZ0ZXIgcHJvY2Vzcy5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmVuZm9yY2VSdGxJblRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgIHJldHVybiBnb29nLmkxOG4uYmlkaS5Gb3JtYXQuUkxFICsgdGV4dCArIGdvb2cuaTE4bi5iaWRpLkZvcm1hdC5QREY7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuZm9yY2UgdGhlIGh0bWwgc25pcHBldCBpbiBSVEwgZGlyZWN0aW9uYWxpdHkgcmVnYXJkbGVzcyBvdmVyYWxsIGNvbnRleHQuXG4gICAqIElmIHRoZSBodG1sIHBpZWNlIHdhcyBlbmNsb3NlZCBieSB0YWcsIGRpciB3aWxsIGJlIGFwcGxpZWQgdG8gZXhpc3RpbmdcbiAgICogdGFnLCBvdGhlcndpc2UgYSBzcGFuIHRhZyB3aWxsIGJlIGFkZGVkIGFzIHdyYXBwZXIuIEZvciB0aGlzIHJlYXNvbiwgaWZcbiAgICogaHRtbCBzbmlwcGV0IHN0YXJ0IHdpdGggd2l0aCB0YWcsIHRoaXMgdGFnIG11c3QgZW5jbG9zZSB0aGUgd2hvbGUgcGllY2UuIElmXG4gICAqIHRoZSB0YWcgYWxyZWFkeSBoYXMgYSBkaXIgc3BlY2lmaWVkLCB0aGlzIG5ldyBvbmUgd2lsbCBvdmVycmlkZSBleGlzdGluZ1xuICAgKiBvbmUgaW4gYmVoYXZpb3IgKHRlc3RlZCBvbiBGRiBhbmQgSUUpLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaHRtbCBUaGUgc3RyaW5nIHRoYXQgbmVlZCB0byBiZSBwcm9jZXNzZWQuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHByb2Nlc3NlZCBzdHJpbmcsIHdpdGggZGlyZWN0aW9uYWxpdHkgZW5mb3JjZWQgdG8gUlRMLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZW5mb3JjZUx0ckluSHRtbCA9IGZ1bmN0aW9uIChodG1sKSB7XG4gICAgaWYgKGh0bWwuY2hhckF0KDApID09ICc8Jykge1xuICAgICAgcmV0dXJuIGh0bWwucmVwbGFjZSgvPFxcdysvLCAnJCYgZGlyPWx0cicpO1xuICAgIH1cbiAgICAvLyAnXFxuJyBpcyBpbXBvcnRhbnQgZm9yIEZGIHNvIHRoYXQgaXQgd29uJ3QgaW5jb3JyZWN0bHkgbWVyZ2Ugc3BhbiBncm91cHNcbiAgICByZXR1cm4gJ1xcbjxzcGFuIGRpcj1sdHI+JyArIGh0bWwgKyAnPC9zcGFuPic7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuZm9yY2UgTFRSIG9uIGJvdGggZW5kIG9mIHRoZSBnaXZlbiB0ZXh0IHBpZWNlIHVzaW5nIHVuaWNvZGUgQmlEaSBmb3JtYXR0aW5nXG4gICAqIGNoYXJhY3RlcnMgTFJFIGFuZCBQREYuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSBwaWVjZSBvZiB0ZXh0IHRoYXQgbmVlZCB0byBiZSB3cmFwcGVkLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB3cmFwcGVkIHN0cmluZyBhZnRlciBwcm9jZXNzLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZW5mb3JjZUx0ckluVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLkZvcm1hdC5MUkUgKyB0ZXh0ICsgZ29vZy5pMThuLmJpZGkuRm9ybWF0LlBERjtcbiAgfTtcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIHRvIGZpbmQgZGltZW5zaW9ucyBzdWNoIGFzIFwicGFkZGluZzogLjMgMC40ZXggNXB4IDY7XCJcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmRpbWVuc2lvbnNSZV8gPSAvOlxccyooWy5cXGRdWy5cXHddKilcXHMrKFsuXFxkXVsuXFx3XSopXFxzKyhbLlxcZF1bLlxcd10qKVxccysoWy5cXGRdWy5cXHddKikvZztcblxuICAvKipcbiAgICogUmVndWxhciBleHByZXNzaW9uIGZvciBsZWZ0LlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkubGVmdFJlXyA9IC9sZWZ0L2dpO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIHJpZ2h0LlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucmlnaHRSZV8gPSAvcmlnaHQvZ2k7XG5cbiAgLyoqXG4gICAqIFBsYWNlaG9sZGVyIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3Igc3dhcHBpbmcuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS50ZW1wUmVfID0gLyUlJSUvZztcblxuICAvKipcbiAgICogU3dhcCBsb2NhdGlvbiBwYXJhbWV0ZXJzIGFuZCAnbGVmdCcvJ3JpZ2h0JyBpbiBDU1Mgc3BlY2lmaWNhdGlvbi4gVGhlXG4gICAqIHByb2Nlc3NlZCBzdHJpbmcgd2lsbCBiZSBzdWl0ZWQgZm9yIFJUTCBsYXlvdXQuIFRob3VnaCB0aGlzIGZ1bmN0aW9uIGNhblxuICAgKiBjb3ZlciBtb3N0IGNhc2VzLCB0aGVyZSBhcmUgYWx3YXlzIGV4Y2VwdGlvbnMuIEl0IGlzIHN1Z2dlc3RlZCB0byBwdXRcbiAgICogdGhvc2UgZXhjZXB0aW9ucyBpbiBzZXBhcmF0ZSBncm91cCBvZiBDU1Mgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzU3RyIENTUyBzcGVmaWNhdGlvbiBzdHJpbmcuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gUHJvY2Vzc2VkIENTUyBzcGVjaWZpY2F0aW9uIHN0cmluZy5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLm1pcnJvckNTUyA9IGZ1bmN0aW9uIChjc3NTdHIpIHtcbiAgICByZXR1cm4gY3NzU3RyLlxuICAgIC8vIHJldmVyc2UgZGltZW5zaW9uc1xuICAgIHJlcGxhY2UoZ29vZy5pMThuLmJpZGkuZGltZW5zaW9uc1JlXywgJzokMSAkNCAkMyAkMicpLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkubGVmdFJlXywgJyUlJSUnKS4gLy8gc3dhcCBsZWZ0IGFuZCByaWdodFxuICAgIHJlcGxhY2UoZ29vZy5pMThuLmJpZGkucmlnaHRSZV8sIGdvb2cuaTE4bi5iaWRpLkxFRlQpLnJlcGxhY2UoZ29vZy5pMThuLmJpZGkudGVtcFJlXywgZ29vZy5pMThuLmJpZGkuUklHSFQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIGhlYnJldyBkb3VibGUgcXVvdGUgc3Vic3RpdHV0aW9uLCBmaW5kaW5nIHF1b3RlXG4gICAqIGRpcmVjdGx5IGFmdGVyIGhlYnJldyBjaGFyYWN0ZXJzLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZG91YmxlUXVvdGVTdWJzdGl0dXRlUmVfID0gLyhbXFx1MDU5MS1cXHUwNWYyXSlcIi9nO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIGhlYnJldyBzaW5nbGUgcXVvdGUgc3Vic3RpdHV0aW9uLCBmaW5kaW5nIHF1b3RlXG4gICAqIGRpcmVjdGx5IGFmdGVyIGhlYnJldyBjaGFyYWN0ZXJzLlxuICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuc2luZ2xlUXVvdGVTdWJzdGl0dXRlUmVfID0gLyhbXFx1MDU5MS1cXHUwNWYyXSknL2c7XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgdGhlIGRvdWJsZSBhbmQgc2luZ2xlIHF1b3RlIGRpcmVjdGx5IGFmdGVyIGEgSGVicmV3IGNoYXJhY3RlciB3aXRoXG4gICAqIEdFUkVTSCBhbmQgR0VSU0hBWUlNLiBJbiBzdWNoIGNhc2UsIG1vc3QgbGlrZWx5IHRoYXQncyB1c2VyIGludGVudGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdGhhdCBuZWVkIHRvIGJlIHByb2Nlc3NlZC5cbiAgICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgc3RyaW5nIHdpdGggZG91YmxlL3NpbmdsZSBxdW90ZSByZXBsYWNlZC5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLm5vcm1hbGl6ZUhlYnJld1F1b3RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShnb29nLmkxOG4uYmlkaS5kb3VibGVRdW90ZVN1YnN0aXR1dGVSZV8sICckMVxcdTA1RjQnKS5yZXBsYWNlKGdvb2cuaTE4bi5iaWRpLnNpbmdsZVF1b3RlU3Vic3RpdHV0ZVJlXywgJyQxXFx1MDVGMycpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gc3BsaXQgYSBzdHJpbmcgaW50byBcIndvcmRzXCIgZm9yIGRpcmVjdGlvbmFsaXR5XG4gICAqIGVzdGltYXRpb24gYmFzZWQgb24gcmVsYXRpdmUgd29yZCBjb3VudHMuXG4gICAqIEB0eXBlIHtSZWdFeHB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS53b3JkU2VwYXJhdG9yUmVfID0gL1xccysvO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyIGV4cHJlc3Npb24gdG8gY2hlY2sgaWYgYSBzdHJpbmcgY29udGFpbnMgYW55IG51bWVyYWxzLiBVc2VkIHRvXG4gICAqIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBjb21wbGV0ZWx5IG5ldXRyYWwgc3RyaW5ncyBhbmQgdGhvc2UgY29udGFpbmluZ1xuICAgKiBudW1iZXJzLCB3aGljaCBhcmUgd2Vha2x5IExUUi5cbiAgICpcbiAgICogTmF0aXZlIEFyYWJpYyBkaWdpdHMgKFxcdTA2NjAgLSBcXHUwNjY5KSBhcmUgbm90IGluY2x1ZGVkIGJlY2F1c2UgYWx0aG91Z2ggdGhleVxuICAgKiBkbyBmbG93IGxlZnQtdG8tcmlnaHQgaW5zaWRlIGEgbnVtYmVyLCB0aGlzIGlzIHRoZSBjYXNlIGV2ZW4gaWYgdGhlICBvdmVyYWxsXG4gICAqIGRpcmVjdGlvbmFsaXR5IGlzIFJUTCwgYW5kIGEgbWF0aGVtYXRpY2FsIGV4cHJlc3Npb24gdXNpbmcgdGhlc2UgZGlnaXRzIGlzXG4gICAqIHN1cHBvc2VkIHRvIGZsb3cgcmlnaHQtdG8tbGVmdCBvdmVyYWxsLCBpbmNsdWRpbmcgdW5hcnkgcGx1cyBhbmQgbWludXNcbiAgICogYXBwZWFyaW5nIHRvIHRoZSByaWdodCBvZiBhIG51bWJlciwgYW5kIHRoaXMgZG9lcyBkZXBlbmQgb24gdGhlIG92ZXJhbGxcbiAgICogZGlyZWN0aW9uYWxpdHkgYmVpbmcgUlRMLiBUaGUgZGlnaXRzIHVzZWQgaW4gRmFyc2kgKFxcdTA2RjAgLSBcXHUwNkY5KSwgb24gdGhlXG4gICAqIG90aGVyIGhhbmQsIGFyZSBpbmNsdWRlZCwgc2luY2UgRmFyc2kgbWF0aCAoaW5jbHVkaW5nIHVuYXJ5IHBsdXMgYW5kIG1pbnVzKVxuICAgKiBkb2VzIGZsb3cgbGVmdC10by1yaWdodC5cbiAgICpcbiAgICogQHR5cGUge1JlZ0V4cH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLmhhc051bWVyYWxzUmVfID0gL1tcXGRcXHUwNmYwLVxcdTA2ZjldLztcblxuICAvKipcbiAgICogVGhpcyBjb25zdGFudCBjb250cm9scyB0aHJlc2hvbGQgb2YgUlRMIGRpcmVjdGlvbmFsaXR5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkucnRsRGV0ZWN0aW9uVGhyZXNob2xkXyA9IDAuNDA7XG5cbiAgLyoqXG4gICAqIEVzdGltYXRlcyB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgYSBzdHJpbmcgYmFzZWQgb24gcmVsYXRpdmUgd29yZCBjb3VudHMuXG4gICAqIElmIHRoZSBudW1iZXIgb2YgUlRMIHdvcmRzIGlzIGFib3ZlIGEgY2VydGFpbiBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbCBudW1iZXJcbiAgICogb2Ygc3Ryb25nbHkgZGlyZWN0aW9uYWwgd29yZHMsIHJldHVybnMgUlRMLlxuICAgKiBPdGhlcndpc2UsIGlmIGFueSB3b3JkcyBhcmUgc3Ryb25nbHkgb3Igd2Vha2x5IExUUiwgcmV0dXJucyBMVFIuXG4gICAqIE90aGVyd2lzZSwgcmV0dXJucyBVTktOT1dOLCB3aGljaCBpcyB1c2VkIHRvIG1lYW4gXCJuZXV0cmFsXCIuXG4gICAqIE51bWJlcnMgYXJlIGNvdW50ZWQgYXMgd2Vha2x5IExUUi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIGJlIGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtnb29nLmkxOG4uYmlkaS5EaXJ9IEVzdGltYXRlZCBvdmVyYWxsIGRpcmVjdGlvbmFsaXR5IG9mIHtAY29kZSBzdHJ9LlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZXN0aW1hdGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgdmFyIHJ0bENvdW50ID0gMDtcbiAgICB2YXIgdG90YWxDb3VudCA9IDA7XG4gICAgdmFyIGhhc1dlYWtseUx0ciA9IGZhbHNlO1xuICAgIHZhciB0b2tlbnMgPSBnb29nLmkxOG4uYmlkaS5zdHJpcEh0bWxJZk5lZWRlZF8oc3RyLCBvcHRfaXNIdG1sKS5zcGxpdChnb29nLmkxOG4uYmlkaS53b3JkU2VwYXJhdG9yUmVfKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgaWYgKGdvb2cuaTE4bi5iaWRpLnN0YXJ0c1dpdGhSdGwodG9rZW4pKSB7XG4gICAgICAgIHJ0bENvdW50Kys7XG4gICAgICAgIHRvdGFsQ291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAoZ29vZy5pMThuLmJpZGkuaXNSZXF1aXJlZEx0clJlXy50ZXN0KHRva2VuKSkge1xuICAgICAgICBoYXNXZWFrbHlMdHIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChnb29nLmkxOG4uYmlkaS5oYXNBbnlMdHIodG9rZW4pKSB7XG4gICAgICAgIHRvdGFsQ291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAoZ29vZy5pMThuLmJpZGkuaGFzTnVtZXJhbHNSZV8udGVzdCh0b2tlbikpIHtcbiAgICAgICAgaGFzV2Vha2x5THRyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG90YWxDb3VudCA9PSAwID8gaGFzV2Vha2x5THRyID8gZ29vZy5pMThuLmJpZGkuRGlyLkxUUiA6IGdvb2cuaTE4bi5iaWRpLkRpci5ORVVUUkFMIDogcnRsQ291bnQgLyB0b3RhbENvdW50ID4gZ29vZy5pMThuLmJpZGkucnRsRGV0ZWN0aW9uVGhyZXNob2xkXyA/IGdvb2cuaTE4bi5iaWRpLkRpci5SVEwgOiBnb29nLmkxOG4uYmlkaS5EaXIuTFRSO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVjayB0aGUgZGlyZWN0aW9uYWxpdHkgb2YgYSBwaWVjZSBvZiB0ZXh0LCByZXR1cm4gdHJ1ZSBpZiB0aGUgcGllY2Ugb2ZcbiAgICogdGV4dCBzaG91bGQgYmUgbGFpZCBvdXQgaW4gUlRMIGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgcGllY2Ugb2YgdGV4dCB0aGF0IG5lZWQgdG8gYmUgZGV0ZWN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9pc0h0bWwgV2hldGhlciBzdHIgaXMgSFRNTCAvIEhUTUwtZXNjYXBlZC5cbiAgICogICAgIERlZmF1bHQ6IGZhbHNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoaXMgcGllY2Ugb2YgdGV4dCBzaG91bGQgYmUgbGFpZCBvdXQgaW4gUlRMLlxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuZGV0ZWN0UnRsRGlyZWN0aW9uYWxpdHkgPSBmdW5jdGlvbiAoc3RyLCBvcHRfaXNIdG1sKSB7XG4gICAgcmV0dXJuIGdvb2cuaTE4bi5iaWRpLmVzdGltYXRlRGlyZWN0aW9uKHN0ciwgb3B0X2lzSHRtbCkgPT0gZ29vZy5pMThuLmJpZGkuRGlyLlJUTDtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyB0ZXh0IGlucHV0IGVsZW1lbnQncyBkaXJlY3Rpb25hbGl0eSBhbmQgdGV4dCBhbGlnbm1lbnQgYmFzZWQgb24gYVxuICAgKiBnaXZlbiBkaXJlY3Rpb25hbGl0eS4gRG9lcyBub3RoaW5nIGlmIHRoZSBnaXZlbiBkaXJlY3Rpb25hbGl0eSBpcyB1bmtub3duIG9yXG4gICAqIG5ldXRyYWwuXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBJbnB1dCBmaWVsZCBlbGVtZW50IHRvIHNldCBkaXJlY3Rpb25hbGl0eSB0by5cbiAgICogQHBhcmFtIHtnb29nLmkxOG4uYmlkaS5EaXJ8bnVtYmVyfGJvb2xlYW58bnVsbH0gZGlyIERlc2lyZWQgZGlyZWN0aW9uYWxpdHksXG4gICAqICAgICBnaXZlbiBpbiBvbmUgb2YgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICAgKiAgICAgMS4gQSBnb29nLmkxOG4uYmlkaS5EaXIgY29uc3RhbnQuXG4gICAqICAgICAyLiBBIG51bWJlciAocG9zaXRpdmUgPSBMUlQsIG5lZ2F0aXZlID0gUlRMLCAwID0gbmV1dHJhbCkuXG4gICAqICAgICAzLiBBIGJvb2xlYW4gKHRydWUgPSBSVEwsIGZhbHNlID0gTFRSKS5cbiAgICogICAgIDQuIEEgbnVsbCBmb3IgdW5rbm93biBkaXJlY3Rpb25hbGl0eS5cbiAgICovXG4gIGdvb2cuaTE4bi5iaWRpLnNldEVsZW1lbnREaXJBbmRBbGlnbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBkaXIpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgZGlyID0gZ29vZy5pMThuLmJpZGkudG9EaXIoZGlyKTtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBkaXIgPT0gZ29vZy5pMThuLmJpZGkuRGlyLlJUTCA/IGdvb2cuaTE4bi5iaWRpLlJJR0hUIDogZ29vZy5pMThuLmJpZGkuTEVGVDtcbiAgICAgICAgZWxlbWVudC5kaXIgPSBkaXIgPT0gZ29vZy5pMThuLmJpZGkuRGlyLlJUTCA/ICdydGwnIDogJ2x0cic7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXRzIGVsZW1lbnQgZGlyIGJhc2VkIG9uIGVzdGltYXRlZCBkaXJlY3Rpb25hbGl0eSBvZiB0aGUgZ2l2ZW4gdGV4dC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuc2V0RWxlbWVudERpckJ5VGV4dERpcmVjdGlvbmFsaXR5ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRleHQpIHtcbiAgICBzd2l0Y2ggKGdvb2cuaTE4bi5iaWRpLmVzdGltYXRlRGlyZWN0aW9uKHRleHQpKSB7XG4gICAgICBjYXNlIGdvb2cuaTE4bi5iaWRpLkRpci5MVFI6XG4gICAgICAgIGVsZW1lbnQuZGlyID0gJ2x0cic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnb29nLmkxOG4uYmlkaS5EaXIuUlRMOlxuICAgICAgICBlbGVtZW50LmRpciA9ICdydGwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIERlZmF1bHQgZm9yIG5vIGRpcmVjdGlvbiwgaW5oZXJpdCBmcm9tIGRvY3VtZW50LlxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGlyJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTdHJpbmdzIHRoYXQgaGF2ZSBhbiAob3B0aW9uYWwpIGtub3duIGRpcmVjdGlvbi5cbiAgICpcbiAgICogSW1wbGVtZW50YXRpb25zIG9mIHRoaXMgaW50ZXJmYWNlIGFyZSBzdHJpbmctbGlrZSBvYmplY3RzIHRoYXQgY2FycnkgYW5cbiAgICogYXR0YWNoZWQgZGlyZWN0aW9uLCBpZiBrbm93bi5cbiAgICogQGludGVyZmFjZVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuRGlyZWN0aW9uYWxTdHJpbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAvKipcbiAgICogSW50ZXJmYWNlIG1hcmtlciBvZiB0aGUgRGlyZWN0aW9uYWxTdHJpbmcgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSBhdCBydW50aW1lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdFxuICAgKiBpbXBsZW1lbnRzIHRoaXMgaW50ZXJmYWNlLiAgQWxsIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzIGludGVyZmFjZSBzZXQgdGhpc1xuICAgKiBwcm9wZXJ0eSB0byB7QGNvZGUgdHJ1ZX0uXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ29vZy5pMThuLmJpZGkuRGlyZWN0aW9uYWxTdHJpbmcucHJvdG90eXBlLmltcGxlbWVudHNHb29nSTE4bkJpZGlEaXJlY3Rpb25hbFN0cmluZztcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoaXMgb2JqZWN0J3Mga25vd24gZGlyZWN0aW9uIChpZiBhbnkpLlxuICAgKiBAcmV0dXJuIHs/Z29vZy5pMThuLmJpZGkuRGlyfSBUaGUga25vd24gZGlyZWN0aW9uLiBOdWxsIGlmIHVua25vd24uXG4gICAqL1xuICBnb29nLmkxOG4uYmlkaS5EaXJlY3Rpb25hbFN0cmluZy5wcm90b3R5cGUuZ2V0RGlyZWN0aW9uO1xuXG4gIC8vIENvcHlyaWdodCAyMDA4IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgLy9cbiAgLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAvLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgLy9cbiAgLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgLy9cbiAgLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAvLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gIC8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAvLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gIC8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4gIC8qKlxuICAgKiBAZmlsZW92ZXJ2aWV3IFV0aWxpdGllcyB0byBjaGVjayB0aGUgcHJlY29uZGl0aW9ucywgcG9zdGNvbmRpdGlvbnMgYW5kXG4gICAqIGludmFyaWFudHMgcnVudGltZS5cbiAgICpcbiAgICogTWV0aG9kcyBpbiB0aGlzIHBhY2thZ2Ugc2hvdWxkIGJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGJ5IHRoZSBjb21waWxlclxuICAgKiBmb3IgdHlwZS1pbmZlcmVuY2UuIEZvciBleGFtcGxlLCA8Y29kZT5nb29nLmFzc2VydHMuYXNzZXJ0KGZvbyk8L2NvZGU+XG4gICAqIHdpbGwgcmVzdHJpY3QgPGNvZGU+Zm9vPC9jb2RlPiB0byBhIHRydXRoeSB2YWx1ZS5cbiAgICpcbiAgICogVGhlIGNvbXBpbGVyIGhhcyBhbiBvcHRpb24gdG8gZGlzYWJsZSBhc3NlcnRzLiBTbyBjb2RlIGxpa2U6XG4gICAqIDxjb2RlPlxuICAgKiB2YXIgeCA9IGdvb2cuYXNzZXJ0cy5hc3NlcnQoZm9vKCkpOyBnb29nLmFzc2VydHMuYXNzZXJ0KGJhcigpKTtcbiAgICogPC9jb2RlPlxuICAgKiB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG86XG4gICAqIDxjb2RlPlxuICAgKiB2YXIgeCA9IGZvbygpO1xuICAgKiA8L2NvZGU+XG4gICAqIFRoZSBjb21waWxlciB3aWxsIGxlYXZlIGluIGZvbygpIChiZWNhdXNlIGl0cyByZXR1cm4gdmFsdWUgaXMgdXNlZCksXG4gICAqIGJ1dCBpdCB3aWxsIHJlbW92ZSBiYXIoKSBiZWNhdXNlIGl0IGFzc3VtZXMgaXQgZG9lcyBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuXG4gICAqXG4gICAqIEBhdXRob3IgYWdyaWV2ZUBnb29nbGUuY29tIChBbmRyZXcgR3JpZXZlKVxuICAgKi9cblxuICBnb29nLnByb3ZpZGUoJ2dvb2cuYXNzZXJ0cycpO1xuXG4gIC8qKlxuICAgKiBAZGVmaW5lIHtib29sZWFufSBXaGV0aGVyIHRvIHN0cmlwIG91dCBhc3NlcnRzIG9yIHRvIGxlYXZlIHRoZW0gaW4uXG4gICAqL1xuICBnb29nLmRlZmluZSgnZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTJywgZ29vZy5ERUJVRyk7XG5cbiAgLyoqXG4gICAqIEVycm9yIG9iamVjdCBmb3IgZmFpbGVkIGFzc2VydGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlUGF0dGVybiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIGZvcm0gbWVzc2FnZS5cbiAgICogQHBhcmFtIHshQXJyYXk8Kj59IG1lc3NhZ2VBcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIHBhdHRlcm4uXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7Z29vZy5kZWJ1Zy5FcnJvcn1cbiAgICogQGZpbmFsXG4gICAqL1xuICBnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZVBhdHRlcm4sIG1lc3NhZ2VBcmdzKSB7XG4gICAgbWVzc2FnZUFyZ3MudW5zaGlmdChtZXNzYWdlUGF0dGVybik7XG4gICAgZ29vZy5kZWJ1Zy5FcnJvci5jYWxsKHRoaXMsIGdvb2cuc3RyaW5nLnN1YnMuYXBwbHkobnVsbCwgbWVzc2FnZUFyZ3MpKTtcbiAgICAvLyBSZW1vdmUgdGhlIG1lc3NhZ2VQYXR0ZXJuIGFmdGVyd2FyZHMgdG8gYXZvaWQgcGVybWFuZW50bHkgbW9kaWZ5aW5nIHRoZVxuICAgIC8vIHBhc3NlZCBpbiBhcnJheS5cbiAgICBtZXNzYWdlQXJncy5zaGlmdCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG1lc3NhZ2UgcGF0dGVybiB1c2VkIHRvIGZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZS4gRXJyb3IgaGFuZGxlcnMgY2FuXG4gICAgICogdXNlIHRoaXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhlIGFzc2VydGlvbi5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubWVzc2FnZVBhdHRlcm4gPSBtZXNzYWdlUGF0dGVybjtcbiAgfTtcbiAgZ29vZy5pbmhlcml0cyhnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IsIGdvb2cuZGVidWcuRXJyb3IpO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgZXJyb3IgaGFuZGxlci5cbiAgICogQHBhcmFtIHshZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBlIFRoZSBleGNlcHRpb24gdG8gYmUgaGFuZGxlZC5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5ERUZBVUxUX0VSUk9SX0hBTkRMRVIgPSBmdW5jdGlvbiAoZSkge1xuICAgIHRocm93IGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBoYW5kbGVyIHJlc3BvbnNpYmxlIGZvciB0aHJvd2luZyBvciBsb2dnaW5nIGFzc2VydGlvbiBlcnJvcnMuXG4gICAqIEBwcml2YXRlIHtmdW5jdGlvbighZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKX1cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5lcnJvckhhbmRsZXJfID0gZ29vZy5hc3NlcnRzLkRFRkFVTFRfRVJST1JfSEFORExFUjtcblxuICAvKipcbiAgICogVGhyb3dzIGFuIGV4Y2VwdGlvbiB3aXRoIHRoZSBnaXZlbiBtZXNzYWdlIGFuZCBcIkFzc2VydGlvbiBmYWlsZWRcIiBwcmVmaXhlZFxuICAgKiBvbnRvIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGVmYXVsdE1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gdXNlIGlmIGdpdmVuTWVzc2FnZSBpcyBlbXB0eS5cbiAgICogQHBhcmFtIHtBcnJheTwqPn0gZGVmYXVsdEFyZ3MgVGhlIHN1YnN0aXR1dGlvbiBhcmd1bWVudHMgZm9yIGRlZmF1bHRNZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGdpdmVuTWVzc2FnZSBNZXNzYWdlIHN1cHBsaWVkIGJ5IHRoZSBjYWxsZXIuXG4gICAqIEBwYXJhbSB7QXJyYXk8Kj59IGdpdmVuQXJncyBUaGUgc3Vic3RpdHV0aW9uIGFyZ3VtZW50cyBmb3IgZ2l2ZW5NZXNzYWdlLlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfID0gZnVuY3Rpb24gKGRlZmF1bHRNZXNzYWdlLCBkZWZhdWx0QXJncywgZ2l2ZW5NZXNzYWdlLCBnaXZlbkFyZ3MpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdBc3NlcnRpb24gZmFpbGVkJztcbiAgICBpZiAoZ2l2ZW5NZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBnaXZlbk1lc3NhZ2U7XG4gICAgICB2YXIgYXJncyA9IGdpdmVuQXJncztcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRNZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlICs9ICc6ICcgKyBkZWZhdWx0TWVzc2FnZTtcbiAgICAgIGFyZ3MgPSBkZWZhdWx0QXJncztcbiAgICB9XG4gICAgLy8gVGhlICcnICsgd29ya3MgYXJvdW5kIGFuIE9wZXJhIDEwIGJ1ZyBpbiB0aGUgdW5pdCB0ZXN0cy4gV2l0aG91dCBpdCxcbiAgICAvLyBhIHN0YWNrIHRyYWNlIGlzIGFkZGVkIHRvIHZhciBtZXNzYWdlIGFib3ZlLiBXaXRoIHRoaXMsIGEgc3RhY2sgdHJhY2UgaXNcbiAgICAvLyBub3QgYWRkZWQgdW50aWwgdGhpcyBsaW5lIChpdCBjYXVzZXMgdGhlIGV4dHJhIGdhcmJhZ2UgdG8gYmUgYWRkZWQgYWZ0ZXJcbiAgICAvLyB0aGUgYXNzZXJ0aW9uIG1lc3NhZ2UgaW5zdGVhZCBvZiBpbiB0aGUgbWlkZGxlIG9mIGl0KS5cbiAgICB2YXIgZSA9IG5ldyBnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3IoJycgKyBtZXNzYWdlLCBhcmdzIHx8IFtdKTtcbiAgICBnb29nLmFzc2VydHMuZXJyb3JIYW5kbGVyXyhlKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0cyBhIGN1c3RvbSBlcnJvciBoYW5kbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSBiZWhhdmlvciBvZlxuICAgKiBhc3NlcnRpb24gZmFpbHVyZXMsIGZvciBleGFtcGxlIGJ5IHR1cm5pbmcgYWxsIGFzc2VydGlvbiBmYWlsdXJlcyBpbnRvIGxvZ1xuICAgKiBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbighZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKX0gZXJyb3JIYW5kbGVyXG4gICAqL1xuICBnb29nLmFzc2VydHMuc2V0RXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGVycm9ySGFuZGxlcikge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5lcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWUgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzXG4gICAqIHRydWUuXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7VH0gY29uZGl0aW9uIFRoZSBjb25kaXRpb24gdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJuIHtUfSBUaGUgdmFsdWUgb2YgdGhlIGNvbmRpdGlvbi5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSBjb25kaXRpb24gZXZhbHVhdGVzIHRvIGZhbHNlLlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWNvbmRpdGlvbikge1xuICAgICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oJycsIG51bGwsIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmRpdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogRmFpbHMgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZnVsIGluIGNhc2VcbiAgICogd2hlbiB3ZSB3YW50IHRvIGFkZCBhIGNoZWNrIGluIHRoZSB1bnJlYWNoYWJsZSBhcmVhIGxpa2Ugc3dpdGNoLWNhc2VcbiAgICogc3RhdGVtZW50OlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiAgc3dpdGNoKHR5cGUpIHtcbiAgICogICAgY2FzZSBGT086IGRvU29tZXRoaW5nKCk7IGJyZWFrO1xuICAgKiAgICBjYXNlIEJBUjogZG9Tb21ldGhpbmdFbHNlKCk7IGJyZWFrO1xuICAgKiAgICBkZWZhdWx0OiBnb29nLmFzc2VydC5mYWlsKCdVbnJlY29nbml6ZWQgdHlwZTogJyArIHR5cGUpO1xuICAgKiAgICAgIC8vIFdlIGhhdmUgb25seSAyIHR5cGVzIC0gXCJkZWZhdWx0OlwiIHNlY3Rpb24gaXMgdW5yZWFjaGFibGUgY29kZS5cbiAgICogIH1cbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IEZhaWx1cmUuXG4gICAqL1xuICBnb29nLmFzc2VydHMuZmFpbCA9IGZ1bmN0aW9uIChvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTKSB7XG4gICAgICBnb29nLmFzc2VydHMuZXJyb3JIYW5kbGVyXyhuZXcgZ29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yKCdGYWlsdXJlJyArIChvcHRfbWVzc2FnZSA/ICc6ICcgKyBvcHRfbWVzc2FnZSA6ICcnKSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIG51bWJlciB3aGVuIGFzc2VydHMgZW5hYmxlZC5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIuXG4gICAqL1xuICBnb29nLmFzc2VydHMuYXNzZXJ0TnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICFnb29nLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oJ0V4cGVjdGVkIG51bWJlciBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuICgvKiogQHR5cGUge251bWJlcn0gKi92YWx1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBzdHJpbmcgd2hlbiBhc3NlcnRzIGVuYWJsZWQuXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydFN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBzdHJpbmcgYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiAoLyoqIEB0eXBlIHtzdHJpbmd9ICovdmFsdWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24gaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7IUZ1bmN0aW9ufSBUaGUgdmFsdWUsIGd1YXJhbnRlZWQgdG8gYmUgYSBmdW5jdGlvbiB3aGVuIGFzc2VydHNcbiAgICogICAgIGVuYWJsZWQuXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGEgZnVuY3Rpb24uXG4gICAqL1xuICBnb29nLmFzc2VydHMuYXNzZXJ0RnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgIWdvb2cuaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBmdW5jdGlvbiBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuICgvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi92YWx1ZVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgdmFsdWUgaXMgYW4gT2JqZWN0IGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpcyB0cnVlLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gICAqIEByZXR1cm4geyFPYmplY3R9IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIG5vbi1udWxsIG9iamVjdC5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0LlxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydE9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlczogJXMuJywgW2dvb2cudHlwZU9mKHZhbHVlKSwgdmFsdWVdLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiAoLyoqIEB0eXBlIHshT2JqZWN0fSAqL3ZhbHVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhbiBBcnJheSBpZiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0X21lc3NhZ2UgRXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAqIEBwYXJhbSB7Li4uKn0gdmFyX2FyZ3MgVGhlIGl0ZW1zIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgZmFpbHVyZSBtZXNzYWdlLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8Pz59IFRoZSB2YWx1ZSwgZ3VhcmFudGVlZCB0byBiZSBhIG5vbi1udWxsIGFycmF5LlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhbiBhcnJheS5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnRBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZ29vZy5hc3NlcnRzLmRvQXNzZXJ0RmFpbHVyZV8oJ0V4cGVjdGVkIGFycmF5IGJ1dCBnb3QgJXM6ICVzLicsIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUFycmF5PD8+fSAqL3ZhbHVlXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVGhlIHZhbHVlLCBndWFyYW50ZWVkIHRvIGJlIGEgYm9vbGVhbiB3aGVuIGFzc2VydHMgYXJlXG4gICAqICAgICBlbmFibGVkLlxuICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIHZhbHVlIGlzIG5vdCBhIGJvb2xlYW4uXG4gICAqL1xuICBnb29nLmFzc2VydHMuYXNzZXJ0Qm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0X21lc3NhZ2UsIHZhcl9hcmdzKSB7XG4gICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhZ29vZy5pc0Jvb2xlYW4odmFsdWUpKSB7XG4gICAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgYm9vbGVhbiBidXQgZ290ICVzOiAlcy4nLCBbZ29vZy50eXBlT2YodmFsdWUpLCB2YWx1ZV0sIG9wdF9tZXNzYWdlLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuICgvKiogQHR5cGUge2Jvb2xlYW59ICovdmFsdWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGEgRE9NIEVsZW1lbnQgaWYgZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9tZXNzYWdlIEVycm9yIG1lc3NhZ2UgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKiBAcGFyYW0gey4uLip9IHZhcl9hcmdzIFRoZSBpdGVtcyB0byBzdWJzdGl0dXRlIGludG8gdGhlIGZhaWx1cmUgbWVzc2FnZS5cbiAgICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSB2YWx1ZSwgbGlrZWx5IHRvIGJlIGEgRE9NIEVsZW1lbnQgd2hlbiBhc3NlcnRzIGFyZVxuICAgKiAgICAgZW5hYmxlZC5cbiAgICogQHRocm93cyB7Z29vZy5hc3NlcnRzLkFzc2VydGlvbkVycm9yfSBXaGVuIHRoZSB2YWx1ZSBpcyBub3QgYW4gRWxlbWVudC5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnRFbGVtZW50ID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRfbWVzc2FnZSwgdmFyX2FyZ3MpIHtcbiAgICBpZiAoZ29vZy5hc3NlcnRzLkVOQUJMRV9BU1NFUlRTICYmICghZ29vZy5pc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUubm9kZVR5cGUgIT0gZ29vZy5kb20uTm9kZVR5cGUuRUxFTUVOVCkpIHtcbiAgICAgIGdvb2cuYXNzZXJ0cy5kb0Fzc2VydEZhaWx1cmVfKCdFeHBlY3RlZCBFbGVtZW50IGJ1dCBnb3QgJXM6ICVzLicsIFtnb29nLnR5cGVPZih2YWx1ZSksIHZhbHVlXSwgb3B0X21lc3NhZ2UsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICAgIH1cbiAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovdmFsdWVcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHRoZSB1c2VyLWRlZmluZWQgdHlwZSBpZlxuICAgKiBnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgaXMgdHJ1ZS5cbiAgICpcbiAgICogVGhlIGNvbXBpbGVyIG1heSB0aWdodGVuIHRoZSB0eXBlIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7P30gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogVCwgLi4uKX0gdHlwZSBBIHVzZXItZGVmaW5lZCBjb25zdHJ1Y3Rvci5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRfbWVzc2FnZSBFcnJvciBtZXNzYWdlIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBUaGUgaXRlbXMgdG8gc3Vic3RpdHV0ZSBpbnRvIHRoZSBmYWlsdXJlIG1lc3NhZ2UuXG4gICAqIEB0aHJvd3Mge2dvb2cuYXNzZXJ0cy5Bc3NlcnRpb25FcnJvcn0gV2hlbiB0aGUgdmFsdWUgaXMgbm90IGFuIGluc3RhbmNlIG9mXG4gICAqICAgICB0eXBlLlxuICAgKiBAcmV0dXJuIHtUfVxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgZ29vZy5hc3NlcnRzLmFzc2VydEluc3RhbmNlb2YgPSBmdW5jdGlvbiAodmFsdWUsIHR5cGUsIG9wdF9tZXNzYWdlLCB2YXJfYXJncykge1xuICAgIGlmIChnb29nLmFzc2VydHMuRU5BQkxFX0FTU0VSVFMgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIHR5cGUpKSB7XG4gICAgICBnb29nLmFzc2VydHMuZG9Bc3NlcnRGYWlsdXJlXygnRXhwZWN0ZWQgaW5zdGFuY2VvZiAlcyBidXQgZ290ICVzLicsIFtnb29nLmFzc2VydHMuZ2V0VHlwZV8odHlwZSksIGdvb2cuYXNzZXJ0cy5nZXRUeXBlXyh2YWx1ZSldLCBvcHRfbWVzc2FnZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIHRoYXQgbm8gZW51bWVyYWJsZSBrZXlzIGFyZSBwcmVzZW50IGluIE9iamVjdC5wcm90b3R5cGUuIFN1Y2gga2V5c1xuICAgKiB3b3VsZCBicmVhayBtb3N0IGNvZGUgdGhhdCB1c2Uge0Bjb2RlIGZvciAodmFyIC4uLiBpbiAuLi4pfSBsb29wcy5cbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5hc3NlcnRPYmplY3RQcm90b3R5cGVJc0ludGFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgZ29vZy5hc3NlcnRzLmZhaWwoa2V5ICsgJyBzaG91bGQgbm90IGJlIGVudW1lcmFibGUgaW4gT2JqZWN0LnByb3RvdHlwZS4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgYSB2YWx1ZS4gSWYgYSBjb25zdHJ1Y3RvciBpcyBwYXNzZWQsIGFuZCBhIHN1aXRhYmxlXG4gICAqIHN0cmluZyBjYW5ub3QgYmUgZm91bmQsICd1bmtub3duIHR5cGUgbmFtZScgd2lsbCBiZSByZXR1cm5lZC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBBIGNvbnN0cnVjdG9yLCBvYmplY3QsIG9yIHByaW1pdGl2ZS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgYmVzdCBkaXNwbGF5IG5hbWUgZm9yIHRoZSB2YWx1ZSwgb3IgJ3Vua25vd24gdHlwZSBuYW1lJy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdvb2cuYXNzZXJ0cy5nZXRUeXBlXyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gdmFsdWUuZGlzcGxheU5hbWUgfHwgdmFsdWUubmFtZSB8fCAndW5rbm93biB0eXBlIG5hbWUnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGZpbGVvdmVydmlldyBVdGlsaXR5IGZvciBmYXN0IHN0cmluZyBjb25jYXRlbmF0aW9uLlxuICAgKi9cblxuICAvKipcbiAgICogVXRpbGl0eSBjbGFzcyB0byBmYWNpbGl0YXRlIHN0cmluZyBjb25jYXRlbmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyo9fSBvcHRfYTEgT3B0aW9uYWwgZmlyc3QgaW5pdGlhbCBpdGVtIHRvIGFwcGVuZC5cbiAgICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBPdGhlciBpbml0aWFsIGl0ZW1zIHRvXG4gICAqICAgICBhcHBlbmQsIGUuZy4sIG5ldyBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIoJ2ZvbycsICdiYXInKS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIgPSBmdW5jdGlvbiAob3B0X2ExLCB2YXJfYXJncykge1xuICAgIGlmIChvcHRfYTEgIT0gbnVsbCkge1xuICAgICAgdGhpcy5hcHBlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGJ1ZmZlciBmb3IgdGhlIHN0cmluZyB0byBiZSBjb25jYXRlbmF0ZWQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmJ1ZmZlcl8gPSAnJztcblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudHMgb2YgdGhlIHN0cmluZyBidWZmZXIgb2JqZWN0LCByZXBsYWNpbmcgd2hhdCdzIGN1cnJlbnRseVxuICAgKiB0aGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBzIFN0cmluZyB0byBzZXQuXG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy5idWZmZXJfID0gJycgKyBzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIG9uZSBvciBtb3JlIGl0ZW1zIHRvIHRoZSBidWZmZXIuXG4gICAqXG4gICAqIENhbGxpbmcgdGhpcyB3aXRoIG51bGwsIHVuZGVmaW5lZCwgb3IgZW1wdHkgYXJndW1lbnRzIGlzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGExIFJlcXVpcmVkIGZpcnN0IHN0cmluZy5cbiAgICogQHBhcmFtIHsqPX0gb3B0X2EyIE9wdGlvbmFsIHNlY29uZCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7Li4uP30gdmFyX2FyZ3MgT3RoZXIgaXRlbXMgdG8gYXBwZW5kLFxuICAgKiAgICAgZS5nLiwgc2IuYXBwZW5kKCdmb28nLCAnYmFyJywgJ2JheicpLlxuICAgKiBAcmV0dXJuIHshZ29vZy5zdHJpbmcuU3RyaW5nQnVmZmVyfSBUaGlzIHNhbWUgU3RyaW5nQnVmZmVyIG9iamVjdC5cbiAgICogQHN1cHByZXNzIHtkdXBsaWNhdGV9XG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChhMSwgb3B0X2EyLCB2YXJfYXJncykge1xuICAgIC8vIFVzZSBhMSBkaXJlY3RseSB0byBhdm9pZCBhcmd1bWVudHMgaW5zdGFudGlhdGlvbiBmb3Igc2luZ2xlLWFyZyBjYXNlLlxuICAgIHRoaXMuYnVmZmVyXyArPSBTdHJpbmcoYTEpO1xuICAgIGlmIChvcHRfYTIgIT0gbnVsbCkge1xuICAgICAgLy8gc2Vjb25kIGFyZ3VtZW50IGlzIHVuZGVmaW5lZCAobnVsbCA9PSB1bmRlZmluZWQpXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmJ1ZmZlcl8gKz0gYXJndW1lbnRzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBpbnRlcm5hbCBidWZmZXIuXG4gICAqL1xuICBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYnVmZmVyXyA9ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGJ1ZmZlci5cbiAgICovXG4gIGdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlci5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlcl8ubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdvb2cuc3RyaW5nLlN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXztcbiAgfTtcblxuICAvLyBDb3B5cmlnaHQgMjAxMiBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gIC8vXG4gIC8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIC8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gIC8vXG4gIC8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gIC8vXG4gIC8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICAvLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAvLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuICAvKipcbiAgICogQGZpbGVvdmVydmlldyBTb3kgZGF0YSBwcmltaXRpdmVzLlxuICAgKlxuICAgKiBUaGUgZ29hbCBpcyB0byBlbmNvbXBhc3MgZGF0YSB0eXBlcyB1c2VkIGJ5IFNveSwgZXNwZWNpYWxseSB0byBtYXJrIGNvbnRlbnRcbiAgICogYXMga25vd24gdG8gYmUgXCJzYWZlXCIuXG4gICAqXG4gICAqIEBhdXRob3IgZ2JveWVyQGdvb2dsZS5jb20gKEdhcnJldHQgQm95ZXIpXG4gICAqL1xuXG4gIGdvb2cuc295ID0ge307XG4gIGdvb2cuc295LmRhdGEgPSB7fTtcblxuICAvKipcbiAgICogQSB0eXBlIG9mIHRleHR1YWwgY29udGVudC5cbiAgICpcbiAgICogVGhpcyBpcyBhbiBlbnVtIG9mIHR5cGUgT2JqZWN0IHNvIHRoYXQgdGhlc2UgdmFsdWVzIGFyZSB1bmZvcmdlYWJsZS5cbiAgICpcbiAgICogQGVudW0geyFPYmplY3R9XG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kID0ge1xuXG4gICAgLyoqXG4gICAgICogQSBzbmlwcGV0IG9mIEhUTUwgdGhhdCBkb2VzIG5vdCBzdGFydCBvciBlbmQgaW5zaWRlIGEgdGFnLCBjb21tZW50LCBlbnRpdHksXG4gICAgICogb3IgRE9DVFlQRTsgYW5kIHRoYXQgZG9lcyBub3QgY29udGFpbiBhbnkgZXhlY3V0YWJsZSBjb2RlXG4gICAgICogKEpTLCB7QGNvZGUgPG9iamVjdD59cywgZXRjLikgZnJvbSBhIGRpZmZlcmVudCB0cnVzdCBkb21haW4uXG4gICAgICovXG4gICAgSFRNTDogZ29vZy5ERUJVRyA/IHsgc2FuaXRpemVkQ29udGVudEtpbmRIdG1sOiB0cnVlIH0gOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGFibGUgSmF2YXNjcmlwdCBjb2RlIG9yIGV4cHJlc3Npb24sIHNhZmUgZm9yIGluc2VydGlvbiBpbiBhXG4gICAgICogc2NyaXB0LXRhZyBvciBldmVudCBoYW5kbGVyIGNvbnRleHQsIGtub3duIHRvIGJlIGZyZWUgb2YgYW55XG4gICAgICogYXR0YWNrZXItY29udHJvbGxlZCBzY3JpcHRzLiBUaGlzIGNhbiBlaXRoZXIgYmUgc2lkZS1lZmZlY3QtZnJlZVxuICAgICAqIEphdmFzY3JpcHQgKHN1Y2ggYXMgSlNPTikgb3IgSmF2YXNjcmlwdCB0aGF0J3MgZW50aXJlbHkgdW5kZXIgR29vZ2xlJ3NcbiAgICAgKiBjb250cm9sLlxuICAgICAqL1xuICAgIEpTOiBnb29nLkRFQlVHID8geyBzYW5pdGl6ZWRDb250ZW50SnNDaGFyczogdHJ1ZSB9IDoge30sXG5cbiAgICAvKiogQSBwcm9wZXJseSBlbmNvZGVkIHBvcnRpb24gb2YgYSBVUkkuICovXG4gICAgVVJJOiBnb29nLkRFQlVHID8geyBzYW5pdGl6ZWRDb250ZW50VXJpOiB0cnVlIH0gOiB7fSxcblxuICAgIC8qKiBBIHJlc291cmNlIFVSSSBub3QgdW5kZXIgYXR0YWNrZXIgY29udHJvbC4gKi9cbiAgICBUUlVTVEVEX1JFU09VUkNFX1VSSTogZ29vZy5ERUJVRyA/IHsgc2FuaXRpemVkQ29udGVudFRydXN0ZWRSZXNvdXJjZVVyaTogdHJ1ZSB9IDoge30sXG5cbiAgICAvKipcbiAgICAgKiBSZXBlYXRlZCBhdHRyaWJ1dGUgbmFtZXMgYW5kIHZhbHVlcy4gRm9yIGV4YW1wbGUsXG4gICAgICoge0Bjb2RlIGRpcj1cImx0clwiIGZvbz1cImJhclwiIG9uY2xpY2s9XCJ0cnVzdGVkRnVuY3Rpb24oKVwiIGNoZWNrZWR9LlxuICAgICAqL1xuICAgIEFUVFJJQlVURVM6IGdvb2cuREVCVUcgPyB7IHNhbml0aXplZENvbnRlbnRIdG1sQXR0cmlidXRlOiB0cnVlIH0gOiB7fSxcblxuICAgIC8vIFRPRE86IENvbnNpZGVyIHNlcGFyYXRpbmcgcnVsZXMsIGRlY2xhcmF0aW9ucywgYW5kIHZhbHVlcyBpbnRvXG4gICAgLy8gc2VwYXJhdGUgdHlwZXMsIGJ1dCBmb3Igc2ltcGxpY2l0eSwgd2UnbGwgdHJlYXQgZXhwbGljaXRseSBibGVzc2VkXG4gICAgLy8gU2FuaXRpemVkQ29udGVudCBhcyBhbGxvd2VkIGluIGFsbCBvZiB0aGVzZSBjb250ZXh0cy5cbiAgICAvKipcbiAgICAgKiBBIENTUzMgZGVjbGFyYXRpb24sIHByb3BlcnR5LCB2YWx1ZSBvciBncm91cCBvZiBzZW1pY29sb24gc2VwYXJhdGVkXG4gICAgICogZGVjbGFyYXRpb25zLlxuICAgICAqL1xuICAgIENTUzogZ29vZy5ERUJVRyA/IHsgc2FuaXRpemVkQ29udGVudENzczogdHJ1ZSB9IDoge30sXG5cbiAgICAvKipcbiAgICAgKiBVbnNhbml0aXplZCBwbGFpbi10ZXh0IGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGVmZmVjdGl2ZWx5IHRoZSBcIm51bGxcIiBlbnRyeSBvZiB0aGlzIGVudW0sIGFuZCBpcyBzb21ldGltZXMgdXNlZFxuICAgICAqIHRvIGV4cGxpY2l0bHkgbWFyayBjb250ZW50IHRoYXQgc2hvdWxkIG5ldmVyIGJlIHVzZWQgdW5lc2NhcGVkLiBTaW5jZSBhbnlcbiAgICAgKiBzdHJpbmcgaXMgc2FmZSB0byB1c2UgYXMgdGV4dCwgYmVpbmcgb2YgQ29udGVudEtpbmQuVEVYVCBtYWtlcyBub1xuICAgICAqIGd1YXJhbnRlZXMgYWJvdXQgaXRzIHNhZmV0eSBpbiBhbnkgb3RoZXIgY29udGV4dCBzdWNoIGFzIEhUTUwuXG4gICAgICovXG4gICAgVEVYVDogZ29vZy5ERUJVRyA/IHsgc2FuaXRpemVkQ29udGVudEtpbmRUZXh0OiB0cnVlIH0gOiB7fVxuICB9O1xuXG4gIC8qKlxuICAgKiBBIHN0cmluZy1saWtlIG9iamVjdCB0aGF0IGNhcnJpZXMgYSBjb250ZW50LXR5cGUgYW5kIGEgY29udGVudCBkaXJlY3Rpb24uXG4gICAqXG4gICAqIElNUE9SVEFOVCEgRG8gbm90IGNyZWF0ZSB0aGVzZSBkaXJlY3RseSwgbm9yIGluc3RhbnRpYXRlIHRoZSBzdWJjbGFzc2VzLlxuICAgKiBJbnN0ZWFkLCB1c2UgYSB0cnVzdGVkLCBjZW50cmFsbHkgcmV2aWV3ZWQgbGlicmFyeSBhcyBlbmRvcnNlZCBieSB5b3VyIHRlYW1cbiAgICogdG8gZ2VuZXJhdGUgdGhlc2Ugb2JqZWN0cy4gT3RoZXJ3aXNlLCB5b3UgcmlzayBhY2NpZGVudGFsbHkgY3JlYXRpbmdcbiAgICogU2FuaXRpemVkQ29udGVudCB0aGF0IGlzIGF0dGFja2VyLWNvbnRyb2xsZWQgYW5kIGdldHMgZXZhbHVhdGVkIHVuZXNjYXBlZCBpblxuICAgKiB0ZW1wbGF0ZXMuXG4gICAqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IEVycm9yKCdEbyBub3QgaW5zdGFudGlhdGUgZGlyZWN0bHknKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGNvbnRleHQgaW4gd2hpY2ggdGhpcyBjb250ZW50IGlzIHNhZmUgZnJvbSBYU1MgYXR0YWNrcy5cbiAgICogQHR5cGUge2dvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudEtpbmR9XG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQucHJvdG90eXBlLmNvbnRlbnRLaW5kO1xuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCdzIGRpcmVjdGlvbjsgbnVsbCBpZiB1bmtub3duIGFuZCB0aHVzIHRvIGJlIGVzdGltYXRlZCB3aGVuXG4gICAqIG5lY2Vzc2FyeS5cbiAgICogQHR5cGUgez9nb29nLmkxOG4uYmlkaS5EaXJ9XG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQucHJvdG90eXBlLmNvbnRlbnREaXIgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgYWxyZWFkeS1zYWZlIGNvbnRlbnQuXG4gICAqIEBwcm90ZWN0ZWQge3N0cmluZ31cbiAgICovXG4gIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudC5wcm90b3R5cGUuY29udGVudDtcblxuICAvKipcbiAgICogR2V0cyB0aGUgYWxyZWFkeS1zYWZlIGNvbnRlbnQuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudC5wcm90b3R5cGUuZ2V0Q29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9O1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBBbiBpbnRlcm1lZGlhcnkgYmFzZSBjbGFzcyB0byBhbGxvdyB0aGUgdHlwZSBzeXN0ZW0gdG8gc2VwY2lmeSB0ZXh0IHRlbXBsYXRlc1xuICAgKiB3aXRob3V0IHJlZmVyZW5jaW5nIHRoZSBzb3lkYXRhIHBhY2thZ2UuXG4gICAqIEBleHRlbmRzIHtnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVE9ETyhnYm95ZXIpOiBEZWxldGUgdGhpcyBjbGFzcyBhZnRlciBtb3Zpbmcgc295ZGF0YSB0byBDbG9zdXJlLlxuICAgIGdvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0LmJhc2UodGhpcywgJ2NvbnN0cnVjdG9yJyk7XG4gIH07XG5cbiAgZ29vZy5pbmhlcml0cyhnb29nLnNveS5kYXRhLlVuc2FuaXRpemVkVGV4dCwgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50KTtcblxuICAvKipcbiAgICogQ29udGVudCBvZiB0eXBlIHtAbGluayBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLkhUTUx9LlxuICAgKlxuICAgKiBUaGUgY29udGVudCBpcyBhIHN0cmluZyBvZiBIVE1MIHRoYXQgY2FuIHNhZmVseSBiZSBlbWJlZGRlZCBpbiBhIFBDREFUQVxuICAgKiBjb250ZXh0IGluIHlvdXIgYXBwLiAgSWYgeW91IHdvdWxkIGJlIHN1cnByaXNlZCB0byBmaW5kIHRoYXQgYW4gSFRNTFxuICAgKiBzYW5pdGl6ZXIgcHJvZHVjZWQge0Bjb2RlIHN9IChlLmcuICBpdCBydW5zIGNvZGUgb3IgZmV0Y2hlcyBiYWQgVVJMcykgYW5kXG4gICAqIHlvdSB3b3VsZG4ndCB3cml0ZSBhIHRlbXBsYXRlIHRoYXQgcHJvZHVjZXMge0Bjb2RlIHN9IG9uIHNlY3VyaXR5IG9yIHByaXZhY3lcbiAgICogZ3JvdW5kcywgdGhlbiBkb24ndCBwYXNzIHtAY29kZSBzfSBoZXJlLiBUaGUgZGVmYXVsdCBjb250ZW50IGRpcmVjdGlvbiBpc1xuICAgKiB1bmtub3duLCBpLmUuIHRvIGJlIGVzdGltYXRlZCB3aGVuIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudH1cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBnb29nLnNveS5kYXRhLlNhbml0aXplZEh0bWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sLmJhc2UodGhpcywgJ2NvbnN0cnVjdG9yJyk7XG4gIH07XG4gIGdvb2cuaW5oZXJpdHMoZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sLCBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQpO1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sLnByb3RvdHlwZS5jb250ZW50S2luZCA9IGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQuSFRNTDtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB2YWx1ZSBjb3VsZCBiZSB1c2VkIGFzIHRoZSBTb3kgdHlwZSB7aHRtbH0uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbC5pc0NvbXBhdGlibGVXaXRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGdvb2cuaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sIHx8IHZhbHVlIGluc3RhbmNlb2YgZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnb29nLmh0bWwuU2FmZUh0bWw7XG4gIH07XG5cbiAgLypcbiAgICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy5cbiAgICpcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICpcbiAgICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAZmlsZW92ZXJ2aWV3XG4gICAqIFV0aWxpdHkgZnVuY3Rpb25zIGFuZCBjbGFzc2VzIGZvciBTb3kuXG4gICAqXG4gICAqIDxwPlxuICAgKiBUaGUgdG9wIHBvcnRpb24gb2YgdGhpcyBmaWxlIGNvbnRhaW5zIHV0aWxpdGllcyBmb3IgU295IHVzZXJzOjx1bD5cbiAgICogICA8bGk+IHNveS5TdHJpbmdCdWlsZGVyOiBDb21wYXRpYmxlIHdpdGggdGhlICdzdHJpbmdidWlsZGVyJyBjb2RlIHN0eWxlLlxuICAgKiA8L3VsPlxuICAgKlxuICAgKiA8cD5cbiAgICogVGhlIGJvdHRvbSBwb3J0aW9uIG9mIHRoaXMgZmlsZSBjb250YWlucyB1dGlsaXRpZXMgdGhhdCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAgICogYnkgU295LWdlbmVyYXRlZCBKUyBjb2RlLiBQbGVhc2UgZG8gbm90IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgZnJvbVxuICAgKiB5b3VyIGhhbmQtd3JpdGVuIGNvZGUuIFRoZWlyIG5hbWVzIGFsbCBzdGFydCB3aXRoICckJCcuXG4gICAqXG4gICAqL1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFN0cmluZ0J1aWxkZXIgKGNvbXBhdGlibGUgd2l0aCB0aGUgJ3N0cmluZ2J1aWxkZXInIGNvZGUgc3R5bGUpLlxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNveSA9IHt9O1xuICAgIHNveS5hc3NlcnRzID0ge307XG4gICAgc295LmVzYyA9IHt9O1xuICAgIHZhciBzb3lkYXRhID0ge307XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGNsYXNzIHRvIGZhY2lsaXRhdGUgbXVjaCBmYXN0ZXIgc3RyaW5nIGNvbmNhdGVuYXRpb24gaW4gSUUsXG4gICAgICogdXNpbmcgQXJyYXkuam9pbigpIHJhdGhlciB0aGFuIHRoZSAnKycgb3BlcmF0b3IuIEZvciBvdGhlciBicm93c2Vyc1xuICAgICAqIHdlIHNpbXBseSB1c2UgdGhlICcrJyBvcGVyYXRvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YXJfYXJncyBJbml0aWFsIGl0ZW1zIHRvIGFwcGVuZCxcbiAgICAgKiAgICAgZS5nLiwgbmV3IHNveS5TdHJpbmdCdWlsZGVyKCdmb28nLCAnYmFyJykuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgc295LlN0cmluZ0J1aWxkZXIgPSBnb29nLnN0cmluZy5TdHJpbmdCdWZmZXI7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIHNveWRhdGE6IERlZmluZXMgdHlwZWQgc3RyaW5ncywgZS5nLiBhbiBIVE1MIHN0cmluZyB7QGNvZGUgXCJhPGI+Y1wifSBpc1xuICAgIC8vIHNlbWFudGljYWxseSBkaXN0aW5jdCBmcm9tIHRoZSBwbGFpbiB0ZXh0IHN0cmluZyB7QGNvZGUgXCJhPGI+Y1wifSBhbmQgc21hcnRcbiAgICAvLyB0ZW1wbGF0ZXMgY2FuIHRha2UgdGhhdCBkaXN0aW5jdGlvbiBpbnRvIGFjY291bnQuXG5cbiAgICAvKipcbiAgICAgKiBBIHR5cGUgb2YgdGV4dHVhbCBjb250ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBlbnVtIG9mIHR5cGUgT2JqZWN0IHNvIHRoYXQgdGhlc2UgdmFsdWVzIGFyZSB1bmZvcmdlYWJsZS5cbiAgICAgKlxuICAgICAqIEBlbnVtIHshT2JqZWN0fVxuICAgICAqL1xuICAgIHNveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQgPSBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSBnaXZlbiB2YWx1ZSBpcyBvZiBhIGdpdmVuIGNvbnRlbnQga2luZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGV4YW1pbmVkLlxuICAgICAqIEBwYXJhbSB7c295ZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZH0gY29udGVudEtpbmQgVGhlIGRlc2lyZWQgY29udGVudFxuICAgICAqICAgICBraW5kLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIG9mIHRoZSBnaXZlbiBraW5kLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc295ZGF0YS5pc0NvbnRlbnRLaW5kID0gZnVuY3Rpb24gKHZhbHVlLCBjb250ZW50S2luZCkge1xuICAgICAgLy8gVE9ETyh1c2VyKTogVGhpcyBmdW5jdGlvbiBzaG91bGQgcmVhbGx5IGluY2x1ZGUgdGhlIGFzc2VydCBvblxuICAgICAgLy8gdmFsdWUuY29uc3RydWN0b3IgdGhhdCBpcyBjdXJyZW50bHkgc3ByaW5rbGVkIGF0IG1vc3Qgb2YgdGhlIGNhbGwgc2l0ZXMuXG4gICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGF0IHdvdWxkIHJlcXVpcmUgYSAoZGVidWctbW9kZS1vbmx5KSBzd2l0Y2ggc3RhdGVtZW50LlxuICAgICAgLy8gVE9ETyh1c2VyKTogUGVyaGFwcyB3ZSBzaG91bGQgZ2V0IHJpZCBvZiB0aGUgY29udGVudEtpbmQgcHJvcGVydHlcbiAgICAgIC8vIGFsdG9nZXRoZXIgYW5kIG9ubHkgYXQgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUuY29udGVudEtpbmQgPT09IGNvbnRlbnRLaW5kO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IG9mIHR5cGUge0BsaW5rIGdvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQuSFRNTH0uXG4gICAgICpcbiAgICAgKiBUaGUgY29udGVudCBpcyBhIHN0cmluZyBvZiBIVE1MIHRoYXQgY2FuIHNhZmVseSBiZSBlbWJlZGRlZCBpbiBhIFBDREFUQVxuICAgICAqIGNvbnRleHQgaW4geW91ciBhcHAuICBJZiB5b3Ugd291bGQgYmUgc3VycHJpc2VkIHRvIGZpbmQgdGhhdCBhbiBIVE1MXG4gICAgICogc2FuaXRpemVyIHByb2R1Y2VkIHtAY29kZSBzfSAoZS5nLiAgaXQgcnVucyBjb2RlIG9yIGZldGNoZXMgYmFkIFVSTHMpIGFuZFxuICAgICAqIHlvdSB3b3VsZG4ndCB3cml0ZSBhIHRlbXBsYXRlIHRoYXQgcHJvZHVjZXMge0Bjb2RlIHN9IG9uIHNlY3VyaXR5IG9yIHByaXZhY3lcbiAgICAgKiBncm91bmRzLCB0aGVuIGRvbid0IHBhc3Mge0Bjb2RlIHN9IGhlcmUuIFRoZSBkZWZhdWx0IGNvbnRlbnQgZGlyZWN0aW9uIGlzXG4gICAgICogdW5rbm93biwgaS5lLiB0byBiZSBlc3RpbWF0ZWQgd2hlbiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7Z29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sfVxuICAgICAqL1xuICAgIHNveWRhdGEuU2FuaXRpemVkSHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHNveWRhdGEuU2FuaXRpemVkSHRtbC5iYXNlKHRoaXMsICdjb25zdHJ1Y3RvcicpOyAvLyBUaHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgIH07XG4gICAgZ29vZy5pbmhlcml0cyhzb3lkYXRhLlNhbml0aXplZEh0bWwsIGdvb2cuc295LmRhdGEuU2FuaXRpemVkSHRtbCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU2FuaXRpemVkSHRtbCBvYmplY3QgZm9yIGEgcGFydGljdWxhciB2YWx1ZS4gVGhlIGNvbnRlbnQgZGlyZWN0aW9uXG4gICAgICogaXMgcHJlc2VydmVkLlxuICAgICAqXG4gICAgICogVGhpcyBIVE1MLWVzY2FwZXMgdGhlIHZhbHVlIHVubGVzcyBpdCBpcyBhbHJlYWR5IFNhbml0aXplZEh0bWwgb3IgU2FmZUh0bWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LiBJZiBpdCBpcyBhbHJlYWR5IGEgU2FuaXRpemVkSHRtbFxuICAgICAqICAgICBvYmplY3QsIGl0IGlzIGxlZnQgYWxvbmUuXG4gICAgICogQHJldHVybiB7IXNveWRhdGEuU2FuaXRpemVkSHRtbH0gQSBTYW5pdGl6ZWRIdG1sIG9iamVjdCBkZXJpdmVkIGZyb20gdGhlXG4gICAgICogICAgIHN0cmluZ2lmaWVkIHZhbHVlLiBJdCBpcyBlc2NhcGVkIHVubGVzcyB0aGUgaW5wdXQgaXMgU2FuaXRpemVkSHRtbCBvclxuICAgICAqICAgICBTYWZlSHRtbC5cbiAgICAgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZEh0bWwuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgLy8gVGhlIGNoZWNrIGlzIHNveWRhdGEuaXNDb250ZW50S2luZF8oKSBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLmNvbnRlbnRLaW5kID09PSBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnRLaW5kLkhUTUwpIHtcbiAgICAgICAgZ29vZy5hc3NlcnRzLmFzc2VydCh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBzb3lkYXRhLlNhbml0aXplZEh0bWwpO1xuICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IXNveWRhdGEuU2FuaXRpemVkSHRtbH0gKi92YWx1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgZ29vZy5odG1sLlNhZmVIdG1sKSB7XG4gICAgICAgIHJldHVybiBzb3lkYXRhLlZFUllfVU5TQUZFLm9yZGFpblNhbml0aXplZEh0bWwoZ29vZy5odG1sLlNhZmVIdG1sLnVud3JhcCh2YWx1ZSksIHZhbHVlLmdldERpcmVjdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3lkYXRhLlZFUllfVU5TQUZFLm9yZGFpblNhbml0aXplZEh0bWwoc295LmVzYy4kJGVzY2FwZUh0bWxIZWxwZXIoU3RyaW5nKHZhbHVlKSksIHNveWRhdGEuZ2V0Q29udGVudERpcih2YWx1ZSkpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGNvdWxkIGJlIHVzZWQgYXMgdGhlIFNveSB0eXBlIHtodG1sfS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzb3lkYXRhLlNhbml0aXplZEh0bWwuaXNDb21wYXRpYmxlV2l0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGdvb2cuaXNTdHJpbmcodmFsdWUpIHx8IHZhbHVlIGluc3RhbmNlb2YgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRIdG1sIHx8IHZhbHVlIGluc3RhbmNlb2YgZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnb29nLmh0bWwuU2FmZUh0bWw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnRlbnQgb2YgdHlwZSB7QGxpbmsgc295ZGF0YS5TYW5pdGl6ZWRDb250ZW50S2luZC5VUkl9LlxuICAgICAqXG4gICAgICogVGhlIGNvbnRlbnQgaXMgYSBVUkkgY2h1bmsgdGhhdCB0aGUgY2FsbGVyIGtub3dzIGlzIHNhZmUgdG8gZW1pdCBpbiBhXG4gICAgICogdGVtcGxhdGUuIFRoZSBjb250ZW50IGRpcmVjdGlvbiBpcyBMVFIuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7Z29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fVxuICAgICAqL1xuICAgIHNveWRhdGEuU2FuaXRpemVkVXJpID0gZnVuY3Rpb24gKCkge1xuICAgICAgZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50LmNhbGwodGhpcyk7IC8vIFRocm93cyBhbiBleGNlcHRpb24uXG4gICAgfTtcbiAgICBnb29nLmluaGVyaXRzKHNveWRhdGEuU2FuaXRpemVkVXJpLCBnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnQpO1xuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIHNveWRhdGEuU2FuaXRpemVkVXJpLnByb3RvdHlwZS5jb250ZW50S2luZCA9IHNveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQuVVJJO1xuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIHNveWRhdGEuU2FuaXRpemVkVXJpLnByb3RvdHlwZS5jb250ZW50RGlyID0gZ29vZy5pMThuLmJpZGkuRGlyLkxUUjtcblxuICAgIC8qKlxuICAgICAqIFVuc2FuaXRpemVkIHBsYWluIHRleHQgc3RyaW5nLlxuICAgICAqXG4gICAgICogV2hpbGUgYWxsIHN0cmluZ3MgYXJlIGVmZmVjdGl2ZWx5IHNhZmUgdG8gdXNlIGFzIGEgcGxhaW4gdGV4dCwgdGhlcmUgYXJlIG5vXG4gICAgICogZ3VhcmFudGVlcyBhYm91dCBzYWZldHkgaW4gYW55IG90aGVyIGNvbnRleHQgc3VjaCBhcyBIVE1MLiBUaGlzIGlzXG4gICAgICogc29tZXRpbWVzIHVzZWQgdG8gbWFyayB0aGF0IHNob3VsZCBuZXZlciBiZSB1c2VkIHVuZXNjYXBlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gY29udGVudCBQbGFpbiB0ZXh0IHdpdGggbm8gZ3VhcmFudGVlcy5cbiAgICAgKiBAcGFyYW0gez9nb29nLmkxOG4uYmlkaS5EaXI9fSBvcHRfY29udGVudERpciBUaGUgY29udGVudCBkaXJlY3Rpb247IG51bGwgaWZcbiAgICAgKiAgICAgdW5rbm93biBhbmQgdGh1cyB0byBiZSBlc3RpbWF0ZWQgd2hlbiBuZWNlc3NhcnkuIERlZmF1bHQ6IG51bGwuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuVW5zYW5pdGl6ZWRUZXh0fVxuICAgICAqL1xuICAgIHNveWRhdGEuVW5zYW5pdGl6ZWRUZXh0ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdF9jb250ZW50RGlyKSB7XG4gICAgICAvKiogQG92ZXJyaWRlICovXG4gICAgICB0aGlzLmNvbnRlbnQgPSBTdHJpbmcoY29udGVudCk7XG4gICAgICB0aGlzLmNvbnRlbnREaXIgPSBvcHRfY29udGVudERpciAhPSBudWxsID8gb3B0X2NvbnRlbnREaXIgOiBudWxsO1xuICAgIH07XG4gICAgZ29vZy5pbmhlcml0cyhzb3lkYXRhLlVuc2FuaXRpemVkVGV4dCwgZ29vZy5zb3kuZGF0YS5VbnNhbml0aXplZFRleHQpO1xuXG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIHNveWRhdGEuVW5zYW5pdGl6ZWRUZXh0LnByb3RvdHlwZS5jb250ZW50S2luZCA9IHNveWRhdGEuU2FuaXRpemVkQ29udGVudEtpbmQuVEVYVDtcblxuICAgIC8qKlxuICAgICAqIEVtcHR5IHN0cmluZywgdXNlZCBhcyBhIHR5cGUgaW4gU295IHRlbXBsYXRlcy5cbiAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc295ZGF0YS4kJEVNUFRZX1NUUklOR18gPSB7XG4gICAgICBWQUxVRTogJydcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZm9yIFNhbml0aXplZENvbnRlbnQgdHlwZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgaGFjayBzbyB0aGF0IHRoZSBzb3lkYXRhLlZFUllfVU5TQUZFLm9yZGFpblNhbml0aXplZCogY2FuXG4gICAgICogaW5zdGFudGlhdGUgU2FuaXRpemVkKiBjbGFzc2VzLCB3aXRob3V0IG1ha2luZyB0aGUgU2FuaXRpemVkKiBjb25zdHJ1Y3RvcnNcbiAgICAgKiBwdWJsaWNseSB1c2FibGUuIFJlcXVpcmluZyBhbGwgY29uc3RydWN0aW9uIHRvIHVzZSB0aGUgVkVSWV9VTlNBRkUgbmFtZXNcbiAgICAgKiBoZWxwcyBjYWxsZXJzIGFuZCB0aGVpciByZXZpZXdlcnMgZWFzaWx5IHRlbGwgdGhhdCBjcmVhdGluZyBTYW5pdGl6ZWRDb250ZW50XG4gICAgICogaXMgbm90IGFsd2F5cyBzYWZlIGFuZCBjYWxscyBmb3IgY2FyZWZ1bCByZXZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzogVCl9IGN0b3IgQSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKiwgP2dvb2cuaTE4bi5iaWRpLkRpcj0pOiBUfSBBIGZhY3RvcnkgdGhhdCB0YWtlc1xuICAgICAqICAgICBjb250ZW50IGFuZCBhbiBvcHRpb25hbCBjb250ZW50IGRpcmVjdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBpbnN0YW5jZS4gSWZcbiAgICAgKiAgICAgdGhlIGNvbnRlbnQgZGlyZWN0aW9uIGlzIHVuZGVmaW5lZCwgY3Rvci5wcm90b3R5cGUuY29udGVudERpciBpcyB1c2VkLlxuICAgICAqIEB0ZW1wbGF0ZSBUXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzb3lkYXRhLiQkbWFrZVNhbml0aXplZENvbnRlbnRGYWN0b3J5XyA9IGZ1bmN0aW9uIChjdG9yKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAqIEBleHRlbmRzIHtnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluc3RhbnRpYWJsZUN0b3IoY29udGVudCkge1xuICAgICAgICAvKiogQG92ZXJyaWRlICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgICBJbnN0YW50aWFibGVDdG9yLnByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgY3Rvci10eXBlIFNhbml0aXplZENvbnRlbnQgaW5zdGFuY2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHsqfSBjb250ZW50IFRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgaW5zdGFuY2UuXG4gICAgICAgKiBAcGFyYW0gez9nb29nLmkxOG4uYmlkaS5EaXI9fSBvcHRfY29udGVudERpciBUaGUgY29udGVudCBkaXJlY3Rpb24uIElmXG4gICAgICAgKiAgICAgdW5kZWZpbmVkLCBjdG9yLnByb3RvdHlwZS5jb250ZW50RGlyIGlzIHVzZWQuXG4gICAgICAgKiBAcmV0dXJuIHshZ29vZy5zb3kuZGF0YS5TYW5pdGl6ZWRDb250ZW50fSBUaGUgbmV3IGluc3RhbmNlLiBJdCBpcyBhY3R1YWxseVxuICAgICAgICogICAgIG9mIHR5cGUgVCBhYm92ZSAoY3RvcidzIHR5cGUsIGEgZGVzY2VuZGFudCBvZiBTYW5pdGl6ZWRDb250ZW50KSwgYnV0XG4gICAgICAgKiAgICAgdGhlcmUgaXMgbm8gd2F5IHRvIGV4cHJlc3MgdGhhdCBoZXJlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBzYW5pdGl6ZWRDb250ZW50RmFjdG9yeShjb250ZW50LCBvcHRfY29udGVudERpcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEluc3RhbnRpYWJsZUN0b3IoU3RyaW5nKGNvbnRlbnQpKTtcbiAgICAgICAgaWYgKG9wdF9jb250ZW50RGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQuY29udGVudERpciA9IG9wdF9jb250ZW50RGlyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2FuaXRpemVkQ29udGVudEZhY3Rvcnk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZvciBTYW5pdGl6ZWRDb250ZW50IHR5cGVzIHRoYXQgc2hvdWxkIGFsd2F5cyBoYXZlIHRoZWlyXG4gICAgICogZGVmYXVsdCBkaXJlY3Rpb25hbGl0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBoYWNrIHNvIHRoYXQgdGhlIHNveWRhdGEuVkVSWV9VTlNBRkUub3JkYWluU2FuaXRpemVkKiBjYW5cbiAgICAgKiBpbnN0YW50aWF0ZSBTYW5pdGl6ZWQqIGNsYXNzZXMsIHdpdGhvdXQgbWFraW5nIHRoZSBTYW5pdGl6ZWQqIGNvbnN0cnVjdG9yc1xuICAgICAqIHB1YmxpY2x5IHVzYWJsZS4gUmVxdWlyaW5nIGFsbCBjb25zdHJ1Y3Rpb24gdG8gdXNlIHRoZSBWRVJZX1VOU0FGRSBuYW1lc1xuICAgICAqIGhlbHBzIGNhbGxlcnMgYW5kIHRoZWlyIHJldmlld2VycyBlYXNpbHkgdGVsbCB0aGF0IGNyZWF0aW5nIFNhbml0aXplZENvbnRlbnRcbiAgICAgKiBpcyBub3QgYWx3YXlzIHNhZmUgYW5kIGNhbGxzIGZvciBjYXJlZnVsIHJldmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24obmV3OiBULCBzdHJpbmcpfSBjdG9yIEEgY29uc3RydWN0b3IuXG4gICAgICogQHJldHVybiB7IWZ1bmN0aW9uKCopOiBUfSBBIGZhY3RvcnkgdGhhdCB0YWtlcyBjb250ZW50IGFuZCByZXR1cm5zIGEgbmV3XG4gICAgICogICAgIGluc3RhbmNlICh3aXRoIGRlZmF1bHQgZGlyZWN0aW9uYWxpdHksIGkuZS4gY3Rvci5wcm90b3R5cGUuY29udGVudERpcikuXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveWRhdGEuJCRtYWtlU2FuaXRpemVkQ29udGVudEZhY3RvcnlXaXRoRGVmYXVsdERpck9ubHlfID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICogQGV4dGVuZHMge2dvb2cuc295LmRhdGEuU2FuaXRpemVkQ29udGVudH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5zdGFudGlhYmxlQ3Rvcihjb250ZW50KSB7XG4gICAgICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgIH1cbiAgICAgIEluc3RhbnRpYWJsZUN0b3IucHJvdG90eXBlID0gY3Rvci5wcm90b3R5cGU7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBjdG9yLXR5cGUgU2FuaXRpemVkQ29udGVudCBpbnN0YW5jZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0geyp9IGNvbnRlbnQgVGhlIGNvbnRlbnQgdG8gcHV0IGluIHRoZSBpbnN0YW5jZS5cbiAgICAgICAqIEByZXR1cm4geyFnb29nLnNveS5kYXRhLlNhbml0aXplZENvbnRlbnR9IFRoZSBuZXcgaW5zdGFuY2UuIEl0IGlzIGFjdHVhbGx5XG4gICAgICAgKiAgICAgb2YgdHlwZSBUIGFib3ZlIChjdG9yJ3MgdHlwZSwgYSBkZXNjZW5kYW50IG9mIFNhbml0aXplZENvbnRlbnQpLCBidXRcbiAgICAgICAqICAgICB0aGVyZSBpcyBubyB3YXkgdG8gZXhwcmVzcyB0aGF0IGhlcmUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHNhbml0aXplZENvbnRlbnRGYWN0b3J5KGNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnN0YW50aWFibGVDdG9yKFN0cmluZyhjb250ZW50KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2FuaXRpemVkQ29udGVudEZhY3Rvcnk7XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gU2FuaXRpemVkIGNvbnRlbnQgb3JkYWluZXJzLiBQbGVhc2UgdXNlIHRoZXNlIHdpdGggZXh0cmVtZSBjYXV0aW9uICh3aXRoIHRoZVxuICAgIC8vIGV4Y2VwdGlvbiBvZiBtYXJrVW5zYW5pdGl6ZWRUZXh0KS4gQSBnb29kIHJlY29tbWVuZGF0aW9uIGlzIHRvIGxpbWl0IHVzYWdlXG4gICAgLy8gb2YgdGhlc2UgdG8ganVzdCBhIGhhbmRmdWwgb2YgZmlsZXMgaW4geW91ciBzb3VyY2UgdHJlZSB3aGVyZSB1c2FnZXMgY2FuIGJlXG4gICAgLy8gY2FyZWZ1bGx5IGF1ZGl0ZWQuXG5cblxuICAgIC8qKlxuICAgICAqIFByb3RlY3RzIGEgc3RyaW5nIGZyb20gYmVpbmcgdXNlZCBpbiBhbiBub0F1dG9lc2NhcGVkIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29udGVudCB3aGVyZSB0aGVyZSBpcyBzaWduaWZpY2FudCByaXNrIG9mIGFjY2lkZW50YWxcbiAgICAgKiB1bmVzY2FwZWQgdXNhZ2UgaW4gYSBTb3kgdGVtcGxhdGUuIEEgZ3JlYXQgY2FzZSBpcyBmb3IgdXNlci1jb250cm9sbGVkXG4gICAgICogZGF0YSB0aGF0IGhhcyBoaXN0b3JpY2FsbHkgYmVlbiBhIHNvdXJjZSBvZiB2dWxlcm5hYmlsaXRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGNvbnRlbnQgVGV4dCB0byBwcm90ZWN0LlxuICAgICAqIEBwYXJhbSB7P2dvb2cuaTE4bi5iaWRpLkRpcj19IG9wdF9jb250ZW50RGlyIFRoZSBjb250ZW50IGRpcmVjdGlvbjsgbnVsbCBpZlxuICAgICAqICAgICB1bmtub3duIGFuZCB0aHVzIHRvIGJlIGVzdGltYXRlZCB3aGVuIG5lY2Vzc2FyeS4gRGVmYXVsdDogbnVsbC5cbiAgICAgKiBAcmV0dXJuIHshc295ZGF0YS5VbnNhbml0aXplZFRleHR9IEEgd3JhcHBlciB0aGF0IGlzIHJlamVjdGVkIGJ5IHRoZVxuICAgICAqICAgICBTb3kgbm9BdXRvZXNjYXBlIHByaW50IGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBzb3lkYXRhLm1hcmtVbnNhbml0aXplZFRleHQgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0X2NvbnRlbnREaXIpIHtcbiAgICAgIHJldHVybiBuZXcgc295ZGF0YS5VbnNhbml0aXplZFRleHQoY29udGVudCwgb3B0X2NvbnRlbnREaXIpO1xuICAgIH07XG5cbiAgICBzb3lkYXRhLlZFUllfVU5TQUZFID0ge307XG5cbiAgICAvKipcbiAgICAqIFRha2VzIGEgbGVhcCBvZiBmYWl0aCB0aGF0IHRoZSBwcm92aWRlZCBjb250ZW50IGlzIFwic2FmZVwiIHRvIHVzZSBhcyBhIFVSSVxuICAgICogaW4gYSBTb3kgdGVtcGxhdGUuXG4gICAgKlxuICAgICogVGhpcyBjcmVhdGVzIGEgU295IFNhbml0aXplZENvbnRlbnQgb2JqZWN0IHdoaWNoIGluZGljYXRlcyB0byBTb3kgdGhlcmUgaXNcbiAgICAqIG5vIG5lZWQgdG8gZXNjYXBlIGl0IHdoZW4gcHJpbnRlZCBhcyBhIFVSSSAoZS5nLiBpbiBhbiBocmVmIG9yIHNyY1xuICAgICogYXR0cmlidXRlKSwgc3VjaCBhcyBpZiBpdCdzIGFscmVhZHkgYmVlbiBlbmNvZGVkIG9yICBpZiBpdCdzIGEgSmF2YXNjcmlwdDpcbiAgICAqIFVSSS5cbiAgICAqXG4gICAgKiBAcGFyYW0geyp9IGNvbnRlbnQgQSBjaHVuayBvZiBVUkkgdGhhdCB0aGUgY2FsbGVyIGtub3dzIGlzIHNhZmUgdG9cbiAgICAqICAgICBlbWl0IGluIGEgdGVtcGxhdGUuXG4gICAgKiBAcmV0dXJuIHshc295ZGF0YS5TYW5pdGl6ZWRVcml9IFNhbml0aXplZCBjb250ZW50IHdyYXBwZXIgdGhhdCBpbmRpY2F0ZXMgdG9cbiAgICAqICAgICBTb3kgbm90IHRvIGVzY2FwZSBvciBmaWx0ZXIgd2hlbiBwcmludGVkIGluIFVSSSBjb250ZXh0LlxuICAgICovXG4gICAgc295ZGF0YS5WRVJZX1VOU0FGRS5vcmRhaW5TYW5pdGl6ZWRVcmkgPSBzb3lkYXRhLiQkbWFrZVNhbml0aXplZENvbnRlbnRGYWN0b3J5V2l0aERlZmF1bHREaXJPbmx5Xyhzb3lkYXRhLlNhbml0aXplZFVyaSk7XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIEJlbG93IGFyZSBwcml2YXRlIHV0aWxpdGllcyB0byBiZSB1c2VkIGJ5IFNveS1nZW5lcmF0ZWQgY29kZSBvbmx5LlxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGFuIGF1Z21lbnRlZCBtYXAuIFRoZSByZXR1cm5lZCBtYXAgd2lsbCBjb250YWluIG1hcHBpbmdzIGZyb20gYm90aFxuICAgICAqIHRoZSBiYXNlIG1hcCBhbmQgdGhlIGFkZGl0aW9uYWwgbWFwLiBJZiB0aGUgc2FtZSBrZXkgYXBwZWFycyBpbiBib3RoLCB0aGVuXG4gICAgICogdGhlIHZhbHVlIGZyb20gdGhlIGFkZGl0aW9uYWwgbWFwIHdpbGwgYmUgdmlzaWJsZSwgd2hpbGUgdGhlIHZhbHVlIGZyb20gdGhlXG4gICAgICogYmFzZSBtYXAgd2lsbCBiZSBoaWRkZW4uIFRoZSBiYXNlIG1hcCB3aWxsIGJlIHVzZWQsIGJ1dCBub3QgbW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGJhc2VNYXAgVGhlIG9yaWdpbmFsIG1hcCB0byBhdWdtZW50LlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gYWRkaXRpb25hbE1hcCBBIG1hcCBjb250YWluaW5nIHRoZSBhZGRpdGlvbmFsIG1hcHBpbmdzLlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9IEFuIGF1Z21lbnRlZCBtYXAgY29udGFpbmluZyBib3RoIHRoZSBvcmlnaW5hbCBhbmRcbiAgICAgKiAgICAgYWRkaXRpb25hbCBtYXBwaW5ncy5cbiAgICAgKi9cbiAgICBzb3kuJCRhdWdtZW50TWFwID0gZnVuY3Rpb24gKGJhc2VNYXAsIGFkZGl0aW9uYWxNYXApIHtcbiAgICAgIHJldHVybiBzb3kuJCRhc3NpZ25EZWZhdWx0cyhzb3kuJCRhc3NpZ25EZWZhdWx0cyh7fSwgYWRkaXRpb25hbE1hcCksIGJhc2VNYXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgZXh0cmEgcHJvcGVydGllcyBpbnRvIGFuIG9iamVjdCBpZiB0aGV5IGRvIG5vdCBhbHJlYWR5IGV4aXN0LiBUaGVcbiAgICAgKiBkZXN0aW5hdGlvbiBvYmplY3QgaXMgbXV0YXRlZCBpbiB0aGUgcHJvY2Vzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2JqIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gZGVmYXVsdHMgQW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzIHRvIGFwcGx5LlxuICAgICAqIEByZXR1cm4geyFPYmplY3R9IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGNvbnZlbmllbmNlLlxuICAgICAqL1xuICAgIHNveS4kJGFzc2lnbkRlZmF1bHRzID0gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkZWZhdWx0cykge1xuICAgICAgICBpZiAoIShrZXkgaW4gb2JqKSkge1xuICAgICAgICAgIG9ialtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhhdCB0aGUgZ2l2ZW4gbWFwIGtleSBpcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0geyp9IGtleSBLZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgZ2l2ZW4ga2V5LlxuICAgICAqL1xuICAgIHNveS4kJGNoZWNrTWFwS2V5ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgLy8gVE9ETzogU3VwcG9ydCBtYXAgbGl0ZXJhbCB3aXRoIG5vbnN0cmluZyBrZXkuXG4gICAgICBpZiAodHlwZW9mIGtleSAhPSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBFcnJvcignTWFwIGxpdGVyYWxcXCdzIGtleSBleHByZXNzaW9uIG11c3QgZXZhbHVhdGUgdG8gc3RyaW5nJyArICcgKGVuY291bnRlcmVkIHR5cGUgXCInICsgKHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGtleSkpICsgJ1wiKS4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGtleXMgaW4gYSBtYXAgYXMgYW4gYXJyYXkuIFRoZXJlIGFyZSBubyBndWFyYW50ZWVzIG9uIHRoZSBvcmRlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gZ2V0IHRoZSBrZXlzIG9mLlxuICAgICAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fSBUaGUgYXJyYXkgb2Yga2V5cyBpbiB0aGUgZ2l2ZW4gbWFwLlxuICAgICAqL1xuICAgIHNveS4kJGdldE1hcEtleXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gICAgICB2YXIgbWFwS2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgICBtYXBLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBLZXlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcmd1bWVudCBpZiBpdCBpcyBub3QgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VH0gdmFsIFRoZSB2YWx1ZSB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge1R9IHZhbCBpZiBpcyBpc24ndCBudWxsXG4gICAgICogQHRlbXBsYXRlIFRcbiAgICAgKi9cbiAgICBzb3kuJCRjaGVja05vdE51bGwgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3VuZXhwZWN0ZWQgbnVsbCB2YWx1ZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNvbnNpc3RlbnQgdW5pcXVlIGlkIGZvciB0aGUgZ2l2ZW4gZGVsZWdhdGUgdGVtcGxhdGUgbmFtZS4gVHdvIGNhbGxzXG4gICAgICogdG8gdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgc2FtZSBpZCBpZiBhbmQgb25seSBpZiB0aGUgaW5wdXQgbmFtZXMgYXJlXG4gICAgICogdGhlIHNhbWUuXG4gICAgICpcbiAgICAgKiA8cD4gSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIG11c3QgYWx3YXlzIGJlIGNhbGxlZCB3aXRoIGEgc3RyaW5nIGNvbnN0YW50LlxuICAgICAqXG4gICAgICogPHA+IElmIENsb3N1cmUgQ29tcGlsZXIgaXMgbm90IGJlaW5nIHVzZWQsIHRoZW4gdGhpcyBpcyBqdXN0IHRoaXMgaWRlbnRpdHlcbiAgICAgKiBmdW5jdGlvbi4gSWYgQ2xvc3VyZSBDb21waWxlciBpcyBiZWluZyB1c2VkLCB0aGVuIGVhY2ggY2FsbCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICogd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgc2hvcnQgc3RyaW5nIGNvbnN0YW50LCB3aGljaCB3aWxsIGJlIGNvbnNpc3RlbnQgcGVyXG4gICAgICogaW5wdXQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWxUZW1wbGF0ZU5hbWUgVGhlIGRlbGVnYXRlIHRlbXBsYXRlIG5hbWUgZm9yIHdoaWNoIHRvIGdldCBhXG4gICAgICogICAgIGNvbnNpc3RlbnQgdW5pcXVlIGlkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSB1bmlxdWUgaWQgdGhhdCBpcyBjb25zaXN0ZW50IHBlciBpbnB1dCBuYW1lLlxuICAgICAqXG4gICAgICogQGNvbnNpc3RlbnRJZEdlbmVyYXRvclxuICAgICAqL1xuICAgIHNveS4kJGdldERlbFRlbXBsYXRlSWQgPSBmdW5jdGlvbiAoZGVsVGVtcGxhdGVOYW1lKSB7XG4gICAgICByZXR1cm4gZGVsVGVtcGxhdGVOYW1lO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNYXAgZnJvbSByZWdpc3RlcmVkIGRlbGVnYXRlIHRlbXBsYXRlIGtleSB0byB0aGUgcHJpb3JpdHkgb2YgdGhlXG4gICAgICogaW1wbGVtZW50YXRpb24uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX1BSSU9SSVRJRVNfID0ge307XG5cbiAgICAvKipcbiAgICAgKiBNYXAgZnJvbSByZWdpc3RlcmVkIGRlbGVnYXRlIHRlbXBsYXRlIGtleSB0byB0aGUgaW1wbGVtZW50YXRpb24gZnVuY3Rpb24uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX0ZVTkNUSU9OU18gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGRlbGVnYXRlIGltcGxlbWVudGF0aW9uLiBJZiB0aGUgc2FtZSBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgKGlkXG4gICAgICogYW5kIHZhcmlhbnQpIGhhcyBiZWVuIHJlZ2lzdGVyZWQgcHJldmlvdXNseSwgdGhlbiBwcmlvcml0eSB2YWx1ZXMgYXJlXG4gICAgICogY29tcGFyZWQgYW5kIG9ubHkgdGhlIGhpZ2hlciBwcmlvcml0eSBpbXBsZW1lbnRhdGlvbiBpcyBzdG9yZWQgKGlmXG4gICAgICogcHJpb3JpdGllcyBhcmUgZXF1YWwsIGFuIGVycm9yIGlzIHRocm93bikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsVGVtcGxhdGVJZCBUaGUgZGVsZWdhdGUgdGVtcGxhdGUgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlbFRlbXBsYXRlVmFyaWFudCBUaGUgZGVsZWdhdGUgdGVtcGxhdGUgdmFyaWFudCAoY2FuIGJlXG4gICAgICogICAgIGVtcHR5IHN0cmluZykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbFByaW9yaXR5IFRoZSBpbXBsZW1lbnRhdGlvbidzIHByaW9yaXR5IHZhbHVlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGRlbEZuIFRoZSBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzb3kuJCRyZWdpc3RlckRlbGVnYXRlRm4gPSBmdW5jdGlvbiAoZGVsVGVtcGxhdGVJZCwgZGVsVGVtcGxhdGVWYXJpYW50LCBkZWxQcmlvcml0eSwgZGVsRm4pIHtcblxuICAgICAgdmFyIG1hcEtleSA9ICdrZXlfJyArIGRlbFRlbXBsYXRlSWQgKyAnOicgKyBkZWxUZW1wbGF0ZVZhcmlhbnQ7XG4gICAgICB2YXIgY3VyclByaW9yaXR5ID0gc295LiQkREVMRUdBVEVfUkVHSVNUUllfUFJJT1JJVElFU19bbWFwS2V5XTtcbiAgICAgIGlmIChjdXJyUHJpb3JpdHkgPT09IHVuZGVmaW5lZCB8fCBkZWxQcmlvcml0eSA+IGN1cnJQcmlvcml0eSkge1xuICAgICAgICAvLyBSZWdpc3RlcmluZyBuZXcgb3IgaGlnaGVyLXByaW9yaXR5IGZ1bmN0aW9uOiByZXBsYWNlIHJlZ2lzdHJ5IGVudHJ5LlxuICAgICAgICBzb3kuJCRERUxFR0FURV9SRUdJU1RSWV9QUklPUklUSUVTX1ttYXBLZXldID0gZGVsUHJpb3JpdHk7XG4gICAgICAgIHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX0ZVTkNUSU9OU19bbWFwS2V5XSA9IGRlbEZuO1xuICAgICAgfSBlbHNlIGlmIChkZWxQcmlvcml0eSA9PSBjdXJyUHJpb3JpdHkpIHtcbiAgICAgICAgLy8gUmVnaXN0ZXJpbmcgc2FtZS1wcmlvcml0eSBmdW5jdGlvbjogZXJyb3IuXG4gICAgICAgIHRocm93IEVycm9yKCdFbmNvdW50ZXJlZCB0d28gYWN0aXZlIGRlbGVnYXRlcyB3aXRoIHRoZSBzYW1lIHByaW9yaXR5IChcIicgKyBkZWxUZW1wbGF0ZUlkICsgJzonICsgZGVsVGVtcGxhdGVWYXJpYW50ICsgJ1wiKS4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyaW5nIGxvd2VyLXByaW9yaXR5IGZ1bmN0aW9uOiBkbyBub3RoaW5nLlxuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIChoaWdoZXN0LXByaW9yaXR5KSBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgZm9yXG4gICAgICogYSBnaXZlbiBkZWxlZ2F0ZSB0ZW1wbGF0ZSBrZXkgKGlkIGFuZCB2YXJpYW50KS4gSWYgbm8gaW1wbGVtZW50YXRpb24gaGFzXG4gICAgICogYmVlbiByZWdpc3RlcmVkIGZvciB0aGUga2V5LCB0aGVuIHRoZSBmYWxsYmFjayBpcyB0aGUgc2FtZSBpZCB3aXRoIGVtcHR5XG4gICAgICogdmFyaWFudC4gSWYgdGhlIGZhbGxiYWNrIGlzIGFsc28gbm90IHJlZ2lzdGVyZWQsIGFuZCBhbGxvd3NFbXB0eURlZmF1bHQgaXNcbiAgICAgKiB0cnVlLCB0aGVuIHJldHVybnMgYW4gaW1wbGVtZW50YXRpb24gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGFuIGVtcHR5IHRlbXBsYXRlXG4gICAgICogKGkuZS4gcmVuZGVyZWQgb3V0cHV0IHdvdWxkIGJlIGVtcHR5IHN0cmluZykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVsVGVtcGxhdGVJZCBUaGUgZGVsZWdhdGUgdGVtcGxhdGUgaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlbFRlbXBsYXRlVmFyaWFudCBUaGUgZGVsZWdhdGUgdGVtcGxhdGUgdmFyaWFudCAoY2FuIGJlXG4gICAgICogICAgIGVtcHR5IHN0cmluZykuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbGxvd3NFbXB0eURlZmF1bHQgV2hldGhlciB0byBkZWZhdWx0IHRvIHRoZSBlbXB0eSB0ZW1wbGF0ZVxuICAgICAqICAgICBmdW5jdGlvbiBpZiB0aGVyZSdzIG5vIGFjdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHJldHJpZXZlZCBpbXBsZW1lbnRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzb3kuJCRnZXREZWxlZ2F0ZUZuID0gZnVuY3Rpb24gKGRlbFRlbXBsYXRlSWQsIGRlbFRlbXBsYXRlVmFyaWFudCwgYWxsb3dzRW1wdHlEZWZhdWx0KSB7XG5cbiAgICAgIHZhciBkZWxGbiA9IHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX0ZVTkNUSU9OU19bJ2tleV8nICsgZGVsVGVtcGxhdGVJZCArICc6JyArIGRlbFRlbXBsYXRlVmFyaWFudF07XG4gICAgICBpZiAoIWRlbEZuICYmIGRlbFRlbXBsYXRlVmFyaWFudCAhPSAnJykge1xuICAgICAgICAvLyBGYWxsYmFjayB0byBlbXB0eSB2YXJpYW50LlxuICAgICAgICBkZWxGbiA9IHNveS4kJERFTEVHQVRFX1JFR0lTVFJZX0ZVTkNUSU9OU19bJ2tleV8nICsgZGVsVGVtcGxhdGVJZCArICc6J107XG4gICAgICB9XG5cbiAgICAgIGlmIChkZWxGbikge1xuICAgICAgICByZXR1cm4gZGVsRm47XG4gICAgICB9IGVsc2UgaWYgKGFsbG93c0VtcHR5RGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gc295LiQkRU1QVFlfVEVNUExBVEVfRk5fO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ZvdW5kIG5vIGFjdGl2ZSBpbXBsIGZvciBkZWxlZ2F0ZSBjYWxsIHRvIFwiJyArIGRlbFRlbXBsYXRlSWQgKyAnOicgKyBkZWxUZW1wbGF0ZVZhcmlhbnQgKyAnXCIgKGFuZCBub3QgYWxsb3dlbXB0eWRlZmF1bHQ9XCJ0cnVlXCIpLicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciBzb3kuJCRnZXREZWxlZ2F0ZUZuKCkuIFRoaXMgaXMgdGhlIGVtcHR5IHRlbXBsYXRlIGZ1bmN0aW9uXG4gICAgICogdGhhdCBpcyByZXR1cm5lZCB3aGVuZXZlciB0aGVyZSdzIG5vIGRlbGVnYXRlIGltcGxlbWVudGF0aW9uIGZvdW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9kYXRhXG4gICAgICogQHBhcmFtIHtzb3kuU3RyaW5nQnVpbGRlcj19IG9wdF9zYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgKj49fSBvcHRfaWpEYXRhXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc295LiQkRU1QVFlfVEVNUExBVEVfRk5fID0gZnVuY3Rpb24gKG9wdF9kYXRhLCBvcHRfc2IsIG9wdF9pakRhdGEpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBCYXNpYyBkaXJlY3RpdmVzL2Z1bmN0aW9ucy5cblxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGEgc3RyaW5nIHRvIGEgZ2l2ZW4gbWF4IGxlbmd0aCAoaWYgaXQncyBjdXJyZW50bHkgbG9uZ2VyKSxcbiAgICAgKiBvcHRpb25hbGx5IGFkZGluZyBlbGxpcHNpcyBhdCB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byB0cnVuY2F0ZS4gQ2FuIGJlIG90aGVyIHR5cGVzLCBidXQgdGhlIHZhbHVlIHdpbGxcbiAgICAgKiAgICAgYmUgY29lcmNlZCB0byBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4TGVuIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGFmdGVyIHRydW5jYXRpb25cbiAgICAgKiAgICAgKGluY2x1ZGluZyBlbGxpcHNpcywgaWYgYXBwbGljYWJsZSkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb0FkZEVsbGlwc2lzIFdoZXRoZXIgdG8gYWRkIGVsbGlwc2lzIGlmIHRoZSBzdHJpbmcgbmVlZHNcbiAgICAgKiAgICAgdHJ1bmNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgYWZ0ZXIgdHJ1bmNhdGlvbi5cbiAgICAgKi9cbiAgICBzb3kuJCR0cnVuY2F0ZSA9IGZ1bmN0aW9uIChzdHIsIG1heExlbiwgZG9BZGRFbGxpcHNpcykge1xuXG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgIGlmIChzdHIubGVuZ3RoIDw9IG1heExlbikge1xuICAgICAgICByZXR1cm4gc3RyOyAvLyBubyBuZWVkIHRvIHRydW5jYXRlXG4gICAgICB9XG5cbiAgICAgIC8vIElmIGRvQWRkRWxsaXBzaXMsIGVpdGhlciByZWR1Y2UgbWF4TGVuIHRvIGNvbXBlbnNhdGUsIG9yIGVsc2UgaWYgbWF4TGVuIGlzXG4gICAgICAvLyB0b28gc21hbGwsIGp1c3QgdHVybiBvZmYgZG9BZGRFbGxpcHNpcy5cbiAgICAgIGlmIChkb0FkZEVsbGlwc2lzKSB7XG4gICAgICAgIGlmIChtYXhMZW4gPiAzKSB7XG4gICAgICAgICAgbWF4TGVuIC09IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9BZGRFbGxpcHNpcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSB0cnVuY2F0aW5nIGF0IG1heExlbiBkb2Vzbid0IGN1dCB1cCBhIHVuaWNvZGUgc3Vycm9nYXRlIHBhaXIuXG4gICAgICBpZiAoc295LiQkaXNIaWdoU3Vycm9nYXRlXyhzdHIuY2hhckF0KG1heExlbiAtIDEpKSAmJiBzb3kuJCRpc0xvd1N1cnJvZ2F0ZV8oc3RyLmNoYXJBdChtYXhMZW4pKSkge1xuICAgICAgICBtYXhMZW4gLT0gMTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ1bmNhdGUuXG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIG1heExlbik7XG5cbiAgICAgIC8vIEFkZCBlbGxpcHNpcy5cbiAgICAgIGlmIChkb0FkZEVsbGlwc2lzKSB7XG4gICAgICAgIHN0ciArPSAnLi4uJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgZm9yICQkdHJ1bmNhdGUoKSB0byBjaGVjayB3aGV0aGVyIGEgY2hhciBpcyBhIGhpZ2ggc3Vycm9nYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaCBUaGUgY2hhciB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBjaGFyIGlzIGEgdW5pY29kZSBoaWdoIHN1cnJvZ2F0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveS4kJGlzSGlnaFN1cnJvZ2F0ZV8gPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgIHJldHVybiAweEQ4MDAgPD0gY2ggJiYgY2ggPD0gMHhEQkZGO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGhlbHBlciBmb3IgJCR0cnVuY2F0ZSgpIHRvIGNoZWNrIHdoZXRoZXIgYSBjaGFyIGlzIGEgbG93IHN1cnJvZ2F0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2ggVGhlIGNoYXIgdG8gY2hlY2suXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gY2hhciBpcyBhIHVuaWNvZGUgbG93IHN1cnJvZ2F0ZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNveS4kJGlzTG93U3Vycm9nYXRlXyA9IGZ1bmN0aW9uIChjaCkge1xuICAgICAgcmV0dXJuIDB4REMwMCA8PSBjaCAmJiBjaCA8PSAweERGRkY7XG4gICAgfTtcblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQXNzZXJ0aW9uIG1ldGhvZHMgdXNlZCBieSBydW50aW1lLlxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSB0eXBlIGFzc2VydGlvbiBpcyB0cnVlIGlmIGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyBpc1xuICAgICAqIHRydWUuIFJlcG9ydCBlcnJvcnMgb24gcnVudGltZSB0eXBlcyBpZiBnb29nLkRFQlVHIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25kaXRpb24gVGhlIHR5cGUgY2hlY2sgY29uZGl0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbU5hbWUgVGhlIFNveSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHs/fSBwYXJhbSBUaGUgSlMgb2JqZWN0IGZvciB0aGUgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7IXN0cmluZ30ganNEb2NUeXBlU3RyIFNveURvYyB0eXBlIHN0ci5cbiAgICAgKiBAcmV0dXJuIHs/fSB0aGUgcGFyYW0gdmFsdWVcbiAgICAgKiBAdGhyb3dzIHtnb29nLmFzc2VydHMuQXNzZXJ0aW9uRXJyb3J9IFdoZW4gdGhlIGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gZmFsc2UuXG4gICAgICovXG4gICAgc295LmFzc2VydHMuYXNzZXJ0VHlwZSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHBhcmFtTmFtZSwgcGFyYW0sIGpzRG9jVHlwZVN0cikge1xuICAgICAgaWYgKGdvb2cuYXNzZXJ0cy5FTkFCTEVfQVNTRVJUUyAmJiAhY29uZGl0aW9uKSB7XG4gICAgICAgIHZhciBtc2cgPSAnZXhwZWN0ZWQgcGFyYW0gJyArIHBhcmFtTmFtZSArICcgb2YgdHlwZSAnICsganNEb2NUeXBlU3RyICsgKGdvb2cuREVCVUcgPyAnLCBidXQgZ290ICcgKyBnb29nLmRlYnVnLnJ1bnRpbWVUeXBlKHBhcmFtKSA6ICcnKSArICcuJztcbiAgICAgICAgZ29vZy5hc3NlcnRzLmZhaWwobXNnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJhbTtcbiAgICB9O1xuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBHZW5lcmF0ZWQgY29kZS5cblxuXG4gICAgLy8gU1RBUlQgR0VORVJBVEVEIENPREUgRk9SIEVTQ0FQRVJTLlxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uICgqKSA6IHN0cmluZ31cbiAgICAgKi9cbiAgICBzb3kuZXNjLiQkZXNjYXBlSHRtbEhlbHBlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICByZXR1cm4gZ29vZy5zdHJpbmcuaHRtbEVzY2FwZShTdHJpbmcodikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgb25seSBkYXRhLXByb3RvY29sIGltYWdlIFVSSSdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy4gTWF5IG5vdCBiZSBhIHN0cmluZywgYnV0IHRoZSB2YWx1ZVxuICAgICAqICAgICB3aWxsIGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcuXG4gICAgICogQHJldHVybiB7IXNveWRhdGEuU2FuaXRpemVkVXJpfSBBbiBlc2NhcGVkIHZlcnNpb24gb2YgdmFsdWUuXG4gICAgICovXG4gICAgc295LiQkZmlsdGVySW1hZ2VEYXRhVXJpID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAvLyBOT1RFOiBFdmVuIGlmIGl0J3MgYSBTYW5pdGl6ZWRVcmksIHdlIHdpbGwgc3RpbGwgZmlsdGVyIGl0LlxuICAgICAgcmV0dXJuIHNveWRhdGEuVkVSWV9VTlNBRkUub3JkYWluU2FuaXRpemVkVXJpKHNveS5lc2MuJCRmaWx0ZXJJbWFnZURhdGFVcmlIZWxwZXIodmFsdWUpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQSBwYXR0ZXJuIHRoYXQgdmV0cyB2YWx1ZXMgcHJvZHVjZWQgYnkgdGhlIG5hbWVkIGRpcmVjdGl2ZXMuXG4gICAgICogQHByaXZhdGUgeyFSZWdFeHB9XG4gICAgICovXG4gICAgc295LmVzYy4kJEZJTFRFUl9GT1JfRklMVEVSX0lNQUdFX0RBVEFfVVJJXyA9IC9eZGF0YTppbWFnZVxcLyg/OmJtcHxnaWZ8anBlP2d8cG5nfHRpZmZ8d2VicCk7YmFzZTY0LFthLXowLTkrXFwvXSs9KiQvaTtcblxuICAgIC8qKlxuICAgICAqIEEgaGVscGVyIGZvciB0aGUgU295IGRpcmVjdGl2ZSB8ZmlsdGVySW1hZ2VEYXRhVXJpXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBDYW4gYmUgb2YgYW55IHR5cGUgYnV0IHdpbGwgYmUgY29lcmNlZCB0byBhIHN0cmluZy5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBlc2NhcGVkIHRleHQuXG4gICAgICovXG4gICAgc295LmVzYy4kJGZpbHRlckltYWdlRGF0YVVyaUhlbHBlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFyIHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICBpZiAoIXNveS5lc2MuJCRGSUxURVJfRk9SX0ZJTFRFUl9JTUFHRV9EQVRBX1VSSV8udGVzdChzdHIpKSB7XG4gICAgICAgIGdvb2cuYXNzZXJ0cy5mYWlsKCdCYWQgdmFsdWUgYCVzYCBmb3IgfGZpbHRlckltYWdlRGF0YVVyaScsIFtzdHJdKTtcbiAgICAgICAgcmV0dXJuICdkYXRhOmltYWdlL2dpZjtiYXNlNjQselNveXonO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgdmFyIGluY3JlbWVudGFsZG9tID0gSW5jcmVtZW50YWxET007XG4gICAgdmFyIHNveUlET00gPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENhbGxzIGFuIGV4cHJlc3Npb24gaW4gY2FzZSBvZiBhIGZ1bmN0aW9uIG9yIG91dHB1dHMgaXQgYXMgdGV4dCBjb250ZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufGZ1bmN0aW9uKCk/fSBleHByXG4gICAgICovXG4gICAgc295SURPTS5yZW5kZXJEeW5hbWljQ29udGVudCA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICBpZiAoZ29vZy5pc0Z1bmN0aW9uKGV4cHIpKSB7XG4gICAgICAgIGV4cHIoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXhwciAhPSBudWxsKSB7XG4gICAgICAgIGluY3JlbWVudGFsZG9tLnRleHQoZXhwcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFByaW50cyBhbiBleHByZXNzaW9uIGRlcGVuZGluZyBvbiBpdHMgdHlwZS5cbiAgICAgKiBAcGFyYW0geyFTYW5pdGl6ZWRIdG1sfHN0cmluZ3xudW1iZXJ8Ym9vbGVhbnxmdW5jdGlvbigpfSBleHByXG4gICAgICovXG4gICAgc295SURPTS5wcmludCA9IGZ1bmN0aW9uIChleHByKSB7XG4gICAgICBpZiAoZXhwciBpbnN0YW5jZW9mIHNveWRhdGEuU2FuaXRpemVkSHRtbCkge1xuICAgICAgICAvLyBGb3IgSFRNTCBjb250ZW50IHdlIG5lZWQgdG8gaW5zZXJ0IGEgY3VzdG9tIGVsZW1lbnQgd2hlcmUgd2UgY2FuIHBsYWNlXG4gICAgICAgIC8vIHRoZSBjb250ZW50IHdpdGhvdXQgaW5jcmVtZW50YWwgZG9tIG1vZGlmeWluZyBpdC5cbiAgICAgICAgdmFyIGVsID0gaW5jcmVtZW50YWxkb20uZWxlbWVudE9wZW4oJ2h0bWwtYmxvYicpO1xuICAgICAgICB2YXIgY29udGVudCA9IGV4cHIudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGVsLl9faW5uZXJIVE1MICE9PSBjb250ZW50KSB7XG4gICAgICAgICAgc295LnJlbmRlckh0bWwoZWwsIGV4cHIpO1xuICAgICAgICAgIGVsLl9faW5uZXJIVE1MID0gY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBpbmNyZW1lbnRhbGRvbS5za2lwKCk7XG4gICAgICAgIGluY3JlbWVudGFsZG9tLmVsZW1lbnRDbG9zZSgnaHRtbC1ibG9iJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3lJRE9NLnJlbmRlckR5bmFtaWNDb250ZW50KGV4cHIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBnb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgZ29vZy5tb2R1bGUoJ3NveS5pZG9tJyk7XG4gICAgICByZXR1cm4gc295SURPTTtcbiAgICB9KTtcblxuICAgIC8vIEVORCBHRU5FUkFURUQgQ09ERVxuXG4gICAgZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdvb2cubW9kdWxlKCdzb3knKTtcbiAgICAgIHJldHVybiBzb3k7XG4gICAgfSk7XG5cbiAgICBnb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24gKCkge1xuICAgICAgZ29vZy5tb2R1bGUoJ3NveWRhdGEnKTtcbiAgICAgIHJldHVybiBzb3lkYXRhO1xuICAgIH0pO1xuXG4gICAgZ29vZy5sb2FkTW9kdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGdvb2cubW9kdWxlKCdzb3kuYXNzZXJ0cycpO1xuICAgICAgcmV0dXJuIHNveTtcbiAgICB9KTtcbiAgfSkoKTtcblxuICBnb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24gKCkge1xuICAgIGdvb2cubW9kdWxlKCdpbmNyZW1lbnRhbGRvbScpO1xuICAgIHJldHVybiBJbmNyZW1lbnRhbERPTTtcbiAgfSk7XG59KS5jYWxsKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc295LWJ1bmRsZS9saWIvYnVuZGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgY2FjaGVkIHJlZmVyZW5jZSB0byB0aGUgaGFzT3duUHJvcGVydHkgZnVuY3Rpb24uXG4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGF0IHdpbGwgY3JlYXRlIGJsYW5rIG9iamVjdHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmxhbmsoKSB7fVxuXG5CbGFuay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4vKipcbiAqIFVzZWQgdG8gcHJldmVudCBwcm9wZXJ0eSBjb2xsaXNpb25zIGJldHdlZW4gb3VyIFwibWFwXCIgYW5kIGl0cyBwcm90b3R5cGUuXG4gKiBAcGFyYW0geyFPYmplY3Q8c3RyaW5nLCAqPn0gbWFwIFRoZSBtYXAgdG8gY2hlY2suXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBtYXAgaGFzIHByb3BlcnR5LlxuICovXG52YXIgaGFzID0gZnVuY3Rpb24gKG1hcCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwobWFwLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbWFwIG9iamVjdCB3aXRob3V0IGEgcHJvdG90eXBlLlxuICogQHJldHVybiB7IU9iamVjdH1cbiAqL1xudmFyIGNyZWF0ZU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBCbGFuaygpO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcGVyZm9ybSBkaWZmcyBmb3IgYSBnaXZlbiBET00gbm9kZS5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbm9kZU5hbWVcbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE5vZGVEYXRhKG5vZGVOYW1lLCBrZXkpIHtcbiAgLyoqXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gICAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICo+fVxuICAgKi9cbiAgdGhpcy5hdHRycyA9IGNyZWF0ZU1hcCgpO1xuXG4gIC8qKlxuICAgKiBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycywgdXNlZCBmb3IgcXVpY2tseSBkaWZmaW5nIHRoZVxuICAgKiBpbmNvbW1pbmcgYXR0cmlidXRlcyB0byBzZWUgaWYgdGhlIERPTSBub2RlJ3MgYXR0cmlidXRlcyBuZWVkIHRvIGJlXG4gICAqIHVwZGF0ZWQuXG4gICAqIEBjb25zdCB7QXJyYXk8Kj59XG4gICAqL1xuICB0aGlzLmF0dHJzQXJyID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBpbmNvbWluZyBhdHRyaWJ1dGVzIGZvciB0aGlzIE5vZGUsIGJlZm9yZSB0aGV5IGFyZSB1cGRhdGVkLlxuICAgKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICovXG4gIHRoaXMubmV3QXR0cnMgPSBjcmVhdGVNYXAoKTtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHN0YXRpY3MgaGF2ZSBiZWVuIGFwcGxpZWQgZm9yIHRoZSBub2RlIHlldC5cbiAgICoge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLnN0YXRpY3NBcHBsaWVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIG5vZGUsIHVzZWQgdG8gcHJlc2VydmUgRE9NIG5vZGVzIHdoZW4gdGhleVxuICAgKiBtb3ZlIHdpdGhpbiB0aGVpciBwYXJlbnQuXG4gICAqIEBjb25zdFxuICAgKi9cbiAgdGhpcy5rZXkgPSBrZXk7XG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIGNoaWxkcmVuIHdpdGhpbiB0aGlzIG5vZGUgYnkgdGhlaXIga2V5LlxuICAgKiB7IU9iamVjdDxzdHJpbmcsICFFbGVtZW50Pn1cbiAgICovXG4gIHRoaXMua2V5TWFwID0gY3JlYXRlTWFwKCk7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBrZXlNYXAgaXMgY3VycmVudGx5IHZhbGlkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMua2V5TWFwVmFsaWQgPSB0cnVlO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIHRoZSBhc3NvY2lhdGVkIG5vZGUgaXMsIG9yIGNvbnRhaW5zLCBhIGZvY3VzZWQgRWxlbWVudC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIG5vZGUgbmFtZSBmb3IgdGhpcyBub2RlLlxuICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICovXG4gIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZTtcblxuICAvKipcbiAgICogQHR5cGUgez9zdHJpbmd9XG4gICAqL1xuICB0aGlzLnRleHQgPSBudWxsO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgTm9kZURhdGEgb2JqZWN0IGZvciBhIE5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIGluaXRpYWxpemUgZGF0YSBmb3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGUgbmFtZSBvZiBub2RlLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBub2RlLlxuICogQHJldHVybiB7IU5vZGVEYXRhfSBUaGUgbmV3bHkgaW5pdGlhbGl6ZWQgZGF0YSBvYmplY3RcbiAqL1xudmFyIGluaXREYXRhID0gZnVuY3Rpb24gKG5vZGUsIG5vZGVOYW1lLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBuZXcgTm9kZURhdGEobm9kZU5hbWUsIGtleSk7XG4gIG5vZGVbJ19faW5jcmVtZW50YWxET01EYXRhJ10gPSBkYXRhO1xuICByZXR1cm4gZGF0YTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBOb2RlRGF0YSBvYmplY3QgZm9yIGEgTm9kZSwgY3JlYXRpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7P05vZGV9IG5vZGUgVGhlIE5vZGUgdG8gcmV0cmlldmUgdGhlIGRhdGEgZm9yLlxuICogQHJldHVybiB7IU5vZGVEYXRhfSBUaGUgTm9kZURhdGEgZm9yIHRoaXMgTm9kZS5cbiAqL1xudmFyIGdldERhdGEgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpbXBvcnROb2RlKG5vZGUpO1xuICByZXR1cm4gbm9kZVsnX19pbmNyZW1lbnRhbERPTURhdGEnXTtcbn07XG5cbi8qKlxuICogSW1wb3J0cyBub2RlIGFuZCBpdHMgc3VidHJlZSwgaW5pdGlhbGl6aW5nIGNhY2hlcy5cbiAqXG4gKiBAcGFyYW0gez9Ob2RlfSBub2RlIFRoZSBOb2RlIHRvIGltcG9ydC5cbiAqL1xudmFyIGltcG9ydE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZVsnX19pbmNyZW1lbnRhbERPTURhdGEnXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpc0VsZW1lbnQgPSBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbiAgdmFyIG5vZGVOYW1lID0gaXNFbGVtZW50ID8gbm9kZS5sb2NhbE5hbWUgOiBub2RlLm5vZGVOYW1lO1xuICB2YXIga2V5ID0gaXNFbGVtZW50ID8gbm9kZS5nZXRBdHRyaWJ1dGUoJ2tleScpIDogbnVsbDtcbiAgdmFyIGRhdGEgPSBpbml0RGF0YShub2RlLCBub2RlTmFtZSwga2V5KTtcblxuICBpZiAoa2V5KSB7XG4gICAgZ2V0RGF0YShub2RlLnBhcmVudE5vZGUpLmtleU1hcFtrZXldID0gbm9kZTtcbiAgfVxuXG4gIGlmIChpc0VsZW1lbnQpIHtcbiAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBuZXdBdHRycyA9IGRhdGEubmV3QXR0cnM7XG4gICAgdmFyIGF0dHJzQXJyID0gZGF0YS5hdHRyc0FycjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVzW2ldO1xuICAgICAgdmFyIG5hbWUgPSBhdHRyLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyLnZhbHVlO1xuXG4gICAgICBhdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgbmV3QXR0cnNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICBhdHRyc0Fyci5wdXNoKG5hbWUpO1xuICAgICAgYXR0cnNBcnIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgaW1wb3J0Tm9kZShjaGlsZCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZXNwYWNlIHRvIGNyZWF0ZSBhbiBlbGVtZW50IChvZiBhIGdpdmVuIHRhZykgaW4uXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSB0YWcgdG8gZ2V0IHRoZSBuYW1lc3BhY2UgZm9yLlxuICogQHBhcmFtIHs/Tm9kZX0gcGFyZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgbmFtZXNwYWNlIHRvIGNyZWF0ZSB0aGUgdGFnIGluLlxuICovXG52YXIgZ2V0TmFtZXNwYWNlRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgcGFyZW50KSB7XG4gIGlmICh0YWcgPT09ICdzdmcnKSB7XG4gICAgcmV0dXJuICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIH1cblxuICBpZiAoZ2V0RGF0YShwYXJlbnQpLm5vZGVOYW1lID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQubmFtZXNwYWNlVVJJO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIEVsZW1lbnQuXG4gKiBAcGFyYW0ge0RvY3VtZW50fSBkb2MgVGhlIGRvY3VtZW50IHdpdGggd2hpY2ggdG8gY3JlYXRlIHRoZSBFbGVtZW50LlxuICogQHBhcmFtIHs/Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSB0YWcgZm9yIHRoZSBFbGVtZW50LlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IEEga2V5IHRvIGlkZW50aWZ5IHRoZSBFbGVtZW50LlxuICogQHJldHVybiB7IUVsZW1lbnR9XG4gKi9cbnZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGRvYywgcGFyZW50LCB0YWcsIGtleSkge1xuICB2YXIgbmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlRm9yVGFnKHRhZywgcGFyZW50KTtcbiAgdmFyIGVsID0gdW5kZWZpbmVkO1xuXG4gIGlmIChuYW1lc3BhY2UpIHtcbiAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWcpO1xuICB9IGVsc2Uge1xuICAgIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgfVxuXG4gIGluaXREYXRhKGVsLCB0YWcsIGtleSk7XG5cbiAgcmV0dXJuIGVsO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgVGV4dCBOb2RlLlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIFRoZSBkb2N1bWVudCB3aXRoIHdoaWNoIHRvIGNyZWF0ZSB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4geyFUZXh0fVxuICovXG52YXIgY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgdmFyIG5vZGUgPSBkb2MuY3JlYXRlVGV4dE5vZGUoJycpO1xuICBpbml0RGF0YShub2RlLCAnI3RleHQnLCBudWxsKTtcbiAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAY29uc3QgKi9cbnZhciBub3RpZmljYXRpb25zID0ge1xuICAvKipcbiAgICogQ2FsbGVkIGFmdGVyIHBhdGNoIGhhcyBjb21wbGVhdGVkIHdpdGggYW55IE5vZGVzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICogYW5kIGFkZGVkIHRvIHRoZSBET00uXG4gICAqIEB0eXBlIHs/ZnVuY3Rpb24oQXJyYXk8IU5vZGU+KX1cbiAgICovXG4gIG5vZGVzQ3JlYXRlZDogbnVsbCxcblxuICAvKipcbiAgICogQ2FsbGVkIGFmdGVyIHBhdGNoIGhhcyBjb21wbGVhdGVkIHdpdGggYW55IE5vZGVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICogZnJvbSB0aGUgRE9NLlxuICAgKiBOb3RlIGl0J3MgYW4gYXBwbGljYXRpb25zIHJlc3BvbnNpYmlsaXR5IHRvIGhhbmRsZSBhbnkgY2hpbGROb2Rlcy5cbiAgICogQHR5cGUgez9mdW5jdGlvbihBcnJheTwhTm9kZT4pfVxuICAgKi9cbiAgbm9kZXNEZWxldGVkOiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBzdGF0ZSBvZiBhIHBhdGNoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7KEFycmF5PCFOb2RlPnx1bmRlZmluZWQpfVxuICAgKi9cbiAgdGhpcy5jcmVhdGVkID0gbm90aWZpY2F0aW9ucy5ub2Rlc0NyZWF0ZWQgJiYgW107XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsoQXJyYXk8IU5vZGU+fHVuZGVmaW5lZCl9XG4gICAqL1xuICB0aGlzLmRlbGV0ZWQgPSBub3RpZmljYXRpb25zLm5vZGVzRGVsZXRlZCAmJiBbXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLm1hcmtDcmVhdGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKHRoaXMuY3JlYXRlZCkge1xuICAgIHRoaXMuY3JlYXRlZC5wdXNoKG5vZGUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUubWFya0RlbGV0ZWQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgdGhpcy5kZWxldGVkLnB1c2gobm9kZSk7XG4gIH1cbn07XG5cbi8qKlxuICogTm90aWZpZXMgYWJvdXQgbm9kZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZHVyaW5nIHRoZSBwYXRjaCBvcGVhcmF0aW9uLlxuICovXG5Db250ZXh0LnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jcmVhdGVkICYmIHRoaXMuY3JlYXRlZC5sZW5ndGggPiAwKSB7XG4gICAgbm90aWZpY2F0aW9ucy5ub2Rlc0NyZWF0ZWQodGhpcy5jcmVhdGVkKTtcbiAgfVxuXG4gIGlmICh0aGlzLmRlbGV0ZWQgJiYgdGhpcy5kZWxldGVkLmxlbmd0aCA+IDApIHtcbiAgICBub3RpZmljYXRpb25zLm5vZGVzRGVsZXRlZCh0aGlzLmRlbGV0ZWQpO1xuICB9XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1IFRoZSBJbmNyZW1lbnRhbCBET00gQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICAqIEtlZXBzIHRyYWNrIHdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBhbiBhdHRyaWJ1dGVzIGRlY2xhcmF0aW9uIChhZnRlclxuICAqIGVsZW1lbnRPcGVuU3RhcnQsIGJ1dCBiZWZvcmUgZWxlbWVudE9wZW5FbmQpLlxuICAqIEB0eXBlIHtib29sZWFufVxuICAqL1xudmFyIGluQXR0cmlidXRlcyA9IGZhbHNlO1xuXG4vKipcbiAgKiBLZWVwcyB0cmFjayB3aGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gYW4gZWxlbWVudCB0aGF0IHNob3VsZCBub3QgaGF2ZSBpdHNcbiAgKiBjaGlsZHJlbiBjbGVhcmVkLlxuICAqIEB0eXBlIHtib29sZWFufVxuICAqL1xudmFyIGluU2tpcCA9IGZhbHNlO1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhhdCB0aGVyZSBpcyBhIGN1cnJlbnQgcGF0Y2ggY29udGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbk5hbWVcbiAqIEBwYXJhbSB7Kn0gY29udGV4dFxuICovXG52YXIgYXNzZXJ0SW5QYXRjaCA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUsIGNvbnRleHQpIHtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCAnICsgZnVuY3Rpb25OYW1lICsgJygpIHVubGVzcyBpbiBwYXRjaC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgYSBwYXRjaCBjbG9zZXMgZXZlcnkgbm9kZSB0aGF0IGl0IG9wZW5lZC5cbiAqIEBwYXJhbSB7P05vZGV9IG9wZW5FbGVtZW50XG4gKiBAcGFyYW0geyFOb2RlfCFEb2N1bWVudEZyYWdtZW50fSByb290XG4gKi9cbnZhciBhc3NlcnROb1VuY2xvc2VkVGFncyA9IGZ1bmN0aW9uIChvcGVuRWxlbWVudCwgcm9vdCkge1xuICBpZiAob3BlbkVsZW1lbnQgPT09IHJvb3QpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudEVsZW1lbnQgPSBvcGVuRWxlbWVudDtcbiAgdmFyIG9wZW5UYWdzID0gW107XG4gIHdoaWxlIChjdXJyZW50RWxlbWVudCAmJiBjdXJyZW50RWxlbWVudCAhPT0gcm9vdCkge1xuICAgIG9wZW5UYWdzLnB1c2goY3VycmVudEVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gICAgY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudC5wYXJlbnROb2RlO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb3IgbW9yZSB0YWdzIHdlcmUgbm90IGNsb3NlZDpcXG4nICsgb3BlblRhZ3Muam9pbignXFxuJykpO1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIGNhbGxlciBpcyBub3Qgd2hlcmUgYXR0cmlidXRlcyBhcmUgZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKi9cbnZhciBhc3NlcnROb3RJbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gIGlmIChpbkF0dHJpYnV0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZnVuY3Rpb25OYW1lICsgJygpIGNhbiBub3QgYmUgY2FsbGVkIGJldHdlZW4gJyArICdlbGVtZW50T3BlblN0YXJ0KCkgYW5kIGVsZW1lbnRPcGVuRW5kKCkuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IHRoZSBjYWxsZXIgaXMgbm90IGluc2lkZSBhbiBlbGVtZW50IHRoYXQgaGFzIGRlY2xhcmVkIHNraXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKi9cbnZhciBhc3NlcnROb3RJblNraXAgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lKSB7XG4gIGlmIChpblNraXApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZnVuY3Rpb25OYW1lICsgJygpIG1heSBub3QgYmUgY2FsbGVkIGluc2lkZSBhbiBlbGVtZW50ICcgKyAndGhhdCBoYXMgY2FsbGVkIHNraXAoKS4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIGNhbGxlciBpcyB3aGVyZSBhdHRyaWJ1dGVzIGFyZSBleHBlY3RlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmdW5jdGlvbk5hbWVcbiAqL1xudmFyIGFzc2VydEluQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUpIHtcbiAgaWYgKCFpbkF0dHJpYnV0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZnVuY3Rpb25OYW1lICsgJygpIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlciBjYWxsaW5nICcgKyAnZWxlbWVudE9wZW5TdGFydCgpLicpO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhlIHBhdGNoIGNsb3NlcyB2aXJ0dWFsIGF0dHJpYnV0ZXMgY2FsbFxuICovXG52YXIgYXNzZXJ0VmlydHVhbEF0dHJpYnV0ZXNDbG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChpbkF0dHJpYnV0ZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnRPcGVuRW5kKCkgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgY2FsbGluZyAnICsgJ2VsZW1lbnRPcGVuU3RhcnQoKS4nKTtcbiAgfVxufTtcblxuLyoqXG4gICogTWFrZXMgc3VyZSB0aGF0IHRhZ3MgYXJlIGNvcnJlY3RseSBuZXN0ZWQuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lXG4gICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAqL1xudmFyIGFzc2VydENsb3NlTWF0Y2hlc09wZW5UYWcgPSBmdW5jdGlvbiAobm9kZU5hbWUsIHRhZykge1xuICBpZiAobm9kZU5hbWUgIT09IHRhZykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVjZWl2ZWQgYSBjYWxsIHRvIGNsb3NlIFwiJyArIHRhZyArICdcIiBidXQgXCInICsgbm9kZU5hbWUgKyAnXCIgd2FzIG9wZW4uJyk7XG4gIH1cbn07XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGF0IG5vIGNoaWxkcmVuIGVsZW1lbnRzIGhhdmUgYmVlbiBkZWNsYXJlZCB5ZXQgaW4gdGhlIGN1cnJlbnRcbiAqIGVsZW1lbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZnVuY3Rpb25OYW1lXG4gKiBAcGFyYW0gez9Ob2RlfSBwcmV2aW91c05vZGVcbiAqL1xudmFyIGFzc2VydE5vQ2hpbGRyZW5EZWNsYXJlZFlldCA9IGZ1bmN0aW9uIChmdW5jdGlvbk5hbWUsIHByZXZpb3VzTm9kZSkge1xuICBpZiAocHJldmlvdXNOb2RlICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGZ1bmN0aW9uTmFtZSArICcoKSBtdXN0IGNvbWUgYmVmb3JlIGFueSBjaGlsZCAnICsgJ2RlY2xhcmF0aW9ucyBpbnNpZGUgdGhlIGN1cnJlbnQgZWxlbWVudC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhhdCBhIGNhbGwgdG8gcGF0Y2hPdXRlciBhY3R1YWxseSBwYXRjaGVkIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHs/Tm9kZX0gc3RhcnROb2RlIFRoZSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnROb2RlIHdoZW4gdGhlIHBhdGNoXG4gKiAgICAgc3RhcnRlZC5cbiAqIEBwYXJhbSB7P05vZGV9IGN1cnJlbnROb2RlIFRoZSBjdXJyZW50Tm9kZSB3aGVuIHRoZSBwYXRjaCBmaW5pc2hlZC5cbiAqIEBwYXJhbSB7P05vZGV9IGV4cGVjdGVkTmV4dE5vZGUgVGhlIE5vZGUgdGhhdCBpcyBleHBlY3RlZCB0byBmb2xsb3cgdGhlXG4gKiAgICBjdXJyZW50Tm9kZSBhZnRlciB0aGUgcGF0Y2g7XG4gKiBAcGFyYW0gez9Ob2RlfSBleHBlY3RlZFByZXZOb2RlIFRoZSBOb2RlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gcHJlY2VlZCB0aGVcbiAqICAgIGN1cnJlbnROb2RlIGFmdGVyIHRoZSBwYXRjaC5cbiAqL1xudmFyIGFzc2VydFBhdGNoRWxlbWVudE5vRXh0cmFzID0gZnVuY3Rpb24gKHN0YXJ0Tm9kZSwgY3VycmVudE5vZGUsIGV4cGVjdGVkTmV4dE5vZGUsIGV4cGVjdGVkUHJldk5vZGUpIHtcbiAgdmFyIHdhc1VwZGF0ZWQgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZyA9PT0gZXhwZWN0ZWROZXh0Tm9kZSAmJiBjdXJyZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IGV4cGVjdGVkUHJldk5vZGU7XG4gIHZhciB3YXNDaGFuZ2VkID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmcgPT09IHN0YXJ0Tm9kZS5uZXh0U2libGluZyAmJiBjdXJyZW50Tm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IGV4cGVjdGVkUHJldk5vZGU7XG4gIHZhciB3YXNSZW1vdmVkID0gY3VycmVudE5vZGUgPT09IHN0YXJ0Tm9kZTtcblxuICBpZiAoIXdhc1VwZGF0ZWQgJiYgIXdhc0NoYW5nZWQgJiYgIXdhc1JlbW92ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIG11c3QgYmUgZXhhY3RseSBvbmUgdG9wIGxldmVsIGNhbGwgY29ycmVzcG9uZGluZyAnICsgJ3RvIHRoZSBwYXRjaGVkIGVsZW1lbnQuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgYmVpbmcgaW4gYW4gYXR0cmlidXRlIGRlY2xhcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHByZXZpb3VzIHZhbHVlLlxuICovXG52YXIgc2V0SW5BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcmV2aW91cyA9IGluQXR0cmlidXRlcztcbiAgaW5BdHRyaWJ1dGVzID0gdmFsdWU7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgYmVpbmcgaW4gYSBza2lwIGVsZW1lbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcHJldmlvdXMgdmFsdWUuXG4gKi9cbnZhciBzZXRJblNraXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByZXZpb3VzID0gaW5Ta2lwO1xuICBpblNraXAgPSB2YWx1ZTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIG5vZGUgdGhlIHJvb3Qgb2YgYSBkb2N1bWVudCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52YXIgaXNEb2N1bWVudFJvb3QgPSBmdW5jdGlvbiAobm9kZSkge1xuICAvLyBGb3IgU2hhZG93Um9vdHMsIGNoZWNrIGlmIHRoZXkgYXJlIGEgRG9jdW1lbnRGcmFnbWVudCBpbnN0ZWFkIG9mIGlmIHRoZXlcbiAgLy8gYXJlIGEgU2hhZG93Um9vdCBzbyB0aGF0IHRoaXMgY2FuIHdvcmsgaW4gJ3VzZSBzdHJpY3QnIGlmIFNoYWRvd1Jvb3RzIGFyZVxuICAvLyBub3Qgc3VwcG9ydGVkLlxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIERvY3VtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50O1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBub2RlIHRvIHN0YXJ0IGF0LCBpbmNsdXNpdmUuXG4gKiBAcGFyYW0gez9Ob2RlfSByb290IFRoZSByb290IGFuY2VzdG9yIHRvIGdldCB1bnRpbCwgZXhjbHVzaXZlLlxuICogQHJldHVybiB7IUFycmF5PCFOb2RlPn0gVGhlIGFuY2VzdHJ5IG9mIERPTSBub2Rlcy5cbiAqL1xudmFyIGdldEFuY2VzdHJ5ID0gZnVuY3Rpb24gKG5vZGUsIHJvb3QpIHtcbiAgdmFyIGFuY2VzdHJ5ID0gW107XG4gIHZhciBjdXIgPSBub2RlO1xuXG4gIHdoaWxlIChjdXIgIT09IHJvb3QpIHtcbiAgICBhbmNlc3RyeS5wdXNoKGN1cik7XG4gICAgY3VyID0gY3VyLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gYW5jZXN0cnk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEByZXR1cm4geyFOb2RlfSBUaGUgcm9vdCBub2RlIG9mIHRoZSBET00gdHJlZSB0aGF0IGNvbnRhaW5zIG5vZGUuXG4gKi9cbnZhciBnZXRSb290ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIGN1ciA9IG5vZGU7XG4gIHZhciBwcmV2ID0gY3VyO1xuXG4gIHdoaWxlIChjdXIpIHtcbiAgICBwcmV2ID0gY3VyO1xuICAgIGN1ciA9IGN1ci5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIHByZXY7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgVGhlIG5vZGUgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50IGZvci5cbiAqIEByZXR1cm4gez9FbGVtZW50fSBUaGUgYWN0aXZlRWxlbWVudCBpbiB0aGUgRG9jdW1lbnQgb3IgU2hhZG93Um9vdFxuICogICAgIGNvcnJlc3BvbmRpbmcgdG8gbm9kZSwgaWYgcHJlc2VudC5cbiAqL1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgcm9vdCA9IGdldFJvb3Qobm9kZSk7XG4gIHJldHVybiBpc0RvY3VtZW50Um9vdChyb290KSA/IHJvb3QuYWN0aXZlRWxlbWVudCA6IG51bGw7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBhdGggb2Ygbm9kZXMgdGhhdCBjb250YWluIHRoZSBmb2N1c2VkIG5vZGUgaW4gdGhlIHNhbWUgZG9jdW1lbnQgYXNcbiAqIGEgcmVmZXJlbmNlIG5vZGUsIHVwIHVudGlsIHRoZSByb290LlxuICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgcmVmZXJlbmNlIG5vZGUgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50IGZvci5cbiAqIEBwYXJhbSB7P05vZGV9IHJvb3QgVGhlIHJvb3QgdG8gZ2V0IHRoZSBmb2N1c2VkIHBhdGggdW50aWwuXG4gKiBAcmV0dXJuIHshQXJyYXk8Tm9kZT59XG4gKi9cbnZhciBnZXRGb2N1c2VkUGF0aCA9IGZ1bmN0aW9uIChub2RlLCByb290KSB7XG4gIHZhciBhY3RpdmVFbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudChub2RlKTtcblxuICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gZ2V0QW5jZXN0cnkoYWN0aXZlRWxlbWVudCwgcm9vdCk7XG59O1xuXG4vKipcbiAqIExpa2UgaW5zZXJ0QmVmb3JlLCBidXQgaW5zdGVhZCBpbnN0ZWFkIG9mIG1vdmluZyB0aGUgZGVzaXJlZCBub2RlLCBpbnN0ZWFkXG4gKiBtb3ZlcyBhbGwgdGhlIG90aGVyIG5vZGVzIGFmdGVyLlxuICogQHBhcmFtIHs/Tm9kZX0gcGFyZW50Tm9kZVxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHBhcmFtIHs/Tm9kZX0gcmVmZXJlbmNlTm9kZVxuICovXG52YXIgbW92ZUJlZm9yZSA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCBub2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHZhciBpbnNlcnRSZWZlcmVuY2VOb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgdmFyIGN1ciA9IHJlZmVyZW5jZU5vZGU7XG5cbiAgd2hpbGUgKGN1ciAhPT0gbm9kZSkge1xuICAgIHZhciBuZXh0ID0gY3VyLm5leHRTaWJsaW5nO1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGN1ciwgaW5zZXJ0UmVmZXJlbmNlTm9kZSk7XG4gICAgY3VyID0gbmV4dDtcbiAgfVxufTtcblxuLyoqIEB0eXBlIHs/Q29udGV4dH0gKi9cbnZhciBjb250ZXh0ID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/Tm9kZX0gKi9cbnZhciBjdXJyZW50Tm9kZSA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P05vZGV9ICovXG52YXIgY3VycmVudFBhcmVudCA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P0RvY3VtZW50fSAqL1xudmFyIGRvYyA9IG51bGw7XG5cbi8qKlxuICogQHBhcmFtIHshQXJyYXk8Tm9kZT59IGZvY3VzUGF0aCBUaGUgbm9kZXMgdG8gbWFyay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9jdXNlZCBXaGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBmb2N1c2VkLlxuICovXG52YXIgbWFya0ZvY3VzZWQgPSBmdW5jdGlvbiAoZm9jdXNQYXRoLCBmb2N1c2VkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm9jdXNQYXRoLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgZ2V0RGF0YShmb2N1c1BhdGhbaV0pLmZvY3VzZWQgPSBmb2N1c2VkO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwYXRjaGVyIGZ1bmN0aW9uIHRoYXQgc2V0cyB1cCBhbmQgcmVzdG9yZXMgYSBwYXRjaCBjb250ZXh0LFxuICogcnVubmluZyB0aGUgcnVuIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGRhdGEuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCghRWxlbWVudHwhRG9jdW1lbnRGcmFnbWVudCksIWZ1bmN0aW9uKFQpLFQ9KTogP05vZGV9IHJ1blxuICogQHJldHVybiB7ZnVuY3Rpb24oKCFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50KSwhZnVuY3Rpb24oVCksVD0pOiA/Tm9kZX1cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBwYXRjaEZhY3RvcnkgPSBmdW5jdGlvbiAocnVuKSB7XG4gIC8qKlxuICAgKiBUT0RPKG1veik6IFRoZXNlIGFubm90YXRpb25zIHdvbid0IGJlIG5lY2Vzc2FyeSBvbmNlIHdlIHN3aXRjaCB0byBDbG9zdXJlXG4gICAqIENvbXBpbGVyJ3MgbmV3IHR5cGUgaW5mZXJlbmNlLiBSZW1vdmUgdGhlc2Ugb25jZSB0aGUgc3dpdGNoIGlzIGRvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7KCFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50KX0gbm9kZVxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm5cbiAgICogQHBhcmFtIHtUPX0gZGF0YVxuICAgKiBAcmV0dXJuIHs/Tm9kZX0gbm9kZVxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cbiAgdmFyIGYgPSBmdW5jdGlvbiAobm9kZSwgZm4sIGRhdGEpIHtcbiAgICB2YXIgcHJldkNvbnRleHQgPSBjb250ZXh0O1xuICAgIHZhciBwcmV2RG9jID0gZG9jO1xuICAgIHZhciBwcmV2Q3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICB2YXIgcHJldkN1cnJlbnRQYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuICAgIHZhciBwcmV2aW91c0luQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgIHZhciBwcmV2aW91c0luU2tpcCA9IGZhbHNlO1xuXG4gICAgY29udGV4dCA9IG5ldyBDb250ZXh0KCk7XG4gICAgZG9jID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJldmlvdXNJbkF0dHJpYnV0ZXMgPSBzZXRJbkF0dHJpYnV0ZXMoZmFsc2UpO1xuICAgICAgcHJldmlvdXNJblNraXAgPSBzZXRJblNraXAoZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBmb2N1c1BhdGggPSBnZXRGb2N1c2VkUGF0aChub2RlLCBjdXJyZW50UGFyZW50KTtcbiAgICBtYXJrRm9jdXNlZChmb2N1c1BhdGgsIHRydWUpO1xuICAgIHZhciByZXRWYWwgPSBydW4obm9kZSwgZm4sIGRhdGEpO1xuICAgIG1hcmtGb2N1c2VkKGZvY3VzUGF0aCwgZmFsc2UpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydFZpcnR1YWxBdHRyaWJ1dGVzQ2xvc2VkKCk7XG4gICAgICBzZXRJbkF0dHJpYnV0ZXMocHJldmlvdXNJbkF0dHJpYnV0ZXMpO1xuICAgICAgc2V0SW5Ta2lwKHByZXZpb3VzSW5Ta2lwKTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm5vdGlmeUNoYW5nZXMoKTtcblxuICAgIGNvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgICBkb2MgPSBwcmV2RG9jO1xuICAgIGN1cnJlbnROb2RlID0gcHJldkN1cnJlbnROb2RlO1xuICAgIGN1cnJlbnRQYXJlbnQgPSBwcmV2Q3VycmVudFBhcmVudDtcblxuICAgIHJldHVybiByZXRWYWw7XG4gIH07XG4gIHJldHVybiBmO1xufTtcblxuLyoqXG4gKiBQYXRjaGVzIHRoZSBkb2N1bWVudCBzdGFydGluZyBhdCBub2RlIHdpdGggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGlzXG4gKiBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGR1cmluZyBhbiBleGlzdGluZyBwYXRjaCBvcGVyYXRpb24uXG4gKiBAcGFyYW0geyFFbGVtZW50fCFEb2N1bWVudEZyYWdtZW50fSBub2RlIFRoZSBFbGVtZW50IG9yIERvY3VtZW50XG4gKiAgICAgdG8gcGF0Y2guXG4gKiBAcGFyYW0geyFmdW5jdGlvbihUKX0gZm4gQSBmdW5jdGlvbiBjb250YWluaW5nIGVsZW1lbnRPcGVuL2VsZW1lbnRDbG9zZS9ldGMuXG4gKiAgICAgY2FsbHMgdGhhdCBkZXNjcmliZSB0aGUgRE9NLlxuICogQHBhcmFtIHtUPX0gZGF0YSBBbiBhcmd1bWVudCBwYXNzZWQgdG8gZm4gdG8gcmVwcmVzZW50IERPTSBzdGF0ZS5cbiAqIEByZXR1cm4geyFOb2RlfSBUaGUgcGF0Y2hlZCBub2RlLlxuICogQHRlbXBsYXRlIFRcbiAqL1xudmFyIHBhdGNoSW5uZXIgPSBwYXRjaEZhY3RvcnkoZnVuY3Rpb24gKG5vZGUsIGZuLCBkYXRhKSB7XG4gIGN1cnJlbnROb2RlID0gbm9kZTtcblxuICBlbnRlck5vZGUoKTtcbiAgZm4oZGF0YSk7XG4gIGV4aXROb2RlKCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb1VuY2xvc2VkVGFncyhjdXJyZW50Tm9kZSwgbm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0pO1xuXG4vKipcbiAqIFBhdGNoZXMgYW4gRWxlbWVudCB3aXRoIHRoZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uIEV4YWN0bHkgb25lIHRvcCBsZXZlbFxuICogZWxlbWVudCBjYWxsIHNob3VsZCBiZSBtYWRlIGNvcnJlc3BvbmRpbmcgdG8gYG5vZGVgLlxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBUaGUgRWxlbWVudCB3aGVyZSB0aGUgcGF0Y2ggc2hvdWxkIHN0YXJ0LlxuICogQHBhcmFtIHshZnVuY3Rpb24oVCl9IGZuIEEgZnVuY3Rpb24gY29udGFpbmluZyBlbGVtZW50T3Blbi9lbGVtZW50Q2xvc2UvZXRjLlxuICogICAgIGNhbGxzIHRoYXQgZGVzY3JpYmUgdGhlIERPTS4gVGhpcyBzaG91bGQgaGF2ZSBhdCBtb3N0IG9uZSB0b3AgbGV2ZWxcbiAqICAgICBlbGVtZW50IGNhbGwuXG4gKiBAcGFyYW0ge1Q9fSBkYXRhIEFuIGFyZ3VtZW50IHBhc3NlZCB0byBmbiB0byByZXByZXNlbnQgRE9NIHN0YXRlLlxuICogQHJldHVybiB7P05vZGV9IFRoZSBub2RlIGlmIGl0IHdhcyB1cGRhdGVkLCBpdHMgcmVwbGFjZWRtZW50IG9yIG51bGwgaWYgaXRcbiAqICAgICB3YXMgcmVtb3ZlZC5cbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbnZhciBwYXRjaE91dGVyID0gcGF0Y2hGYWN0b3J5KGZ1bmN0aW9uIChub2RlLCBmbiwgZGF0YSkge1xuICB2YXIgc3RhcnROb2RlID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi97IG5leHRTaWJsaW5nOiBub2RlIH07XG4gIHZhciBleHBlY3RlZE5leHROb2RlID0gbnVsbDtcbiAgdmFyIGV4cGVjdGVkUHJldk5vZGUgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZXhwZWN0ZWROZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgZXhwZWN0ZWRQcmV2Tm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICB9XG5cbiAgY3VycmVudE5vZGUgPSBzdGFydE5vZGU7XG4gIGZuKGRhdGEpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0UGF0Y2hFbGVtZW50Tm9FeHRyYXMoc3RhcnROb2RlLCBjdXJyZW50Tm9kZSwgZXhwZWN0ZWROZXh0Tm9kZSwgZXhwZWN0ZWRQcmV2Tm9kZSk7XG4gIH1cblxuICBpZiAobm9kZSAhPT0gY3VycmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZSwgZ2V0RGF0YShjdXJyZW50UGFyZW50KS5rZXlNYXApO1xuICB9XG5cbiAgcmV0dXJuIHN0YXJ0Tm9kZSA9PT0gY3VycmVudE5vZGUgPyBudWxsIDogY3VycmVudE5vZGU7XG59KTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnQgbm9kZSBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbm9kZU5hbWUgYW5kXG4gKiBrZXkuXG4gKlxuICogQHBhcmFtIHshTm9kZX0gbWF0Y2hOb2RlIEEgbm9kZSB0byBtYXRjaCB0aGUgZGF0YSB0by5cbiAqIEBwYXJhbSB7P3N0cmluZ30gbm9kZU5hbWUgVGhlIG5vZGVOYW1lIGZvciB0aGlzIG5vZGUuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgQW4gb3B0aW9uYWwga2V5IHRoYXQgaWRlbnRpZmllcyBhIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBub2RlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xudmFyIG1hdGNoZXMgPSBmdW5jdGlvbiAobWF0Y2hOb2RlLCBub2RlTmFtZSwga2V5KSB7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShtYXRjaE5vZGUpO1xuXG4gIC8vIEtleSBjaGVjayBpcyBkb25lIHVzaW5nIGRvdWJsZSBlcXVhbHMgYXMgd2Ugd2FudCB0byB0cmVhdCBhIG51bGwga2V5IHRoZVxuICAvLyBzYW1lIGFzIHVuZGVmaW5lZC4gVGhpcyBzaG91bGQgYmUgb2theSBhcyB0aGUgb25seSB2YWx1ZXMgYWxsb3dlZCBhcmVcbiAgLy8gc3RyaW5ncywgbnVsbCBhbmQgdW5kZWZpbmVkIHNvIHRoZSA9PSBzZW1hbnRpY3MgYXJlIG5vdCB0b28gd2VpcmQuXG4gIHJldHVybiBub2RlTmFtZSA9PT0gZGF0YS5ub2RlTmFtZSAmJiBrZXkgPT0gZGF0YS5rZXk7XG59O1xuXG4vKipcbiAqIEFsaWducyB0aGUgdmlydHVhbCBFbGVtZW50IGRlZmluaXRpb24gd2l0aCB0aGUgYWN0dWFsIERPTSwgbW92aW5nIHRoZVxuICogY29ycmVzcG9uZGluZyBET00gbm9kZSB0byB0aGUgY29ycmVjdCBsb2NhdGlvbiBvciBjcmVhdGluZyBpdCBpZiBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbm9kZU5hbWUgRm9yIGFuIEVsZW1lbnQsIHRoaXMgc2hvdWxkIGJlIGEgdmFsaWQgdGFnIHN0cmluZy5cbiAqICAgICBGb3IgYSBUZXh0LCB0aGlzIHNob3VsZCBiZSAjdGV4dC5cbiAqIEBwYXJhbSB7P3N0cmluZz19IGtleSBUaGUga2V5IHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBlbGVtZW50LlxuICovXG52YXIgYWxpZ25XaXRoRE9NID0gZnVuY3Rpb24gKG5vZGVOYW1lLCBrZXkpIHtcbiAgaWYgKGN1cnJlbnROb2RlICYmIG1hdGNoZXMoY3VycmVudE5vZGUsIG5vZGVOYW1lLCBrZXkpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudERhdGEgPSBnZXREYXRhKGN1cnJlbnRQYXJlbnQpO1xuICB2YXIgY3VycmVudE5vZGVEYXRhID0gY3VycmVudE5vZGUgJiYgZ2V0RGF0YShjdXJyZW50Tm9kZSk7XG4gIHZhciBrZXlNYXAgPSBwYXJlbnREYXRhLmtleU1hcDtcbiAgdmFyIG5vZGUgPSB1bmRlZmluZWQ7XG5cbiAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBub2RlIGhhcyBtb3ZlZCB3aXRoaW4gdGhlIHBhcmVudC5cbiAgaWYgKGtleSkge1xuICAgIHZhciBrZXlOb2RlID0ga2V5TWFwW2tleV07XG4gICAgaWYgKGtleU5vZGUpIHtcbiAgICAgIGlmIChtYXRjaGVzKGtleU5vZGUsIG5vZGVOYW1lLCBrZXkpKSB7XG4gICAgICAgIG5vZGUgPSBrZXlOb2RlO1xuICAgICAgfSBlbHNlIGlmIChrZXlOb2RlID09PSBjdXJyZW50Tm9kZSkge1xuICAgICAgICBjb250ZXh0Lm1hcmtEZWxldGVkKGtleU5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwga2V5Tm9kZSwga2V5TWFwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5vZGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgaWYgKCFub2RlKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnI3RleHQnKSB7XG4gICAgICBub2RlID0gY3JlYXRlVGV4dChkb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gY3JlYXRlRWxlbWVudChkb2MsIGN1cnJlbnRQYXJlbnQsIG5vZGVOYW1lLCBrZXkpO1xuICAgIH1cblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGtleU1hcFtrZXldID0gbm9kZTtcbiAgICB9XG5cbiAgICBjb250ZXh0Lm1hcmtDcmVhdGVkKG5vZGUpO1xuICB9XG5cbiAgLy8gUmUtb3JkZXIgdGhlIG5vZGUgaW50byB0aGUgcmlnaHQgcG9zaXRpb24sIHByZXNlcnZpbmcgZm9jdXMgaWYgZWl0aGVyXG4gIC8vIG5vZGUgb3IgY3VycmVudE5vZGUgYXJlIGZvY3VzZWQgYnkgbWFraW5nIHN1cmUgdGhhdCB0aGV5IGFyZSBub3QgZGV0YWNoZWRcbiAgLy8gZnJvbSB0aGUgRE9NLlxuICBpZiAoZ2V0RGF0YShub2RlKS5mb2N1c2VkKSB7XG4gICAgLy8gTW92ZSBldmVyeXRoaW5nIGVsc2UgYmVmb3JlIHRoZSBub2RlLlxuICAgIG1vdmVCZWZvcmUoY3VycmVudFBhcmVudCwgbm9kZSwgY3VycmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlRGF0YSAmJiBjdXJyZW50Tm9kZURhdGEua2V5ICYmICFjdXJyZW50Tm9kZURhdGEuZm9jdXNlZCkge1xuICAgIC8vIFJlbW92ZSB0aGUgY3VycmVudE5vZGUsIHdoaWNoIGNhbiBhbHdheXMgYmUgYWRkZWQgYmFjayBzaW5jZSB3ZSBob2xkIGFcbiAgICAvLyByZWZlcmVuY2UgdGhyb3VnaCB0aGUga2V5TWFwLiBUaGlzIHByZXZlbnRzIGEgbGFyZ2UgbnVtYmVyIG9mIG1vdmVzIHdoZW5cbiAgICAvLyBhIGtleWVkIGl0ZW0gaXMgcmVtb3ZlZCBvciBtb3ZlZCBiYWNrd2FyZHMgaW4gdGhlIERPTS5cbiAgICBjdXJyZW50UGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCBjdXJyZW50Tm9kZSk7XG4gICAgcGFyZW50RGF0YS5rZXlNYXBWYWxpZCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgfVxuXG4gIGN1cnJlbnROb2RlID0gbm9kZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/Tm9kZX0gbm9kZVxuICogQHBhcmFtIHs/Tm9kZX0gY2hpbGRcbiAqIEBwYXJhbSB7P09iamVjdDxzdHJpbmcsICFFbGVtZW50Pn0ga2V5TWFwXG4gKi9cbnZhciByZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChub2RlLCBjaGlsZCwga2V5TWFwKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICBjb250ZXh0Lm1hcmtEZWxldGVkKCAvKiogQHR5cGUgeyFOb2RlfSovY2hpbGQpO1xuXG4gIHZhciBrZXkgPSBnZXREYXRhKGNoaWxkKS5rZXk7XG4gIGlmIChrZXkpIHtcbiAgICBkZWxldGUga2V5TWFwW2tleV07XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIG91dCBhbnkgdW52aXNpdGVkIE5vZGVzLCBhcyB0aGUgY29ycmVzcG9uZGluZyB2aXJ0dWFsIGVsZW1lbnRcbiAqIGZ1bmN0aW9ucyB3ZXJlIG5ldmVyIGNhbGxlZCBmb3IgdGhlbS5cbiAqL1xudmFyIGNsZWFyVW52aXNpdGVkRE9NID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHZhciBkYXRhID0gZ2V0RGF0YShub2RlKTtcbiAgdmFyIGtleU1hcCA9IGRhdGEua2V5TWFwO1xuICB2YXIga2V5TWFwVmFsaWQgPSBkYXRhLmtleU1hcFZhbGlkO1xuICB2YXIgY2hpbGQgPSBub2RlLmxhc3RDaGlsZDtcbiAgdmFyIGtleSA9IHVuZGVmaW5lZDtcblxuICBpZiAoY2hpbGQgPT09IGN1cnJlbnROb2RlICYmIGtleU1hcFZhbGlkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBjdXJyZW50Tm9kZSkge1xuICAgIHJlbW92ZUNoaWxkKG5vZGUsIGNoaWxkLCBrZXlNYXApO1xuICAgIGNoaWxkID0gbm9kZS5sYXN0Q2hpbGQ7XG4gIH1cblxuICAvLyBDbGVhbiB0aGUga2V5TWFwLCByZW1vdmluZyBhbnkgdW51c3VlZCBrZXlzLlxuICBpZiAoIWtleU1hcFZhbGlkKSB7XG4gICAgZm9yIChrZXkgaW4ga2V5TWFwKSB7XG4gICAgICBjaGlsZCA9IGtleU1hcFtrZXldO1xuICAgICAgaWYgKGNoaWxkLnBhcmVudE5vZGUgIT09IG5vZGUpIHtcbiAgICAgICAgY29udGV4dC5tYXJrRGVsZXRlZChjaGlsZCk7XG4gICAgICAgIGRlbGV0ZSBrZXlNYXBba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhLmtleU1hcFZhbGlkID0gdHJ1ZTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRvIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgY3VycmVudCBub2RlLlxuICovXG52YXIgZW50ZXJOb2RlID0gZnVuY3Rpb24gKCkge1xuICBjdXJyZW50UGFyZW50ID0gY3VycmVudE5vZGU7XG4gIGN1cnJlbnROb2RlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7P05vZGV9IFRoZSBuZXh0IE5vZGUgdG8gYmUgcGF0Y2hlZC5cbiAqL1xudmFyIGdldE5leHROb2RlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICByZXR1cm4gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGN1cnJlbnRQYXJlbnQuZmlyc3RDaGlsZDtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIHRvIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqL1xudmFyIG5leHROb2RlID0gZnVuY3Rpb24gKCkge1xuICBjdXJyZW50Tm9kZSA9IGdldE5leHROb2RlKCk7XG59O1xuXG4vKipcbiAqIENoYW5nZXMgdG8gdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudCBub2RlLCByZW1vdmluZyBhbnkgdW52aXNpdGVkIGNoaWxkcmVuLlxuICovXG52YXIgZXhpdE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIGNsZWFyVW52aXNpdGVkRE9NKCk7XG5cbiAgY3VycmVudE5vZGUgPSBjdXJyZW50UGFyZW50O1xuICBjdXJyZW50UGFyZW50ID0gY3VycmVudFBhcmVudC5wYXJlbnROb2RlO1xufTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIGN1cnJlbnQgbm9kZSBpcyBhbiBFbGVtZW50IHdpdGggYSBtYXRjaGluZyB0YWdOYW1lIGFuZFxuICoga2V5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbnZhciBjb3JlRWxlbWVudE9wZW4gPSBmdW5jdGlvbiAodGFnLCBrZXkpIHtcbiAgbmV4dE5vZGUoKTtcbiAgYWxpZ25XaXRoRE9NKHRhZywga2V5KTtcbiAgZW50ZXJOb2RlKCk7XG4gIHJldHVybiAoLyoqIEB0eXBlIHshRWxlbWVudH0gKi9jdXJyZW50UGFyZW50XG4gICk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY3VycmVudGx5IG9wZW4gRWxlbWVudCwgcmVtb3ZpbmcgYW55IHVudmlzaXRlZCBjaGlsZHJlbiBpZlxuICogbmVjZXNzYXJ5LlxuICpcbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgY29yZUVsZW1lbnRDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBzZXRJblNraXAoZmFsc2UpO1xuICB9XG5cbiAgZXhpdE5vZGUoKTtcbiAgcmV0dXJuICgvKiogQHR5cGUgeyFFbGVtZW50fSAqL2N1cnJlbnROb2RlXG4gICk7XG59O1xuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIFRleHQgbm9kZSBhbmQgY3JlYXRlcyBhIFRleHQgbm9kZSBpZiBpdCBpc1xuICogbm90LlxuICpcbiAqIEByZXR1cm4geyFUZXh0fSBUaGUgY29ycmVzcG9uZGluZyBUZXh0IE5vZGUuXG4gKi9cbnZhciBjb3JlVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgbmV4dE5vZGUoKTtcbiAgYWxpZ25XaXRoRE9NKCcjdGV4dCcsIG51bGwpO1xuICByZXR1cm4gKC8qKiBAdHlwZSB7IVRleHR9ICovY3VycmVudE5vZGVcbiAgKTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgY3VycmVudCBFbGVtZW50IGJlaW5nIHBhdGNoZWQuXG4gKiBAcmV0dXJuIHshRWxlbWVudH1cbiAqL1xudmFyIGN1cnJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydEluUGF0Y2goJ2N1cnJlbnRFbGVtZW50JywgY29udGV4dCk7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCdjdXJyZW50RWxlbWVudCcpO1xuICB9XG4gIHJldHVybiAoLyoqIEB0eXBlIHshRWxlbWVudH0gKi9jdXJyZW50UGFyZW50XG4gICk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge05vZGV9IFRoZSBOb2RlIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgZm9yIHRoZSBuZXh0IGluc3RydWN0aW9uLlxuICovXG52YXIgY3VycmVudFBvaW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0SW5QYXRjaCgnY3VycmVudFBvaW50ZXInLCBjb250ZXh0KTtcbiAgICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMoJ2N1cnJlbnRQb2ludGVyJyk7XG4gIH1cbiAgcmV0dXJuIGdldE5leHROb2RlKCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBjaGlsZHJlbiBpbiBhIHN1YnRyZWUsIGFsbG93aW5nIGFuIEVsZW1lbnQgdG8gYmUgY2xvc2VkIHdpdGhvdXRcbiAqIGNsZWFyaW5nIG91dCB0aGUgY2hpbGRyZW4uXG4gKi9cbnZhciBza2lwID0gZnVuY3Rpb24gKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE5vQ2hpbGRyZW5EZWNsYXJlZFlldCgnc2tpcCcsIGN1cnJlbnROb2RlKTtcbiAgICBzZXRJblNraXAodHJ1ZSk7XG4gIH1cbiAgY3VycmVudE5vZGUgPSBjdXJyZW50UGFyZW50Lmxhc3RDaGlsZDtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgTm9kZSB0byBiZSBwYXRjaGVkLCBtb3ZpbmcgdGhlIHBvaW50ZXIgZm9yd2FyZCB0byB0aGUgbmV4dFxuICogc2libGluZyBvZiB0aGUgY3VycmVudCBwb2ludGVyLlxuICovXG52YXIgc2tpcE5vZGUgPSBuZXh0Tm9kZTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSBUaGUgSW5jcmVtZW50YWwgRE9NIEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUy1JU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGNvbnN0ICovXG52YXIgc3ltYm9scyA9IHtcbiAgZGVmYXVsdDogJ19fZGVmYXVsdCdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge3N0cmluZ3x1bmRlZmluZWR9IFRoZSBuYW1lc3BhY2UgdG8gdXNlIGZvciB0aGUgYXR0cmlidXRlLlxuICovXG52YXIgZ2V0TmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKG5hbWUubGFzdEluZGV4T2YoJ3htbDonLCAwKSA9PT0gMCkge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJztcbiAgfVxuXG4gIGlmIChuYW1lLmxhc3RJbmRleE9mKCd4bGluazonLCAwKSA9PT0gMCkge1xuICAgIHJldHVybiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG4gIH1cbn07XG5cbi8qKlxuICogQXBwbGllcyBhbiBhdHRyaWJ1dGUgb3IgcHJvcGVydHkgdG8gYSBnaXZlbiBFbGVtZW50LiBJZiB0aGUgdmFsdWUgaXMgbnVsbFxuICogb3IgdW5kZWZpbmVkLCBpdCBpcyByZW1vdmVkIGZyb20gdGhlIEVsZW1lbnQuIE90aGVyd2lzZSwgdGhlIHZhbHVlIGlzIHNldFxuICogYXMgYW4gYXR0cmlidXRlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHs/KGJvb2xlYW58bnVtYmVyfHN0cmluZyk9fSB2YWx1ZSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gKi9cbnZhciBhcHBseUF0dHIgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBhdHRyTlMgPSBnZXROYW1lc3BhY2UobmFtZSk7XG4gICAgaWYgKGF0dHJOUykge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoYXR0ck5TLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBwcm9wZXJ0eSB0byBhIGdpdmVuIEVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIHByb3BlcnR5J3MgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHByb3BlcnR5J3MgdmFsdWUuXG4gKi9cbnZhciBhcHBseVByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGVsW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIHN0eWxlIGRlY2xhcmF0aW9uLiBTdXBwb3J0cyBDU1MgY3VzdG9tIHByb3BlcnRpZXMgYnlcbiAqIHNldHRpbmcgcHJvcGVydGllcyBjb250YWluaW5nIGEgZGFzaCB1c2luZyBDU1NTdHlsZURlY2xhcmF0aW9uLnNldFByb3BlcnR5LlxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZVxuICogQHBhcmFtIHshc3RyaW5nfSBwcm9wXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnZhciBzZXRTdHlsZVZhbHVlID0gZnVuY3Rpb24gKHN0eWxlLCBwcm9wLCB2YWx1ZSkge1xuICBpZiAocHJvcC5pbmRleE9mKCctJykgPj0gMCkge1xuICAgIHN0eWxlLnNldFByb3BlcnR5KHByb3AsIC8qKiBAdHlwZSB7c3RyaW5nfSAqL3ZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZVtwcm9wXSA9IHZhbHVlO1xuICB9XG59O1xuXG4vKipcbiAqIEFwcGxpZXMgYSBzdHlsZSB0byBhbiBFbGVtZW50LiBObyB2ZW5kb3IgcHJlZml4IGV4cGFuc2lvbiBpcyBkb25lIGZvclxuICogcHJvcGVydHkgbmFtZXMvdmFsdWVzLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBhdHRyaWJ1dGUncyBuYW1lLlxuICogQHBhcmFtIHsqfSBzdHlsZSBUaGUgc3R5bGUgdG8gc2V0LiBFaXRoZXIgYSBzdHJpbmcgb2YgY3NzIG9yIGFuIG9iamVjdFxuICogICAgIGNvbnRhaW5pbmcgcHJvcGVydHktdmFsdWUgcGFpcnMuXG4gKi9cbnZhciBhcHBseVN0eWxlID0gZnVuY3Rpb24gKGVsLCBuYW1lLCBzdHlsZSkge1xuICBpZiAodHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJykge1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSBzdHlsZTtcbiAgfSBlbHNlIHtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJyc7XG4gICAgdmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgICB2YXIgb2JqID0gLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZyxzdHJpbmc+fSAqL3N0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopIHtcbiAgICAgIGlmIChoYXMob2JqLCBwcm9wKSkge1xuICAgICAgICBzZXRTdHlsZVZhbHVlKGVsU3R5bGUsIHByb3AsIG9ialtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGFuIEVsZW1lbnQuXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCBvclxuICogICAgIGZ1bmN0aW9uIGl0IGlzIHNldCBvbiB0aGUgRWxlbWVudCwgb3RoZXJ3aXNlLCBpdCBpcyBzZXQgYXMgYW4gSFRNTFxuICogICAgIGF0dHJpYnV0ZS5cbiAqL1xudmFyIGFwcGx5QXR0cmlidXRlVHlwZWQgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlQcm9wKGVsLCBuYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlBdHRyKGVsLCBuYW1lLCAvKiogQHR5cGUgez8oYm9vbGVhbnxudW1iZXJ8c3RyaW5nKX0gKi92YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIGFwcHJvcHJpYXRlIGF0dHJpYnV0ZSBtdXRhdG9yIGZvciB0aGlzIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgYXR0cmlidXRlJ3MgbmFtZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICovXG52YXIgdXBkYXRlQXR0cmlidXRlID0gZnVuY3Rpb24gKGVsLCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldERhdGEoZWwpO1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuXG4gIGlmIChhdHRyc1tuYW1lXSA9PT0gdmFsdWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbXV0YXRvciA9IGF0dHJpYnV0ZXNbbmFtZV0gfHwgYXR0cmlidXRlc1tzeW1ib2xzLmRlZmF1bHRdO1xuICBtdXRhdG9yKGVsLCBuYW1lLCB2YWx1ZSk7XG5cbiAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQSBwdWJsaWNseSBtdXRhYmxlIG9iamVjdCB0byBwcm92aWRlIGN1c3RvbSBtdXRhdG9ycyBmb3IgYXR0cmlidXRlcy5cbiAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsIGZ1bmN0aW9uKCFFbGVtZW50LCBzdHJpbmcsICopPn1cbiAqL1xudmFyIGF0dHJpYnV0ZXMgPSBjcmVhdGVNYXAoKTtcblxuLy8gU3BlY2lhbCBnZW5lcmljIG11dGF0b3IgdGhhdCdzIGNhbGxlZCBmb3IgYW55IGF0dHJpYnV0ZSB0aGF0IGRvZXMgbm90XG4vLyBoYXZlIGEgc3BlY2lmaWMgbXV0YXRvci5cbmF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XSA9IGFwcGx5QXR0cmlidXRlVHlwZWQ7XG5cbmF0dHJpYnV0ZXNbJ3N0eWxlJ10gPSBhcHBseVN0eWxlO1xuXG4vKipcbiAqIFRoZSBvZmZzZXQgaW4gdGhlIHZpcnR1YWwgZWxlbWVudCBkZWNsYXJhdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlcyBhcmVcbiAqIHNwZWNpZmllZC5cbiAqIEBjb25zdFxuICovXG52YXIgQVRUUklCVVRFU19PRkZTRVQgPSAzO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgZm9yIHVzZSB3aXRoIGVsZW1lbnRPcGVuU3RhcnQsIGF0dHIgYW5kXG4gKiBlbGVtZW50T3BlbkVuZC5cbiAqIEBjb25zdCB7QXJyYXk8Kj59XG4gKi9cbnZhciBhcmdzQnVpbGRlciA9IFtdO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncywgQXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgYXR0cmlidXRlc1xuICogICAgIGZvciB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4geyFFbGVtZW50fSBUaGUgY29ycmVzcG9uZGluZyBFbGVtZW50LlxuICovXG52YXIgZWxlbWVudE9wZW4gPSBmdW5jdGlvbiAodGFnLCBrZXksIHN0YXRpY3MsIHZhcl9hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0Tm90SW5BdHRyaWJ1dGVzKCdlbGVtZW50T3BlbicpO1xuICAgIGFzc2VydE5vdEluU2tpcCgnZWxlbWVudE9wZW4nKTtcbiAgfVxuXG4gIHZhciBub2RlID0gY29yZUVsZW1lbnRPcGVuKHRhZywga2V5KTtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKG5vZGUpO1xuXG4gIGlmICghZGF0YS5zdGF0aWNzQXBwbGllZCkge1xuICAgIGlmIChzdGF0aWNzKSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc3RhdGljcy5sZW5ndGg7IF9pICs9IDIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSAvKiogQHR5cGUge3N0cmluZ30gKi9zdGF0aWNzW19pXTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGljc1tfaSArIDFdO1xuICAgICAgICB1cGRhdGVBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBEb3duIHRoZSByb2FkLCB3ZSBtYXkgd2FudCB0byBrZWVwIHRyYWNrIG9mIHRoZSBzdGF0aWNzIGFycmF5IHRvIHVzZSBpdFxuICAgIC8vIGFzIGFuIGFkZGl0aW9uYWwgc2lnbmFsIGFib3V0IHdoZXRoZXIgYSBub2RlIG1hdGNoZXMgb3Igbm90LiBGb3Igbm93LFxuICAgIC8vIGp1c3QgdXNlIGEgbWFya2VyIHNvIHRoYXQgd2UgZG8gbm90IHJlYXBwbHkgc3RhdGljcy5cbiAgICBkYXRhLnN0YXRpY3NBcHBsaWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qXG4gICAqIENoZWNrcyB0byBzZWUgaWYgb25lIG9yIG1vcmUgYXR0cmlidXRlcyBoYXZlIGNoYW5nZWQgZm9yIGEgZ2l2ZW4gRWxlbWVudC5cbiAgICogV2hlbiBubyBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCwgdGhpcyBpcyBtdWNoIGZhc3RlciB0aGFuIGNoZWNraW5nIGVhY2hcbiAgICogaW5kaXZpZHVhbCBhcmd1bWVudC4gV2hlbiBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZCwgdGhlIG92ZXJoZWFkIG9mIHRoaXMgaXNcbiAgICogbWluaW1hbC5cbiAgICovXG4gIHZhciBhdHRyc0FyciA9IGRhdGEuYXR0cnNBcnI7XG4gIHZhciBuZXdBdHRycyA9IGRhdGEubmV3QXR0cnM7XG4gIHZhciBpc05ldyA9ICFhdHRyc0Fyci5sZW5ndGg7XG4gIHZhciBpID0gQVRUUklCVVRFU19PRkZTRVQ7XG4gIHZhciBqID0gMDtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMiwgaiArPSAyKSB7XG4gICAgdmFyIF9hdHRyID0gYXJndW1lbnRzW2ldO1xuICAgIGlmIChpc05ldykge1xuICAgICAgYXR0cnNBcnJbal0gPSBfYXR0cjtcbiAgICAgIG5ld0F0dHJzW19hdHRyXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKGF0dHJzQXJyW2pdICE9PSBfYXR0cikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICBpZiAoaXNOZXcgfHwgYXR0cnNBcnJbaiArIDFdICE9PSB2YWx1ZSkge1xuICAgICAgYXR0cnNBcnJbaiArIDFdID0gdmFsdWU7XG4gICAgICB1cGRhdGVBdHRyaWJ1dGUobm9kZSwgX2F0dHIsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaSA8IGFyZ3VtZW50cy5sZW5ndGggfHwgaiA8IGF0dHJzQXJyLmxlbmd0aCkge1xuICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxLCBqICs9IDEpIHtcbiAgICAgIGF0dHJzQXJyW2pdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGlmIChqIDwgYXR0cnNBcnIubGVuZ3RoKSB7XG4gICAgICBhdHRyc0Fyci5sZW5ndGggPSBqO1xuICAgIH1cblxuICAgIC8qXG4gICAgICogQWN0dWFsbHkgcGVyZm9ybSB0aGUgYXR0cmlidXRlIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cnNBcnIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBuYW1lID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovYXR0cnNBcnJbaV07XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyc0FycltpICsgMV07XG4gICAgICBuZXdBdHRyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIF9hdHRyMiBpbiBuZXdBdHRycykge1xuICAgICAgdXBkYXRlQXR0cmlidXRlKG5vZGUsIF9hdHRyMiwgbmV3QXR0cnNbX2F0dHIyXSk7XG4gICAgICBuZXdBdHRyc1tfYXR0cjJdID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHZpcnR1YWwgRWxlbWVudCBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuIFRoaXNcbiAqIGNvcnJlc3BvbmRzIHRvIGFuIG9wZW5pbmcgdGFnIGFuZCBhIGVsZW1lbnRDbG9zZSB0YWcgaXMgcmVxdWlyZWQuIFRoaXMgaXNcbiAqIGxpa2UgZWxlbWVudE9wZW4sIGJ1dCB0aGUgYXR0cmlidXRlcyBhcmUgZGVmaW5lZCB1c2luZyB0aGUgYXR0ciBmdW5jdGlvblxuICogcmF0aGVyIHRoYW4gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50cy4gTXVzdCBiZSBmb2xsbG93ZWQgYnkgMCBvciBtb3JlIGNhbGxzXG4gKiB0byBhdHRyLCB0aGVuIGEgY2FsbCB0byBlbGVtZW50T3BlbkVuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICovXG52YXIgZWxlbWVudE9wZW5TdGFydCA9IGZ1bmN0aW9uICh0YWcsIGtleSwgc3RhdGljcykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGFzc2VydE5vdEluQXR0cmlidXRlcygnZWxlbWVudE9wZW5TdGFydCcpO1xuICAgIHNldEluQXR0cmlidXRlcyh0cnVlKTtcbiAgfVxuXG4gIGFyZ3NCdWlsZGVyWzBdID0gdGFnO1xuICBhcmdzQnVpbGRlclsxXSA9IGtleTtcbiAgYXJnc0J1aWxkZXJbMl0gPSBzdGF0aWNzO1xufTtcblxuLyoqKlxuICogRGVmaW5lcyBhIHZpcnR1YWwgYXR0cmlidXRlIGF0IHRoaXMgcG9pbnQgb2YgdGhlIERPTS4gVGhpcyBpcyBvbmx5IHZhbGlkXG4gKiB3aGVuIGNhbGxlZCBiZXR3ZWVuIGVsZW1lbnRPcGVuU3RhcnQgYW5kIGVsZW1lbnRPcGVuRW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbnZhciBhdHRyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0SW5BdHRyaWJ1dGVzKCdhdHRyJyk7XG4gIH1cblxuICBhcmdzQnVpbGRlci5wdXNoKG5hbWUpO1xuICBhcmdzQnVpbGRlci5wdXNoKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIGFuIG9wZW4gdGFnIHN0YXJ0ZWQgd2l0aCBlbGVtZW50T3BlblN0YXJ0LlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbnZhciBlbGVtZW50T3BlbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRJbkF0dHJpYnV0ZXMoJ2VsZW1lbnRPcGVuRW5kJyk7XG4gICAgc2V0SW5BdHRyaWJ1dGVzKGZhbHNlKTtcbiAgfVxuXG4gIHZhciBub2RlID0gZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJnc0J1aWxkZXIpO1xuICBhcmdzQnVpbGRlci5sZW5ndGggPSAwO1xuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIGFuIG9wZW4gdmlydHVhbCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcmV0dXJuIHshRWxlbWVudH0gVGhlIGNvcnJlc3BvbmRpbmcgRWxlbWVudC5cbiAqL1xudmFyIGVsZW1lbnRDbG9zZSA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMoJ2VsZW1lbnRDbG9zZScpO1xuICB9XG5cbiAgdmFyIG5vZGUgPSBjb3JlRWxlbWVudENsb3NlKCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRDbG9zZU1hdGNoZXNPcGVuVGFnKGdldERhdGEobm9kZSkubm9kZU5hbWUsIHRhZyk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50IHRoYXQgaGFzXG4gKiBubyBjaGlsZHJlbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGVsZW1lbnQncyB0YWcuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBhdHRyaWJ1dGVzXG4gKiAgICAgZm9yIHRoZSBFbGVtZW50LlxuICogQHJldHVybiB7IUVsZW1lbnR9IFRoZSBjb3JyZXNwb25kaW5nIEVsZW1lbnQuXG4gKi9cbnZhciBlbGVtZW50Vm9pZCA9IGZ1bmN0aW9uICh0YWcsIGtleSwgc3RhdGljcywgdmFyX2FyZ3MpIHtcbiAgZWxlbWVudE9wZW4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGVsZW1lbnRDbG9zZSh0YWcpO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHZpcnR1YWwgVGV4dCBhdCB0aGlzIHBvaW50IGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8Ym9vbGVhbn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBUZXh0LlxuICogQHBhcmFtIHsuLi4oZnVuY3Rpb24oKHN0cmluZ3xudW1iZXJ8Ym9vbGVhbikpOnN0cmluZyl9IHZhcl9hcmdzXG4gKiAgICAgRnVuY3Rpb25zIHRvIGZvcm1hdCB0aGUgdmFsdWUgd2hpY2ggYXJlIGNhbGxlZCBvbmx5IHdoZW4gdGhlIHZhbHVlIGhhc1xuICogICAgIGNoYW5nZWQuXG4gKiBAcmV0dXJuIHshVGV4dH0gVGhlIGNvcnJlc3BvbmRpbmcgdGV4dCBub2RlLlxuICovXG52YXIgdGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSwgdmFyX2FyZ3MpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnROb3RJbkF0dHJpYnV0ZXMoJ3RleHQnKTtcbiAgICBhc3NlcnROb3RJblNraXAoJ3RleHQnKTtcbiAgfVxuXG4gIHZhciBub2RlID0gY29yZVRleHQoKTtcbiAgdmFyIGRhdGEgPSBnZXREYXRhKG5vZGUpO1xuXG4gIGlmIChkYXRhLnRleHQgIT09IHZhbHVlKSB7XG4gICAgZGF0YS50ZXh0ID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovdmFsdWU7XG5cbiAgICB2YXIgZm9ybWF0dGVkID0gdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIC8qXG4gICAgICAgKiBDYWxsIHRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24gZGlyZWN0bHkgdG8gcHJldmVudCBsZWFraW5nIGFyZ3VtZW50cy5cbiAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvaW5jcmVtZW50YWwtZG9tL3B1bGwvMjA0I2lzc3VlY29tbWVudC0xNzgyMjM1NzRcbiAgICAgICAqL1xuICAgICAgdmFyIGZuID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9ybWF0dGVkID0gZm4oZm9ybWF0dGVkKTtcbiAgICB9XG5cbiAgICBub2RlLmRhdGEgPSBmb3JtYXR0ZWQ7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn07XG5cbmV4cG9ydHMucGF0Y2ggPSBwYXRjaElubmVyO1xuZXhwb3J0cy5wYXRjaElubmVyID0gcGF0Y2hJbm5lcjtcbmV4cG9ydHMucGF0Y2hPdXRlciA9IHBhdGNoT3V0ZXI7XG5leHBvcnRzLmN1cnJlbnRFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG5leHBvcnRzLmN1cnJlbnRQb2ludGVyID0gY3VycmVudFBvaW50ZXI7XG5leHBvcnRzLnNraXAgPSBza2lwO1xuZXhwb3J0cy5za2lwTm9kZSA9IHNraXBOb2RlO1xuZXhwb3J0cy5lbGVtZW50Vm9pZCA9IGVsZW1lbnRWb2lkO1xuZXhwb3J0cy5lbGVtZW50T3BlblN0YXJ0ID0gZWxlbWVudE9wZW5TdGFydDtcbmV4cG9ydHMuZWxlbWVudE9wZW5FbmQgPSBlbGVtZW50T3BlbkVuZDtcbmV4cG9ydHMuZWxlbWVudE9wZW4gPSBlbGVtZW50T3BlbjtcbmV4cG9ydHMuZWxlbWVudENsb3NlID0gZWxlbWVudENsb3NlO1xuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmV4cG9ydHMuYXR0ciA9IGF0dHI7XG5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuZXhwb3J0cy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbmV4cG9ydHMuYXBwbHlBdHRyID0gYXBwbHlBdHRyO1xuZXhwb3J0cy5hcHBseVByb3AgPSBhcHBseVByb3A7XG5leHBvcnRzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuZXhwb3J0cy5pbXBvcnROb2RlID0gaW1wb3J0Tm9kZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5jcmVtZW50YWwtZG9tLWNqcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pbmNyZW1lbnRhbC1kb20vZGlzdC9pbmNyZW1lbnRhbC1kb20tY2pzLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuSW5jcmVtZW50YWxET00gPSBnbG9iYWwuSW5jcmVtZW50YWxET00gfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQW4gYXJyYXkgdXNlZCB0byBzdG9yZSB0aGUgc3RyaW5ncyBnZW5lcmF0ZWQgYnkgY2FsbHMgdG9cbiAqIGVsZW1lbnRPcGVuLCBlbGVtZW50T3BlblN0YXJ0LCBlbGVtZW50T3BlbkVuZCwgZWxlbWVudEVuZCBhbmQgZWxlbWVudFZvaWRcbiAqL1xuZXhwb3J0cy5idWZmZXIgPSBbXTtcblxuLyoqIEB0eXBlIHs/T2JqZWN0fSAqL1xuZXhwb3J0cy5jdXJyZW50UGFyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBjdXJyZW50IEVsZW1lbnQgYmVpbmcgcGF0Y2hlZC5cbiAqIEByZXR1cm4geyFFbGVtZW50fVxuICovXG52YXIgY3VycmVudEVsZW1lbnQgPSBmdW5jdGlvbiBjdXJyZW50RWxlbWVudCgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY3VycmVudFBhcmVudDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7Tm9kZX0gVGhlIE5vZGUgdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBmb3IgdGhlIG5leHQgaW5zdHJ1Y3Rpb24uXG4gKi9cbnZhciBjdXJyZW50UG9pbnRlciA9IGZ1bmN0aW9uIGN1cnJlbnRQb2ludGVyKCkge1xuICByZXR1cm4ge307XG59O1xuXG4vKipcbiAqIFBhdGNoZXMgYW4gRWxlbWVudCB3aXRoIHRoZSB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uIEV4YWN0bHkgb25lIHRvcCBsZXZlbFxuICogZWxlbWVudCBjYWxsIHNob3VsZCBiZSBtYWRlIGNvcnJlc3BvbmRpbmcgdG8gYG5vZGVgLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbm9kZSBUaGUgRWxlbWVudCB3aGVyZSB0aGUgcGF0Y2ggc2hvdWxkIHN0YXJ0LlxuICogQHBhcmFtIHshZnVuY3Rpb24oVCl9IGZuIEEgZnVuY3Rpb24gY29udGFpbmluZyBvcGVuL2Nsb3NlL2V0Yy4gY2FsbHMgdGhhdFxuICogICAgIGRlc2NyaWJlIHRoZSBET00uIFRoaXMgc2hvdWxkIGhhdmUgYXQgbW9zdCBvbmUgdG9wIGxldmVsIGVsZW1lbnQgY2FsbC5cbiAqIEBwYXJhbSB7VD19IGRhdGEgQW4gYXJndW1lbnQgcGFzc2VkIHRvIGZuIHRvIHJlcHJlc2VudCBET00gc3RhdGUuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG52YXIgcGF0Y2ggPSBmdW5jdGlvbiBwYXRjaChub2RlLCBmbiwgZGF0YSkge1xuICBleHBvcnRzLmN1cnJlbnRQYXJlbnQgPSBub2RlO1xuICBmbihkYXRhKTtcbiAgZXhwb3J0cy5jdXJyZW50UGFyZW50LmlubmVySFRNTCA9IGV4cG9ydHMuYnVmZmVyLmpvaW4oJycpO1xuICBleHBvcnRzLmJ1ZmZlciA9IFtdO1xuICByZXR1cm4gZXhwb3J0cy5jdXJyZW50UGFyZW50O1xufTtcblxudmFyIHBhdGNoT3V0ZXIgPSBwYXRjaDtcbnZhciBwYXRjaElubmVyID0gcGF0Y2g7XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIFRleHQgYXQgdGhpcyBwb2ludCBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfGJvb2xlYW59IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgVGV4dC5cbiAqIEBwYXJhbSB7Li4uKGZ1bmN0aW9uKChzdHJpbmd8bnVtYmVyfGJvb2xlYW4pKTpzdHJpbmcpfSB2YXJfYXJnc1xuICogICAgIEZ1bmN0aW9ucyB0byBmb3JtYXQgdGhlIHZhbHVlIHdoaWNoIGFyZSBjYWxsZWQgb25seSB3aGVuIHRoZSB2YWx1ZSBoYXNcbiAqICAgICBjaGFuZ2VkLlxuICpcbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciB0ZXh0ID0gZnVuY3Rpb24gdGV4dCh2YWx1ZSwgdmFyX2FyZ3MpIHtcbiAgdmFyIGZvcm1hdHRlZCA9IHZhbHVlO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBmbiA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3JtYXR0ZWQgPSBmbihmb3JtYXR0ZWQpO1xuICB9XG4gIGV4cG9ydHMuYnVmZmVyLnB1c2goZm9ybWF0dGVkKTtcbn07XG5cbi8qKiBAY29uc3QgKi9cbnZhciBzeW1ib2xzID0ge1xuICBkZWZhdWx0OiAnX19kZWZhdWx0J1xufTtcblxuLyoqIEBjb25zdCAqL1xudmFyIGF0dHJpYnV0ZXMgPSB7fTtcblxuLyoqXG4gKiBDYWxscyB0aGUgYXBwcm9wcmlhdGUgYXR0cmlidXRlIG11dGF0b3IgZm9yIHRoaXMgYXR0cmlidXRlLlxuICogQHBhcmFtIHshQXJyYXkuPHN0cmluZz59IGVsIEJ1ZmZlciB0byBhcHBlbmQgZWxlbWVudCBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAqL1xudmFyIHVwZGF0ZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZShlbCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIG11dGF0b3IgPSBhdHRyaWJ1dGVzW25hbWVdIHx8IGF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XTtcbiAgbXV0YXRvcihlbCwgbmFtZSwgdmFsdWUpO1xufTtcblxuLy8gU3BlY2lhbCBnZW5lcmljIG11dGF0b3IgdGhhdCdzIGNhbGxlZCBmb3IgYW55IGF0dHJpYnV0ZSB0aGF0IGRvZXMgbm90XG4vLyBoYXZlIGEgc3BlY2lmaWMgbXV0YXRvci5cbmF0dHJpYnV0ZXNbc3ltYm9scy5kZWZhdWx0XSA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZWwpKSB7XG4gICAgZWwucHVzaCgnICcgKyBuYW1lICsgJz1cIicgKyB2YWx1ZSArICdcIicpO1xuICB9XG59O1xuXG4vKipcbiAqIFRydW5jYXRlcyBhbiBhcnJheSwgcmVtb3ZpbmcgaXRlbXMgdXAgdW50aWwgbGVuZ3RoLlxuICogQHBhcmFtIHshQXJyYXk8Kj59IGFyciBUaGUgYXJyYXkgdG8gdHJ1bmNhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAqL1xudmFyIHRydW5jYXRlQXJyYXkgPSBmdW5jdGlvbiB0cnVuY2F0ZUFycmF5KGFyciwgbGVuZ3RoKSB7XG4gIHdoaWxlIChhcnIubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgYXJyLnBvcCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFRoZSBvZmZzZXQgaW4gdGhlIHZpcnR1YWwgZWxlbWVudCBkZWNsYXJhdGlvbiB3aGVyZSB0aGUgYXR0cmlidXRlcyBhcmVcbiAqIHNwZWNpZmllZC5cbiAqIEBjb25zdFxuICovXG52YXIgQVRUUklCVVRFU19PRkZTRVQgPSAzO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBhcnJheSBvZiBhcmd1bWVudHMgZm9yIHVzZSB3aXRoIGVsZW1lbnRPcGVuU3RhcnQsIGF0dHIgYW5kXG4gKiBlbGVtZW50T3BlbkVuZC5cbiAqIEBjb25zdCB7IUFycmF5PCo+fVxuICovXG52YXIgYXJnc0J1aWxkZXIgPSBbXTtcblxuLyoqXG4gKiBEZWZpbmVzIGEgdmlydHVhbCBhdHRyaWJ1dGUgYXQgdGhpcyBwb2ludCBvZiB0aGUgRE9NLiBUaGlzIGlzIG9ubHkgdmFsaWRcbiAqIHdoZW4gY2FsbGVkIGJldHdlZW4gZWxlbWVudE9wZW5TdGFydCBhbmQgZWxlbWVudE9wZW5FbmQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGF0dHJpYnV0ZSdzIG5hbWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciBhdHRyID0gZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSkge1xuICBhcmdzQnVpbGRlci5wdXNoKG5hbWUpO1xuICBhcmdzQnVpbGRlci5wdXNoKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIGFuIG9wZW4gdmlydHVhbCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgRWxlbWVudCdzIHRhZy5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciBlbGVtZW50Q2xvc2UgPSBmdW5jdGlvbiBlbGVtZW50Q2xvc2UobmFtZU9yQ3Rvcikge1xuICBpZiAodHlwZW9mIG5hbWVPckN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBuZXcgbmFtZU9yQ3RvcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBleHBvcnRzLmJ1ZmZlci5wdXNoKCc8LycgKyBuYW1lT3JDdG9yICsgJz4nKTtcbn07XG5cbi8qKlxuICogRGVjbGFyZXMgYSB2aXJ0dWFsIEVsZW1lbnQgYXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50IHRoYXQgaGFzXG4gKiBubyBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gVGhlIEVsZW1lbnQncyB0YWcgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncyBBdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBhdHRyaWJ1dGVzXG4gKiAgICAgZm9yIHRoZSBFbGVtZW50LlxuICogQHJldHVybiB7dm9pZH0gTm90aGluZy5cbiAqL1xudmFyIGVsZW1lbnRWb2lkID0gZnVuY3Rpb24gZWxlbWVudFZvaWQobmFtZU9yQ3Rvciwga2V5LCBzdGF0aWNzLCB2YXJfYXJncykge1xuICBlbGVtZW50T3Blbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gZWxlbWVudENsb3NlKG5hbWVPckN0b3IpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVPckN0b3IgVGhlIEVsZW1lbnQncyB0YWcgb3IgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBrZXkgVGhlIGtleSB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgZWxlbWVudC4gVGhpcyBjYW4gYmUgYW5cbiAqICAgICBlbXB0eSBzdHJpbmcsIGJ1dCBwZXJmb3JtYW5jZSBtYXkgYmUgYmV0dGVyIGlmIGEgdW5pcXVlIHZhbHVlIGlzIHVzZWRcbiAqICAgICB3aGVuIGl0ZXJhdGluZyBvdmVyIGFuIGFycmF5IG9mIGl0ZW1zLlxuICogQHBhcmFtIHs/QXJyYXk8Kj49fSBzdGF0aWNzIEFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIG9mIHRoZVxuICogICAgIHN0YXRpYyBhdHRyaWJ1dGVzIGZvciB0aGUgRWxlbWVudC4gVGhlc2Ugd2lsbCBvbmx5IGJlIHNldCBvbmNlIHdoZW4gdGhlXG4gKiAgICAgRWxlbWVudCBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHsuLi4qfSB2YXJfYXJncywgQXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgYXR0cmlidXRlc1xuICogICAgIGZvciB0aGUgRWxlbWVudC5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciBlbGVtZW50T3BlbiA9IGZ1bmN0aW9uIGVsZW1lbnRPcGVuKG5hbWVPckN0b3IsIGtleSwgc3RhdGljcywgdmFyX2FyZ3MpIHtcbiAgaWYgKHR5cGVvZiBuYW1lT3JDdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgbmV3IG5hbWVPckN0b3IoKTtcbiAgICByZXR1cm4gZXhwb3J0cy5jdXJyZW50UGFyZW50O1xuICB9XG5cbiAgZXhwb3J0cy5idWZmZXIucHVzaCgnPCcgKyBuYW1lT3JDdG9yKTtcblxuICBpZiAoc3RhdGljcykge1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBzdGF0aWNzLmxlbmd0aDsgX2kgKz0gMikge1xuICAgICAgdmFyIG5hbWUgPSAvKiogQHR5cGUge3N0cmluZ30gKi9zdGF0aWNzW19pXTtcbiAgICAgIHZhciB2YWx1ZSA9IHN0YXRpY3NbX2kgKyAxXTtcbiAgICAgIHVwZGF0ZUF0dHJpYnV0ZShleHBvcnRzLmJ1ZmZlciwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpID0gQVRUUklCVVRFU19PRkZTRVQ7XG4gIHZhciBqID0gMDtcblxuICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKz0gMiwgaiArPSAyKSB7XG4gICAgdmFyIF9uYW1lID0gYXJndW1lbnRzW2ldO1xuICAgIHZhciBfdmFsdWUgPSBhcmd1bWVudHNbaSArIDFdO1xuICAgIHVwZGF0ZUF0dHJpYnV0ZShleHBvcnRzLmJ1ZmZlciwgX25hbWUsIF92YWx1ZSk7XG4gIH1cblxuICBleHBvcnRzLmJ1ZmZlci5wdXNoKCc+Jyk7XG5cbiAgcmV0dXJuIGV4cG9ydHMuY3VycmVudFBhcmVudDtcbn07XG5cbi8qKlxuICogQ2xvc2VzIGFuIG9wZW4gdGFnIHN0YXJ0ZWQgd2l0aCBlbGVtZW50T3BlblN0YXJ0LlxuICpcbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciBlbGVtZW50T3BlbkVuZCA9IGZ1bmN0aW9uIGVsZW1lbnRPcGVuRW5kKCkge1xuICBlbGVtZW50T3Blbi5hcHBseShudWxsLCBhcmdzQnVpbGRlcik7XG4gIHRydW5jYXRlQXJyYXkoYXJnc0J1aWxkZXIsIDApO1xufTtcblxuLyoqXG4gKiBEZWNsYXJlcyBhIHZpcnR1YWwgRWxlbWVudCBhdCB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuIFRoaXNcbiAqIGNvcnJlc3BvbmRzIHRvIGFuIG9wZW5pbmcgdGFnIGFuZCBhIGVsZW1lbnRDbG9zZSB0YWcgaXMgcmVxdWlyZWQuIFRoaXMgaXNcbiAqIGxpa2UgZWxlbWVudE9wZW4sIGJ1dCB0aGUgYXR0cmlidXRlcyBhcmUgZGVmaW5lZCB1c2luZyB0aGUgYXR0ciBmdW5jdGlvblxuICogcmF0aGVyIHRoYW4gYmVpbmcgcGFzc2VkIGFzIGFyZ3VtZW50cy4gTXVzdCBiZSBmb2xsbG93ZWQgYnkgMCBvciBtb3JlIGNhbGxzXG4gKiB0byBhdHRyLCB0aGVuIGEgY2FsbCB0byBlbGVtZW50T3BlbkVuZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lT3JDdG9yIFRoZSBFbGVtZW50J3MgdGFnIG9yIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHs/c3RyaW5nPX0ga2V5IFRoZSBrZXkgdXNlZCB0byBpZGVudGlmeSB0aGlzIGVsZW1lbnQuIFRoaXMgY2FuIGJlIGFuXG4gKiAgICAgZW1wdHkgc3RyaW5nLCBidXQgcGVyZm9ybWFuY2UgbWF5IGJlIGJldHRlciBpZiBhIHVuaXF1ZSB2YWx1ZSBpcyB1c2VkXG4gKiAgICAgd2hlbiBpdGVyYXRpbmcgb3ZlciBhbiBhcnJheSBvZiBpdGVtcy5cbiAqIEBwYXJhbSB7P0FycmF5PCo+PX0gc3RhdGljcyBBbiBhcnJheSBvZiBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBvZiB0aGVcbiAqICAgICBzdGF0aWMgYXR0cmlidXRlcyBmb3IgdGhlIEVsZW1lbnQuIFRoZXNlIHdpbGwgb25seSBiZSBzZXQgb25jZSB3aGVuIHRoZVxuICogICAgIEVsZW1lbnQgaXMgY3JlYXRlZC5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbnZhciBlbGVtZW50T3BlblN0YXJ0ID0gZnVuY3Rpb24gZWxlbWVudE9wZW5TdGFydChuYW1lT3JDdG9yLCBrZXksIHN0YXRpY3MpIHtcbiAgYXJnc0J1aWxkZXJbMF0gPSBuYW1lT3JDdG9yO1xuICBhcmdzQnVpbGRlclsxXSA9IGtleTtcbiAgYXJnc0J1aWxkZXJbMl0gPSBzdGF0aWNzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RyZWQgRE9NIHN0cmluZyBhdCB0aGlzIHBvaW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbnN0cnVjdGVkIERPTSBzdHJpbmcuXG4gKi9cbnZhciByZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nKGZuKSB7XG4gIHBhdGNoKHt9LCBmbik7XG4gIHJldHVybiBjdXJyZW50RWxlbWVudCgpLmlubmVySFRNTDtcbn07XG5cbmV4cG9ydHMuY3VycmVudEVsZW1lbnQgPSBjdXJyZW50RWxlbWVudDtcbmV4cG9ydHMuY3VycmVudFBvaW50ZXIgPSBjdXJyZW50UG9pbnRlcjtcbmV4cG9ydHMucGF0Y2ggPSBwYXRjaDtcbmV4cG9ydHMucGF0Y2hJbm5lciA9IHBhdGNoSW5uZXI7XG5leHBvcnRzLnBhdGNoT3V0ZXIgPSBwYXRjaE91dGVyO1xuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmV4cG9ydHMuYXR0ciA9IGF0dHI7XG5leHBvcnRzLmVsZW1lbnRDbG9zZSA9IGVsZW1lbnRDbG9zZTtcbmV4cG9ydHMuZWxlbWVudE9wZW4gPSBlbGVtZW50T3BlbjtcbmV4cG9ydHMuZWxlbWVudE9wZW5FbmQgPSBlbGVtZW50T3BlbkVuZDtcbmV4cG9ydHMuZWxlbWVudE9wZW5TdGFydCA9IGVsZW1lbnRPcGVuU3RhcnQ7XG5leHBvcnRzLmVsZW1lbnRWb2lkID0gZWxlbWVudFZvaWQ7XG5leHBvcnRzLnJlbmRlclRvU3RyaW5nID0gcmVuZGVyVG9TdHJpbmc7XG5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuZXhwb3J0cy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbmV4cG9ydHMudXBkYXRlQXR0cmlidXRlID0gdXBkYXRlQXR0cmlidXRlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaW5jcmVtZW50YWwtZG9tLXN0cmluZy9kaXN0L2luY3JlbWVudGFsLWRvbS1zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDg3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY29yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBjb25zdFxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5hYnN0cmFjdE1ldGhvZCA9IGFic3RyYWN0TWV0aG9kO1xuZXhwb3J0cy5kaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUgPSBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmVuYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGU7XG5leHBvcnRzLmdldENvbXBhdGliaWxpdHlNb2RlRGF0YSA9IGdldENvbXBhdGliaWxpdHlNb2RlRGF0YTtcbmV4cG9ydHMuZ2V0RnVuY3Rpb25OYW1lID0gZ2V0RnVuY3Rpb25OYW1lO1xuZXhwb3J0cy5nZXRTdGF0aWNQcm9wZXJ0eSA9IGdldFN0YXRpY1Byb3BlcnR5O1xuZXhwb3J0cy5nZXRVaWQgPSBnZXRVaWQ7XG5leHBvcnRzLmlkZW50aXR5RnVuY3Rpb24gPSBpZGVudGl0eUZ1bmN0aW9uO1xuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5leHBvcnRzLmlzRGVmID0gaXNEZWY7XG5leHBvcnRzLmlzRGVmQW5kTm90TnVsbCA9IGlzRGVmQW5kTm90TnVsbDtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzRG9jdW1lbnRGcmFnbWVudCA9IGlzRG9jdW1lbnRGcmFnbWVudDtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuZXhwb3J0cy5pc1dpbmRvdyA9IGlzV2luZG93O1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzU2VydmVyU2lkZSA9IGlzU2VydmVyU2lkZTtcbmV4cG9ydHMubnVsbEZ1bmN0aW9uID0gbnVsbEZ1bmN0aW9uO1xudmFyIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB2b2lkIDA7XG5cbi8qKlxuICogQ291bnRlciBmb3IgdW5pcXVlIGlkLlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1bmlxdWVJZENvdW50ZXJfID0gMTtcblxuLyoqXG4gKiBVbmlxdWUgaWQgcHJvcGVydHkgcHJlZml4LlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBwcm90ZWN0ZWRcbiAqL1xudmFyIFVJRF9QUk9QRVJUWSA9IGV4cG9ydHMuVUlEX1BST1BFUlRZID0gJ2NvcmVfJyArIChNYXRoLnJhbmRvbSgpICogMWU5ID4+PiAwKTtcblxuLyoqXG4gKiBXaGVuIGRlZmluaW5nIGEgY2xhc3MgRm9vIHdpdGggYW4gYWJzdHJhY3QgbWV0aG9kIGJhcigpLCB5b3UgY2FuIGRvOlxuICogRm9vLnByb3RvdHlwZS5iYXIgPSBhYnN0cmFjdE1ldGhvZFxuICpcbiAqIE5vdyBpZiBhIHN1YmNsYXNzIG9mIEZvbyBmYWlscyB0byBvdmVycmlkZSBiYXIoKSwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cbiAqIHdoZW4gYmFyKCkgaXMgaW52b2tlZC5cbiAqXG4gKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBhYnN0cmFjdE1ldGhvZCgpIHtcbiAgdGhyb3cgRXJyb3IoJ1VuaW1wbGVtZW50ZWQgYWJzdHJhY3QgbWV0aG9kJyk7XG59XG5cbi8qKlxuICogRGlzYWJsZXMgTWV0YWwuanMncyBjb21wYXRpYmlsaXR5IG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBFbmFibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlIHdpdGggdGhlIGZvbGxvd2luZyBmZWF0dXJlcyBmcm9tIHJjXG4gKiBhbmQgMS54IHZlcnNpb25zOlxuICogICAgIC0gVXNpbmcgXCJrZXlcIiB0byByZWZlcmVuY2UgY29tcG9uZW50IGluc3RhbmNlcy4gSW4gdGhlIGN1cnJlbnQgdmVyc2lvblxuICogICAgICAgdGhpcyBzaG91bGQgYmUgZG9uZSB2aWEgXCJyZWZcIiBpbnN0ZWFkLiBUaGlzIGFsbG93cyBvbGQgY29kZSBzdGlsbFxuICogICAgICAgdXNpbmcgXCJrZXlcIiB0byBrZWVwIHdvcmtpbmcgbGlrZSBiZWZvcmUuIE5PVEU6IHRoaXMgbWF5IGNhdXNlXG4gKiAgICAgICBwcm9ibGVtcywgc2luY2UgXCJrZXlcIiBpcyBtZWFudCB0byBiZSB1c2VkIGRpZmZlcmVudGx5LiBPbmx5IHVzZSB0aGlzXG4gKiAgICAgICBpZiBpdCdzIG5vdCBwb3NzaWJsZSB0byB1cGdyYWRlIHRoZSBjb2RlIHRvIHVzZSBcInJlZlwiIGluc3RlYWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9kYXRhIE9wdGlvbmFsIG9iamVjdCB3aXRoIGRhdGEgdG8gc3BlY2lmeSBtb3JlXG4gKiAgICAgZGV0YWlscywgc3VjaCBhczpcbiAqICAgICAgICAgLSByZW5kZXJlcnMge0FycmF5fSB0aGUgdGVtcGxhdGUgcmVuZGVyZXJzIHRoYXQgc2hvdWxkIGJlIGluXG4gKiAgICAgICAgICAgY29tcGF0aWJpbGl0eSBtb2RlLCBlaXRoZXIgdGhlaXIgY29uc3RydWN0b3JzIG9yIHN0cmluZ3NcbiAqICAgICAgICAgICByZXByZXNlbnRpbmcgdGhlbSAoZS5nLiAnc295JyBvciAnanN4JykuIEJ5IGRlZmF1bHQsIGFsbCB0aGUgb25lc1xuICogICAgICAgICAgIHRoYXQgZXh0ZW5kIGZyb20gSW5jcmVtZW50YWxEb21SZW5kZXJlci5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlKCkge1xuICB2YXIgb3B0X2RhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSBvcHRfZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkYXRhIHVzZWQgZm9yIGNvbXBhdGliaWxpdHkgbW9kZSwgb3Igbm90aGluZyBpZiBpdCBoYXNuJ3QgYmVlblxuICogZW5hYmxlZC5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcGF0aWJpbGl0eU1vZGVEYXRhKCkge1xuICAvLyBDb21wYXRpYmlsaXR5IG1vZGUgY2FuIGJlIHNldCB2aWEgdGhlIF9fTUVUQUxfQ09NUEFUSUJJTElUWV9fIGdsb2JhbCB2YXIuXG4gIGlmIChjb21wYXRpYmlsaXR5TW9kZURhdGFfID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKSB7XG4gICAgICBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSh3aW5kb3cuX19NRVRBTF9DT01QQVRJQklMSVRZX18pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcGF0aWJpbGl0eU1vZGVEYXRhXztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpZiBpdCdzIHRydXRoeSwgb3IgdGhlIHNlY29uZCBvdGhlcndpc2UuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Kn1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RUcnV0aHlfKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYW1lIG9mIHRoZSBnaXZlbiBmdW5jdGlvbi4gSWYgdGhlIGN1cnJlbnQgYnJvd3NlciBkb2Vzbid0XG4gKiBzdXBwb3J0IHRoZSBgbmFtZWAgcHJvcGVydHksIHRoaXMgd2lsbCBjYWxjdWxhdGUgaXQgZnJvbSB0aGUgZnVuY3Rpb24nc1xuICogY29udGVudCBzdHJpbmcuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUoZm4pIHtcbiAgaWYgKCFmbi5uYW1lKSB7XG4gICAgdmFyIHN0ciA9IGZuLnRvU3RyaW5nKCk7XG4gICAgZm4ubmFtZSA9IHN0ci5zdWJzdHJpbmcoOSwgc3RyLmluZGV4T2YoJygnKSk7XG4gIH1cbiAgcmV0dXJuIGZuLm5hbWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgb2YgYSBzdGF0aWMgcHJvcGVydHkgaW4gdGhlIGdpdmVuIGNsYXNzLiBUaGUgdmFsdWUgd2lsbCBiZVxuICogaW5oZXJpdGVkIGZyb20gYW5jZXN0b3JzIGFzIGV4cGVjdGVkLCB1bmxlc3MgYSBjdXN0b20gbWVyZ2UgZnVuY3Rpb24gaXMgZ2l2ZW4sXG4gKiB3aGljaCBjYW4gY2hhbmdlIGhvdyB0aGUgc3VwZXIgY2xhc3NlcycgdmFsdWUgZm9yIHRoYXQgcHJvcGVydHkgd2lsbCBiZSBtZXJnZWRcbiAqIHRvZ2V0aGVyLlxuICogVGhlIGZpbmFsIG1lcmdlZCB2YWx1ZSB3aWxsIGJlIHN0b3JlZCBpbiBhbm90aGVyIHByb3BlcnR5LCBzbyB0aGF0IGl0IHdvbid0XG4gKiBiZSByZWNhbGN1bGF0ZWQgZXZlbiBpZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCl9IGN0b3IgQ2xhc3MgY29uc3RydWN0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lIFByb3BlcnR5IG5hbWUgdG8gYmUgbWVyZ2VkLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCAqKToqPX0gb3B0X21lcmdlRm4gRnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbWVyZ2VkXG4gKiAgICAgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHNvIGZhciBhbmQgdGhlIG5leHQgdmFsdWUgdG8gYmUgbWVyZ2VkIHRvIGl0LlxuICogICAgIFNob3VsZCByZXR1cm4gdGhlc2UgdHdvIG1lcmdlZCB0b2dldGhlci4gSWYgbm90IHBhc3NlZCB0aGUgZmluYWwgcHJvcGVydHlcbiAqICAgICB3aWxsIGJlIHRoZSBmaXJzdCB0cnV0aHkgdmFsdWUgYW1vbmcgYW5jZXN0b3JzLlxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLCBwcm9wZXJ0eU5hbWUsIG9wdF9tZXJnZUZuKSB7XG4gIHZhciBtZXJnZWROYW1lID0gcHJvcGVydHlOYW1lICsgJ19NRVJHRUQnO1xuICBpZiAoIWN0b3IuaGFzT3duUHJvcGVydHkobWVyZ2VkTmFtZSkpIHtcbiAgICB2YXIgbWVyZ2VkID0gY3Rvci5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpID8gY3Rvcltwcm9wZXJ0eU5hbWVdIDogbnVsbDtcbiAgICBpZiAoY3Rvci5fX3Byb3RvX18gJiYgIWN0b3IuX19wcm90b19fLmlzUHJvdG90eXBlT2YoRnVuY3Rpb24pKSB7XG4gICAgICB2YXIgbWVyZ2VGbiA9IG9wdF9tZXJnZUZuIHx8IGdldEZpcnN0VHJ1dGh5XztcbiAgICAgIG1lcmdlZCA9IG1lcmdlRm4obWVyZ2VkLCBnZXRTdGF0aWNQcm9wZXJ0eShjdG9yLl9fcHJvdG9fXywgcHJvcGVydHlOYW1lLCBtZXJnZUZuKSk7XG4gICAgfVxuICAgIGN0b3JbbWVyZ2VkTmFtZV0gPSBtZXJnZWQ7XG4gIH1cbiAgcmV0dXJuIGN0b3JbbWVyZ2VkTmFtZV07XG59XG5cbi8qKlxuICogR2V0cyBhbiB1bmlxdWUgaWQuIElmIGBvcHRfb2JqZWN0YCBhcmd1bWVudCBpcyBwYXNzZWQsIHRoZSBvYmplY3QgaXNcbiAqIG11dGF0ZWQgd2l0aCBhbiB1bmlxdWUgaWQuIENvbnNlY3V0aXZlIGNhbGxzIHdpdGggdGhlIHNhbWUgb2JqZWN0XG4gKiByZWZlcmVuY2Ugd29uJ3QgbXV0YXRlIHRoZSBvYmplY3QgYWdhaW4sIGluc3RlYWQgdGhlIGN1cnJlbnQgb2JqZWN0IHVpZFxuICogcmV0dXJucy4gU2VlIHtAbGluayBVSURfUFJPUEVSVFl9LlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfb2JqZWN0IE9wdGlvbmFsIG9iamVjdCB0byBiZSBtdXRhdGVkIHdpdGggdGhlIHVpZC4gSWZcbiAqICAgICBub3Qgc3BlY2lmaWVkIHRoaXMgbWV0aG9kIG9ubHkgcmV0dXJucyB0aGUgdWlkLlxuICogQHBhcmFtIHtib29sZWFuPX0gb3B0X25vSW5oZXJpdGFuY2UgT3B0aW9uYWwgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXNcbiAqICAgICBvYmplY3QncyB1aWQgcHJvcGVydHkgY2FuIGJlIGluaGVyaXRlZCBmcm9tIHBhcmVudHMgb3Igbm90LlxuICogQHRocm93cyB7RXJyb3J9IHdoZW4gaW52b2tlZCB0byBpbmRpY2F0ZSB0aGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuLlxuICovXG5mdW5jdGlvbiBnZXRVaWQob3B0X29iamVjdCwgb3B0X25vSW5oZXJpdGFuY2UpIHtcbiAgaWYgKG9wdF9vYmplY3QpIHtcbiAgICB2YXIgaWQgPSBvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV07XG4gICAgaWYgKG9wdF9ub0luaGVyaXRhbmNlICYmICFvcHRfb2JqZWN0Lmhhc093blByb3BlcnR5KFVJRF9QUk9QRVJUWSkpIHtcbiAgICAgIGlkID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGlkIHx8IChvcHRfb2JqZWN0W1VJRF9QUk9QRVJUWV0gPSB1bmlxdWVJZENvdW50ZXJfKyspO1xuICB9XG4gIHJldHVybiB1bmlxdWVJZENvdW50ZXJfKys7XG59XG5cbi8qKlxuICogVGhlIGlkZW50aXR5IGZ1bmN0aW9uLiBSZXR1cm5zIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kj19IG9wdF9yZXR1cm5WYWx1ZSBUaGUgc2luZ2xlIHZhbHVlIHRoYXQgd2lsbCBiZSByZXR1cm5lZC5cbiAqIEByZXR1cm4gez99IFRoZSBmaXJzdCBhcmd1bWVudC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbihvcHRfcmV0dXJuVmFsdWUpIHtcbiAgcmV0dXJuIG9wdF9yZXR1cm5WYWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBib29sZWFuLlxuICovXG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAqIEBwYXJhbSB7P30gdmFsIFZhcmlhYmxlIHRvIHRlc3QuXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHZhcmlhYmxlIGlzIGRlZmluZWQuXG4gKi9cbmZ1bmN0aW9uIGlzRGVmKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RlZkFuZE5vdE51bGwodmFsKSB7XG4gIHJldHVybiBpc0RlZih2YWwpICYmICFpc051bGwodmFsKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSA5O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvY3VtZW50LWZyYWdtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRG9jdW1lbnRGcmFnbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9tIGVsZW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50KHZhbCkge1xuICByZXR1cm4gdmFsICYmICh0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpKSA9PT0gJ29iamVjdCcgJiYgdmFsLm5vZGVUeXBlID09PSAxO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgbnVsbC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bGwodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSB3aW5kb3cuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNXaW5kb3codmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdmFsID09PSB2YWwud2luZG93O1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdC4gVGhpcyBpbmNsdWRlcyBhcnJheXNcbiAqIGFuZCBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBhbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCk7XG4gIHJldHVybiB0eXBlID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGwgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBQcm9taXNlLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB2YWwgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5cbi8qKlxuICogU2V0cyB0byB0cnVlIGlmIHJ1bm5pbmcgaW5zaWRlIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aCBleHRyYSBjaGVjayBmb3JcbiAqIGBwcm9jZXNzLmJyb3dzZXJgIHRvIHNraXAgS2FybWEgcnVubmVyIGVudmlyb25tZW50LiBLYXJtYSBlbnZpcm9ubWVudCBoYXNcbiAqIGBwcm9jZXNzYCBkZWZpbmVkIGV2ZW4gdGhvdWdoIGl0IHJ1bnMgb24gdGhlIGJyb3dzZXIuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1NlcnZlclNpZGUoKSB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MuZW52ICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmICFwcm9jZXNzLmJyb3dzZXI7XG59XG5cbi8qKlxuICogTnVsbCBmdW5jdGlvbiB1c2VkIGZvciBkZWZhdWx0IHZhbHVlcyBvZiBjYWxsYmFja3MsIGV0Yy5cbiAqIEByZXR1cm4ge3ZvaWR9IE5vdGhpbmcuXG4gKi9cbmZ1bmN0aW9uIG51bGxGdW5jdGlvbigpIHt9XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvY29yZU5hbWVkLmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfY29yZSA9IHJlcXVpcmUoJy4uL2NvcmUnKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBhcnJheSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgYXJyYXkpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKGFycmF5LCBudWxsLCBbe1xuXHRcdGtleTogJ2VxdWFsJyxcblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFycmF5cyBoYXZlIHRoZSBzYW1lIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIxXG4gICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBlcXVhbChhcnIxLCBhcnIyKSB7XG5cdFx0XHRpZiAoYXJyMSA9PT0gYXJyMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgaXNuJ3QgdW5kZWZpbmVkLlxuICAgKiBAcGFyYW0geyFBcnJheX0gYXJyXG4gICAqIEByZXR1cm4geyp9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmaXJzdERlZmluZWRWYWx1ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGZpcnN0RGVmaW5lZFZhbHVlKGFycikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFycltpXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoZSBpbnB1dCBuZXN0ZWQgYXJyYXkgdG8gYmVjb21lIGZsYXQuXG4gICAqIEBwYXJhbSB7QXJyYXkuPCp8QXJyYXkuPCo+Pn0gYXJyIE5lc3RlZCBhcnJheSB0byBmbGF0dGVuLlxuICAgKiBAcGFyYW0ge0FycmF5LjwqPn0gb3B0X291dHB1dCBPcHRpb25hbCBvdXRwdXQgYXJyYXkuXG4gICAqIEByZXR1cm4ge0FycmF5LjwqPn0gRmxhdCBhcnJheS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2ZsYXR0ZW4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmbGF0dGVuKGFyciwgb3B0X291dHB1dCkge1xuXHRcdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcnJbaV0pKSB7XG5cdFx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdmFsdWUgZnJvbSBhbiBhcnJheS5cbiAgICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtUfSBvYmogT2JqZWN0IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG5cdFx0XHR2YXIgaSA9IGFyci5pbmRleE9mKG9iaik7XG5cdFx0XHR2YXIgcnYgPSB2b2lkIDA7XG5cdFx0XHRpZiAocnYgPSBpID49IDApIHtcblx0XHRcdFx0YXJyYXkucmVtb3ZlQXQoYXJyLCBpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBydjtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVtb3ZlcyBmcm9tIGFuIGFycmF5IHRoZSBlbGVtZW50IGF0IGluZGV4IGlcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyIEFycmF5IG9yIGFycmF5IGxpa2Ugb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHZhbHVlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggdG8gcmVtb3ZlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZW1vdmVBdCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUF0KGFyciwgaSkge1xuXHRcdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcnIsIGksIDEpLmxlbmd0aCA9PT0gMTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogU2xpY2VzIHRoZSBnaXZlbiBhcnJheSwganVzdCBsaWtlIEFycmF5LnByb3RvdHlwZS5zbGljZSwgYnV0IHRoaXNcbiAgICogaXMgZmFzdGVyIGFuZCB3b3JraW5nIG9uIGFsbCBhcnJheS1saWtlIG9iamVjdHMgKGxpa2UgYXJndW1lbnRzKS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgaW5kZXggdGhhdCBzaG91bGQgc3RhcnQgdGhlIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdF9lbmQgVGhlIGluZGV4IHdoZXJlIHRoZSBzbGljZSBzaG91bGQgZW5kLCBub3RcbiAgICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuICAgKiAgIHN0YXJ0IGluZGV4IHdpbGwgYmUgaW5jbHVkZWQuXG4gICAqIEByZXR1cm4geyFBcnJheX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NsaWNlJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gc2xpY2UoYXJyLCBzdGFydCwgb3B0X2VuZCkge1xuXHRcdFx0dmFyIHNsaWNlZCA9IFtdO1xuXHRcdFx0dmFyIGVuZCA9ICgwLCBfY29yZS5pc0RlZikob3B0X2VuZCkgPyBvcHRfZW5kIDogYXJyLmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHRcdHNsaWNlZC5wdXNoKGFycltpXSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2xpY2VkO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBhcnJheTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXJyYXk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIVxuICogUG9seWZpbGwgZnJvbSBHb29nbGUncyBDbG9zdXJlIExpYnJhcnkuXG4gKiBDb3B5cmlnaHQgMjAxMyBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xudmFyIGFzeW5jID0ge307XG5cbi8qKlxuICogVGhyb3cgYW4gaXRlbSB3aXRob3V0IGludGVycnVwdGluZyB0aGUgY3VycmVudCBleGVjdXRpb24gY29udGV4dC4gIEZvclxuICogZXhhbXBsZSwgaWYgcHJvY2Vzc2luZyBhIGdyb3VwIG9mIGl0ZW1zIGluIGEgbG9vcCwgc29tZXRpbWVzIGl0IGlzIHVzZWZ1bFxuICogdG8gcmVwb3J0IGFuIGVycm9yIHdoaWxlIHN0aWxsIGFsbG93aW5nIHRoZSByZXN0IG9mIHRoZSBiYXRjaCB0byBiZVxuICogcHJvY2Vzc2VkLlxuICogQHBhcmFtIHsqfSBleGNlcHRpb25cbiAqL1xuYXN5bmMudGhyb3dFeGNlcHRpb24gPSBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG5cdC8vIEVhY2ggdGhyb3cgbmVlZHMgdG8gYmUgaW4gaXRzIG93biBjb250ZXh0LlxuXHRhc3luYy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgZXhjZXB0aW9uO1xuXHR9KTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGp1c3QgYmVmb3JlIHRoZSBjdXJyZW50IGNhbGxzdGFjayB1bndpbmRzLCBvciBhc1xuICogc29vbiBhcyBwb3NzaWJsZSBhZnRlciB0aGUgY3VycmVudCBKUyBleGVjdXRpb24gY29udGV4dC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpUSElTKX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7VEhJUz19IG9wdF9jb250ZXh0IE9iamVjdCB0byB1c2UgYXMgdGhlIFwidGhpcyB2YWx1ZVwiIHdoZW4gY2FsbGluZ1xuICogICAgIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIEB0ZW1wbGF0ZSBUSElTXG4gKi9cbmFzeW5jLnJ1biA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0aWYgKCFhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXykge1xuXHRcdC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHNjaGVkdWxlZCwgc2NoZWR1bGUgaXQgbm93LlxuXHRcdGFzeW5jLm5leHRUaWNrKGFzeW5jLnJ1bi5wcm9jZXNzV29ya1F1ZXVlKTtcblx0XHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IHRydWU7XG5cdH1cblxuXHRhc3luYy5ydW4ud29ya1F1ZXVlXy5wdXNoKG5ldyBhc3luYy5ydW4uV29ya0l0ZW1fKGNhbGxiYWNrLCBvcHRfY29udGV4dCkpO1xufTtcblxuLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcblxuLyoqIEBwcml2YXRlIHshQXJyYXkuPCFhc3luYy5ydW4uV29ya0l0ZW1fPn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cbi8qKlxuICogUnVuIGFueSBwZW5kaW5nIGFzeW5jLnJ1biB3b3JrIGl0ZW1zLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBpbnRlbmRlZFxuICogZm9yIGdlbmVyYWwgdXNlLCBidXQgZm9yIHVzZSBieSBlbnRyeSBwb2ludCBoYW5kbGVycyB0byBydW4gaXRlbXMgYWhlYWQgb2ZcbiAqIGFzeW5jLm5leHRUaWNrLlxuICovXG5hc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gTk9URTogYWRkaXRpb25hbCB3b3JrIHF1ZXVlIGl0ZW1zIG1heSBiZSBwdXNoZWQgd2hpbGUgcHJvY2Vzc2luZy5cblx0d2hpbGUgKGFzeW5jLnJ1bi53b3JrUXVldWVfLmxlbmd0aCkge1xuXHRcdC8vIERvbid0IGxldCB0aGUgd29yayBxdWV1ZSBncm93IGluZGVmaW5pdGVseS5cblx0XHR2YXIgd29ya0l0ZW1zID0gYXN5bmMucnVuLndvcmtRdWV1ZV87XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZV8gPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHdvcmtJdGVtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHdvcmtJdGVtID0gd29ya0l0ZW1zW2ldO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d29ya0l0ZW0uZm4uY2FsbCh3b3JrSXRlbS5zY29wZSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGFzeW5jLnRocm93RXhjZXB0aW9uKGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoZXJlIGFyZSBubyBtb3JlIHdvcmsgaXRlbXMsIHJlc2V0IHRoZSB3b3JrIHF1ZXVlLlxuXHRhc3luYy5ydW4ud29ya1F1ZXVlU2NoZWR1bGVkXyA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBmaW5hbFxuICogQHN0cnVjdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGZuXG4gKiBAcGFyYW0ge09iamVjdHxudWxsfHVuZGVmaW5lZH0gc2NvcGVcbiAqL1xuYXN5bmMucnVuLldvcmtJdGVtXyA9IGZ1bmN0aW9uIChmbiwgc2NvcGUpIHtcblx0LyoqIEBjb25zdCAqL1xuXHR0aGlzLmZuID0gZm47XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5zY29wZSA9IHNjb3BlO1xufTtcblxuLyoqXG4gKiBGaXJlcyB0aGUgcHJvdmlkZWQgY2FsbGJhY2tzIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlNcbiAqIGV4ZWN1dGlvbiBjb250ZXh0LiBzZXRUaW1lb3V0KOKApiwgMCkgYWx3YXlzIHRha2VzIGF0IGxlYXN0IDVtcyBmb3IgbGVnYWN5XG4gKiByZWFzb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOlNDT1BFKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzXG4gKiAgICAgcG9zc2libGUuXG4gKiBAcGFyYW0ge1NDT1BFPX0gb3B0X2NvbnRleHQgT2JqZWN0IGluIHdob3NlIHNjb3BlIHRvIGNhbGwgdGhlIGxpc3RlbmVyLlxuICogQHRlbXBsYXRlIFNDT1BFXG4gKi9cbmFzeW5jLm5leHRUaWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRfY29udGV4dCkge1xuXHR2YXIgY2IgPSBjYWxsYmFjaztcblx0aWYgKG9wdF9jb250ZXh0KSB7XG5cdFx0Y2IgPSBjYWxsYmFjay5iaW5kKG9wdF9jb250ZXh0KTtcblx0fVxuXHRjYiA9IGFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18oY2IpO1xuXHQvLyBJbnRyb2R1Y2VkIGFuZCBjdXJyZW50bHkgb25seSBzdXBwb3J0ZWQgYnkgSUUxMC5cblx0Ly8gVmVyaWZ5IGlmIHZhcmlhYmxlIGlzIGRlZmluZWQgb24gdGhlIGN1cnJlbnQgcnVudGltZSAoaS5lLiwgbm9kZSwgYnJvd3NlcikuXG5cdC8vIENhbid0IHVzZSB0eXBlb2YgZW5jbG9zZWQgaW4gYSBmdW5jdGlvbiAoc3VjaCBhcyBjb3JlLmlzRnVuY3Rpb24pIG9yIGFuXG5cdC8vIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93biB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYW4gZW52aXJvbm1lbnRcblx0Ly8gd2hlcmUgdGhlIHZhcmlhYmxlIGlzIHVuZGVmaW5lZC5cblx0aWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRzZXRJbW1lZGlhdGUoY2IpO1xuXHRcdHJldHVybjtcblx0fVxuXHQvLyBMb29rIGZvciBhbmQgY2FjaGUgdGhlIGN1c3RvbSBmYWxsYmFjayB2ZXJzaW9uIG9mIHNldEltbWVkaWF0ZS5cblx0aWYgKCFhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKSB7XG5cdFx0YXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXyA9IGFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXygpO1xuXHR9XG5cdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8oY2IpO1xufTtcblxuLyoqXG4gKiBDYWNoZSBmb3IgdGhlIHNldEltbWVkaWF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqIEB0eXBlIHtmdW5jdGlvbihmdW5jdGlvbigpKX1cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBudWxsO1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGJlc3QgcG9zc2libGUgaW1wbGVtZW50YXRpb24gdG8gcnVuIGEgZnVuY3Rpb24gYXMgc29vbiBhc1xuICogdGhlIEpTIGV2ZW50IGxvb3AgaXMgaWRsZS5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCkpfSBUaGUgXCJzZXRJbW1lZGlhdGVcIiBpbXBsZW1lbnRhdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLmdldFNldEltbWVkaWF0ZUVtdWxhdG9yXyA9IGZ1bmN0aW9uICgpIHtcblx0Ly8gQ3JlYXRlIGEgcHJpdmF0ZSBtZXNzYWdlIGNoYW5uZWwgYW5kIHVzZSBpdCB0byBwb3N0TWVzc2FnZSBlbXB0eSBtZXNzYWdlc1xuXHQvLyB0byBvdXJzZWx2ZXMuXG5cdHZhciBDaGFubmVsID0gdm9pZCAwO1xuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRDaGFubmVsID0gTWVzc2FnZUNoYW5uZWw7XG5cdH1cblxuXHQvLyBJZiBNZXNzYWdlQ2hhbm5lbCBpcyBub3QgYXZhaWxhYmxlIGFuZCB3ZSBhcmUgaW4gYSBicm93c2VyLCBpbXBsZW1lbnRcblx0Ly8gYW4gaWZyYW1lIGJhc2VkIHBvbHlmaWxsIGluIGJyb3dzZXJzIHRoYXQgaGF2ZSBwb3N0TWVzc2FnZSBhbmRcblx0Ly8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lci4gVGhlIGxhdHRlciBleGNsdWRlcyBJRTggYmVjYXVzZSBpdCBoYXMgYVxuXHQvLyBzeW5jaHJvbm91cyBwb3N0TWVzc2FnZSBpbXBsZW1lbnRhdGlvbi5cblx0aWYgKHR5cGVvZiBDaGFubmVsID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHQvKiogQGNvbnN0cnVjdG9yICovXG5cdFx0Q2hhbm5lbCA9IGZ1bmN0aW9uIENoYW5uZWwoKSB7XG5cdFx0XHQvLyBNYWtlIGFuIGVtcHR5LCBpbnZpc2libGUgaWZyYW1lLlxuXHRcdFx0dmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdFx0aWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRpZnJhbWUuc3JjID0gJyc7XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblx0XHRcdHZhciB3aW4gPSBpZnJhbWUuY29udGVudFdpbmRvdztcblx0XHRcdHZhciBkb2MgPSB3aW4uZG9jdW1lbnQ7XG5cdFx0XHRkb2Mub3BlbigpO1xuXHRcdFx0ZG9jLndyaXRlKCcnKTtcblx0XHRcdGRvYy5jbG9zZSgpO1xuXHRcdFx0dmFyIG1lc3NhZ2UgPSAnY2FsbEltbWVkaWF0ZScgKyBNYXRoLnJhbmRvbSgpO1xuXHRcdFx0dmFyIG9yaWdpbiA9IHdpbi5sb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyB3aW4ubG9jYXRpb24uaG9zdDtcblx0XHRcdHZhciBvbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHQvLyBWYWxpZGF0ZSBvcmlnaW4gYW5kIG1lc3NhZ2UgdG8gbWFrZSBzdXJlIHRoYXQgdGhpcyBtZXNzYWdlIHdhc1xuXHRcdFx0XHQvLyBpbnRlbmRlZCBmb3IgdXMuXG5cdFx0XHRcdGlmIChlLm9yaWdpbiAhPT0gb3JpZ2luICYmIGUuZGF0YSAhPT0gbWVzc2FnZSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnBvcnQxLm9ubWVzc2FnZSgpO1xuXHRcdFx0fS5iaW5kKHRoaXMpO1xuXHRcdFx0d2luLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBvbm1lc3NhZ2UsIGZhbHNlKTtcblx0XHRcdHRoaXMucG9ydDEgPSB7fTtcblx0XHRcdHRoaXMucG9ydDIgPSB7XG5cdFx0XHRcdHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZSgpIHtcblx0XHRcdFx0XHR3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZSwgb3JpZ2luKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9XG5cdGlmICh0eXBlb2YgQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHR2YXIgY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG5cdFx0Ly8gVXNlIGEgZmlmbyBsaW5rZWQgbGlzdCB0byBjYWxsIGNhbGxiYWNrcyBpbiB0aGUgcmlnaHQgb3JkZXIuXG5cdFx0dmFyIGhlYWQgPSB7fTtcblx0XHR2YXIgdGFpbCA9IGhlYWQ7XG5cdFx0Y2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRoZWFkID0gaGVhZC5uZXh0O1xuXHRcdFx0dmFyIGNiID0gaGVhZC5jYjtcblx0XHRcdGhlYWQuY2IgPSBudWxsO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHRhaWwubmV4dCA9IHtcblx0XHRcdFx0Y2I6IGNiXG5cdFx0XHR9O1xuXHRcdFx0dGFpbCA9IHRhaWwubmV4dDtcblx0XHRcdGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG5cdFx0fTtcblx0fVxuXHQvLyBJbXBsZW1lbnRhdGlvbiBmb3IgSUU2LTg6IFNjcmlwdCBlbGVtZW50cyBmaXJlIGFuIGFzeW5jaHJvbm91c1xuXHQvLyBvbnJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2hlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG5cdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Ly8gQ2xlYW4gdXAgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxuXHRcdFx0XHRzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblx0XHRcdFx0c2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRcdFx0c2NyaXB0ID0gbnVsbDtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0Y2IgPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdH07XG5cdH1cblx0Ly8gRmFsbCBiYWNrIHRvIHNldFRpbWVvdXQgd2l0aCAwLiBJbiBicm93c2VycyB0aGlzIGNyZWF0ZXMgYSBkZWxheSBvZiA1bXNcblx0Ly8gb3IgbW9yZS5cblx0cmV0dXJuIGZ1bmN0aW9uIChjYikge1xuXHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHR9O1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBpcyBvdmVycmlkZWQgdG8gcHJvdGVjdCBjYWxsYmFja3Mgd2l0aCBlbnRyeSBwb2ludFxuICogbW9uaXRvciBpZiB0aGUgYXBwbGljYXRpb24gbW9uaXRvcnMgZW50cnkgcG9pbnRzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIGFzIHNvb24gYXMgcG9zc2libGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpfSBUaGUgd3JhcHBlZCBjYWxsYmFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmFzeW5jLm5leHRUaWNrLndyYXBDYWxsYmFja18gPSBmdW5jdGlvbiAob3B0X3JldHVyblZhbHVlKSB7XG5cdHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhc3luYztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1pbmNyZW1lbnRhbC1kb20vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9hc3luYy9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBEaXNwb3NhYmxlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuXHRcdC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG4gICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLiBDYWxscyBgZGlzcG9zZUludGVybmFsYC5cbiAgKi9cblxuXG5cdF9jcmVhdGVDbGFzcyhEaXNwb3NhYmxlLCBbe1xuXHRcdGtleTogJ2Rpc3Bvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0aWYgKCF0aGlzLmRpc3Bvc2VkXykge1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VJbnRlcm5hbCgpO1xuXHRcdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcbiAgICogZGlzcG9zaW5nIGxvZ2ljIChsaWtlIGNsZWFyaW5nIHJlZmVyZW5jZXMgYW5kIGNhbGxpbmcgYGRpc3Bvc2VgIG9uIG90aGVyXG4gICAqIGRpc3Bvc2FibGVzKS5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2Rpc3Bvc2VJbnRlcm5hbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2VJbnRlcm5hbCgpIHt9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2lzRGlzcG9zZWQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBpc0Rpc3Bvc2VkKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzcG9zZWRfO1xuXHRcdH1cblx0fV0pO1xuXG5cdHJldHVybiBEaXNwb3NhYmxlO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEaXNwb3NhYmxlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBvYmplY3QoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIG9iamVjdCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Mob2JqZWN0LCBudWxsLCBbe1xuXHRcdGtleTogJ21peGluJyxcblxuXHRcdC8qKlxuICAgKiBDb3BpZXMgYWxsIHRoZSBtZW1iZXJzIG9mIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIFRoZSBvYmplY3RzIGZyb20gd2hpY2ggdmFsdWVzIHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG5cdFx0XHR2YXIga2V5ID0gdm9pZCAwLFxuXHRcdFx0ICAgIHNvdXJjZSA9IHZvaWQgMDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gICAqICAgICA8Y29kZT53aW5kb3c8L2NvZGU+LlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgdmFsdWUgKG9iamVjdCBvciBwcmltaXRpdmUpIG9yLCBpZiBub3QgZm91bmQsIHVuZGVmaW5lZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE9iamVjdEJ5TmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHRcdHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcblx0XHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnQsIGtleSkge1xuXHRcdFx0XHRyZXR1cm4gcGFydFtrZXldO1xuXHRcdFx0fSwgc2NvcGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcbiAgICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0XHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcHBlZE9iajtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG4gICAqIGNoZWNrLCBpbmNsdWRpbmcgb25seSB0aGUga2V5cyBkaXJlY3RseSBjb250YWluZWQgYnkgdGhlIDIgb2JqZWN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NoYWxsb3dFcXVhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmoxLCBvYmoyKSB7XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRcdGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIG9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gc3RyaW5nKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBzdHJpbmcpO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKHN0cmluZywgbnVsbCwgW3tcblx0XHRrZXk6ICdjYXNlSW5zZW5zaXRpdmVDb21wYXJlJyxcblxuXHRcdC8qKlxuICAgKiBDb21wYXJlcyB0aGUgZ2l2ZW4gc3RyaW5ncyB3aXRob3V0IHRha2luZyB0aGUgY2FzZSBpbnRvIGFjY291bnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RyMVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjJcbiAgICogQHJldHVybiB7bnVtYmVyfSBFaXRoZXIgLTEsIDAgb3IgMSwgYWNjb3JkaW5nIHRvIGlmIHRoZSBmaXJzdCBzdHJpbmcgaXNcbiAgICogICAgIFwic21hbGxlclwiLCBlcXVhbCBvciBcImJpZ2dlclwiIHRoYW4gdGhlIHNlY29uZCBnaXZlbiBzdHJpbmcuXG4gICAqL1xuXHRcdHZhbHVlOiBmdW5jdGlvbiBjYXNlSW5zZW5zaXRpdmVDb21wYXJlKHN0cjEsIHN0cjIpIHtcblx0XHRcdHZhciB0ZXN0MSA9IFN0cmluZyhzdHIxKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0dmFyIHRlc3QyID0gU3RyaW5nKHN0cjIpLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICh0ZXN0MSA8IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH0gZWxzZSBpZiAodGVzdDEgPT09IHRlc3QyKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGJyZWFraW5nIHNwYWNlcyBmcm9tIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgc3RyaW5nIGFuZFxuICAgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gICAqIFRoZSBvcmlnaW5hbCBhbmQgdGhlIHJlc3VsdCBzdHJpbmdzIHJlbmRlciB0aGUgc2FtZSB3YXkgaW4gSFRNTC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBBIHN0cmluZyBpbiB3aGljaCB0byBjb2xsYXBzZSBzcGFjZXMuXG4gICAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdjb2xsYXBzZUJyZWFraW5nU3BhY2VzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvW1xcdFxcclxcbiBdKy9nLCAnICcpLnJlcGxhY2UoL15bXFx0XFxyXFxuIF0rfFtcXHRcXHJcXG4gXSskL2csICcnKTtcblx0XHR9XG5cblx0XHQvKipcbiAgKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG4gICogQHBhcmFtIHsqfSBzdHIgVGhlIHN0cmluZyB0byBlc2NhcGUuIElmIG5vdCBhIHN0cmluZywgaXQgd2lsbCBiZSBjYXN0ZWRcbiAgKiAgICAgdG8gb25lLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZXNjYXBlUmVnZXgnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC8oWy0oKVxcW1xcXXt9Kz8qLiRcXF58LDojPCFcXFxcXSkvZywgJ1xcXFwkMScpLnJlcGxhY2UoL1xceDA4L2csICdcXFxceDA4Jyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogUmV0dXJucyBhIHN0cmluZyB3aXRoIGF0IGxlYXN0IDY0LWJpdHMgb2YgcmFuZG9tbmVzcy5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFJhbmRvbVN0cmluZycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFJhbmRvbVN0cmluZygpIHtcblx0XHRcdHZhciB4ID0gMjE0NzQ4MzY0ODtcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgaGFzaGNvZGUgZm9yIGEgc3RyaW5nLiBUaGUgaGFzaGNvZGUgdmFsdWUgaXMgY29tcHV0ZWQgYnlcbiAgICogdGhlIHN1bSBhbGdvcml0aG06IHNbMF0qMzFeKG4tMSkgKyBzWzFdKjMxXihuLTIpICsgLi4uICsgc1tuLTFdLiBBIG5pY2VcbiAgICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG4gICAqIGEgc2hpZnQgYW5kIGEgc3VidHJhY3Rpb24gZm9yIGJldHRlciBwZXJmb3JtYW5jZTogMzEqaSA9PSAoaTw8NSktaS5cbiAgICogTW9kZXJuIFZNcyBkbyB0aGlzIHNvcnQgb2Ygb3B0aW1pemF0aW9uIGF1dG9tYXRpY2FsbHkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cbiAgICogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgaGFzaGNvZGUuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdoYXNoQ29kZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGhhc2hDb2RlKHZhbCkge1xuXHRcdFx0dmFyIGhhc2ggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdGhhc2ggJT0gMHgxMDAwMDAwMDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmVwbGFjZXMgaW50ZXJ2YWwgaW50byB0aGUgc3RyaW5nIHdpdGggc3BlY2lmaWVkIHZhbHVlLCBlLmcuXG4gICAqIGByZXBsYWNlSW50ZXJ2YWwoXCJhYmNkZVwiLCAxLCA0LCBcIlwiKWAgcmV0dXJucyBcImFlXCIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IGludGVydmFsIHBvc2l0aW9uIHRvIGJlIHJlcGxhY2VkLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlcGxhY2VJbnRlcnZhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnN1YnN0cmluZygwLCBzdGFydCkgKyB2YWx1ZSArIHN0ci5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gc3RyaW5nO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtaW5jcmVtZW50YWwtZG9tL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvc3RyaW5nL3N0cmluZy5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRQYXRjaGluZ0NvbXBvbmVudCA9IGdldFBhdGNoaW5nQ29tcG9uZW50O1xuZXhwb3J0cy5wYXRjaCA9IHBhdGNoO1xuXG52YXIgX21ldGFsRG9tID0gcmVxdWlyZSgnbWV0YWwtZG9tJyk7XG5cbnZhciBfZGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxudmFyIF9yZW5kZXIgPSByZXF1aXJlKCcuL3JlbmRlcicpO1xuXG52YXIgcGF0Y2hpbmdDb21wb25lbnRzXyA9IFtdO1xuXG4vKipcbiAqIEd1YXJhbnRlZXMgdGhhdCB0aGUgY29tcG9uZW50J3MgZWxlbWVudCBoYXMgYSBwYXJlbnQuIFRoYXQncyBuZWNlc3NhcnlcbiAqIHdoZW4gY2FsbGluZyBpbmNyZW1lbnRhbCBkb20ncyBgcGF0Y2hPdXRlcmAgZm9yIG5vdywgYXMgb3RoZXJ3aXNlIGl0IHdpbGxcbiAqIHRocm93IGFuIGVycm9yIGlmIHRoZSBlbGVtZW50IG5lZWRzIHRvIGJlIHJlcGxhY2VkLlxuICogQHJldHVybiB7RWxlbWVudH0gVGhlIHBhcmVudCwgaW4gY2FzZSBpdCB3YXMgYWRkZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWlsZFBhcmVudElmTmVjZXNzYXJ5XyhlbGVtZW50KSB7XG5cdGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnROb2RlKSB7XG5cdFx0dmFyIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHQoMCwgX21ldGFsRG9tLmFwcGVuZCkocGFyZW50LCBlbGVtZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcmVudDtcblx0fVxufVxuXG4vKipcbiAqIENhbGxzIGluY3JlbWVudGFsIGRvbSdzIHBhdGNoIGZ1bmN0aW9uLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byBwYXRjaC5cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgcGF0Y2hlZCBvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9vdXRlciBGbGFnIGluZGljYXRpbmcgaWYgYHBhdGNoT3V0ZXJgIHNob3VsZCBiZSB1c2VkXG4gKiAgICAgaW5zdGVhZCBvZiBgcGF0Y2hgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbFBhdGNoXyhjb21wb25lbnQsIGVsZW1lbnQsIG9wdF9vdXRlcikge1xuXHRwYXRjaGluZ0NvbXBvbmVudHNfLnB1c2goY29tcG9uZW50KTtcblxuXHR2YXIgZGF0YSA9ICgwLCBfZGF0YS5nZXREYXRhKShjb21wb25lbnQpO1xuXHRpZiAoIWRhdGEucmVuZGVyKSB7XG5cdFx0Ly8gU3RvcmUgcmVmZXJlbmNlIHRvIGF2b2lkIGJpbmRzIG9uIGV2ZXJ5IHBhdGNoLlxuXHRcdGRhdGEucmVuZGVyID0gX3JlbmRlci5yZW5kZXIuYmluZChudWxsLCBjb21wb25lbnQpO1xuXHR9XG5cblx0dmFyIHBhdGNoRm4gPSBvcHRfb3V0ZXIgPyBJbmNyZW1lbnRhbERPTS5wYXRjaE91dGVyIDogSW5jcmVtZW50YWxET00ucGF0Y2g7XG5cdHBhdGNoRm4oZWxlbWVudCwgZGF0YS5yZW5kZXIpO1xuXG5cdHBhdGNoaW5nQ29tcG9uZW50c18ucG9wKCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY29tcG9uZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBjdXJyZW50IHBhdGNoIG9wZXJhdGlvbi5cbiAqIEByZXR1cm4ge0NvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0UGF0Y2hpbmdDb21wb25lbnQoKSB7XG5cdHJldHVybiBwYXRjaGluZ0NvbXBvbmVudHNfW3BhdGNoaW5nQ29tcG9uZW50c18ubGVuZ3RoIC0gMV07XG59XG5cbi8qKlxuICogUGF0Y2hlcyB0aGUgY29tcG9uZW50IHdpdGggaW5jcmVtZW50YWwgZG9tIGZ1bmN0aW9uIGNhbGxzLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gcGF0Y2goY29tcG9uZW50KSB7XG5cdGlmICghdHJ5UGF0Y2hFbXB0eVdpdGhQYXJlbnRfKGNvbXBvbmVudCkpIHtcblx0XHRpZiAoIXRyeVBhdGNoV2l0aE5vUGFyZW50Xyhjb21wb25lbnQpKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGNvbXBvbmVudC5lbGVtZW50O1xuXHRcdFx0Y2FsbFBhdGNoXyhjb21wb25lbnQsIGVsZW1lbnQsIHRydWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgY29tcG9uZW50IGhhcyBubyBjb250ZW50IGJ1dCB3YXMgcmVuZGVyZWQgZnJvbSBhbm90aGVyXG4gKiBjb21wb25lbnQuIElmIHNvLCB3ZSdsbCBuZWVkIHRvIHBhdGNoIHRoaXMgcGFyZW50IHRvIG1ha2Ugc3VyZSB0aGF0IGFueSBuZXdcbiAqIGNvbnRlbnQgd2lsbCBiZSBhZGRlZCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uXG4gKiBAcGFyYW0geyFDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybiB7P2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhdGNoIGhhcHBlbmVkLiBOb3RoaW5nIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRyeVBhdGNoRW1wdHlXaXRoUGFyZW50Xyhjb21wb25lbnQpIHtcblx0dmFyIGRhdGEgPSAoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcG9uZW50KTtcblx0aWYgKCFjb21wb25lbnQuZWxlbWVudCAmJiBkYXRhLnBhcmVudCkge1xuXHRcdGRhdGEucGFyZW50LmdldFJlbmRlcmVyKCkucGF0Y2goZGF0YS5wYXJlbnQpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBjb21wb25lbnQncyBlbGVtZW50IGV4aXN0cyBhbmQgaGFzIGEgcGFyZW50LiBJZiB0aGF0J3Mgbm90IHRoZVxuICogY2FzZSwgYSB0ZW1wb3JhcnkgcGFyZW50IHdpbGwgYmUgY3JlYXRlZCBhbmQgcGFzc2VkIHRvIHRoZSBgcGF0Y2hgIGZ1bmN0aW9uLFxuICogc2luY2UgaW5jcmVtZW50YWwgZG9tIHJlcXVpcmVzIGl0LiBPbmNlIHRoZSBwYXRjaCBpcyBkb25lIHRoZSB0ZW1wb3JhcnlcbiAqIHBhcmVudCBpcyByZW1vdmVkIGFuZCB0aGUgY29tcG9uZW50J3MgY29udGVudCBpcyByZWF0dGFjaGVkIHRvIHRoZSBjb3JyZWN0XG4gKiBmaW5hbCBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJuIHs/Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGF0Y2ggaGFwcGVuZWQuIE5vdGhpbmcgb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJ5UGF0Y2hXaXRoTm9QYXJlbnRfKGNvbXBvbmVudCkge1xuXHR2YXIgdGVtcFBhcmVudCA9IGJ1aWxkUGFyZW50SWZOZWNlc3NhcnlfKGNvbXBvbmVudC5lbGVtZW50KTtcblx0aWYgKHRlbXBQYXJlbnQpIHtcblx0XHRjYWxsUGF0Y2hfKGNvbXBvbmVudCwgdGVtcFBhcmVudCk7XG5cdFx0KDAsIF9tZXRhbERvbS5leGl0RG9jdW1lbnQpKGNvbXBvbmVudC5lbGVtZW50KTtcblx0XHRpZiAoY29tcG9uZW50LmVsZW1lbnQgJiYgY29tcG9uZW50LmluRG9jdW1lbnQpIHtcblx0XHRcdHZhciBhdHRhY2ggPSBjb21wb25lbnQuZ2V0QXR0YWNoRGF0YSgpO1xuXHRcdFx0Y29tcG9uZW50LmF0dGFjaEVsZW1lbnQoYXR0YWNoLnBhcmVudCwgYXR0YWNoLnNpYmxpbmcpO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL3BhdGNoLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFwcGx5QXR0cmlidXRlID0gYXBwbHlBdHRyaWJ1dGU7XG5leHBvcnRzLmNvbnZlcnRMaXN0ZW5lck5hbWVzVG9GbnMgPSBjb252ZXJ0TGlzdGVuZXJOYW1lc1RvRm5zO1xuXG52YXIgX21ldGFsID0gcmVxdWlyZSgnbWV0YWwnKTtcblxudmFyIF9tZXRhbERvbSA9IHJlcXVpcmUoJ21ldGFsLWRvbScpO1xuXG52YXIgX21ldGFsQ29tcG9uZW50ID0gcmVxdWlyZSgnbWV0YWwtY29tcG9uZW50Jyk7XG5cbnZhciBfaW5jcmVtZW50YWxEb21Bb3AgPSByZXF1aXJlKCcuLi9pbmNyZW1lbnRhbC1kb20tYW9wJyk7XG5cbnZhciBIQU5ETEVfU1VGRklYID0gJ19faGFuZGxlX18nO1xudmFyIExJU1RFTkVSX1JFR0VYID0gL14oPzpvbihbQS1aXS4rKSl8KD86ZGF0YS1vbiguKykpJC87XG5cbi8qKlxuICogQXBwbGllcyBhbiBhdHRyaWJ1dGUgdG8gYSBzcGVjaWZpZWQgZWxlbWVudCBvd25lZCBieSB0aGUgZ2l2ZW4gY29tcG9uZW50LlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlKGNvbXBvbmVudCwgZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIGV2ZW50TmFtZSA9IGdldEV2ZW50RnJvbUxpc3RlbmVyQXR0cl8obmFtZSk7XG4gIGlmIChldmVudE5hbWUpIHtcbiAgICBhdHRhY2hFdmVudF8oY29tcG9uZW50LCBlbGVtZW50LCBuYW1lLCBldmVudE5hbWUsIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YWx1ZSA9IGZpeENoZWNrZWRBdHRyXyhuYW1lLCB2YWx1ZSk7XG4gIHNldFZhbHVlQXR0ckFzUHJvcGVydHlfKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcblxuICBpZiAoKDAsIF9tZXRhbC5pc0Jvb2xlYW4pKHZhbHVlKSkge1xuICAgIHNldEJvb2xlYW5BdHRyXyhlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgKDAsIF9pbmNyZW1lbnRhbERvbUFvcC5nZXRPcmlnaW5hbEZuKSgnYXR0cmlidXRlcycpKGVsZW1lbnQsIG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIExpc3RlbnMgdG8gdGhlIHNwZWNpZmllZCBldmVudCwgYXR0YWNoZWQgdmlhIGluY3JlbWVudGFsIGRvbSBjYWxscy5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXR0YWNoRXZlbnRfKGNvbXBvbmVudCwgZWxlbWVudCwgYXR0ciwgZXZlbnROYW1lLCBmbikge1xuICBpZiAoKDAsIF9tZXRhbC5pc1NlcnZlclNpZGUpKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGhhbmRsZUtleSA9IGV2ZW50TmFtZSArIEhBTkRMRV9TVUZGSVg7XG4gIGlmIChlbGVtZW50W2hhbmRsZUtleV0pIHtcbiAgICBlbGVtZW50W2hhbmRsZUtleV0ucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICBlbGVtZW50W2hhbmRsZUtleV0gPSBudWxsO1xuICB9XG4gIGlmIChmbikge1xuICAgIGVsZW1lbnRbYXR0cl0gPSBmbjtcbiAgICBlbGVtZW50W2hhbmRsZUtleV0gPSAoMCwgX21ldGFsRG9tLmRlbGVnYXRlKShkb2N1bWVudCwgZXZlbnROYW1lLCBlbGVtZW50LCBmbik7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgZXZlbnQgbGlzdGVuZXIgYXR0cmlidXRlcyBnaXZlbiBhcyBmdW5jdGlvbiBuYW1lcyB0byBhY3R1YWxcbiAqIGZ1bmN0aW9uIHJlZmVyZW5jZXMuIEl0J3MgaW1wb3J0YW50IHRvIGRvIHRoaXMgYmVmb3JlIGNhbGxpbmcgdGhlIHJlYWxcbiAqIGluY3JlbWVudGFsIGRvbSBgZWxlbWVudE9wZW5gIGZ1bmN0aW9uLCBvdGhlcndpc2UgaWYgYSBjb21wb25lbnQgcGFzc2VzXG4gKiB0aGUgc2FtZSBmdW5jdGlvbiBuYW1lIHRoYXQgYW4gZWxlbWVudCB3YXMgYWxyZWFkeSB1c2luZyBmb3IgYW5vdGhlclxuICogY29tcG9uZW50LCB0aGF0IGV2ZW50IHdvbid0IGJlIHJlYXR0YWNoZWQgYXMgaW5jcmVtZW50YWwgZG9tIHdpbGwgdGhpbmsgdGhhdFxuICogdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkLiBQYXNzaW5nIHRoZSBmdW5jdGlvbiByZWZlcmVuY2VzIGFzIHRoZSB2YWx1ZSB3aWxsXG4gKiBndWFyYW50ZWUgdGhhdCBkaWZmZXJlbnQgZnVuY3Rpb25zIHdpbGwgY2F1c2UgZXZlbnRzIHRvIGJlIHJlYXR0YWNoZWQsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIG9yaWdpbmFsIG5hbWVzLlxuICogQHBhcmFtIHshQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRMaXN0ZW5lck5hbWVzVG9GbnMoY29tcG9uZW50LCBjb25maWcpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBjb25maWdba2V5XSA9IGNvbnZlcnRMaXN0ZW5lck5hbWVUb0ZuXyhjb21wb25lbnQsIGtleSwgY29uZmlnW2tleV0pO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGF0dHJpYnV0ZSdzIHZhbHVlIHRvIGEgZnVuY3Rpb24gcmVmZXJlbmNlLCBpZiBpdCdzXG4gKiBjdXJyZW50bHkgYSBsaXN0ZW5lciBuYW1lLiBJdCBhbHNvIHJlZ2lzdGVyIHRoZSBsaXN0ZW5lciBuYW1lIGZvclxuICogZnVydGhlciB1c2FnZS5cbiAqIEBwYXJhbSB7IUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Kn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRMaXN0ZW5lck5hbWVUb0ZuXyhjb21wb25lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICgoMCwgX21ldGFsLmlzU3RyaW5nKSh2YWx1ZSkpIHtcbiAgICB2YXIgZXZlbnROYW1lID0gZ2V0RXZlbnRGcm9tTGlzdGVuZXJBdHRyXyhuYW1lKTtcbiAgICBpZiAoZXZlbnROYW1lKSB7XG4gICAgICB2YXIgZm4gPSAoMCwgX21ldGFsQ29tcG9uZW50LmdldENvbXBvbmVudEZuKShjb21wb25lbnQsIHZhbHVlKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICByZXR1cm4gZm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDaGFuZ2VzIHRoZSB2YWx1ZSBvZiB0aGUgYGNoZWNrZWRgIGF0dHJpYnV0ZSB0byBiZSBhIGJvb2xlYW4uXG4gKiBOT1RFOiBUaGlzIGlzIGEgdGVtcG9yYXJ5IGZpeCB0byBhY2NvdW50IGZvciBpbmNyZW1lbnRhbCBkb20gc2V0dGluZ1xuICogXCJjaGVja2VkXCIgYXMgYW4gYXR0cmlidXRlIG9ubHksIHdoaWNoIGNhbiBjYXVzZSBidWdzIHNpbmNlIHRoYXQgd29uJ3RcbiAqIG5lY2Vzc2FyaWx5IGNoZWNrL3VuY2hlY2sgdGhlIGVsZW1lbnQgaXQncyBzZXQgb24uIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9pbmNyZW1lbnRhbC1kb20vaXNzdWVzLzE5OCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmaXhDaGVja2VkQXR0cl8obmFtZSwgdmFsdWUpIHtcbiAgaWYgKG5hbWUgPT09ICdjaGVja2VkJykge1xuICAgIHZhbHVlID0gKDAsIF9tZXRhbC5pc0RlZkFuZE5vdE51bGwpKHZhbHVlKSAmJiB2YWx1ZSAhPT0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGV2ZW50IG5hbWUgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZSBpcyBhIGxpc3RlbmVyIChtYXRjaGluZyB0aGVcbiAqIGBMSVNURU5FUl9SRUdFWGAgcmVnZXgpLCBvciBudWxsIGlmIGl0IGlzbid0LlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRFdmVudEZyb21MaXN0ZW5lckF0dHJfKGF0dHIpIHtcbiAgdmFyIG1hdGNoZXMgPSBMSVNURU5FUl9SRUdFWC5leGVjKGF0dHIpO1xuICB2YXIgZXZlbnROYW1lID0gbWF0Y2hlcyA/IG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogbWF0Y2hlc1syXSA6IG51bGw7XG4gIHJldHVybiBldmVudE5hbWUgPyBldmVudE5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5cbi8qKlxuICogU2V0cyBib29sZWFuIGF0dHJpYnV0ZXMgbWFudWFsbHkuIFRoaXMgaXMgZG9uZSBiZWNhdXNlIGluY3JlbWVudGFsIGRvbSBzZXRzXG4gKiBib29sZWFuIHZhbHVlcyBhcyBzdHJpbmcgZGF0YSBhdHRyaWJ1dGVzIGJ5IGRlZmF1bHQsIHdoaWNoIGlzIGNvdW50ZXJcbiAqIGludHVpdGl2ZS4gVGhpcyBjaGFuZ2VzIHRoZSBiZWhhdmlvciB0byB1c2UgdGhlIGFjdHVhbCBib29sZWFuIHZhbHVlLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldEJvb2xlYW5BdHRyXyhlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoKDAsIF9tZXRhbC5pc1NlcnZlclNpZGUpKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudFtuYW1lXSA9IHZhbHVlO1xuICBpZiAodmFsdWUpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHZhbHVlYCBhdHRyaWJ1dGUgZGlyZWN0bHkgaW4gdGhlIGVsZW1lbnQuXG4gKiBOT1RFOiBUaGlzIGlzIGEgdGVtcG9yYXJ5IGZpeCB0byBhY2NvdW50IGZvciBpbmNyZW1lbnRhbCBkb20gc2V0dGluZyBcInZhbHVlXCJcbiAqIGFzIGFuIGF0dHJpYnV0ZSBvbmx5LCB3aGljaCBjYW4gY2F1c2UgYnVncyBzaW5jZSB0aGF0IHdvbid0IG5lY2Vzc2FyaWx5XG4gKiB1cGRhdGUgdGhlIGlucHV0J3MgY29udGVudCBpdCdzIHNldCBvbi4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2luY3JlbWVudGFsLWRvbS9pc3N1ZXMvMjM5IGZvciBtb3JlIGRldGFpbHMuIFdlXG4gKiBvbmx5IGRvIHRoaXMgaWYgdGhlIG5ldyB2YWx1ZSBpcyBkaWZmZXJlbnQgdGhvdWdoLCBhcyBvdGhlcndpc2UgdGhlIGJyb3dzZXJcbiAqIHdpbGwgYXV0b21hdGljYWxseSBtb3ZlIHRoZSB0eXBpbmcgY3Vyc29yIHRvIHRoZSBlbmQgb2YgdGhlIGZpZWxkLlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlQXR0ckFzUHJvcGVydHlfKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICgoMCwgX21ldGFsLmlzU2VydmVyU2lkZSkoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobmFtZSA9PT0gJ3ZhbHVlJyAmJiBlbGVtZW50LnZhbHVlICE9PSB2YWx1ZSkge1xuICAgIGVsZW1lbnRbbmFtZV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvcmVuZGVyL2F0dHJpYnV0ZXMuanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGlzcG9zZVVudXNlZCA9IGRpc3Bvc2VVbnVzZWQ7XG5leHBvcnRzLnNjaGVkdWxlID0gc2NoZWR1bGU7XG5cbnZhciBfZGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxudmFyIGNvbXBzXyA9IFtdO1xudmFyIGRpc3Bvc2luZ18gPSBmYWxzZTtcblxuLyoqXG4gKiBEaXNwb3NlcyBhbGwgc3ViIGNvbXBvbmVudHMgdGhhdCB3ZXJlIG5vdCByZXJlbmRlcmVkIHNpbmNlIHRoZSBsYXN0XG4gKiB0aW1lIHRoaXMgZnVuY3Rpb24gd2FzIHNjaGVkdWxlZC5cbiAqL1xuZnVuY3Rpb24gZGlzcG9zZVVudXNlZCgpIHtcblx0aWYgKGRpc3Bvc2luZ18pIHtcblx0XHRyZXR1cm47XG5cdH1cblx0ZGlzcG9zaW5nXyA9IHRydWU7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb21wc18ubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgY29tcCA9IGNvbXBzX1tpXTtcblx0XHRpZiAoIWNvbXAuaXNEaXNwb3NlZCgpICYmICEoMCwgX2RhdGEuZ2V0RGF0YSkoY29tcCkucGFyZW50KSB7XG5cdFx0XHQvLyBEb24ndCBsZXQgZGlzcG9zaW5nIGNhdXNlIHRoZSBlbGVtZW50IHRvIGJlIHJlbW92ZWQsIHNpbmNlIGl0IG1heVxuXHRcdFx0Ly8gYmUgY3VycmVudGx5IGJlaW5nIHJldXNlZCBieSBhbm90aGVyIGNvbXBvbmVudC5cblx0XHRcdGNvbXAuZWxlbWVudCA9IG51bGw7XG5cdFx0XHRjb21wLmRpc3Bvc2UoKTtcblx0XHR9XG5cdH1cblx0Y29tcHNfID0gW107XG5cdGRpc3Bvc2luZ18gPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgdGhlIGdpdmVuIGNvbXBvbmVudHMgdG8gYmUgY2hlY2tlZCBhbmQgZGlzcG9zZWQgaWYgbm90IHVzZWRcbiAqIGFueW1vcmUgd2hlbiBgZGlzcG9zZVVudXNlZGAgaXMgY2FsbGVkLlxuICogQHBhcmFtIHshQXJyYXk8IUNvbXBvbmVudD59IGNvbXBzXG4gKi9cbmZ1bmN0aW9uIHNjaGVkdWxlKGNvbXBzKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgY29tcHMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoIWNvbXBzW2ldLmlzRGlzcG9zZWQoKSkge1xuXHRcdFx0KDAsIF9kYXRhLmdldERhdGEpKGNvbXBzW2ldKS5wYXJlbnQgPSBudWxsO1xuXHRcdFx0Y29tcHNfLnB1c2goY29tcHNbaV0pO1xuXHRcdH1cblx0fVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLWluY3JlbWVudGFsLWRvbS9saWIvY2xlYW51cC91bnVzZWQuanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbk9iamVjdC5rZXlzKF9jb3JlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfY29yZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcblxudmFyIF9jb3JlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvcmUpO1xuXG52YXIgX2FycmF5ID0gcmVxdWlyZSgnLi9hcnJheS9hcnJheScpO1xuXG52YXIgX2FycmF5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2FycmF5KTtcblxudmFyIF9hc3luYyA9IHJlcXVpcmUoJy4vYXN5bmMvYXN5bmMnKTtcblxudmFyIF9hc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hc3luYyk7XG5cbnZhciBfRGlzcG9zYWJsZSA9IHJlcXVpcmUoJy4vZGlzcG9zYWJsZS9EaXNwb3NhYmxlJyk7XG5cbnZhciBfRGlzcG9zYWJsZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9EaXNwb3NhYmxlKTtcblxudmFyIF9vYmplY3QgPSByZXF1aXJlKCcuL29iamVjdC9vYmplY3QnKTtcblxudmFyIF9vYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb2JqZWN0KTtcblxudmFyIF9zdHJpbmcgPSByZXF1aXJlKCcuL3N0cmluZy9zdHJpbmcnKTtcblxudmFyIF9zdHJpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RyaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5hcnJheSA9IF9hcnJheTIuZGVmYXVsdDtcbmV4cG9ydHMuYXN5bmMgPSBfYXN5bmMyLmRlZmF1bHQ7XG5leHBvcnRzLkRpc3Bvc2FibGUgPSBfRGlzcG9zYWJsZTIuZGVmYXVsdDtcbmV4cG9ydHMub2JqZWN0ID0gX29iamVjdDIuZGVmYXVsdDtcbmV4cG9ydHMuc3RyaW5nID0gX3N0cmluZzIuZGVmYXVsdDtcbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL21ldGFsLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNvcmUgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKiBAY29uc3RcbiAqL1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmV4cG9ydHMuYWJzdHJhY3RNZXRob2QgPSBhYnN0cmFjdE1ldGhvZDtcbmV4cG9ydHMuZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlID0gZGlzYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5lbmFibGVDb21wYXRpYmlsaXR5TW9kZSA9IGVuYWJsZUNvbXBhdGliaWxpdHlNb2RlO1xuZXhwb3J0cy5nZXRDb21wYXRpYmlsaXR5TW9kZURhdGEgPSBnZXRDb21wYXRpYmlsaXR5TW9kZURhdGE7XG5leHBvcnRzLmdldEZ1bmN0aW9uTmFtZSA9IGdldEZ1bmN0aW9uTmFtZTtcbmV4cG9ydHMuZ2V0U3RhdGljUHJvcGVydHkgPSBnZXRTdGF0aWNQcm9wZXJ0eTtcbmV4cG9ydHMuZ2V0VWlkID0gZ2V0VWlkO1xuZXhwb3J0cy5pZGVudGl0eUZ1bmN0aW9uID0gaWRlbnRpdHlGdW5jdGlvbjtcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuZXhwb3J0cy5pc0RlZiA9IGlzRGVmO1xuZXhwb3J0cy5pc0RlZkFuZE5vdE51bGwgPSBpc0RlZkFuZE5vdE51bGw7XG5leHBvcnRzLmlzRG9jdW1lbnQgPSBpc0RvY3VtZW50O1xuZXhwb3J0cy5pc0RvY3VtZW50RnJhZ21lbnQgPSBpc0RvY3VtZW50RnJhZ21lbnQ7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcbmV4cG9ydHMuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NlcnZlclNpZGUgPSBpc1NlcnZlclNpZGU7XG5leHBvcnRzLm51bGxGdW5jdGlvbiA9IG51bGxGdW5jdGlvbjtcbnZhciBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gdm9pZCAwO1xuXG4vKipcbiAqIENvdW50ZXIgZm9yIHVuaXF1ZSBpZC5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgdW5pcXVlSWRDb3VudGVyXyA9IDE7XG5cbi8qKlxuICogVW5pcXVlIGlkIHByb3BlcnR5IHByZWZpeC5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbnZhciBVSURfUFJPUEVSVFkgPSBleHBvcnRzLlVJRF9QUk9QRVJUWSA9ICdjb3JlXycgKyAoTWF0aC5yYW5kb20oKSAqIDFlOSA+Pj4gMCk7XG5cbi8qKlxuICogV2hlbiBkZWZpbmluZyBhIGNsYXNzIEZvbyB3aXRoIGFuIGFic3RyYWN0IG1ldGhvZCBiYXIoKSwgeW91IGNhbiBkbzpcbiAqIEZvby5wcm90b3R5cGUuYmFyID0gYWJzdHJhY3RNZXRob2RcbiAqXG4gKiBOb3cgaWYgYSBzdWJjbGFzcyBvZiBGb28gZmFpbHMgdG8gb3ZlcnJpZGUgYmFyKCksIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiB3aGVuIGJhcigpIGlzIGludm9rZWQuXG4gKlxuICogQHR5cGUgeyFGdW5jdGlvbn1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gYWJzdHJhY3RNZXRob2QoKSB7XG4gIHRocm93IEVycm9yKCdVbmltcGxlbWVudGVkIGFic3RyYWN0IG1ldGhvZCcpO1xufVxuXG4vKipcbiAqIERpc2FibGVzIE1ldGFsLmpzJ3MgY29tcGF0aWJpbGl0eSBtb2RlLlxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ29tcGF0aWJpbGl0eU1vZGUoKSB7XG4gIGNvbXBhdGliaWxpdHlNb2RlRGF0YV8gPSB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogRW5hYmxlcyBNZXRhbC5qcydzIGNvbXBhdGliaWxpdHkgbW9kZSB3aXRoIHRoZSBmb2xsb3dpbmcgZmVhdHVyZXMgZnJvbSByY1xuICogYW5kIDEueCB2ZXJzaW9uczpcbiAqICAgICAtIFVzaW5nIFwia2V5XCIgdG8gcmVmZXJlbmNlIGNvbXBvbmVudCBpbnN0YW5jZXMuIEluIHRoZSBjdXJyZW50IHZlcnNpb25cbiAqICAgICAgIHRoaXMgc2hvdWxkIGJlIGRvbmUgdmlhIFwicmVmXCIgaW5zdGVhZC4gVGhpcyBhbGxvd3Mgb2xkIGNvZGUgc3RpbGxcbiAqICAgICAgIHVzaW5nIFwia2V5XCIgdG8ga2VlcCB3b3JraW5nIGxpa2UgYmVmb3JlLiBOT1RFOiB0aGlzIG1heSBjYXVzZVxuICogICAgICAgcHJvYmxlbXMsIHNpbmNlIFwia2V5XCIgaXMgbWVhbnQgdG8gYmUgdXNlZCBkaWZmZXJlbnRseS4gT25seSB1c2UgdGhpc1xuICogICAgICAgaWYgaXQncyBub3QgcG9zc2libGUgdG8gdXBncmFkZSB0aGUgY29kZSB0byB1c2UgXCJyZWZcIiBpbnN0ZWFkLlxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRfZGF0YSBPcHRpb25hbCBvYmplY3Qgd2l0aCBkYXRhIHRvIHNwZWNpZnkgbW9yZVxuICogICAgIGRldGFpbHMsIHN1Y2ggYXM6XG4gKiAgICAgICAgIC0gcmVuZGVyZXJzIHtBcnJheX0gdGhlIHRlbXBsYXRlIHJlbmRlcmVycyB0aGF0IHNob3VsZCBiZSBpblxuICogICAgICAgICAgIGNvbXBhdGliaWxpdHkgbW9kZSwgZWl0aGVyIHRoZWlyIGNvbnN0cnVjdG9ycyBvciBzdHJpbmdzXG4gKiAgICAgICAgICAgcmVwcmVzZW50aW5nIHRoZW0gKGUuZy4gJ3NveScgb3IgJ2pzeCcpLiBCeSBkZWZhdWx0LCBhbGwgdGhlIG9uZXNcbiAqICAgICAgICAgICB0aGF0IGV4dGVuZCBmcm9tIEluY3JlbWVudGFsRG9tUmVuZGVyZXIuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBlbmFibGVDb21wYXRpYmlsaXR5TW9kZSgpIHtcbiAgdmFyIG9wdF9kYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBjb21wYXRpYmlsaXR5TW9kZURhdGFfID0gb3B0X2RhdGE7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGF0YSB1c2VkIGZvciBjb21wYXRpYmlsaXR5IG1vZGUsIG9yIG5vdGhpbmcgaWYgaXQgaGFzbid0IGJlZW5cbiAqIGVuYWJsZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhdGliaWxpdHlNb2RlRGF0YSgpIHtcbiAgLy8gQ29tcGF0aWJpbGl0eSBtb2RlIGNhbiBiZSBzZXQgdmlhIHRoZSBfX01FVEFMX0NPTVBBVElCSUxJVFlfXyBnbG9iYWwgdmFyLlxuICBpZiAoY29tcGF0aWJpbGl0eU1vZGVEYXRhXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5fX01FVEFMX0NPTVBBVElCSUxJVFlfXykge1xuICAgICAgZW5hYmxlQ29tcGF0aWJpbGl0eU1vZGUod2luZG93Ll9fTUVUQUxfQ09NUEFUSUJJTElUWV9fKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBhdGliaWxpdHlNb2RlRGF0YV87XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQncyB0cnV0aHksIG9yIHRoZSBzZWNvbmQgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbmZ1bmN0aW9uIGdldEZpcnN0VHJ1dGh5XyhhLCBiKSB7XG4gIHJldHVybiBhIHx8IGI7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgZ2l2ZW4gZnVuY3Rpb24uIElmIHRoZSBjdXJyZW50IGJyb3dzZXIgZG9lc24ndFxuICogc3VwcG9ydCB0aGUgYG5hbWVgIHByb3BlcnR5LCB0aGlzIHdpbGwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGZ1bmN0aW9uJ3NcbiAqIGNvbnRlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshZnVuY3Rpb24oKX0gZm5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RnVuY3Rpb25OYW1lKGZuKSB7XG4gIGlmICghZm4ubmFtZSkge1xuICAgIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGZuLm5hbWUgPSBzdHIuc3Vic3RyaW5nKDksIHN0ci5pbmRleE9mKCcoJykpO1xuICB9XG4gIHJldHVybiBmbi5uYW1lO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIG9mIGEgc3RhdGljIHByb3BlcnR5IGluIHRoZSBnaXZlbiBjbGFzcy4gVGhlIHZhbHVlIHdpbGwgYmVcbiAqIGluaGVyaXRlZCBmcm9tIGFuY2VzdG9ycyBhcyBleHBlY3RlZCwgdW5sZXNzIGEgY3VzdG9tIG1lcmdlIGZ1bmN0aW9uIGlzIGdpdmVuLFxuICogd2hpY2ggY2FuIGNoYW5nZSBob3cgdGhlIHN1cGVyIGNsYXNzZXMnIHZhbHVlIGZvciB0aGF0IHByb3BlcnR5IHdpbGwgYmUgbWVyZ2VkXG4gKiB0b2dldGhlci5cbiAqIFRoZSBmaW5hbCBtZXJnZWQgdmFsdWUgd2lsbCBiZSBzdG9yZWQgaW4gYW5vdGhlciBwcm9wZXJ0eSwgc28gdGhhdCBpdCB3b24ndFxuICogYmUgcmVjYWxjdWxhdGVkIGV2ZW4gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbigpfSBjdG9yIENsYXNzIGNvbnN0cnVjdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZSBQcm9wZXJ0eSBuYW1lIHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgKik6Kj19IG9wdF9tZXJnZUZuIEZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIG1lcmdlZFxuICogICAgIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBzbyBmYXIgYW5kIHRoZSBuZXh0IHZhbHVlIHRvIGJlIG1lcmdlZCB0byBpdC5cbiAqICAgICBTaG91bGQgcmV0dXJuIHRoZXNlIHR3byBtZXJnZWQgdG9nZXRoZXIuIElmIG5vdCBwYXNzZWQgdGhlIGZpbmFsIHByb3BlcnR5XG4gKiAgICAgd2lsbCBiZSB0aGUgZmlyc3QgdHJ1dGh5IHZhbHVlIGFtb25nIGFuY2VzdG9ycy5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGljUHJvcGVydHkoY3RvciwgcHJvcGVydHlOYW1lLCBvcHRfbWVyZ2VGbikge1xuICB2YXIgbWVyZ2VkTmFtZSA9IHByb3BlcnR5TmFtZSArICdfTUVSR0VEJztcbiAgaWYgKCFjdG9yLmhhc093blByb3BlcnR5KG1lcmdlZE5hbWUpKSB7XG4gICAgdmFyIG1lcmdlZCA9IGN0b3IuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSA/IGN0b3JbcHJvcGVydHlOYW1lXSA6IG51bGw7XG4gICAgaWYgKGN0b3IuX19wcm90b19fICYmICFjdG9yLl9fcHJvdG9fXy5pc1Byb3RvdHlwZU9mKEZ1bmN0aW9uKSkge1xuICAgICAgdmFyIG1lcmdlRm4gPSBvcHRfbWVyZ2VGbiB8fCBnZXRGaXJzdFRydXRoeV87XG4gICAgICBtZXJnZWQgPSBtZXJnZUZuKG1lcmdlZCwgZ2V0U3RhdGljUHJvcGVydHkoY3Rvci5fX3Byb3RvX18sIHByb3BlcnR5TmFtZSwgbWVyZ2VGbikpO1xuICAgIH1cbiAgICBjdG9yW21lcmdlZE5hbWVdID0gbWVyZ2VkO1xuICB9XG4gIHJldHVybiBjdG9yW21lcmdlZE5hbWVdO1xufVxuXG4vKipcbiAqIEdldHMgYW4gdW5pcXVlIGlkLiBJZiBgb3B0X29iamVjdGAgYXJndW1lbnQgaXMgcGFzc2VkLCB0aGUgb2JqZWN0IGlzXG4gKiBtdXRhdGVkIHdpdGggYW4gdW5pcXVlIGlkLiBDb25zZWN1dGl2ZSBjYWxscyB3aXRoIHRoZSBzYW1lIG9iamVjdFxuICogcmVmZXJlbmNlIHdvbid0IG11dGF0ZSB0aGUgb2JqZWN0IGFnYWluLCBpbnN0ZWFkIHRoZSBjdXJyZW50IG9iamVjdCB1aWRcbiAqIHJldHVybnMuIFNlZSB7QGxpbmsgVUlEX1BST1BFUlRZfS5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0X29iamVjdCBPcHRpb25hbCBvYmplY3QgdG8gYmUgbXV0YXRlZCB3aXRoIHRoZSB1aWQuIElmXG4gKiAgICAgbm90IHNwZWNpZmllZCB0aGlzIG1ldGhvZCBvbmx5IHJldHVybnMgdGhlIHVpZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdF9ub0luaGVyaXRhbmNlIE9wdGlvbmFsIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzXG4gKiAgICAgb2JqZWN0J3MgdWlkIHByb3BlcnR5IGNhbiBiZSBpbmhlcml0ZWQgZnJvbSBwYXJlbnRzIG9yIG5vdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIGludm9rZWQgdG8gaW5kaWNhdGUgdGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbi5cbiAqL1xuZnVuY3Rpb24gZ2V0VWlkKG9wdF9vYmplY3QsIG9wdF9ub0luaGVyaXRhbmNlKSB7XG4gIGlmIChvcHRfb2JqZWN0KSB7XG4gICAgdmFyIGlkID0gb3B0X29iamVjdFtVSURfUFJPUEVSVFldO1xuICAgIGlmIChvcHRfbm9Jbmhlcml0YW5jZSAmJiAhb3B0X29iamVjdC5oYXNPd25Qcm9wZXJ0eShVSURfUFJPUEVSVFkpKSB7XG4gICAgICBpZCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpZCB8fCAob3B0X29iamVjdFtVSURfUFJPUEVSVFldID0gdW5pcXVlSWRDb3VudGVyXysrKTtcbiAgfVxuICByZXR1cm4gdW5pcXVlSWRDb3VudGVyXysrO1xufVxuXG4vKipcbiAqIFRoZSBpZGVudGl0eSBmdW5jdGlvbi4gUmV0dXJucyBpdHMgZmlyc3QgYXJndW1lbnQuXG4gKiBAcGFyYW0geyo9fSBvcHRfcmV0dXJuVmFsdWUgVGhlIHNpbmdsZSB2YWx1ZSB0aGF0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHs/fSBUaGUgZmlyc3QgYXJndW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5RnVuY3Rpb24ob3B0X3JldHVyblZhbHVlKSB7XG4gIHJldHVybiBvcHRfcmV0dXJuVmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gaXNCb29sZWFuKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gKiBAcGFyYW0gez99IHZhbCBWYXJpYWJsZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB2YXJpYWJsZSBpcyBkZWZpbmVkLlxuICovXG5mdW5jdGlvbiBpc0RlZih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBub3QgdW5kZWZpbmVkIG9yIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEZWZBbmROb3ROdWxsKHZhbCkge1xuICByZXR1cm4gaXNEZWYodmFsKSAmJiAhaXNOdWxsKHZhbCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgZG9jdW1lbnQuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gOTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdmFsdWUgaXMgYSBkb2N1bWVudC1mcmFnbWVudC5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB2YWwubm9kZVR5cGUgPT09IDExO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB2YWx1ZSBpcyBhIGRvbSBlbGVtZW50LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsKSkgPT09ICdvYmplY3QnICYmIHZhbC5ub2RlVHlwZSA9PT0gMTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIG51bGwuXG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdWxsKHZhbCkge1xuICByZXR1cm4gdmFsID09PSBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgd2luZG93LlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzV2luZG93KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHZhbCA9PT0gdmFsLndpbmRvdztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBvYmplY3QuIFRoaXMgaW5jbHVkZXMgYXJyYXlzXG4gKiBhbmQgZnVuY3Rpb25zLlxuICogQHBhcmFtIHs/fSB2YWwgVmFyaWFibGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdmFyaWFibGUgaXMgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWwpO1xuICByZXR1cm4gdHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsIHx8IHR5cGUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIHJldHVybiB2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbCkpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuXG4vKipcbiAqIFNldHMgdG8gdHJ1ZSBpZiBydW5uaW5nIGluc2lkZSBOb2RlLmpzIGVudmlyb25tZW50IHdpdGggZXh0cmEgY2hlY2sgZm9yXG4gKiBgcHJvY2Vzcy5icm93c2VyYCB0byBza2lwIEthcm1hIHJ1bm5lciBlbnZpcm9ubWVudC4gS2FybWEgZW52aXJvbm1lbnQgaGFzXG4gKiBgcHJvY2Vzc2AgZGVmaW5lZCBldmVuIHRob3VnaCBpdCBydW5zIG9uIHRoZSBicm93c2VyLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJTaWRlKCkge1xuICByZXR1cm4gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBwcm9jZXNzLmVudiAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhcHJvY2Vzcy5icm93c2VyO1xufVxuXG4vKipcbiAqIE51bGwgZnVuY3Rpb24gdXNlZCBmb3IgZGVmYXVsdCB2YWx1ZXMgb2YgY2FsbGJhY2tzLCBldGMuXG4gKiBAcmV0dXJuIHt2b2lkfSBOb3RoaW5nLlxuICovXG5mdW5jdGlvbiBudWxsRnVuY3Rpb24oKSB7fVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2NvcmVOYW1lZC5qc1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKCcuLi9jb3JlJyk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhhcnJheSwgbnVsbCwgW3tcblx0XHRrZXk6ICdlcXVhbCcsXG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LlxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gZXF1YWwoYXJyMSwgYXJyMikge1xuXHRcdFx0aWYgKGFycjEgPT09IGFycjIpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHZhbHVlIGluIHRoZSBnaXZlbiBhcnJheSB0aGF0IGlzbid0IHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHshQXJyYXl9IGFyclxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZmlyc3REZWZpbmVkVmFsdWUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChhcnJbaV0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgbmVzdGVkIGFycmF5IHRvIGJlY29tZSBmbGF0LlxuICAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICogQHBhcmFtIHtBcnJheS48Kj59IG9wdF9vdXRwdXQgT3B0aW9uYWwgb3V0cHV0IGFycmF5LlxuICAgKiBAcmV0dXJuIHtBcnJheS48Kj59IEZsYXQgYXJyYXkuXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdmbGF0dGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZmxhdHRlbihhcnIsIG9wdF9vdXRwdXQpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBvcHRfb3V0cHV0IHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJyW2ldKSkge1xuXHRcdFx0XHRcdGFycmF5LmZsYXR0ZW4oYXJyW2ldLCBvdXRwdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKGFycltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICAqIEBwYXJhbSB7QXJyYXkuPFQ+fSBhcnIgQXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gb2JqIE9iamVjdCB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICogQHRlbXBsYXRlIFRcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3JlbW92ZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuXHRcdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdFx0dmFyIHJ2ID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJ2ID0gaSA+PSAwKSB7XG5cdFx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcnY7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlbW92ZXMgZnJvbSBhbiBhcnJheSB0aGUgZWxlbWVudCBhdCBpbmRleCBpXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGkgVGhlIGluZGV4IHRvIHJlbW92ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAncmVtb3ZlQXQnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZW1vdmVBdChhcnIsIGkpIHtcblx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJyLCBpLCAxKS5sZW5ndGggPT09IDE7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFNsaWNlcyB0aGUgZ2l2ZW4gYXJyYXksIGp1c3QgbGlrZSBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCB0aGlzXG4gICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gYXJyIEFycmF5LWxpa2Ugb2JqZWN0IHRvIHNsaWNlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIGluZGV4IHRoYXQgc2hvdWxkIHN0YXJ0IHRoZSBzbGljZS5cbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICAqICAgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIGFycmF5LiBJZiBub3QgZ2l2ZW4sIGFsbCBlbGVtZW50cyBhZnRlciB0aGVcbiAgICogICBzdGFydCBpbmRleCB3aWxsIGJlIGluY2x1ZGVkLlxuICAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdzbGljZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHRcdHZhciBzbGljZWQgPSBbXTtcblx0XHRcdHZhciBlbmQgPSAoMCwgX2NvcmUuaXNEZWYpKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuXHRcdFx0XHRzbGljZWQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNsaWNlZDtcblx0XHR9XG5cdH1dKTtcblxuXHRyZXR1cm4gYXJyYXk7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGFycmF5O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FycmF5L2FycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbnZhciBhc3luYyA9IHt9O1xuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbCA9IHZvaWQgMDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbiBDaGFubmVsKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24gKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXN5bmMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGlzcG9zYWJsZSB1dGlsaXR5LiBXaGVuIGluaGVyaXRlZCBwcm92aWRlcyB0aGUgYGRpc3Bvc2VgIGZ1bmN0aW9uIHRvIGl0c1xuICogc3ViY2xhc3MsIHdoaWNoIGlzIHJlc3BvbnNpYmxlIGZvciBkaXNwb3Npbmcgb2YgYW55IG9iamVjdCByZWZlcmVuY2VzXG4gKiB3aGVuIGFuIGluc3RhbmNlIHdvbid0IGJlIHVzZWQgYW55bW9yZS4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbiAqIGBkaXNwb3NlSW50ZXJuYWxgIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWMgZGlzcG9zaW5nIGxvZ2ljLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERpc3Bvc2FibGUgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIERpc3Bvc2FibGUoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3Bvc2FibGUpO1xuXG5cdFx0LyoqXG4gICAqIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXHRcdHRoaXMuZGlzcG9zZWRfID0gZmFsc2U7XG5cdH1cblxuXHQvKipcbiAgKiBEaXNwb3NlcyBvZiB0aGlzIGluc3RhbmNlJ3Mgb2JqZWN0IHJlZmVyZW5jZXMuIENhbGxzIGBkaXNwb3NlSW50ZXJuYWxgLlxuICAqL1xuXG5cblx0X2NyZWF0ZUNsYXNzKERpc3Bvc2FibGUsIFt7XG5cdFx0a2V5OiAnZGlzcG9zZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG5cdFx0XHRpZiAoIXRoaXMuZGlzcG9zZWRfKSB7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHRcdHRoaXMuZGlzcG9zZWRfID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKipcbiAgICogU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW1wbGVtZW50IGFueSBzcGVjaWZpY1xuICAgKiBkaXNwb3NpbmcgbG9naWMgKGxpa2UgY2xlYXJpbmcgcmVmZXJlbmNlcyBhbmQgY2FsbGluZyBgZGlzcG9zZWAgb24gb3RoZXJcbiAgICogZGlzcG9zYWJsZXMpLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnZGlzcG9zZUludGVybmFsJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUludGVybmFsKCkge31cblxuXHRcdC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaXNEaXNwb3NlZCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGlzRGlzcG9zZWQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIERpc3Bvc2FibGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3Bvc2FibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwtc295L25vZGVfbW9kdWxlcy9tZXRhbC9saWIvZGlzcG9zYWJsZS9EaXNwb3NhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBvYmplY3QoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIG9iamVjdCk7XG5cdH1cblxuXHRfY3JlYXRlQ2xhc3Mob2JqZWN0LCBudWxsLCBbe1xuXHRcdGtleTogJ21peGluJyxcblxuXHRcdC8qKlxuICAgKiBDb3BpZXMgYWxsIHRoZSBtZW1iZXJzIG9mIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdC5cbiAgICogQHBhcmFtIHsuLi5PYmplY3R9IHZhcl9hcmdzIFRoZSBvYmplY3RzIGZyb20gd2hpY2ggdmFsdWVzIHdpbGwgYmUgY29waWVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHRhcmdldCBvYmplY3QgcmVmZXJlbmNlLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG5cdFx0XHR2YXIga2V5ID0gdm9pZCAwLFxuXHRcdFx0ICAgIHNvdXJjZSA9IHZvaWQgMDtcblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0Zm9yIChrZXkgaW4gc291cmNlKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRhcmdldDtcblx0XHR9XG5cblx0XHQvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGZ1bGx5IHF1YWxpZmllZCBleHRlcm5hbCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUuXG4gICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gICAqICAgICA8Y29kZT53aW5kb3c8L2NvZGU+LlxuICAgKiBAcmV0dXJuIHs/fSBUaGUgdmFsdWUgKG9iamVjdCBvciBwcmltaXRpdmUpIG9yLCBpZiBub3QgZm91bmQsIHVuZGVmaW5lZC5cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldE9iamVjdEJ5TmFtZScsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9iamVjdEJ5TmFtZShuYW1lLCBvcHRfb2JqKSB7XG5cdFx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHRcdHZhciBwYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcblx0XHRcdHJldHVybiBwYXJ0cy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnQsIGtleSkge1xuXHRcdFx0XHRyZXR1cm4gcGFydFtrZXldO1xuXHRcdFx0fSwgc2NvcGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcbiAgICogdGhlaXIgdmFsdWVzIHNldCB0byB0aGUgcmV0dXJuIHZhbHVlcyBvZiB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IG9ialxuICAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuICAgKiBAcmV0dXJuIHshT2JqZWN0fVxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnbWFwJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0XHRcdHZhciBtYXBwZWRPYmogPSB7fTtcblx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRtYXBwZWRPYmpba2V5c1tpXV0gPSBmbihrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcHBlZE9iajtcblx0XHR9XG5cblx0XHQvKipcbiAgICogQ2hlY2tzIGlmIHRoZSB0d28gZ2l2ZW4gb2JqZWN0cyBhcmUgZXF1YWwuIFRoaXMgaXMgZG9uZSB2aWEgYSBzaGFsbG93XG4gICAqIGNoZWNrLCBpbmNsdWRpbmcgb25seSB0aGUga2V5cyBkaXJlY3RseSBjb250YWluZWQgYnkgdGhlIDIgb2JqZWN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NoYWxsb3dFcXVhbCcsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmoxLCBvYmoyKSB7XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG5cdFx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRcdGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5czEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKG9iajFba2V5czFbaV1dICE9PSBvYmoyW2tleXMxW2ldXSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIG9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL29iamVjdC9vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDEwMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdGZ1bmN0aW9uIHN0cmluZygpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgc3RyaW5nKTtcblx0fVxuXG5cdF9jcmVhdGVDbGFzcyhzdHJpbmcsIG51bGwsIFt7XG5cdFx0a2V5OiAnY2FzZUluc2Vuc2l0aXZlQ29tcGFyZScsXG5cblx0XHQvKipcbiAgICogQ29tcGFyZXMgdGhlIGdpdmVuIHN0cmluZ3Mgd2l0aG91dCB0YWtpbmcgdGhlIGNhc2UgaW50byBhY2NvdW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IHN0cjFcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdHIyXG4gICAqIEByZXR1cm4ge251bWJlcn0gRWl0aGVyIC0xLCAwIG9yIDEsIGFjY29yZGluZyB0byBpZiB0aGUgZmlyc3Qgc3RyaW5nIGlzXG4gICAqICAgICBcInNtYWxsZXJcIiwgZXF1YWwgb3IgXCJiaWdnZXJcIiB0aGFuIHRoZSBzZWNvbmQgZ2l2ZW4gc3RyaW5nLlxuICAgKi9cblx0XHR2YWx1ZTogZnVuY3Rpb24gY2FzZUluc2Vuc2l0aXZlQ29tcGFyZShzdHIxLCBzdHIyKSB7XG5cdFx0XHR2YXIgdGVzdDEgPSBTdHJpbmcoc3RyMSkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHZhciB0ZXN0MiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAodGVzdDEgPCB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9IGVsc2UgaWYgKHRlc3QxID09PSB0ZXN0Mikge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBSZW1vdmVzIHRoZSBicmVha2luZyBzcGFjZXMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHN0cmluZyBhbmRcbiAgICogY29sbGFwc2VzIHRoZSBzZXF1ZW5jZXMgb2YgYnJlYWtpbmcgc3BhY2VzIGluIHRoZSBtaWRkbGUgaW50byBzaW5nbGUgc3BhY2VzLlxuICAgKiBUaGUgb3JpZ2luYWwgYW5kIHRoZSByZXN1bHQgc3RyaW5ncyByZW5kZXIgdGhlIHNhbWUgd2F5IGluIEhUTUwuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgaW4gd2hpY2ggdG8gY29sbGFwc2Ugc3BhY2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IENvcHkgb2YgdGhlIHN0cmluZyB3aXRoIG5vcm1hbGl6ZWQgYnJlYWtpbmcgc3BhY2VzLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnY29sbGFwc2VCcmVha2luZ1NwYWNlcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGNvbGxhcHNlQnJlYWtpbmdTcGFjZXMoc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICogRXNjYXBlcyBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcgdGhhdCBhcmUgbm90IHNhZmUgdG8gdXNlIGluIGEgUmVnRXhwLlxuICAqIEBwYXJhbSB7Kn0gc3RyIFRoZSBzdHJpbmcgdG8gZXNjYXBlLiBJZiBub3QgYSBzdHJpbmcsIGl0IHdpbGwgYmUgY2FzdGVkXG4gICogICAgIHRvIG9uZS5cbiAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVnRXhwIHNhZmUsIGVzY2FwZWQgY29weSBvZiB7QGNvZGUgc30uXG4gICovXG5cblx0fSwge1xuXHRcdGtleTogJ2VzY2FwZVJlZ2V4Jyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFstKClcXFtcXF17fSs/Ki4kXFxefCw6IzwhXFxcXF0pL2csICdcXFxcJDEnKS5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXHgwOCcpO1xuXHRcdH1cblxuXHRcdC8qKlxuICAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG4gICogQHJldHVybiB7c3RyaW5nfSBBIHJhbmRvbSBzdHJpbmcsIGUuZy4gc24xczd2YjRnY2ljLlxuICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdnZXRSYW5kb21TdHJpbmcnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0XHR2YXIgeCA9IDIxNDc0ODM2NDg7XG5cdFx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogeCkgXiBEYXRlLm5vdygpKS50b1N0cmluZygzNik7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGhhc2hjb2RlIGZvciBhIHN0cmluZy4gVGhlIGhhc2hjb2RlIHZhbHVlIGlzIGNvbXB1dGVkIGJ5XG4gICAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG4gICAqIHByb3BlcnR5IG9mIHVzaW5nIDMxIHByaW1lIGlzIHRoYXQgdGhlIG11bHRpcGxpY2F0aW9uIGNhbiBiZSByZXBsYWNlZCBieVxuICAgKiBhIHNoaWZ0IGFuZCBhIHN1YnRyYWN0aW9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2U6IDMxKmkgPT0gKGk8PDUpLWkuXG4gICAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsIFRhcmdldCBzdHJpbmcuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIGhhc2hjb2RlLlxuICAgKi9cblxuXHR9LCB7XG5cdFx0a2V5OiAnaGFzaENvZGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBoYXNoQ29kZSh2YWwpIHtcblx0XHRcdHZhciBoYXNoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aGFzaCA9IDMxICogaGFzaCArIHZhbC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhhc2g7XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIFJlcGxhY2VzIGludGVydmFsIGludG8gdGhlIHN0cmluZyB3aXRoIHNwZWNpZmllZCB2YWx1ZSwgZS5nLlxuICAgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbnB1dCBzdHJpbmcuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBpbnRlcnZhbCBwb3NpdGlvbiB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCByZXBsYWNlcyB0aGUgc3BlY2lmaWVkIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdyZXBsYWNlSW50ZXJ2YWwnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlSW50ZXJ2YWwoc3RyLCBzdGFydCwgZW5kLCB2YWx1ZSkge1xuXHRcdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIHN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsLXNveS9ub2RlX21vZHVsZXMvbWV0YWwvbGliL3N0cmluZy9zdHJpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnJlcXVpcmUoJy4vSFRNTFBhcnNlcicpO1xuXG52YXIgX0hUTUwySW5jRG9tID0gcmVxdWlyZSgnLi9IVE1MMkluY0RvbScpO1xuXG52YXIgX0hUTUwySW5jRG9tMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hUTUwySW5jRG9tKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gX0hUTUwySW5jRG9tMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2h0bWwyaW5jZG9tL2xpYi93aXRoUGFyc2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuLypcbiAqIEhUTUw1IFBhcnNlciBCeSBTYW0gQmxvd2VzXG4gKlxuICogRGVzaWduZWQgZm9yIEhUTUw1IGRvY3VtZW50c1xuICpcbiAqIE9yaWdpbmFsIGNvZGUgYnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuICogaHR0cDovL2Vqb2huLm9yZy9ibG9nL3B1cmUtamF2YXNjcmlwdC1odG1sLXBhcnNlci9cbiAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIGh0dHA6Ly9lcmlrLmVhZS5uZXQvc2ltcGxlaHRtbHBhcnNlci9zaW1wbGVodG1scGFyc2VyLmpzXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogTGljZW5zZVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFRoaXMgY29kZSBpcyB0cmlwbGUgbGljZW5zZWQgdXNpbmcgQXBhY2hlIFNvZnR3YXJlIExpY2Vuc2UgMi4wLFxuICogTW96aWxsYSBQdWJsaWMgTGljZW5zZSBvciBHTlUgUHVibGljIExpY2Vuc2VcbiAqXG4gKiAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3RcbiAqIHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weVxuICogb2YgdGhlIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICpcbiAqIFRoZSBjb250ZW50cyBvZiB0aGlzIGZpbGUgYXJlIHN1YmplY3QgdG8gdGhlIE1vemlsbGEgUHVibGljIExpY2Vuc2VcbiAqIFZlcnNpb24gMS4xICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpblxuICogY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqIGh0dHA6Ly93d3cubW96aWxsYS5vcmcvTVBML1xuICpcbiAqIFNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIlxuICogYmFzaXMsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGVcbiAqIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcmlnaHRzIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogVGhlIE9yaWdpbmFsIENvZGUgaXMgU2ltcGxlIEhUTUwgUGFyc2VyLlxuICpcbiAqIFRoZSBJbml0aWFsIERldmVsb3BlciBvZiB0aGUgT3JpZ2luYWwgQ29kZSBpcyBFcmlrIEFydmlkc3Nvbi5cbiAqIFBvcnRpb25zIGNyZWF0ZWQgYnkgRXJpayBBcnZpZHNzc29uIGFyZSBDb3B5cmlnaHQgKEMpIDIwMDQuIEFsbCBSaWdodHNcbiAqIFJlc2VydmVkLlxuICpcbiAqIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gKiBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb247IGVpdGhlciB2ZXJzaW9uIDJcbiAqIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BICAwMjExMC0xMzAxLCBVU0EuXG4gKiBAbGljZW5zZVxuICovXG5cbi8qXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVXNhZ2VcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAvLyBVc2UgbGlrZSBzbzpcbiAqIEhUTUxQYXJzZXIoaHRtbFN0cmluZywge1xuICogICAgIHN0YXJ0OiBmdW5jdGlvbih0YWcsIGF0dHJzLCB1bmFyeSkge30sXG4gKiAgICAgZW5kOiBmdW5jdGlvbih0YWcpIHt9LFxuICogICAgIGNoYXJzOiBmdW5jdGlvbih0ZXh0KSB7fSxcbiAqICAgICBjb21tZW50OiBmdW5jdGlvbih0ZXh0KSB7fVxuICogfSk7XG4gKlxuICogLy8gb3IgdG8gZ2V0IGFuIFhNTCBzdHJpbmc6XG4gKiBIVE1MdG9YTUwoaHRtbFN0cmluZyk7XG4gKlxuICogLy8gb3IgdG8gZ2V0IGFuIFhNTCBET00gRG9jdW1lbnRcbiAqIEhUTUx0b0RPTShodG1sU3RyaW5nKTtcbiAqXG4gKiAvLyBvciB0byBpbmplY3QgaW50byBhbiBleGlzdGluZyBkb2N1bWVudC9ET00gbm9kZVxuICogSFRNTHRvRE9NKGh0bWxTdHJpbmcsIGRvY3VtZW50KTtcbiAqIEhUTUx0b0RPTShodG1sU3RyaW5nLCBkb2N1bWVudC5ib2R5KTtcbiAqXG4gKi9cblxuKGZ1bmN0aW9uICgpIHtcblx0Ly8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5cdHZhciBzdGFydFRhZyA9IC9ePChbLUEtWmEtejAtOV9dKykoKD86XFxzK1thLXpBLVpfOl1bLWEtekEtWjAtOV86Ll0qKD86XFxzKj1cXHMqKD86KD86XCJbXlwiXSpcIil8KD86J1teJ10qJyl8W14+XFxzXSspKT8pKilcXHMqKFxcLz8pPi8sXG5cdCAgICBlbmRUYWcgPSAvXjxcXC8oWy1BLVphLXowLTlfXSspW14+XSo+Lyxcblx0ICAgIGF0dHIgPSAvKFthLXpBLVpfOl1bLWEtekEtWjAtOV86Ll0qKSg/Olxccyo9XFxzKig/Oig/OlwiKCg/OlxcXFwufFteXCJdKSopXCIpfCg/OicoKD86XFxcXC58W14nXSkqKScpfChbXj5cXHNdKykpKT8vZztcblxuXHQvLyBFbXB0eSBFbGVtZW50cyAtIEhUTUwgNVxuXHR2YXIgZW1wdHkgPSBtYWtlTWFwKFwiYXJlYSxiYXNlLGJhc2Vmb250LGJyLGNvbCxmcmFtZSxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLGVtYmVkLGNvbW1hbmQsa2V5Z2VuLHNvdXJjZSx0cmFjayx3YnJcIik7XG5cblx0Ly8gQmxvY2sgRWxlbWVudHMgLSBIVE1MIDVcblx0dmFyIGJsb2NrID0gbWFrZU1hcChcImEsYWRkcmVzcyxhcnRpY2xlLGFwcGxldCxhc2lkZSxhdWRpbyxibG9ja3F1b3RlLGJ1dHRvbixjYW52YXMsY2VudGVyLGRkLGRlbCxkaXIsZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLGZyYW1lc2V0LGgxLGgyLGgzLGg0LGg1LGg2LGhlYWRlcixoZ3JvdXAsaHIsaWZyYW1lLGlucyxpc2luZGV4LGxpLG1hcCxtZW51LG5vZnJhbWVzLG5vc2NyaXB0LG9iamVjdCxvbCxvdXRwdXQscCxwcmUsc2VjdGlvbixzY3JpcHQsdGFibGUsdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdHIsdWwsdmlkZW9cIik7XG5cblx0Ly8gSW5saW5lIEVsZW1lbnRzIC0gSFRNTCA1XG5cdHZhciBpbmxpbmUgPSBtYWtlTWFwKFwiYWJicixhY3JvbnltLGFwcGxldCxiLGJhc2Vmb250LGJkbyxiaWcsYnIsYnV0dG9uLGNpdGUsY29kZSxkZWwsZGZuLGVtLGZvbnQsaSxpZnJhbWUsaW1nLGlucHV0LGlucyxrYmQsbGFiZWwsbWFwLG9iamVjdCxxLHMsc2FtcCxzY3JpcHQsc2VsZWN0LHNtYWxsLHNwYW4sc3RyaWtlLHN0cm9uZyxzdWIsc3VwLHRleHRhcmVhLHR0LHUsdmFyXCIpO1xuXG5cdC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuXHQvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5cdHZhciBjbG9zZVNlbGYgPSBtYWtlTWFwKFwiY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyXCIpO1xuXG5cdC8vIEF0dHJpYnV0ZXMgdGhhdCBoYXZlIHRoZWlyIHZhbHVlcyBmaWxsZWQgaW4gZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG5cdHZhciBmaWxsQXR0cnMgPSBtYWtlTWFwKFwiY2hlY2tlZCxjb21wYWN0LGRlY2xhcmUsZGVmZXIsZGlzYWJsZWQsaXNtYXAsbXVsdGlwbGUsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm93cmFwLHJlYWRvbmx5LHNlbGVjdGVkXCIpO1xuXG5cdC8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuXHR2YXIgc3BlY2lhbCA9IG1ha2VNYXAoXCJzY3JpcHQsc3R5bGVcIik7XG5cblx0dmFyIEhUTUxQYXJzZXIgPSB3aW5kb3cuSFRNTFBhcnNlciA9IGZ1bmN0aW9uIChodG1sLCBoYW5kbGVyKSB7XG5cdFx0dmFyIGluZGV4LFxuXHRcdCAgICBjaGFycyxcblx0XHQgICAgbWF0Y2gsXG5cdFx0ICAgIHN0YWNrID0gW10sXG5cdFx0ICAgIGxhc3QgPSBodG1sO1xuXHRcdHN0YWNrLmxhc3QgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdO1xuXHRcdH07XG5cblx0XHR3aGlsZSAoaHRtbCkge1xuXHRcdFx0Y2hhcnMgPSB0cnVlO1xuXG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgc2NyaXB0IG9yIHN0eWxlIGVsZW1lbnRcblx0XHRcdGlmICghc3RhY2subGFzdCgpIHx8ICFzcGVjaWFsW3N0YWNrLmxhc3QoKV0pIHtcblxuXHRcdFx0XHQvLyBDb21tZW50XG5cdFx0XHRcdGlmIChodG1sLmluZGV4T2YoXCI8IS0tXCIpID09IDApIHtcblx0XHRcdFx0XHRpbmRleCA9IGh0bWwuaW5kZXhPZihcIi0tPlwiKTtcblxuXHRcdFx0XHRcdGlmIChpbmRleCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRpZiAoaGFuZGxlci5jb21tZW50KSBoYW5kbGVyLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgaW5kZXgpKTtcblx0XHRcdFx0XHRcdGh0bWwgPSBodG1sLnN1YnN0cmluZyhpbmRleCArIDMpO1xuXHRcdFx0XHRcdFx0Y2hhcnMgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBlbmQgdGFnXG5cdFx0XHRcdH0gZWxzZSBpZiAoaHRtbC5pbmRleE9mKFwiPC9cIikgPT0gMCkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG5cblx0XHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0XHRodG1sID0gaHRtbC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0bWF0Y2hbMF0ucmVwbGFjZShlbmRUYWcsIHBhcnNlRW5kVGFnKTtcblx0XHRcdFx0XHRcdFx0Y2hhcnMgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gc3RhcnQgdGFnXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChodG1sLmluZGV4T2YoXCI8XCIpID09IDApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2ggPSBodG1sLm1hdGNoKHN0YXJ0VGFnKTtcblxuXHRcdFx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0XHRodG1sID0gaHRtbC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRtYXRjaFswXS5yZXBsYWNlKHN0YXJ0VGFnLCBwYXJzZVN0YXJ0VGFnKTtcblx0XHRcdFx0XHRcdFx0XHRjaGFycyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNoYXJzKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBodG1sLmluZGV4T2YoXCI8XCIpO1xuXG5cdFx0XHRcdFx0dmFyIHRleHQgPSBpbmRleCA8IDAgPyBodG1sIDogaHRtbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuXHRcdFx0XHRcdGh0bWwgPSBpbmRleCA8IDAgPyBcIlwiIDogaHRtbC5zdWJzdHJpbmcoaW5kZXgpO1xuXG5cdFx0XHRcdFx0aWYgKGhhbmRsZXIuY2hhcnMpIGhhbmRsZXIuY2hhcnModGV4dCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UobmV3IFJlZ0V4cChcIihbXFxcXHNcXFxcU10qPyk8XFwvXCIgKyBzdGFjay5sYXN0KCkgKyBcIltePl0qPlwiKSwgZnVuY3Rpb24gKGFsbCwgdGV4dCkge1xuXHRcdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLzwhLS0oW1xcc1xcU10qPyktLT58PCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCBcIiQxJDJcIik7XG5cdFx0XHRcdFx0aWYgKGhhbmRsZXIuY2hhcnMpIGhhbmRsZXIuY2hhcnModGV4dCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cGFyc2VFbmRUYWcoXCJcIiwgc3RhY2subGFzdCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGh0bWwgPT0gbGFzdCkgdGhyb3cgXCJQYXJzZSBFcnJvcjogXCIgKyBodG1sO1xuXHRcdFx0bGFzdCA9IGh0bWw7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG5cdFx0cGFyc2VFbmRUYWcoKTtcblxuXHRcdGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcodGFnLCB0YWdOYW1lLCByZXN0LCB1bmFyeSkge1xuXHRcdFx0dGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKGJsb2NrW3RhZ05hbWVdKSB7XG5cdFx0XHRcdC8vIENsb3NlIGxhc3QgdGFnIGlmIGl0J3MgaW5saW5lLCBleGNlcHQgaWYgaXQncyBhIFwic3BhblwiIChzaW5jZSBwZW9wbGVcblx0XHRcdFx0Ly8gdXN1YWxseSBhZGQgYW55dGhpbmcgdGhleSB3YW50IHRvIHNwYW5zLCBhbmQgYnJvd3NlcnMgYWxsb3cgaXQpLlxuXHRcdFx0XHQvLyBOb3RlOiB0aGlzIGV4Y2VwdGlvbiBmb3IgXCJzcGFuXCIgd2FzIGFkZGVkIG1hbnVhbGx5IChpLmUuIGl0J3Mgbm90XG5cdFx0XHRcdC8vIHByZXNlbnQgaW4gdGhlIG9yaWdpbmFsIGNvZGUpLlxuXHRcdFx0XHR3aGlsZSAoc3RhY2subGFzdCgpICYmIGlubGluZVtzdGFjay5sYXN0KCldICYmIHN0YWNrLmxhc3QoKSAhPT0gJ3NwYW4nKSB7XG5cdFx0XHRcdFx0cGFyc2VFbmRUYWcoXCJcIiwgc3RhY2subGFzdCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xvc2VTZWxmW3RhZ05hbWVdICYmIHN0YWNrLmxhc3QoKSA9PSB0YWdOYW1lKSB7XG5cdFx0XHRcdHBhcnNlRW5kVGFnKFwiXCIsIHRhZ05hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHR1bmFyeSA9IGVtcHR5W3RhZ05hbWVdIHx8ICEhdW5hcnk7XG5cblx0XHRcdGlmICghdW5hcnkpIHN0YWNrLnB1c2godGFnTmFtZSk7XG5cblx0XHRcdGlmIChoYW5kbGVyLnN0YXJ0KSB7XG5cdFx0XHRcdHZhciBhdHRycyA9IFtdO1xuXG5cdFx0XHRcdHJlc3QucmVwbGFjZShhdHRyLCBmdW5jdGlvbiAobWF0Y2gsIG5hbWUpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhcmd1bWVudHNbMl0gPyBhcmd1bWVudHNbMl0gOiBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiBhcmd1bWVudHNbNF0gPyBhcmd1bWVudHNbNF0gOiBmaWxsQXR0cnNbbmFtZV0gPyBuYW1lIDogXCJcIjtcblxuXHRcdFx0XHRcdGF0dHJzLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGVzY2FwZWQ6IHZhbHVlLnJlcGxhY2UoLyhefFteXFxcXF0pXCIvZywgJyQxXFxcXFxcXCInKSAvL1wiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGlmIChoYW5kbGVyLnN0YXJ0KSBoYW5kbGVyLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFbmRUYWcodGFnLCB0YWdOYW1lKSB7XG5cdFx0XHQvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuXHRcdFx0aWYgKCF0YWdOYW1lKSB2YXIgcG9zID0gMDtcblxuXHRcdFx0Ly8gRmluZCB0aGUgY2xvc2VzdCBvcGVuZWQgdGFnIG9mIHRoZSBzYW1lIHR5cGVcblx0XHRcdGVsc2UgZm9yICh2YXIgcG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG5cdFx0XHRcdFx0aWYgKHN0YWNrW3Bvc10gPT0gdGFnTmFtZSkgYnJlYWs7XG5cdFx0XHRcdH1pZiAocG9zID49IDApIHtcblx0XHRcdFx0Ly8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcblx0XHRcdFx0Zm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcblx0XHRcdFx0XHRpZiAoaGFuZGxlci5lbmQpIGhhbmRsZXIuZW5kKHN0YWNrW2ldKTtcblx0XHRcdFx0fSAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcblx0XHRcdFx0c3RhY2subGVuZ3RoID0gcG9zO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBtYWtlTWFwKHN0cikge1xuXHRcdHZhciBvYmogPSB7fSxcblx0XHQgICAgaXRlbXMgPSBzdHIuc3BsaXQoXCIsXCIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG9ialtpdGVtc1tpXV0gPSB0cnVlO1xuXHRcdH1yZXR1cm4gb2JqO1xuXHR9XG59KS5jYWxsKHVuZGVmaW5lZCk7XG5cbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaHRtbDJpbmNkb20vbGliL0hUTUxQYXJzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfdW5lc2NhcGUgPSByZXF1aXJlKCcuL3VuZXNjYXBlJyk7XG5cbnZhciBfdW5lc2NhcGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdW5lc2NhcGUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgcGFyc2VyXztcblxudmFyIEhUTUwySW5jRG9tID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBIVE1MMkluY0RvbSgpIHtcblx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgSFRNTDJJbmNEb20pO1xuXHR9XG5cblx0X2NyZWF0ZUNsYXNzKEhUTUwySW5jRG9tLCBudWxsLCBbe1xuXHRcdGtleTogJ2J1aWxkRm4nLFxuXG5cdFx0LyoqXG4gICAqIFNob3VsZCBjb252ZXJ0IHRoZSBnaXZlbiBodG1sIHN0cmluZyB0byBhIGZ1bmN0aW9uIHdpdGggY2FsbHMgdG9cbiAgICogaW5jcmVtZW50YWwgZG9tIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAqIEByZXR1cm4geyFmdW5jdGlvbigpfSBGdW5jdGlvbiB3aXRoIGluY3JlbWVudGFsIGRvbSBjYWxscyBmb3IgYnVpbGRpbmdcbiAgICogICAgIHRoZSBnaXZlbiBodG1sIHN0cmluZy5cbiAgICovXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGJ1aWxkRm4oaHRtbCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIEhUTUwySW5jRG9tLnJ1bihodG1sKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG4gICAqIEdldHMgdGhlIGh0bWwgcGFyc2VyIGJlaW5nIGN1cnJlbnRseSB1c2VkLlxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oKX1cbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ2dldFBhcnNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIGdldFBhcnNlcigpIHtcblx0XHRcdHJldHVybiBwYXJzZXJfIHx8IHdpbmRvdy5IVE1MUGFyc2VyO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBTaG91bGQgY29udmVydCB0aGUgZ2l2ZW4gaHRtbCBzdHJpbmcgdG8gY2FsbHMgdG8gaW5jcmVtZW50YWwgZG9tIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gICAqL1xuXG5cdH0sIHtcblx0XHRrZXk6ICdydW4nLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBydW4oaHRtbCkge1xuXHRcdFx0SFRNTDJJbmNEb20uZ2V0UGFyc2VyKCkoaHRtbCwge1xuXHRcdFx0XHRzdGFydDogZnVuY3Rpb24gc3RhcnQodGFnLCBhdHRycywgdW5hcnkpIHtcblx0XHRcdFx0XHR2YXIgZm4gPSB1bmFyeSA/IEluY3JlbWVudGFsRE9NLmVsZW1lbnRWb2lkIDogSW5jcmVtZW50YWxET00uZWxlbWVudE9wZW47XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBbdGFnLCBudWxsLCBbXV07XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0YXJncy5wdXNoKGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldLnZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm4uYXBwbHkobnVsbCwgYXJncyk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0ZW5kOiBmdW5jdGlvbiBlbmQodGFnKSB7XG5cdFx0XHRcdFx0SW5jcmVtZW50YWxET00uZWxlbWVudENsb3NlKHRhZyk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Y2hhcnM6IGZ1bmN0aW9uIGNoYXJzKHRleHQpIHtcblx0XHRcdFx0XHRJbmNyZW1lbnRhbERPTS50ZXh0KHRleHQsIF91bmVzY2FwZTIuZGVmYXVsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuICAgKiBDaGFuZ2VzIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCB0byBwYXJzZSBodG1sIHN0cmluZ3MuIEJ5IGRlZmF1bHRcbiAgICogdGhpcyB3aWxsIHVzZSB0aGUgYEhUTUxQYXJzZXJgIGZ1bmN0aW9uIGZyb21cbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2Jsb3dzaWUvUHVyZS1KYXZhU2NyaXB0LUhUTUw1LVBhcnNlci4gVGhpcyB3aWxsIGFjY2VwdFxuICAgKiBhbnkgZnVuY3Rpb24gdGhhdCBmb2xsb3dzIHRoYXQgc2FtZSBhcGksIGJhc2ljYWxseSBhY2NlcHRpbmcgdGhlIGh0bWxcbiAgICogc3RyaW5nIGFuZCBhbiBvYmplY3Qgd2l0aCBgc3RhcnRgLCBgZW5kYCBhbmQgYGNoYXJzYCBmdW5jdGlvbnMgdG8gYmUgY2FsbGVkXG4gICAqIGR1cmluZyB0aGUgcGFyc2luZy5cbiAgICogQHBhcmFtIHshZnVuY3Rpb24oc3RyaW5nLCAhT2JqZWN0fSBuZXdQYXJzZXJcbiAgICovXG5cblx0fSwge1xuXHRcdGtleTogJ3NldFBhcnNlcicsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIHNldFBhcnNlcihuZXdQYXJzZXIpIHtcblx0XHRcdHBhcnNlcl8gPSBuZXdQYXJzZXI7XG5cdFx0fVxuXHR9XSk7XG5cblx0cmV0dXJuIEhUTUwySW5jRG9tO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBIVE1MMkluY0RvbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9odG1sMmluY2RvbS9saWIvSFRNTDJJbmNEb20uanNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbi8vIENvcHlyaWdodCAyMDA2IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTLUlTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4vKipcbiAqIFVuZXNjYXBlcyBhbiBIVE1MIHN0cmluZyB1c2luZyBhIERPTSB0byByZXNvbHZlIG5vbi1YTUwsIG5vbi1udW1lcmljXG4gKiBlbnRpdGllcy4gVGhpcyBmdW5jdGlvbiBpcyBYU1Mtc2FmZSBhbmQgd2hpdGVzcGFjZS1wcmVzZXJ2aW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHVuZXNjYXBlZCB7QGNvZGUgc3RyfSBzdHJpbmcuXG4gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmZ1bmN0aW9uIHVuZXNjYXBlKHN0cikge1xuICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICB2YXIgc2VlbiA9IHsgJyZhbXA7JzogJyYnLCAnJmx0Oyc6ICc8JywgJyZndDsnOiAnPicsICcmcXVvdDsnOiAnXCInIH07XG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAvLyBNYXRjaCBhcyBtYW55IHZhbGlkIGVudGl0eSBjaGFyYWN0ZXJzIGFzIHBvc3NpYmxlLiBJZiB0aGUgYWN0dWFsIGVudGl0eVxuICAvLyBoYXBwZW5zIHRvIGJlIHNob3J0ZXIsIGl0IHdpbGwgc3RpbGwgd29yayBhcyBpbm5lckhUTUwgd2lsbCByZXR1cm4gdGhlXG4gIC8vIHRyYWlsaW5nIGNoYXJhY3RlcnMgdW5jaGFuZ2VkLiBTaW5jZSB0aGUgZW50aXR5IGNoYXJhY3RlcnMgZG8gbm90IGluY2x1ZGVcbiAgLy8gb3BlbiBhbmdsZSBicmFja2V0LCB0aGVyZSBpcyBubyBjaGFuY2Ugb2YgWFNTIGZyb20gdGhlIGlubmVySFRNTCB1c2UuXG4gIC8vIFNpbmNlIG5vIHdoaXRlc3BhY2UgaXMgcGFzc2VkIHRvIGlubmVySFRNTCwgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWQuXG4gIHJldHVybiBzdHIucmVwbGFjZShIVE1MX0VOVElUWV9QQVRURVJOXywgZnVuY3Rpb24gKHMsIGVudGl0eSkge1xuICAgIC8vIENoZWNrIGZvciBjYWNoZWQgZW50aXR5LlxuICAgIHZhciB2YWx1ZSA9IHNlZW5bc107XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBudW1lcmljIGVudGl0eS5cbiAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAvLyBQcmVmaXggd2l0aCAwIHNvIHRoYXQgaGV4IGVudGl0aWVzIChlLmcuICYjeDEwKSBwYXJzZSBhcyBoZXggbnVtYmVycy5cbiAgICAgIHZhciBuID0gTnVtYmVyKCcwJyArIGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgaWYgKCFpc05hTihuKSkge1xuICAgICAgICB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGwgYmFjayB0byBpbm5lckhUTUwgb3RoZXJ3aXNlLlxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIC8vIEFwcGVuZCBhIG5vbi1lbnRpdHkgY2hhcmFjdGVyIHRvIGF2b2lkIGEgYnVnIGluIFdlYmtpdCB0aGF0IHBhcnNlc1xuICAgICAgLy8gYW4gaW52YWxpZCBlbnRpdHkgYXQgdGhlIGVuZCBvZiBpbm5lckhUTUwgdGV4dCBhcyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgZGl2LmlubmVySFRNTCA9IHMgKyAnICc7XG4gICAgICAvLyBUaGVuIHJlbW92ZSB0aGUgdHJhaWxpbmcgY2hhcmFjdGVyIGZyb20gdGhlIHJlc3VsdC5cbiAgICAgIHZhbHVlID0gZGl2LmZpcnN0Q2hpbGQubm9kZVZhbHVlLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgLy8gQ2FjaGUgYW5kIHJldHVybi5cbiAgICBzZWVuW3NdID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdW5lc2NhcGU7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHRoYXQgbWF0Y2hlcyBhbiBIVE1MIGVudGl0eS5cbiAqIEB0eXBlIHshUmVnRXhwfVxuICovXG5cbnZhciBIVE1MX0VOVElUWV9QQVRURVJOXyA9IC8mKFteO1xcczwmXSspOz8vZztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9odG1sMmluY2RvbS9saWIvdW5lc2NhcGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG52YXIgU295QW9wID0ge1xuXHQvKipcbiAgKiBUaGUgZnVuY3Rpb25zIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCBpbnN0ZWFkIG9mIGEgdGVtcGxhdGUgY2FsbC4gVGhlIGxhc3RcbiAgKiBmdW5jdGlvbiBpbiB0aGUgYXJyYXkgaXMgdGhlIG9uZSB0aGF0IGlzIGludGVyY2VwdGluZyBhdCB0aGUgbW9tZW50LiBJZiB0aGVcbiAgKiBhcnJheSBpcyBlbXB0eSwgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGluc3RlYWQuXG4gICogQHR5cGUgeyFBcnJheTxmdW5jdGlvbigpPn1cbiAgKiBAcHJvdGVjdGVkXG4gICovXG5cdGludGVyY2VwdEZuc186IFtdLFxuXG5cdC8qKlxuICAqIEdldHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIG9mIHRoZSBnaXZlbiB0ZW1wbGF0ZSBmdW5jdGlvbi4gSWYgbm8gb3JpZ2luYWwgZXhpc3RzLFxuICAqIHJldHVybnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGl0c2VsZi5cbiAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICAqIEByZXR1cm4geyFmdW5jdGlvbigpfVxuICAqL1xuXHRnZXRPcmlnaW5hbEZuOiBmdW5jdGlvbiBnZXRPcmlnaW5hbEZuKGZuKSB7XG5cdFx0cmV0dXJuIGZuLm9yaWdpbmFsRm4gPyBmbi5vcmlnaW5hbEZuIDogZm47XG5cdH0sXG5cblx0LyoqXG4gICogSGFuZGxlcyBhIHRlbXBsYXRlIGNhbGwsIGNhbGxpbmcgdGhlIGN1cnJlbnQgaW50ZXJjZXB0aW9uIGZ1bmN0aW9uIGlmIG9uZVxuICAqIGlzIHNldCwgb3Igb3RoZXJ3aXNlIGp1c3QgY2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gaW5zdGVhZC5cbiAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBvcmlnaW5hbEZuIFRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IHdhc1xuICAqICAgICBpbnRlcmNlcHRlZC5cbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0X2RhdGEgVGVtcGxhdGUgZGF0YSBvYmplY3QuXG4gICogQHBhcmFtIHsqfSBvcHRfaWdub3JlZFxuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRfaWpEYXRhIFRlbXBsYXRlIGluamVjdGVkIGRhdGEgb2JqZWN0LlxuICAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGhhbmRsZSB0aGlzXG4gICogICAgIGludGVyY2VwdGlvbi5cbiAgKi9cblx0aGFuZGxlVGVtcGxhdGVDYWxsXzogZnVuY3Rpb24gaGFuZGxlVGVtcGxhdGVDYWxsXyhvcmlnaW5hbEZuLCBvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpIHtcblx0XHR2YXIgaW50ZXJjZXB0Rm4gPSBTb3lBb3AuaW50ZXJjZXB0Rm5zX1tTb3lBb3AuaW50ZXJjZXB0Rm5zXy5sZW5ndGggLSAxXTtcblx0XHRpZiAoaW50ZXJjZXB0Rm4pIHtcblx0XHRcdHJldHVybiBpbnRlcmNlcHRGbi5jYWxsKG51bGwsIG9yaWdpbmFsRm4sIG9wdF9kYXRhLCBvcHRfaWdub3JlZCwgb3B0X2lqRGF0YSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBvcmlnaW5hbEZuLmNhbGwobnVsbCwgb3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG4gICogUmVnaXN0ZXJzIGEgdGVtcGxhdGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW50ZXJjZXB0ZWQuXG4gICogQHBhcmFtIHshT2JqZWN0fSB0ZW1wbGF0ZXMgVGhlIG9yaWdpbmFsIHRlbXBsYXRlcyBvYmplY3QgY29udGFpbmluZyB0aGVcbiAgKiAgICAgZnVuY3Rpb24gdG8gYmUgaW50ZXJjZXB0ZWQuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uIHRvIGludGVyY2VwdC5cbiAgKi9cblx0cmVnaXN0ZXJGb3JJbnRlcmNlcHRpb246IGZ1bmN0aW9uIHJlZ2lzdGVyRm9ySW50ZXJjZXB0aW9uKHRlbXBsYXRlcywgbmFtZSkge1xuXHRcdHZhciBvcmlnaW5hbEZuID0gdGVtcGxhdGVzW25hbWVdO1xuXHRcdGlmICghb3JpZ2luYWxGbi5vcmlnaW5hbEZuKSB7XG5cdFx0XHR0ZW1wbGF0ZXNbbmFtZV0gPSBTb3lBb3AuaGFuZGxlVGVtcGxhdGVDYWxsXy5iaW5kKG51bGwsIG9yaWdpbmFsRm4pO1xuXHRcdFx0dGVtcGxhdGVzW25hbWVdLm9yaWdpbmFsRm4gPSBvcmlnaW5hbEZuO1xuXHRcdH1cblx0fSxcblxuXHQvKipcbiAgKiBTdGFydHMgaW50ZXJjZXB0aW5nIGFsbCB0ZW1wbGF0ZSBjYWxscywgcmVwbGFjaW5nIHRoZW0gd2l0aCBhIGNhbGwgdG8gdGhlXG4gICogZ2l2ZW4gZnVuY3Rpb24gaW5zdGVhZC5cbiAgKiBAcGFyYW0geyFmdW5jdGlvbigpfSBmblxuICAqL1xuXHRzdGFydEludGVyY2VwdGlvbjogZnVuY3Rpb24gc3RhcnRJbnRlcmNlcHRpb24oZm4pIHtcblx0XHRTb3lBb3AuaW50ZXJjZXB0Rm5zXy5wdXNoKGZuKTtcblx0fSxcblxuXHQvKipcbiAgKiBTdG9wcyBpbnRlcmNlcHRpbmcgdGVtcGxhdGUgY2FsbHMuXG4gICovXG5cdHN0b3BBbGxJbnRlcmNlcHRpb25zOiBmdW5jdGlvbiBzdG9wQWxsSW50ZXJjZXB0aW9ucygpIHtcblx0XHRTb3lBb3AuaW50ZXJjZXB0Rm5zXyA9IFtdO1xuXHR9LFxuXG5cdC8qKlxuICAqIFN0b3BzIGludGVyY2VwdGluZyB0ZW1wbGF0ZSBjYWxscyB3aXRoIHRoZSBsYXN0IHJlZ2lzdGVyZWQgZnVuY3Rpb24uXG4gICovXG5cdHN0b3BJbnRlcmNlcHRpb246IGZ1bmN0aW9uIHN0b3BJbnRlcmNlcHRpb24oKSB7XG5cdFx0U295QW9wLmludGVyY2VwdEZuc18ucG9wKCk7XG5cdH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNveUFvcDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC1zb3kvbGliL1NveUFvcC5qc1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5vYmplY3QgPSBleHBvcnRzLkRpc3Bvc2FibGUgPSBleHBvcnRzLmFzeW5jID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuY29yZSA9IHVuZGVmaW5lZDtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5cbnZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblxudmFyIF9hcnJheSA9IHJlcXVpcmUoJy4vYXJyYXkvYXJyYXknKTtcblxudmFyIF9hcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcnJheSk7XG5cbnZhciBfYXN5bmMgPSByZXF1aXJlKCcuL2FzeW5jL2FzeW5jJyk7XG5cbnZhciBfYXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmMpO1xuXG52YXIgX0Rpc3Bvc2FibGUgPSByZXF1aXJlKCcuL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZScpO1xuXG52YXIgX0Rpc3Bvc2FibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRGlzcG9zYWJsZSk7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnLi9vYmplY3Qvb2JqZWN0Jyk7XG5cbnZhciBfb2JqZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29iamVjdCk7XG5cbnZhciBfc3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcvc3RyaW5nJyk7XG5cbnZhciBfc3RyaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N0cmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IF9jb3JlMi5kZWZhdWx0O1xuZXhwb3J0cy5jb3JlID0gX2NvcmUyLmRlZmF1bHQ7XG5leHBvcnRzLmFycmF5ID0gX2FycmF5Mi5kZWZhdWx0O1xuZXhwb3J0cy5hc3luYyA9IF9hc3luYzIuZGVmYXVsdDtcbmV4cG9ydHMuRGlzcG9zYWJsZSA9IF9EaXNwb3NhYmxlMi5kZWZhdWx0O1xuZXhwb3J0cy5vYmplY3QgPSBfb2JqZWN0Mi5kZWZhdWx0O1xuZXhwb3J0cy5zdHJpbmcgPSBfc3RyaW5nMi5kZWZhdWx0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9tZXRhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jb3JlID0gcmVxdWlyZSgnLi4vY29yZScpO1xuXG52YXIgX2NvcmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29yZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gYXJyYXkoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIGFycmF5KTtcblx0fVxuXG5cdC8qKlxuICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudC5cbiAgKiBAcGFyYW0geyFBcnJheTwqPn0gYXJyMVxuICAqIEBwYXJhbSB7IUFycmF5PCo+fSBhcnIyXG4gICogQHJldHVybiB7Ym9vbGVhbn1cbiAgKi9cblx0YXJyYXkuZXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhcnIxLCBhcnIyKSB7XG5cdFx0aWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0LyoqXG4gICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGdpdmVuIGFycmF5IHRoYXQgaXNuJ3QgdW5kZWZpbmVkLlxuICAqIEBwYXJhbSB7IUFycmF5fSBhcnJcbiAgKiBAcmV0dXJuIHsqfVxuICAqL1xuXG5cblx0YXJyYXkuZmlyc3REZWZpbmVkVmFsdWUgPSBmdW5jdGlvbiBmaXJzdERlZmluZWRWYWx1ZShhcnIpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBhcnJbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuICAqIFRyYW5zZm9ybXMgdGhlIGlucHV0IG5lc3RlZCBhcnJheSB0byBiZWNvbWUgZmxhdC5cbiAgKiBAcGFyYW0ge0FycmF5LjwqfEFycmF5LjwqPj59IGFyciBOZXN0ZWQgYXJyYXkgdG8gZmxhdHRlbi5cbiAgKiBAcGFyYW0ge0FycmF5LjwqPn0gb3B0X291dHB1dCBPcHRpb25hbCBvdXRwdXQgYXJyYXkuXG4gICogQHJldHVybiB7QXJyYXkuPCo+fSBGbGF0IGFycmF5LlxuICAqL1xuXG5cblx0YXJyYXkuZmxhdHRlbiA9IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyLCBvcHRfb3V0cHV0KSB7XG5cdFx0dmFyIG91dHB1dCA9IG9wdF9vdXRwdXQgfHwgW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFycltpXSkpIHtcblx0XHRcdFx0YXJyYXkuZmxhdHRlbihhcnJbaV0sIG91dHB1dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaChhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9O1xuXG5cdC8qKlxuICAqIFJlbW92ZXMgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYSBwYXJ0aWN1bGFyIHZhbHVlIGZyb20gYW4gYXJyYXkuXG4gICogQHBhcmFtIHtBcnJheS48VD59IGFyciBBcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge1R9IG9iaiBPYmplY3QgdG8gcmVtb3ZlLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgKiBAdGVtcGxhdGUgVFxuICAqL1xuXG5cblx0YXJyYXkucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGFyciwgb2JqKSB7XG5cdFx0dmFyIGkgPSBhcnIuaW5kZXhPZihvYmopO1xuXHRcdHZhciBydjtcblx0XHRpZiAocnYgPSBpID49IDApIHtcblx0XHRcdGFycmF5LnJlbW92ZUF0KGFyciwgaSk7XG5cdFx0fVxuXHRcdHJldHVybiBydjtcblx0fTtcblxuXHQvKipcbiAgKiBSZW1vdmVzIGZyb20gYW4gYXJyYXkgdGhlIGVsZW1lbnQgYXQgaW5kZXggaVxuICAqIEBwYXJhbSB7QXJyYXl9IGFyciBBcnJheSBvciBhcnJheSBsaWtlIG9iamVjdCBmcm9tIHdoaWNoIHRvIHJlbW92ZSB2YWx1ZS5cbiAgKiBAcGFyYW0ge251bWJlcn0gaSBUaGUgaW5kZXggdG8gcmVtb3ZlLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgKi9cblxuXG5cdGFycmF5LnJlbW92ZUF0ID0gZnVuY3Rpb24gcmVtb3ZlQXQoYXJyLCBpKSB7XG5cdFx0cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbChhcnIsIGksIDEpLmxlbmd0aCA9PT0gMTtcblx0fTtcblxuXHQvKipcbiAgKiBTbGljZXMgdGhlIGdpdmVuIGFycmF5LCBqdXN0IGxpa2UgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgdGhpc1xuICAqIGlzIGZhc3RlciBhbmQgd29ya2luZyBvbiBhbGwgYXJyYXktbGlrZSBvYmplY3RzIChsaWtlIGFyZ3VtZW50cykuXG4gICogQHBhcmFtIHshT2JqZWN0fSBhcnIgQXJyYXktbGlrZSBvYmplY3QgdG8gc2xpY2UuXG4gICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBpbmRleCB0aGF0IHNob3VsZCBzdGFydCB0aGUgc2xpY2UuXG4gICogQHBhcmFtIHtudW1iZXI9fSBvcHRfZW5kIFRoZSBpbmRleCB3aGVyZSB0aGUgc2xpY2Ugc2hvdWxkIGVuZCwgbm90XG4gICogICBpbmNsdWRlZCBpbiB0aGUgZmluYWwgYXJyYXkuIElmIG5vdCBnaXZlbiwgYWxsIGVsZW1lbnRzIGFmdGVyIHRoZVxuICAqICAgc3RhcnQgaW5kZXggd2lsbCBiZSBpbmNsdWRlZC5cbiAgKiBAcmV0dXJuIHshQXJyYXl9XG4gICovXG5cblxuXHRhcnJheS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlKGFyciwgc3RhcnQsIG9wdF9lbmQpIHtcblx0XHR2YXIgc2xpY2VkID0gW107XG5cdFx0dmFyIGVuZCA9IF9jb3JlMi5kZWZhdWx0LmlzRGVmKG9wdF9lbmQpID8gb3B0X2VuZCA6IGFyci5sZW5ndGg7XG5cdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcblx0XHRcdHNsaWNlZC5wdXNoKGFycltpXSk7XG5cdFx0fVxuXHRcdHJldHVybiBzbGljZWQ7XG5cdH07XG5cblx0cmV0dXJuIGFycmF5O1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBhcnJheTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9tZXRhbC9saWIvYXJyYXkvYXJyYXkuanNcbi8vIG1vZHVsZSBpZCA9IDExMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiFcbiAqIFBvbHlmaWxsIGZyb20gR29vZ2xlJ3MgQ2xvc3VyZSBMaWJyYXJ5LlxuICogQ29weXJpZ2h0IDIwMTMgVGhlIENsb3N1cmUgTGlicmFyeSBBdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcbnZhciBhc3luYyA9IHt9O1xuXG4vKipcbiAqIFRocm93IGFuIGl0ZW0gd2l0aG91dCBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuICBGb3JcbiAqIGV4YW1wbGUsIGlmIHByb2Nlc3NpbmcgYSBncm91cCBvZiBpdGVtcyBpbiBhIGxvb3AsIHNvbWV0aW1lcyBpdCBpcyB1c2VmdWxcbiAqIHRvIHJlcG9ydCBhbiBlcnJvciB3aGlsZSBzdGlsbCBhbGxvd2luZyB0aGUgcmVzdCBvZiB0aGUgYmF0Y2ggdG8gYmVcbiAqIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7Kn0gZXhjZXB0aW9uXG4gKi9cbmFzeW5jLnRocm93RXhjZXB0aW9uID0gZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuXHQvLyBFYWNoIHRocm93IG5lZWRzIHRvIGJlIGluIGl0cyBvd24gY29udGV4dC5cblx0YXN5bmMubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGV4Y2VwdGlvbjtcblx0fSk7XG59O1xuXG4vKipcbiAqIEZpcmVzIHRoZSBwcm92aWRlZCBjYWxsYmFjayBqdXN0IGJlZm9yZSB0aGUgY3VycmVudCBjYWxsc3RhY2sgdW53aW5kcywgb3IgYXNcbiAqIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uIGNvbnRleHQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6VEhJUyl9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge1RISVM9fSBvcHRfY29udGV4dCBPYmplY3QgdG8gdXNlIGFzIHRoZSBcInRoaXMgdmFsdWVcIiB3aGVuIGNhbGxpbmdcbiAqICAgICB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gKiBAdGVtcGxhdGUgVEhJU1xuICovXG5hc3luYy5ydW4gPSBmdW5jdGlvbiAoY2FsbGJhY2ssIG9wdF9jb250ZXh0KSB7XG5cdGlmICghYXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8pIHtcblx0XHQvLyBOb3RoaW5nIGlzIGN1cnJlbnRseSBzY2hlZHVsZWQsIHNjaGVkdWxlIGl0IG5vdy5cblx0XHRhc3luYy5uZXh0VGljayhhc3luYy5ydW4ucHJvY2Vzc1dvcmtRdWV1ZSk7XG5cdFx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSB0cnVlO1xuXHR9XG5cblx0YXN5bmMucnVuLndvcmtRdWV1ZV8ucHVzaChuZXcgYXN5bmMucnVuLldvcmtJdGVtXyhjYWxsYmFjaywgb3B0X2NvbnRleHQpKTtcbn07XG5cbi8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbmFzeW5jLnJ1bi53b3JrUXVldWVTY2hlZHVsZWRfID0gZmFsc2U7XG5cbi8qKiBAcHJpdmF0ZSB7IUFycmF5LjwhYXN5bmMucnVuLldvcmtJdGVtXz59ICovXG5hc3luYy5ydW4ud29ya1F1ZXVlXyA9IFtdO1xuXG4vKipcbiAqIFJ1biBhbnkgcGVuZGluZyBhc3luYy5ydW4gd29yayBpdGVtcy4gVGhpcyBmdW5jdGlvbiBpcyBub3QgaW50ZW5kZWRcbiAqIGZvciBnZW5lcmFsIHVzZSwgYnV0IGZvciB1c2UgYnkgZW50cnkgcG9pbnQgaGFuZGxlcnMgdG8gcnVuIGl0ZW1zIGFoZWFkIG9mXG4gKiBhc3luYy5uZXh0VGljay5cbiAqL1xuYXN5bmMucnVuLnByb2Nlc3NXb3JrUXVldWUgPSBmdW5jdGlvbiAoKSB7XG5cdC8vIE5PVEU6IGFkZGl0aW9uYWwgd29yayBxdWV1ZSBpdGVtcyBtYXkgYmUgcHVzaGVkIHdoaWxlIHByb2Nlc3NpbmcuXG5cdHdoaWxlIChhc3luYy5ydW4ud29ya1F1ZXVlXy5sZW5ndGgpIHtcblx0XHQvLyBEb24ndCBsZXQgdGhlIHdvcmsgcXVldWUgZ3JvdyBpbmRlZmluaXRlbHkuXG5cdFx0dmFyIHdvcmtJdGVtcyA9IGFzeW5jLnJ1bi53b3JrUXVldWVfO1xuXHRcdGFzeW5jLnJ1bi53b3JrUXVldWVfID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB3b3JrSXRlbXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB3b3JrSXRlbSA9IHdvcmtJdGVtc1tpXTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdvcmtJdGVtLmZuLmNhbGwod29ya0l0ZW0uc2NvcGUpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRhc3luYy50aHJvd0V4Y2VwdGlvbihlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBUaGVyZSBhcmUgbm8gbW9yZSB3b3JrIGl0ZW1zLCByZXNldCB0aGUgd29yayBxdWV1ZS5cblx0YXN5bmMucnVuLndvcmtRdWV1ZVNjaGVkdWxlZF8gPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZmluYWxcbiAqIEBzdHJ1Y3RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpfSBmblxuICogQHBhcmFtIHtPYmplY3R8bnVsbHx1bmRlZmluZWR9IHNjb3BlXG4gKi9cbmFzeW5jLnJ1bi5Xb3JrSXRlbV8gPSBmdW5jdGlvbiAoZm4sIHNjb3BlKSB7XG5cdC8qKiBAY29uc3QgKi9cblx0dGhpcy5mbiA9IGZuO1xuXHQvKiogQGNvbnN0ICovXG5cdHRoaXMuc2NvcGUgPSBzY29wZTtcbn07XG5cbi8qKlxuICogRmlyZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHRoZSBjdXJyZW50IEpTXG4gKiBleGVjdXRpb24gY29udGV4dC4gc2V0VGltZW91dCjigKYsIDApIGFsd2F5cyB0YWtlcyBhdCBsZWFzdCA1bXMgZm9yIGxlZ2FjeVxuICogcmVhc29ucy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odGhpczpTQ09QRSl9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgYXMgc29vbiBhc1xuICogICAgIHBvc3NpYmxlLlxuICogQHBhcmFtIHtTQ09QRT19IG9wdF9jb250ZXh0IE9iamVjdCBpbiB3aG9zZSBzY29wZSB0byBjYWxsIHRoZSBsaXN0ZW5lci5cbiAqIEB0ZW1wbGF0ZSBTQ09QRVxuICovXG5hc3luYy5uZXh0VGljayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgb3B0X2NvbnRleHQpIHtcblx0dmFyIGNiID0gY2FsbGJhY2s7XG5cdGlmIChvcHRfY29udGV4dCkge1xuXHRcdGNiID0gY2FsbGJhY2suYmluZChvcHRfY29udGV4dCk7XG5cdH1cblx0Y2IgPSBhc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfKGNiKTtcblx0Ly8gSW50cm9kdWNlZCBhbmQgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGJ5IElFMTAuXG5cdC8vIFZlcmlmeSBpZiB2YXJpYWJsZSBpcyBkZWZpbmVkIG9uIHRoZSBjdXJyZW50IHJ1bnRpbWUgKGkuZS4sIG5vZGUsIGJyb3dzZXIpLlxuXHQvLyBDYW4ndCB1c2UgdHlwZW9mIGVuY2xvc2VkIGluIGEgZnVuY3Rpb24gKHN1Y2ggYXMgY29yZS5pc0Z1bmN0aW9uKSBvciBhblxuXHQvLyBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24gd2hlbiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGFuIGVudmlyb25tZW50XG5cdC8vIHdoZXJlIHRoZSB2YXJpYWJsZSBpcyB1bmRlZmluZWQuXG5cdGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0c2V0SW1tZWRpYXRlKGNiKTtcblx0XHRyZXR1cm47XG5cdH1cblx0Ly8gTG9vayBmb3IgYW5kIGNhY2hlIHRoZSBjdXN0b20gZmFsbGJhY2sgdmVyc2lvbiBvZiBzZXRJbW1lZGlhdGUuXG5cdGlmICghYXN5bmMubmV4dFRpY2suc2V0SW1tZWRpYXRlXykge1xuXHRcdGFzeW5jLm5leHRUaWNrLnNldEltbWVkaWF0ZV8gPSBhc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8oKTtcblx0fVxuXHRhc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfKGNiKTtcbn07XG5cbi8qKlxuICogQ2FjaGUgZm9yIHRoZSBzZXRJbW1lZGlhdGUgaW1wbGVtZW50YXRpb24uXG4gKiBAdHlwZSB7ZnVuY3Rpb24oZnVuY3Rpb24oKSl9XG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5zZXRJbW1lZGlhdGVfID0gbnVsbDtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBiZXN0IHBvc3NpYmxlIGltcGxlbWVudGF0aW9uIHRvIHJ1biBhIGZ1bmN0aW9uIGFzIHNvb24gYXNcbiAqIHRoZSBKUyBldmVudCBsb29wIGlzIGlkbGUuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihmdW5jdGlvbigpKX0gVGhlIFwic2V0SW1tZWRpYXRlXCIgaW1wbGVtZW50YXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay5nZXRTZXRJbW1lZGlhdGVFbXVsYXRvcl8gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIENyZWF0ZSBhIHByaXZhdGUgbWVzc2FnZSBjaGFubmVsIGFuZCB1c2UgaXQgdG8gcG9zdE1lc3NhZ2UgZW1wdHkgbWVzc2FnZXNcblx0Ly8gdG8gb3Vyc2VsdmVzLlxuXHR2YXIgQ2hhbm5lbDtcblxuXHQvLyBWZXJpZnkgaWYgdmFyaWFibGUgaXMgZGVmaW5lZCBvbiB0aGUgY3VycmVudCBydW50aW1lIChpLmUuLCBub2RlLCBicm93c2VyKS5cblx0Ly8gQ2FuJ3QgdXNlIHR5cGVvZiBlbmNsb3NlZCBpbiBhIGZ1bmN0aW9uIChzdWNoIGFzIGNvcmUuaXNGdW5jdGlvbikgb3IgYW5cblx0Ly8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duIHdoZW4gdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBhbiBlbnZpcm9ubWVudFxuXHQvLyB3aGVyZSB0aGUgdmFyaWFibGUgaXMgdW5kZWZpbmVkLlxuXHRpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Q2hhbm5lbCA9IE1lc3NhZ2VDaGFubmVsO1xuXHR9XG5cblx0Ly8gSWYgTWVzc2FnZUNoYW5uZWwgaXMgbm90IGF2YWlsYWJsZSBhbmQgd2UgYXJlIGluIGEgYnJvd3NlciwgaW1wbGVtZW50XG5cdC8vIGFuIGlmcmFtZSBiYXNlZCBwb2x5ZmlsbCBpbiBicm93c2VycyB0aGF0IGhhdmUgcG9zdE1lc3NhZ2UgYW5kXG5cdC8vIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIuIFRoZSBsYXR0ZXIgZXhjbHVkZXMgSUU4IGJlY2F1c2UgaXQgaGFzIGFcblx0Ly8gc3luY2hyb25vdXMgcG9zdE1lc3NhZ2UgaW1wbGVtZW50YXRpb24uXG5cdGlmICh0eXBlb2YgQ2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0LyoqIEBjb25zdHJ1Y3RvciAqL1xuXHRcdENoYW5uZWwgPSBmdW5jdGlvbiBDaGFubmVsKCkge1xuXHRcdFx0Ly8gTWFrZSBhbiBlbXB0eSwgaW52aXNpYmxlIGlmcmFtZS5cblx0XHRcdHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcblx0XHRcdGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0aWZyYW1lLnNyYyA9ICcnO1xuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cdFx0XHR2YXIgd2luID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG5cdFx0XHR2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuXHRcdFx0ZG9jLm9wZW4oKTtcblx0XHRcdGRvYy53cml0ZSgnJyk7XG5cdFx0XHRkb2MuY2xvc2UoKTtcblx0XHRcdHZhciBtZXNzYWdlID0gJ2NhbGxJbW1lZGlhdGUnICsgTWF0aC5yYW5kb20oKTtcblx0XHRcdHZhciBvcmlnaW4gPSB3aW4ubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luLmxvY2F0aW9uLmhvc3Q7XG5cdFx0XHR2YXIgb25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0Ly8gVmFsaWRhdGUgb3JpZ2luIGFuZCBtZXNzYWdlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoaXMgbWVzc2FnZSB3YXNcblx0XHRcdFx0Ly8gaW50ZW5kZWQgZm9yIHVzLlxuXHRcdFx0XHRpZiAoZS5vcmlnaW4gIT09IG9yaWdpbiAmJiBlLmRhdGEgIT09IG1lc3NhZ2UpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5wb3J0MS5vbm1lc3NhZ2UoKTtcblx0XHRcdH0uYmluZCh0aGlzKTtcblx0XHRcdHdpbi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25tZXNzYWdlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLnBvcnQxID0ge307XG5cdFx0XHR0aGlzLnBvcnQyID0ge1xuXHRcdFx0XHRwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoKSB7XG5cdFx0XHRcdFx0d2luLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXHRpZiAodHlwZW9mIENoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCgpO1xuXHRcdC8vIFVzZSBhIGZpZm8gbGlua2VkIGxpc3QgdG8gY2FsbCBjYWxsYmFja3MgaW4gdGhlIHJpZ2h0IG9yZGVyLlxuXHRcdHZhciBoZWFkID0ge307XG5cdFx0dmFyIHRhaWwgPSBoZWFkO1xuXHRcdGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aGVhZCA9IGhlYWQubmV4dDtcblx0XHRcdHZhciBjYiA9IGhlYWQuY2I7XG5cdFx0XHRoZWFkLmNiID0gbnVsbDtcblx0XHRcdGNiKCk7XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHR0YWlsLm5leHQgPSB7XG5cdFx0XHRcdGNiOiBjYlxuXHRcdFx0fTtcblx0XHRcdHRhaWwgPSB0YWlsLm5leHQ7XG5cdFx0XHRjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuXHRcdH07XG5cdH1cblx0Ly8gSW1wbGVtZW50YXRpb24gZm9yIElFNi04OiBTY3JpcHQgZWxlbWVudHMgZmlyZSBhbiBhc3luY2hyb25vdXNcblx0Ly8gb25yZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdoZW4gaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuXHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblx0XHRcdHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdC8vIENsZWFuIHVwIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cblx0XHRcdFx0c2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cdFx0XHRcdHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0XHRcdHNjcmlwdCA9IG51bGw7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdGNiID0gbnVsbDtcblx0XHRcdH07XG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHR9O1xuXHR9XG5cdC8vIEZhbGwgYmFjayB0byBzZXRUaW1lb3V0IHdpdGggMC4gSW4gYnJvd3NlcnMgdGhpcyBjcmVhdGVzIGEgZGVsYXkgb2YgNW1zXG5cdC8vIG9yIG1vcmUuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0fTtcbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaXMgb3ZlcnJpZGVkIHRvIHByb3RlY3QgY2FsbGJhY2tzIHdpdGggZW50cnkgcG9pbnRcbiAqIG1vbml0b3IgaWYgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3JzIGVudHJ5IHBvaW50cy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuICogQHJldHVybiB7ZnVuY3Rpb24oKX0gVGhlIHdyYXBwZWQgY2FsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5hc3luYy5uZXh0VGljay53cmFwQ2FsbGJhY2tfID0gZnVuY3Rpb24gKG9wdF9yZXR1cm5WYWx1ZSkge1xuXHRyZXR1cm4gb3B0X3JldHVyblZhbHVlO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2FzeW5jL2FzeW5jLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERpc3Bvc2FibGUgdXRpbGl0eS4gV2hlbiBpbmhlcml0ZWQgcHJvdmlkZXMgdGhlIGBkaXNwb3NlYCBmdW5jdGlvbiB0byBpdHNcbiAqIHN1YmNsYXNzLCB3aGljaCBpcyByZXNwb25zaWJsZSBmb3IgZGlzcG9zaW5nIG9mIGFueSBvYmplY3QgcmVmZXJlbmNlc1xuICogd2hlbiBhbiBpbnN0YW5jZSB3b24ndCBiZSB1c2VkIGFueW1vcmUuIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG4gKiBgZGlzcG9zZUludGVybmFsYCB0byBpbXBsZW1lbnQgYW55IHNwZWNpZmljIGRpc3Bvc2luZyBsb2dpYy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHR2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBEaXNwb3NhYmxlID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBEaXNwb3NhYmxlKCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEaXNwb3NhYmxlKTtcblxuXHRcdC8qKlxuICAgKiBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cblx0XHR0aGlzLmRpc3Bvc2VkXyA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG4gICogRGlzcG9zZXMgb2YgdGhpcyBpbnN0YW5jZSdzIG9iamVjdCByZWZlcmVuY2VzLiBDYWxscyBgZGlzcG9zZUludGVybmFsYC5cbiAgKi9cblxuXG5cdERpc3Bvc2FibGUucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdGlmICghdGhpcy5kaXNwb3NlZF8pIHtcblx0XHRcdHRoaXMuZGlzcG9zZUludGVybmFsKCk7XG5cdFx0XHR0aGlzLmRpc3Bvc2VkXyA9IHRydWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuICAqIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGltcGxlbWVudCBhbnkgc3BlY2lmaWNcbiAgKiBkaXNwb3NpbmcgbG9naWMgKGxpa2UgY2xlYXJpbmcgcmVmZXJlbmNlcyBhbmQgY2FsbGluZyBgZGlzcG9zZWAgb24gb3RoZXJcbiAgKiBkaXNwb3NhYmxlcykuXG4gICovXG5cblxuXHREaXNwb3NhYmxlLnByb3RvdHlwZS5kaXNwb3NlSW50ZXJuYWwgPSBmdW5jdGlvbiBkaXNwb3NlSW50ZXJuYWwoKSB7fTtcblxuXHQvKipcbiAgKiBDaGVja3MgaWYgdGhpcyBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkLlxuICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICovXG5cblxuXHREaXNwb3NhYmxlLnByb3RvdHlwZS5pc0Rpc3Bvc2VkID0gZnVuY3Rpb24gaXNEaXNwb3NlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5kaXNwb3NlZF87XG5cdH07XG5cblx0cmV0dXJuIERpc3Bvc2FibGU7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERpc3Bvc2FibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbWV0YWwvbGliL2Rpc3Bvc2FibGUvRGlzcG9zYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblx0ZnVuY3Rpb24gb2JqZWN0KCkge1xuXHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBvYmplY3QpO1xuXHR9XG5cblx0LyoqXG4gICogQ29waWVzIGFsbCB0aGUgbWVtYmVycyBvZiBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdC5cbiAgKiBAcGFyYW0gey4uLk9iamVjdH0gdmFyX2FyZ3MgVGhlIG9iamVjdHMgZnJvbSB3aGljaCB2YWx1ZXMgd2lsbCBiZSBjb3BpZWQuXG4gICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZS5cbiAgKi9cblx0b2JqZWN0Lm1peGluID0gZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG5cdFx0dmFyIGtleSwgc291cmNlO1xuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRmb3IgKGtleSBpbiBzb3VyY2UpIHtcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIGFuIG9iamVjdCBiYXNlZCBvbiBpdHMgZnVsbHkgcXVhbGlmaWVkIGV4dGVybmFsIG5hbWUuXG4gICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lLlxuICAqIEBwYXJhbSB7b2JqZWN0PX0gb3B0X29iaiBUaGUgb2JqZWN0IHdpdGhpbiB3aGljaCB0byBsb29rOyBkZWZhdWx0IGlzXG4gICogICAgIDxjb2RlPndpbmRvdzwvY29kZT4uXG4gICogQHJldHVybiB7P30gVGhlIHZhbHVlIChvYmplY3Qgb3IgcHJpbWl0aXZlKSBvciwgaWYgbm90IGZvdW5kLCB1bmRlZmluZWQuXG4gICovXG5cblxuXHRvYmplY3QuZ2V0T2JqZWN0QnlOYW1lID0gZnVuY3Rpb24gZ2V0T2JqZWN0QnlOYW1lKG5hbWUsIG9wdF9vYmopIHtcblx0XHR2YXIgc2NvcGUgPSBvcHRfb2JqIHx8IHdpbmRvdztcblx0XHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cdFx0cmV0dXJuIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAocGFydCwga2V5KSB7XG5cdFx0XHRyZXR1cm4gcGFydFtrZXldO1xuXHRcdH0sIHNjb3BlKTtcblx0fTtcblxuXHQvKipcbiAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgdGhlIGdpdmVuIG9uZSwgYnV0IHdpdGhcbiAgKiB0aGVpciB2YWx1ZXMgc2V0IHRvIHRoZSByZXR1cm4gdmFsdWVzIG9mIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24uXG4gICogQHBhcmFtIHshT2JqZWN0fSBvYmpcbiAgKiBAcGFyYW0geyFmdW5jdGlvbihzdHJpbmcsICopfSBmblxuICAqIEByZXR1cm4geyFPYmplY3R9XG4gICovXG5cblxuXHRvYmplY3QubWFwID0gZnVuY3Rpb24gbWFwKG9iaiwgZm4pIHtcblx0XHR2YXIgbWFwcGVkT2JqID0ge307XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwcGVkT2JqW2tleXNbaV1dID0gZm4oa2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcHBlZE9iajtcblx0fTtcblxuXHQvKipcbiAgKiBDaGVja3MgaWYgdGhlIHR3byBnaXZlbiBvYmplY3RzIGFyZSBlcXVhbC4gVGhpcyBpcyBkb25lIHZpYSBhIHNoYWxsb3dcbiAgKiBjaGVjaywgaW5jbHVkaW5nIG9ubHkgdGhlIGtleXMgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoZSAyIG9iamVjdHMuXG4gICogQHJldHVybiB7Ym9vbGVhbn1cbiAgKi9cblxuXG5cdG9iamVjdC5zaGFsbG93RXF1YWwgPSBmdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqMSwgb2JqMikge1xuXHRcdGlmIChvYmoxID09PSBvYmoyKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR2YXIga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcblx0XHR2YXIga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcblx0XHRpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAob2JqMVtrZXlzMVtpXV0gIT09IG9iajJba2V5czFbaV1dKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0cmV0dXJuIG9iamVjdDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gb2JqZWN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9vYmplY3Qvb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0dmFsdWU6IHRydWVcbn0pO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBzdHJpbmcoKSB7XG5cdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIHN0cmluZyk7XG5cdH1cblxuXHQvKipcbiAgKiBSZW1vdmVzIHRoZSBicmVha2luZyBzcGFjZXMgZnJvbSB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIHN0cmluZyBhbmRcbiAgKiBjb2xsYXBzZXMgdGhlIHNlcXVlbmNlcyBvZiBicmVha2luZyBzcGFjZXMgaW4gdGhlIG1pZGRsZSBpbnRvIHNpbmdsZSBzcGFjZXMuXG4gICogVGhlIG9yaWdpbmFsIGFuZCB0aGUgcmVzdWx0IHN0cmluZ3MgcmVuZGVyIHRoZSBzYW1lIHdheSBpbiBIVE1MLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgQSBzdHJpbmcgaW4gd2hpY2ggdG8gY29sbGFwc2Ugc3BhY2VzLlxuICAqIEByZXR1cm4ge3N0cmluZ30gQ29weSBvZiB0aGUgc3RyaW5nIHdpdGggbm9ybWFsaXplZCBicmVha2luZyBzcGFjZXMuXG4gICovXG5cdHN0cmluZy5jb2xsYXBzZUJyZWFraW5nU3BhY2VzID0gZnVuY3Rpb24gY29sbGFwc2VCcmVha2luZ1NwYWNlcyhzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1tcXHRcXHJcXG4gXSsvZywgJyAnKS5yZXBsYWNlKC9eW1xcdFxcclxcbiBdK3xbXFx0XFxyXFxuIF0rJC9nLCAnJyk7XG5cdH07XG5cblx0LyoqXG4gKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZyB0aGF0IGFyZSBub3Qgc2FmZSB0byB1c2UgaW4gYSBSZWdFeHAuXG4gKiBAcGFyYW0geyp9IHN0ciBUaGUgc3RyaW5nIHRvIGVzY2FwZS4gSWYgbm90IGEgc3RyaW5nLCBpdCB3aWxsIGJlIGNhc3RlZFxuICogICAgIHRvIG9uZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQSBSZWdFeHAgc2FmZSwgZXNjYXBlZCBjb3B5IG9mIHtAY29kZSBzfS5cbiAqL1xuXG5cblx0c3RyaW5nLmVzY2FwZVJlZ2V4ID0gZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdFx0cmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLSgpXFxbXFxde30rPyouJFxcXnwsOiM8IVxcXFxdKS9nLCAnXFxcXCQxJykucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFx4MDgnKTtcblx0fTtcblxuXHQvKipcbiAqIFJldHVybnMgYSBzdHJpbmcgd2l0aCBhdCBsZWFzdCA2NC1iaXRzIG9mIHJhbmRvbW5lc3MuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgcmFuZG9tIHN0cmluZywgZS5nLiBzbjFzN3ZiNGdjaWMuXG4gKi9cblxuXG5cdHN0cmluZy5nZXRSYW5kb21TdHJpbmcgPSBmdW5jdGlvbiBnZXRSYW5kb21TdHJpbmcoKSB7XG5cdFx0dmFyIHggPSAyMTQ3NDgzNjQ4O1xuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KS50b1N0cmluZygzNikgKyBNYXRoLmFicyhNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB4KSBeIERhdGUubm93KCkpLnRvU3RyaW5nKDM2KTtcblx0fTtcblxuXHQvKipcbiAgKiBDYWxjdWxhdGVzIHRoZSBoYXNoY29kZSBmb3IgYSBzdHJpbmcuIFRoZSBoYXNoY29kZSB2YWx1ZSBpcyBjb21wdXRlZCBieVxuICAqIHRoZSBzdW0gYWxnb3JpdGhtOiBzWzBdKjMxXihuLTEpICsgc1sxXSozMV4obi0yKSArIC4uLiArIHNbbi0xXS4gQSBuaWNlXG4gICogcHJvcGVydHkgb2YgdXNpbmcgMzEgcHJpbWUgaXMgdGhhdCB0aGUgbXVsdGlwbGljYXRpb24gY2FuIGJlIHJlcGxhY2VkIGJ5XG4gICogYSBzaGlmdCBhbmQgYSBzdWJ0cmFjdGlvbiBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlOiAzMSppID09IChpPDw1KS1pLlxuICAqIE1vZGVybiBWTXMgZG8gdGhpcyBzb3J0IG9mIG9wdGltaXphdGlvbiBhdXRvbWF0aWNhbGx5LlxuICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgVGFyZ2V0IHN0cmluZy5cbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBoYXNoY29kZS5cbiAgKi9cblxuXG5cdHN0cmluZy5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlKHZhbCkge1xuXHRcdHZhciBoYXNoID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRoYXNoID0gMzEgKiBoYXNoICsgdmFsLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoICU9IDB4MTAwMDAwMDAwO1xuXHRcdH1cblx0XHRyZXR1cm4gaGFzaDtcblx0fTtcblxuXHQvKipcbiAgKiBSZXBsYWNlcyBpbnRlcnZhbCBpbnRvIHRoZSBzdHJpbmcgd2l0aCBzcGVjaWZpZWQgdmFsdWUsIGUuZy5cbiAgKiBgcmVwbGFjZUludGVydmFsKFwiYWJjZGVcIiwgMSwgNCwgXCJcIilgIHJldHVybnMgXCJhZVwiLlxuICAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGlucHV0IHN0cmluZy5cbiAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnQgU3RhcnQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgaW50ZXJ2YWwgcG9zaXRpb24gdG8gYmUgcmVwbGFjZWQuXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHJlcGxhY2VzIHRoZSBzcGVjaWZpZWQgaW50ZXJ2YWwuXG4gICogQHJldHVybiB7c3RyaW5nfVxuICAqL1xuXG5cblx0c3RyaW5nLnJlcGxhY2VJbnRlcnZhbCA9IGZ1bmN0aW9uIHJlcGxhY2VJbnRlcnZhbChzdHIsIHN0YXJ0LCBlbmQsIHZhbHVlKSB7XG5cdFx0cmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpICsgdmFsdWUgKyBzdHIuc3Vic3RyaW5nKGVuZCk7XG5cdH07XG5cblx0cmV0dXJuIHN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaW5nO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL21ldGFsL2xpYi9zdHJpbmcvc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcbmltcG9ydCBkb20gZnJvbSAnbWV0YWwtZG9tJztcbmltcG9ydCBFbWl0dGVyIGZyb20gJy4uLy4uL1V0aWxzL0V2ZW50RW1pdHRlcic7XG5pbXBvcnQgdGVtcGxhdGVzIGZyb20gJy4vRHJvcGRvd24uc295LmpzJztcbmltcG9ydCB7IElURU1TX0RBVEEgfSBmcm9tICcuL0Ryb3Bkb3duVXRpbHMnXG5cblxuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBDb21wb25lbnQge1xuXHQvKipcblx0ICogRHJvcGRvd24gY29tcG9uZW50LlxuXHQgKi9cblx0Y3JlYXRlZCgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0XG5cdFx0aW5zdGFuY2UuY2FzaEl0ZW1zRGF0YSA9IElURU1TX0RBVEE7XG5cdFx0aW5zdGFuY2UuTGlzdGVuZXIub24oJ0xJU1RFTl9EUk9QRE9XTl9FUlJPUicsIGVyciA9PiBpbnN0YW5jZS53YXJuaW5nID0gZXJyKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNldCB0aGUgY2xpY2sgZXZlbnQgd2hlbiB0aGUgYm9keSB3YXMgcHJlc3NlZFxuXHQgKi9cblx0YXR0YWNoZWQoKXtcblx0XHRjb25zdCBzaG93SXRlbXMgPSB0aGlzLnNob3dJdGVtcztcblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzaG93SXRlbXMuYmluZCh0aGlzKSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBTaG93IHRoZSBkcm9wZG93bnMgaXRlbXNcblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICovXG5cdHNob3dJdGVtcyhlKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzLFxuXHRcdFx0YWN0aXZlLFxuXHRcdFx0ZWxlbWVudENsYXNzID0gZS50YXJnZXQuY2xhc3NOYW1lO1xuXHRcdFxuXHRcdGlmKChlbGVtZW50Q2xhc3MuaW5kZXhPZignZHJvcGRvd24tZGlzcGxheScpICE9IC0xKSB8fCAoZWxlbWVudENsYXNzLmluZGV4T2YoJ2Ryb3Bkb3duLWlucHV0JykgIT0gLTEpKXtcblx0XHRcdGFjdGl2ZSA9IHRydWU7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IGluc3RhbmNlLmVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLWlucHV0JykuZm9jdXMoKSwgMjAwKTtcblx0XHR9ZWxzZSB7XG5cdFx0XHRpbnN0YW5jZS5mb2N1c091dCgpO1xuXHRcdH1cblx0XHRcblx0XHRpbnN0YW5jZS5zaG93biA9IGFjdGl2ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoYW5nZSB0aGUgc2VsZWN0ZWQgaXRlbSBpbiB0aGUgZHJvcGRvd25cblx0ICogQHBhcmFtIHtPYmplY3R9IGVcblx0ICovXG5cdGNoYW5nZUFjdGl2ZVBsYW4oZSl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRjb25zdCBpdGVtID0gZS50YXJnZXQ7XG5cdFx0Y29uc3QgZGF0YSA9IGluc3RhbmNlLmNhc2hJdGVtc0RhdGEuZmlsdGVyKG9iaiA9PiBvYmouaWQgPT0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnKSk7XG5cdFx0XG5cdFx0aXRlbS5jbGFzc0xpc3QuYWRkKCdkcm9wZG93bi1saXN0LWl0ZW0tLXNlbGVjdGVkJyk7XG5cdFx0XG5cdFx0aWYoZGF0YS5sZW5ndGgpIHtcblx0XHRcdGluc3RhbmNlLmJpbmRTZWxlY3RlZEl0ZW1DbGFzcyhkYXRhWzBdKTtcblx0XHRcdGluc3RhbmNlLnNldFN0YXRlKHthY3RpdmVEcm9wZG93bkl0ZW06IGRhdGFbMF19KTtcblx0XHRcdGluc3RhbmNlLmVtaXRMaXN0ZW5lcihkYXRhWzBdKTtcblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDbGVhciB0aGUgaW5wdXQgYW5kIHJlbW92ZSB0aGUgaW5wdXQgZm9jdXNcblx0ICovXG5cdGZvY3VzT3V0KCl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRjb25zdCBpdGVtID0gaW5zdGFuY2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24taW5wdXQnKTtcblx0XHRcblx0XHRpdGVtLnZhbHVlID0gJyc7XG5cdFx0aW5zdGFuY2UuaXRlbXMgPSBpbnN0YW5jZS5jYXNoSXRlbXNEYXRhO1xuXHR9XG5cdFxuXHQvKipcblx0ICogU2VhcmNoIGl0ZW1zIHRocm91Z2ggb2YgdGhlIGlucHV0IGludGVyYWN0aW9uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqL1xuXHRzZWFyY2hJdGVtKGUpe1xuXHRcdGNvbnN0IGl0ZW0gPSBlLnRhcmdldDtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdGluc3RhbmNlLml0ZW1zID0gaW5zdGFuY2UuY2FzaEl0ZW1zRGF0YS5maWx0ZXIob2JqID0+IG9iai5uYW1lLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihpdGVtLnZhbHVlLnRvTG93ZXJDYXNlKCkpICE9IC0xKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEVtaXQgYW4gZXZlbnQgdG8gdGhlIG90aGVyIGNvbXBvbmVudHMgcHJlc2VudCBpbiB0aGUgYXBwbGljYXRpb25cblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcblx0ICovXG5cdGVtaXRMaXN0ZW5lcihkYXRhKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdGluc3RhbmNlLndhcm5pbmcgPSBmYWxzZTtcblx0XHRpbnN0YW5jZS5MaXN0ZW5lci5lbWl0KCdMSVNURU5fRFJPUERPV05fRVZFTlQnLCBkYXRhKTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIHRoZSBrZXkgY29kZSBvZiB0aGUga2V5Ym9hcmQgaW50ZXJhY3Rpb25zXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlXG5cdCAqL1xuXHRiaW5kS2V5Q29kZShlKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdGlmKGUua2V5Q29kZSA9PSAyNykgcmV0dXJuIGluc3RhbmNlLmJpbmRFU0NLZXkoKTtcblx0XHRpZihlLmtleUNvZGUgPT0gMTMpIHJldHVybiBpbnN0YW5jZS5iaW5kRU5URVJLZXkoaW5zdGFuY2UuaXRlbXNbMF0pO1xuXHR9XG5cdFxuXHQvKipcblx0ICogTGVhdmUgb2YgdGhlIGRyb3Bkb3duIHNlYXJjaCBhbmRcblx0ICogaGlkZSB0aGUgbGlzdCBvZiBpdGVtc1xuXHQgKi9cblx0YmluZEVTQ0tleSgpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0aW5zdGFuY2UuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24taW5wdXQnKS5ibHVyKCk7XG5cdFx0aW5zdGFuY2Uuc2hvd24gPSBmYWxzZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIFNlbGVjdCB0aGUgZmlyc3QgaXRlbSBwcmVzZW50IGluIHRoZSBzYXJjaFxuXHQgKiBpZiB0aGUgdXNlciBkaWRuJ3Qgc2VhcmNoIGFueSBpdGVtXG5cdCAqIHNlbGVjdCB0aGUgZmlyc3QgZGVmYXVsdCBpdGVtXG5cdCAqL1xuXHRiaW5kRU5URVJLZXkoZGF0YSl7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRcblx0XHRpbnN0YW5jZS5zZXRTdGF0ZSh7YWN0aXZlRHJvcGRvd25JdGVtOiBkYXRhfSk7XG5cdFx0aW5zdGFuY2UuZW1pdExpc3RlbmVyKGRhdGEpO1xuXHRcdGluc3RhbmNlLmJpbmRTZWxlY3RlZEl0ZW1DbGFzcyhkYXRhKTtcblx0XHRpbnN0YW5jZS5zaG93biA9IGZhbHNlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hhbmdlIHRoZSBzZWxlY3RlZCBpdGVtIHByb3BlcnR5XG5cdCAqIHRvIGFkZCB0aGUgY2xhc3Mgc2VsZWN0ZWQgaW4gdGhlIGNvbXBvbmVudFxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHQgKi9cblx0YmluZFNlbGVjdGVkSXRlbUNsYXNzKGRhdGEpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXM7XG5cdFx0aW5zdGFuY2UuY2FzaEl0ZW1zRGF0YS5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5pZCA9PSBkYXRhLmlkID8gaXRlbS5zZWxlY3RlZCA9IHRydWUgOiBkZWxldGUgaXRlbS5zZWxlY3RlZCk7XG5cdH1cbn1cblNveS5yZWdpc3RlcihEcm9wZG93biwgdGVtcGxhdGVzKTtcblxuLyoqXG4gKiBEcm9wZG93biBzdGF0ZSBkZWZpbml0aW9uXG4gKi9cbkRyb3Bkb3duLlNUQVRFID0ge1xuXHQvKipcblx0ICogVG8gc2hvdyB0aGUgZHJvcGRvd24gaXRlbXNcblx0ICovXG5cdHNob3duOiB7XG5cdFx0dmFsdWU6IGZhbHNlXG5cdH0sXG5cdFxuXHQvKipcblx0ICogQWN0aXZlIGl0ZW0gc2VsZWN0ZWQgaW4gdGhlIGRyb3Bkb3duXG5cdCAqL1xuXHRhY3RpdmVEcm9wZG93bkl0ZW06IHtcblx0XHR2YWx1ZTogZmFsc2Vcblx0fSxcblx0XG5cdC8qKlxuXHQgKiBMaXN0IG9mIGl0ZW1zIHRvIHRoZSBkcm9wZG93biBpdGVtcyBsaXN0XG5cdCAqL1xuXHRpdGVtczoge1xuXHRcdHZhbHVlOiBJVEVNU19EQVRBXG5cdH0sXG5cdFxuXHQvKipcblx0ICogTWVzc2FnZSBvZiB3YXJuaW5nIG9mIHRoZSBjYWxjdWxhdG9yXG5cdCAqL1xuXHR3YXJuaW5nOiB7XG5cdFx0dmFsdWU6ICcnXG5cdH0sXG5cdFxuXHQvKipcblx0ICogTGlzdGVuZXIgZm9yIHRoZSBvdGhlcnMgY29tcG9uZW50c1xuXHQgKi9cblx0TGlzdGVuZXI6IHtcblx0XHR2YWx1ZTogbmV3IEVtaXR0ZXIoKVxuXHR9XG59O1xuXG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93bi5qc1xuLy8gbW9kdWxlIGlkID0gMTE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcbnZhciB0ZW1wbGF0ZXM7XG5nb29nLmxvYWRNb2R1bGUoZnVuY3Rpb24oZXhwb3J0cykge1xuXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gRHJvcGRvd24uc295LlxuLy8gUGxlYXNlIGRvbid0IGVkaXQgdGhpcyBmaWxlIGJ5IGhhbmQuXG5cbi8qKlxuICogQGZpbGVvdmVydmlldyBUZW1wbGF0ZXMgaW4gbmFtZXNwYWNlIERyb3Bkb3duLlxuICogQHB1YmxpY1xuICovXG5cbmdvb2cubW9kdWxlKCdEcm9wZG93bi5pbmNyZW1lbnRhbGRvbScpO1xuXG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG52YXIgc295ID0gZ29vZy5yZXF1aXJlKCdzb3knKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3lkYXRhID0gZ29vZy5yZXF1aXJlKCdzb3lkYXRhJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuaTE4bi5iaWRpJyk7XG4vKiogQHN1cHByZXNzIHtleHRyYVJlcXVpcmV9ICovXG5nb29nLnJlcXVpcmUoJ2dvb2cuYXNzZXJ0cycpO1xudmFyIEluY3JlbWVudGFsRG9tID0gZ29vZy5yZXF1aXJlKCdpbmNyZW1lbnRhbGRvbScpO1xudmFyIGllX29wZW4gPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbjtcbnZhciBpZV9jbG9zZSA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRDbG9zZTtcbnZhciBpZV92b2lkID0gSW5jcmVtZW50YWxEb20uZWxlbWVudFZvaWQ7XG52YXIgaWVfb3Blbl9zdGFydCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuU3RhcnQ7XG52YXIgaWVfb3Blbl9lbmQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50T3BlbkVuZDtcbnZhciBpdGV4dCA9IEluY3JlbWVudGFsRG9tLnRleHQ7XG52YXIgaWF0dHIgPSBJbmNyZW1lbnRhbERvbS5hdHRyO1xuXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9kYXRhXG4gKiBAcGFyYW0geyhudWxsfHVuZGVmaW5lZCk9fSBvcHRfaWdub3JlZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCAqPj19IG9wdF9pakRhdGFcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gKi9cbmZ1bmN0aW9uICRyZW5kZXIob3B0X2RhdGEsIG9wdF9pZ25vcmVkLCBvcHRfaWpEYXRhKSB7XG4gIGllX29wZW4oJ2RpdicsIG51bGwsIG51bGwsXG4gICAgICAnY2xhc3MnLCAnZHJvcGRvd24nKTtcbiAgICBpZV92b2lkKCdzcGFuJywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ2NsYXNzJywgJ2Fycm93X2JveCcpO1xuICAgIGllX29wZW4oJ2lucHV0JywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ3R5cGUnLCAndGV4dCcsXG4gICAgICAgICdjbGFzcycsICdkcm9wZG93bi1kaXNwbGF5ICcgKyAob3B0X2RhdGEud2FybmluZyA/ICdpbnB1dC1lcnJvcicgOiAnJyksXG4gICAgICAgICdwbGFjZWhvbGRlcicsIG9wdF9kYXRhLmFjdGl2ZURyb3Bkb3duSXRlbSA/IG9wdF9kYXRhLmFjdGl2ZURyb3Bkb3duSXRlbS5uYW1lIDogJ1NlbGVjdCB5b3VyIHBsYW4nLFxuICAgICAgICAncmVhZG9ubHknLCAndHJ1ZScpO1xuICAgIGllX2Nsb3NlKCdpbnB1dCcpO1xuICAgIGllX29wZW4oJ3NwYW4nLCBudWxsLCBudWxsLFxuICAgICAgICAnY2xhc3MnLCAnd2FybmluZy1sYWJlbCAnICsgKG9wdF9kYXRhLndhcm5pbmcgPyAnc2hvdycgOiAnJykpO1xuICAgICAgaXRleHQoKGdvb2cuYXNzZXJ0cy5hc3NlcnQoKG9wdF9kYXRhLndhcm5pbmcpICE9IG51bGwpLCBvcHRfZGF0YS53YXJuaW5nKSk7XG4gICAgaWVfY2xvc2UoJ3NwYW4nKTtcbiAgICBpZV9vcGVuKCdkaXYnLCBudWxsLCBudWxsLFxuICAgICAgICAnY2xhc3MnLCBvcHRfZGF0YS5zaG93biA/ICdkcm9wZG93bi1saXN0LXdyYXBwZXIgc2hvdycgOiAnZHJvcGRvd24tbGlzdC13cmFwcGVyJyk7XG4gICAgICBpZV9vcGVuKCdpbnB1dCcsIG51bGwsIG51bGwsXG4gICAgICAgICAgJ3R5cGUnLCAndGV4dCcsXG4gICAgICAgICAgJ2RhdGEtb25LZXlkb3duJywgJ2JpbmRLZXlDb2RlJyxcbiAgICAgICAgICAnZGF0YS1vbktleXVwJywgJ3NlYXJjaEl0ZW0nLFxuICAgICAgICAgICdwbGFjZWhvbGRlcicsICdUeXBlIHlvdXIgc2VhcmNoJyxcbiAgICAgICAgICAnY2xhc3MnLCAnZHJvcGRvd24taW5wdXQnKTtcbiAgICAgIGllX2Nsb3NlKCdpbnB1dCcpO1xuICAgICAgaWVfb3BlbigndWwnLCBudWxsLCBudWxsLFxuICAgICAgICAgICdjbGFzcycsICdkcm9wZG93bi1saXN0Jyk7XG4gICAgICAgIHZhciBpdGVtTGlzdDU5ID0gb3B0X2RhdGEuaXRlbXM7XG4gICAgICAgIHZhciBpdGVtTGlzdExlbjU5ID0gaXRlbUxpc3Q1OS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGl0ZW1JbmRleDU5ID0gMDsgaXRlbUluZGV4NTkgPCBpdGVtTGlzdExlbjU5OyBpdGVtSW5kZXg1OSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW1EYXRhNTkgPSBpdGVtTGlzdDU5W2l0ZW1JbmRleDU5XTtcbiAgICAgICAgICBpZV9vcGVuKCdsaScsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAgICdjbGFzcycsICdkcm9wZG93bi1saXN0LWl0ZW0nLFxuICAgICAgICAgICAgICAnZGF0YS1zZWxlY3RlZCcsIGl0ZW1EYXRhNTkuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICdkYXRhLWlkJywgaXRlbURhdGE1OS5pZCxcbiAgICAgICAgICAgICAgJ2RhdGEtb25DbGljaycsICdjaGFuZ2VBY3RpdmVQbGFuJyk7XG4gICAgICAgICAgICBpdGV4dCgoZ29vZy5hc3NlcnRzLmFzc2VydCgoaXRlbURhdGE1OS5uYW1lKSAhPSBudWxsKSwgaXRlbURhdGE1OS5uYW1lKSk7XG4gICAgICAgICAgICBpdGV4dCgnICgnKTtcbiAgICAgICAgICAgIGl0ZXh0KChnb29nLmFzc2VydHMuYXNzZXJ0KChpdGVtRGF0YTU5Lm1vbnRocykgIT0gbnVsbCksIGl0ZW1EYXRhNTkubW9udGhzKSk7XG4gICAgICAgICAgICBpdGV4dCgnIG1lc2VzKScpO1xuICAgICAgICAgIGllX2Nsb3NlKCdsaScpO1xuICAgICAgICB9XG4gICAgICBpZV9jbG9zZSgndWwnKTtcbiAgICBpZV9jbG9zZSgnZGl2Jyk7XG4gIGllX2Nsb3NlKCdkaXYnKTtcbn1cbmV4cG9ydHMucmVuZGVyID0gJHJlbmRlcjtcbmlmIChnb29nLkRFQlVHKSB7XG4gICRyZW5kZXIuc295VGVtcGxhdGVOYW1lID0gJ0Ryb3Bkb3duLnJlbmRlcic7XG59XG5cbmV4cG9ydHMucmVuZGVyLnBhcmFtcyA9IFtcInNob3duXCIsXCJpdGVtc1wiLFwiYWN0aXZlRHJvcGRvd25JdGVtXCIsXCJ3YXJuaW5nXCJdO1xuZXhwb3J0cy5yZW5kZXIudHlwZXMgPSB7XCJzaG93blwiOlwiYW55XCIsXCJpdGVtc1wiOlwiYW55XCIsXCJhY3RpdmVEcm9wZG93bkl0ZW1cIjpcImFueVwiLFwid2FybmluZ1wiOlwiYW55XCJ9O1xudGVtcGxhdGVzID0gZXhwb3J0cztcbnJldHVybiBleHBvcnRzO1xuXG59KTtcblxuY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBDb21wb25lbnQge31cblNveS5yZWdpc3RlcihEcm9wZG93biwgdGVtcGxhdGVzKTtcbmV4cG9ydCB7IERyb3Bkb3duLCB0ZW1wbGF0ZXMgfTtcbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlcztcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9jb21wb25lbnRzL0Ryb3Bkb3duL0Ryb3Bkb3duLnNveS5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBJVEVNU19EQVRBID0gW1xuXHR7aWQ6IDAsIG1vbnRoczogMTIsIGludGVyZXN0OjUsIG5hbWU6IFwiSW5pdGlhbFwifSxcblx0e2lkOiAxLCBtb250aHM6IDI0LCBpbnRlcmVzdDo3LCBuYW1lOiBcIkJyb256ZVwifSxcblx0e2lkOiAyLCBtb250aHM6IDM2LCBpbnRlcmVzdDo5LCBuYW1lOiBcIkdvbGRcIn0sXG5cdHtpZDogMywgbW9udGhzOiA0OCwgaW50ZXJlc3Q6MTUsIG5hbWU6IFwiU3BoZXJlXCJ9XG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9Ecm9wZG93bi9Ecm9wZG93blV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ21ldGFsLWNvbXBvbmVudCc7XG5pbXBvcnQgU295IGZyb20gJ21ldGFsLXNveSc7XG5pbXBvcnQgdGVtcGxhdGVzIGZyb20gJy4vQ2FsY3VsYXRvci5zb3kuanMnO1xuaW1wb3J0IHsgbGFiZWxzLCBvcGVyYXRvcnMgfSBmcm9tICcuL0NhbGN1bGF0b3JVdGlscyc7XG5pbXBvcnQgRW1pdHRlciBmcm9tICcuLi8uLi9VdGlscy9FdmVudEVtaXR0ZXInO1xuXG5jbGFzcyBDYWxjdWxhdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcblx0LyoqXG5cdFx0Q2FsY3VsYXRvciBjb21wb25lbnRcblx0ICovXG5cdGNyZWF0ZWQoKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdFxuXHRcdGluc3RhbmNlLmxhYmVscy5mb3JFYWNoKGxhYmVsID0+IGluc3RhbmNlLnNldENhbGN1bGF0b3JCdXR0b25zRXZlbnRzKGxhYmVsKSk7XG5cdFx0aW5zdGFuY2Uub3BlcmF0b3JzLmZvckVhY2gob3BlcmF0b3IgPT4gaW5zdGFuY2Uuc2V0Q2FsY3VsYXRvckJ1dHRvbnNFdmVudHMob3BlcmF0b3IpKTtcblx0XHRpbnN0YW5jZS5MaXN0ZW5lci5vbignTElTVEVOX0NBTENVTEFUT1JfRVJST1InLCBlcnIgPT4gaW5zdGFuY2Uud2FybmluZyA9IGVycik7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBZGQgZXZlbnRzIGZvciBhbGwgYnV0dG9ucyBpbiB0aGUgY2FsY3VsYXRvciBjb21wb25lbnRcblx0ICogbG9jYXRlZCBpbiBDYWxjdWxhdG9yVXRpbHNcblx0ICovXG5cdHNldENhbGN1bGF0b3JCdXR0b25zRXZlbnRzKGJ1dHRvbil7XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcztcblx0XHRcblx0XHRpZihidXR0b24uaXNDbGVhckJ1dHRvbil7XG5cdFx0XHRidXR0b24uY2xpY2tGbiA9IGluc3RhbmNlLmRlbGVnYXRlRGVsZXRlQnV0dG9uLmJpbmQoaW5zdGFuY2UpO1xuXHRcdH1lbHNlIGlmKGJ1dHRvbi5pc1Jlc3VsdEJ1dHRvbSl7XG5cdFx0XHRidXR0b24uY2xpY2tGbiA9IGluc3RhbmNlLnJlc3VsdE9mRGlzcGxheUV4cHJlc3Npb25zLmJpbmQoaW5zdGFuY2UpO1xuXHRcdH1lbHNlIHtcblx0XHRcdGJ1dHRvbi5jbGlja0ZuID0gaW5zdGFuY2UuYXBwZW5kSW50b0Rpc3BsYXkuYmluZChpbnN0YW5jZSk7XG5cdFx0fVxuXHR9XG5cdFxuXHQvKipcblx0ICogUmVtb3ZlIGRpZ2l0cyBpbiB0aGUgY2FsY3VsYXRvciBkaXNwbGF5XG5cdCAqIHRvIHVwZGF0ZSBsYWJlbERpc3BsYXlcblx0ICogYW5kIGVtaXQgdGhlIGxpc3RlbmVyIHRvIHRoZSBvdGhlcnMgY29tcG9uZW50c1xuXHQgKi9cblx0ZGVsZWdhdGVEZWxldGVCdXR0b24oKXtcblx0XHRsZXQgaW5zdGFuY2UgPSB0aGlzO1xuXHRcdFxuXHRcdGluc3RhbmNlLmxhYmVsRGlzcGxheSA9IGluc3RhbmNlLnJlbW92ZUxhc3REaWdpdDtcblx0XHRpbnN0YW5jZS53YXJuaW5nID0gZmFsc2U7XG5cdFx0aW5zdGFuY2UuZW1pdExpc3RlbmVyKGluc3RhbmNlLmxhYmVsRGlzcGxheSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBBcHBlbmQgZGlnaXRzIGluIHRoZSBjYWxjdWxhdG9yIGRpc3BsYXlcblx0ICovXG5cdGFwcGVuZEludG9EaXNwbGF5KGUpe1xuXHRcdGNvbnN0IHRleHQgPSBlLnRhcmdldC5kYXRhc2V0LnRleHQ7XG5cdFx0XG5cdFx0bGV0IGluc3RhbmNlID0gdGhpcyxsYWJlbERpc3BsYXkgPSBpbnN0YW5jZS5sYWJlbERpc3BsYXksXG5cdFx0XHRcdGxhc3REaWd0T2ZMYWJlbERpc3BsYXkgPSBsYWJlbERpc3BsYXlbbGFiZWxEaXNwbGF5Lmxlbmd0aC0xXTtcblx0XHRcblx0XHRpZihpbnN0YW5jZS5oYXNPcGVyYXRvcih0ZXh0KSAmJiBpbnN0YW5jZS5pc0xhc3REaWdpdEFuT3BlcmF0b3IobGFzdERpZ3RPZkxhYmVsRGlzcGxheSkpe1xuXHRcdFx0bGFzdERpZ3RPZkxhYmVsRGlzcGxheSA9ICcnO1xuXHRcdFx0aW5zdGFuY2UubGFiZWxEaXNwbGF5ID0gaW5zdGFuY2UucmVtb3ZlTGFzdERpZ2l0O1xuXHRcdH1cblx0XHRcblx0XHRpZihpbnN0YW5jZS5jaGVja0NhbGN1bGF0b3JFeHByZXNzaW9ucyh0ZXh0LCBsYXN0RGlndE9mTGFiZWxEaXNwbGF5KSl7XG5cdFx0XHRpbnN0YW5jZS5sYWJlbERpc3BsYXkgKz0gdGV4dDtcblx0XHR9XG5cblx0XHRpbnN0YW5jZS53YXJuaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIGluc3RhbmNlLmVtaXRMaXN0ZW5lcihpbnN0YW5jZS5sYWJlbERpc3BsYXkpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXMgbm90IGEgZGlnaXQgb3Jcblx0ICogaWYgaXMgYSBkaWdpdCwgY2hlY2sgaWYgdGhlIGRpZ2l0XG5cdCAqIGNvbWVzIGFmdGVyIGEgbnVtYmVyIG9yIGFuIGV4cHJlc3Npb25cblx0ICovXG5cdGNoZWNrQ2FsY3VsYXRvckV4cHJlc3Npb25zKHRleHQsIGxhc3REaWd0T2ZMYWJlbERpc3BsYXkpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXMsbGFiZWxEaXNwbGF5ID0gaW5zdGFuY2UubGFiZWxEaXNwbGF5O1xuXG5cdFx0aWYoKCFpbnN0YW5jZS5oYXNPcGVyYXRvcih0ZXh0KSkgfHxcblx0XHRcdCghaW5zdGFuY2UuaGFzRG91YmxlUGVyaW9kKGxhYmVsRGlzcGxheSwgdGV4dCkpICYmXG5cdFx0XHQoIWluc3RhbmNlLmlzRmlyc3REaWdpdEFuT3BlcmF0b3IobGFiZWxEaXNwbGF5K3RleHQpICYmXG5cdFx0XHRcdGluc3RhbmNlLmhhc09wZXJhdG9yKHRleHQpICYmXG5cdFx0XHRcdCFpbnN0YW5jZS5pc0xhc3REaWdpdEFuT3BlcmF0b3IobGFzdERpZ3RPZkxhYmVsRGlzcGxheSkpKSByZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqXG5cdCAqL1xuXHRoYXNEb3VibGVQZXJpb2QoY2FsY3VsYXRvckV4cHJlc3Npb24sIGlucHV0KXtcblx0XHRjb25zdCBudW1iZXJzID0gY2FsY3VsYXRvckV4cHJlc3Npb24raW5wdXQ7XG5cdFx0Y29uc3QgcmVnZXggPSAvXihbMC05XSkqXFwuKFswLTldKSpcXC4vO1xuXHRcdGNvbnN0IGxhc3ROdW1iZXIgPSBudW1iZXJzLnNwbGl0KC9bK1xcLVxcLypdLyk7XG5cdFx0cmV0dXJuIHJlZ2V4LnRlc3QobGFzdE51bWJlcltsYXN0TnVtYmVyLmxlbmd0aC0xXSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBFbWl0IGV2ZW50IHRvIHRoZSBvdGhlcnMgY29tcG9uZW50c1xuXHQgKi9cblx0ZW1pdExpc3RlbmVyKGRhdGEpe1xuXHRcdHJldHVybiB0aGlzLkxpc3RlbmVyLmVtaXQoJ0xJU1RFTl9DQUxDVUxBVE9SX0VWRU5UJywgZGF0YSk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBSZW1vdmUgdGhlIGNhbGN1bGF0b3IgZGlnaXRzXG5cdCAqL1xuXHRnZXQgcmVtb3ZlTGFzdERpZ2l0KCl7XG5cdFx0bGV0IHRleHREaXNwbGF5ID0gdGhpcy5sYWJlbERpc3BsYXk7XG5cblx0XHRyZXR1cm4gdGV4dERpc3BsYXkuc3Vic3RyKDAsIHRleHREaXNwbGF5Lmxlbmd0aCAtIDEpO1xuXHR9XG5cdFxuXHQvKipcblx0ICogUHJvY2VzcyB0aGUgcmVzdWx0IG9mIHRoZSBleHByZXNzaW9ucyBpbiB0aGUgY2FsY3VsYXRvciBkaXNwbGF5XG5cdCAqL1xuXHRyZXN1bHRPZkRpc3BsYXlFeHByZXNzaW9ucygpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXMsXG5cdFx0XHRcdHRleHREaXNwbGF5ID0gaW5zdGFuY2UubGFiZWxEaXNwbGF5O1xuXHRcdFxuXHRcdGlmKCF0ZXh0RGlzcGxheSkgcmV0dXJuO1xuXHRcdFxuXHRcdGlmKGluc3RhbmNlLmlzTGFzdERpZ2l0QW5PcGVyYXRvcih0ZXh0RGlzcGxheVt0ZXh0RGlzcGxheS5sZW5ndGgtMV0pKXtcblx0XHRcdHRleHREaXNwbGF5ID0gaW5zdGFuY2UucmVtb3ZlTGFzdERpZ2l0O1xuXHRcdH1cblx0XHRcblx0XHRpZihpbnN0YW5jZS5oYXNEaWZmZXJlbnROdW1iZXJPZlBhcmVudGhlc2VzKHRleHREaXNwbGF5KSkgcmV0dXJuIGluc3RhbmNlLndhcm5pbmcgPSBcIlVubWF0Y2hlZCBwYXJlbnRoZXNpc1wiO1xuXHRcdFxuXHRcdHRyeSB7XG5cdFx0XHRpbnN0YW5jZS53YXJuaW5nID0gZmFsc2U7XG5cdFx0XHRpbnN0YW5jZS5sYWJlbERpc3BsYXkgPSBNYXRoLmFicyhuZXcgRnVuY3Rpb24oJycsICdyZXR1cm4gJyt0ZXh0RGlzcGxheSkoKSkudG9TdHJpbmcoKTtcblx0XHRcdHJldHVybiBpbnN0YW5jZS5lbWl0TGlzdGVuZXIoaW5zdGFuY2UubGFiZWxEaXNwbGF5KTtcblx0XHR9Y2F0Y2goZSkge1xuXHRcdFx0cmV0dXJuIGluc3RhbmNlLndhcm5pbmcgPSBcIlBsZWFzZSB0eXBlIGEgdmFsaWQgZXhwcmVzc2lvblwiO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIGhhcyBkaWZmZXJlbnQgbnVtYmVyIG9mIHBhcmVudGhlc2VzXG5cdCAqIGluIHRoZSBjYWxjdWxhdG9yIGRpc3BsYXlcblx0ICovXG5cdGhhc0RpZmZlcmVudE51bWJlck9mUGFyZW50aGVzZXModGV4dERpc3BsYXkpe1xuXHRcdGxldCBpbnN0YW5jZSA9IHRoaXMsXG5cdFx0XHRcdG9wZW5QYXJlbnRoZXNlcyA9IGluc3RhbmNlLmNvdW50RGlnaXRPY2N1cnJlbmNlcyh0ZXh0RGlzcGxheSwgJygnKSxcblx0XHRcdFx0Y2xvc2VkUGFyZW50aGVzZXMgPSBpbnN0YW5jZS5jb3VudERpZ2l0T2NjdXJyZW5jZXModGV4dERpc3BsYXksICcpJyk7XG5cdFx0XG5cdFx0aWYob3BlblBhcmVudGhlc2VzICE9IGNsb3NlZFBhcmVudGhlc2VzKSByZXR1cm4gdHJ1ZTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENvdW50IHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgb2YgYSBkZXRlcm1pbmF0ZSBkaWdpdFxuXHQgKi9cblx0Y291bnREaWdpdE9jY3VycmVuY2VzKHRleHQsIHMxKXtcblx0XHRyZXR1cm4gdGV4dC5zcGxpdChzMSkubGVuZ3RoIC0gMTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBsYXN0IGRpZ2l0IGlzIGFuIG9wZXJhdG9yXG5cdCAqL1xuXHRpc0xhc3REaWdpdEFuT3BlcmF0b3IodGV4dCl7XG5cdFx0Y29uc3QgcmVnZXggPSAvWystXFwvKi5dJC87XG5cdFx0cmV0dXJuIHJlZ2V4LnRlc3QodGV4dCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgZmlyc3QgZGlnaXQgaXMgYW4gb3BlcmF0b3Jcblx0ICovXG5cdGlzRmlyc3REaWdpdEFuT3BlcmF0b3IodGV4dCl7XG5cdFx0Y29uc3QgcmVnZXggPSAvXlsrLVxcLyouXS87XG5cdFx0cmV0dXJuIHJlZ2V4LnRlc3QodGV4dCk7XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBDaGVjayBpZiBoYXMgb3BlcmF0b3IgaW4gdGhlIHBhcmFtXG5cdCAqL1xuXHRoYXNPcGVyYXRvcih0ZXh0KXtcblx0XHRjb25zdCByZWdleCA9IC9bKy1cXC8qLl0vO1xuXHRcdHJldHVybiByZWdleC50ZXN0KHRleHQpO1xuXHR9XG59XG5cblNveS5yZWdpc3RlcihDYWxjdWxhdG9yLCB0ZW1wbGF0ZXMpO1xuXG5cbi8qKlxuICogQWxlcnQgQ29tcG9uZW50IGRlZmluaXRpb24uXG4gKi9cbkNhbGN1bGF0b3IuU1RBVEUgPSB7XG5cdC8qKlxuXHQgKiBBcnJheSBvZiBsYWJlbHMgdGhhdCBhcmUgY2FsY3VsYXRvciBidXR0b25zXG5cdCAqL1xuXHRsYWJlbHM6IHtcblx0XHR2YWx1ZTogbGFiZWxzXG5cdH0sXG5cdFxuXHQvKipcblx0ICogTWVzc2FnZSBvZiB3YXJuaW5nIG9mIHRoZSBjYWxjdWxhdG9yXG5cdCAqL1xuXHR3YXJuaW5nOiB7XG5cdFx0dmFsdWU6ICcnXG5cdH0sXG5cdFxuXHQvKipcblx0ICogQXJyYXkgb2Ygb3BlcmF0b3JzIHRoYXQgYXJlIGNhbGN1bGF0b3IgYnV0dG9uc1xuXHQgKi9cblx0b3BlcmF0b3JzOiB7XG5cdFx0dmFsdWU6IG9wZXJhdG9yc1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIExhYmVsIHdoZXJlIHdpbGwgc3RheSB0aGUgdXNlciBudW1lcmljIGV4cHJlc3Npb25cblx0ICovXG5cdGxhYmVsRGlzcGxheToge1xuXHRcdHZhbHVlOiAnJ1xuXHR9LFxuXHRcblx0LyoqXG5cdCAqIExpc3RlbmVyIGZvciB0aGUgb3RoZXJzIGNvbXBvbmVudHNcblx0ICovXG5cdExpc3RlbmVyOiB7XG5cdFx0dmFsdWU6IG5ldyBFbWl0dGVyKClcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FsY3VsYXRvcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2FsY3VsYXRvci9DYWxjdWxhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdtZXRhbC1jb21wb25lbnQnO1xuaW1wb3J0IFNveSBmcm9tICdtZXRhbC1zb3knO1xudmFyIHRlbXBsYXRlcztcbmdvb2cubG9hZE1vZHVsZShmdW5jdGlvbihleHBvcnRzKSB7XG5cbi8vIFRoaXMgZmlsZSB3YXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSBDYWxjdWxhdG9yLnNveS5cbi8vIFBsZWFzZSBkb24ndCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGVtcGxhdGVzIGluIG5hbWVzcGFjZSBDYWxjdWxhdG9yLlxuICogQHB1YmxpY1xuICovXG5cbmdvb2cubW9kdWxlKCdDYWxjdWxhdG9yLmluY3JlbWVudGFsZG9tJyk7XG5cbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3kgPSBnb29nLnJlcXVpcmUoJ3NveScpO1xuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xudmFyIHNveWRhdGEgPSBnb29nLnJlcXVpcmUoJ3NveWRhdGEnKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbmdvb2cucmVxdWlyZSgnZ29vZy5pMThuLmJpZGknKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbmdvb2cucmVxdWlyZSgnZ29vZy5hc3NlcnRzJyk7XG52YXIgSW5jcmVtZW50YWxEb20gPSBnb29nLnJlcXVpcmUoJ2luY3JlbWVudGFsZG9tJyk7XG52YXIgaWVfb3BlbiA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuO1xudmFyIGllX2Nsb3NlID0gSW5jcmVtZW50YWxEb20uZWxlbWVudENsb3NlO1xudmFyIGllX3ZvaWQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50Vm9pZDtcbnZhciBpZV9vcGVuX3N0YXJ0ID0gSW5jcmVtZW50YWxEb20uZWxlbWVudE9wZW5TdGFydDtcbnZhciBpZV9vcGVuX2VuZCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuRW5kO1xudmFyIGl0ZXh0ID0gSW5jcmVtZW50YWxEb20udGV4dDtcbnZhciBpYXR0ciA9IEluY3JlbWVudGFsRG9tLmF0dHI7XG5cbnZhciAkdGVtcGxhdGVBbGlhczEgPSBTb3kuZ2V0VGVtcGxhdGUoJ0NhbGN1bGF0b3JCdXR0b24uaW5jcmVtZW50YWxkb20nLCAncmVuZGVyJyk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2RhdGFcbiAqIEBwYXJhbSB7KG51bGx8dW5kZWZpbmVkKT19IG9wdF9pZ25vcmVkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2lqRGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZnVuY3Rpb24gJHJlbmRlcihvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpIHtcbiAgb3B0X2RhdGEgPSBvcHRfZGF0YSB8fCB7fTtcbiAgaWVfb3BlbignZGl2JywgbnVsbCwgbnVsbCxcbiAgICAgICdjbGFzcycsICdjYWxjdWxhdG9yJyk7XG4gICAgaWVfb3Blbignc2VjdGlvbicsIG51bGwsIG51bGwsXG4gICAgICAgICdjbGFzcycsICdjYWxjdWxhdG9yLWRpc3BsYXkgJyArIChvcHRfZGF0YS53YXJuaW5nID8gJ2lucHV0LWVycm9yJyA6ICcnKSxcbiAgICAgICAgJ2lkJywgJ2NhbGN1bGF0b3ItZGlzcGxheScpO1xuICAgICAgaXRleHQoKGdvb2cuYXNzZXJ0cy5hc3NlcnQoKG9wdF9kYXRhLmxhYmVsRGlzcGxheSkgIT0gbnVsbCksIG9wdF9kYXRhLmxhYmVsRGlzcGxheSkpO1xuICAgIGllX2Nsb3NlKCdzZWN0aW9uJyk7XG4gICAgaWVfb3BlbignZGl2JywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ2NsYXNzJywgJ3dhcm5pbmctbGFiZWwgJyArIChvcHRfZGF0YS53YXJuaW5nID8gJ3Nob3cnIDogJycpKTtcbiAgICAgIGl0ZXh0KChnb29nLmFzc2VydHMuYXNzZXJ0KChvcHRfZGF0YS53YXJuaW5nKSAhPSBudWxsKSwgb3B0X2RhdGEud2FybmluZykpO1xuICAgIGllX2Nsb3NlKCdkaXYnKTtcbiAgICBpZV9vcGVuKCdzZWN0aW9uJywgbnVsbCwgbnVsbCxcbiAgICAgICAgJ2NsYXNzJywgJ2NhbGN1bGF0b3ItYnV0dG9ucy13cmFwcGVyJyk7XG4gICAgICBpZV9vcGVuKCdzZWN0aW9uJywgbnVsbCwgbnVsbCxcbiAgICAgICAgICAnY2xhc3MnLCAnY2FsY3VsYXRvci1kaWdpdHMnKTtcbiAgICAgICAgdmFyIGxhYmVsTGlzdDE2ID0gb3B0X2RhdGEubGFiZWxzO1xuICAgICAgICB2YXIgbGFiZWxMaXN0TGVuMTYgPSBsYWJlbExpc3QxNi5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGxhYmVsSW5kZXgxNiA9IDA7IGxhYmVsSW5kZXgxNiA8IGxhYmVsTGlzdExlbjE2OyBsYWJlbEluZGV4MTYrKykge1xuICAgICAgICAgIHZhciBsYWJlbERhdGExNiA9IGxhYmVsTGlzdDE2W2xhYmVsSW5kZXgxNl07XG4gICAgICAgICAgJHRlbXBsYXRlQWxpYXMxKHt0ZXh0OiBsYWJlbERhdGExNi50ZXh0LCBjbGljazogbGFiZWxEYXRhMTYuY2xpY2tGbiwgYnV0dG9uQ2xhc3M6IGxhYmVsRGF0YTE2LmJ1dHRvbkNsYXNzfSwgbnVsbCwgb3B0X2lqRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIGllX2Nsb3NlKCdzZWN0aW9uJyk7XG4gICAgICBpZV9vcGVuKCdzZWN0aW9uJywgbnVsbCwgbnVsbCxcbiAgICAgICAgICAnY2xhc3MnLCAnY2FsY3VsYXRvci1vcGVyYXRvcnMnKTtcbiAgICAgICAgdmFyIG9wZXJhdG9yTGlzdDIzID0gb3B0X2RhdGEub3BlcmF0b3JzO1xuICAgICAgICB2YXIgb3BlcmF0b3JMaXN0TGVuMjMgPSBvcGVyYXRvckxpc3QyMy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIG9wZXJhdG9ySW5kZXgyMyA9IDA7IG9wZXJhdG9ySW5kZXgyMyA8IG9wZXJhdG9yTGlzdExlbjIzOyBvcGVyYXRvckluZGV4MjMrKykge1xuICAgICAgICAgIHZhciBvcGVyYXRvckRhdGEyMyA9IG9wZXJhdG9yTGlzdDIzW29wZXJhdG9ySW5kZXgyM107XG4gICAgICAgICAgJHRlbXBsYXRlQWxpYXMxKHt0ZXh0OiBvcGVyYXRvckRhdGEyMy50ZXh0LCBjbGljazogb3BlcmF0b3JEYXRhMjMuY2xpY2tGbiwgYnV0dG9uQ2xhc3M6IG9wZXJhdG9yRGF0YTIzLmJ1dHRvbkNsYXNzfSwgbnVsbCwgb3B0X2lqRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIGllX2Nsb3NlKCdzZWN0aW9uJyk7XG4gICAgaWVfY2xvc2UoJ3NlY3Rpb24nKTtcbiAgaWVfY2xvc2UoJ2RpdicpO1xufVxuZXhwb3J0cy5yZW5kZXIgPSAkcmVuZGVyO1xuaWYgKGdvb2cuREVCVUcpIHtcbiAgJHJlbmRlci5zb3lUZW1wbGF0ZU5hbWUgPSAnQ2FsY3VsYXRvci5yZW5kZXInO1xufVxuXG5leHBvcnRzLnJlbmRlci5wYXJhbXMgPSBbXCJsYWJlbHNcIixcImxhYmVsRGlzcGxheVwiLFwib3BlcmF0b3JzXCIsXCJ3YXJuaW5nXCJdO1xuZXhwb3J0cy5yZW5kZXIudHlwZXMgPSB7XCJsYWJlbHNcIjpcImFueVwiLFwibGFiZWxEaXNwbGF5XCI6XCJhbnlcIixcIm9wZXJhdG9yc1wiOlwiYW55XCIsXCJ3YXJuaW5nXCI6XCJhbnlcIn07XG50ZW1wbGF0ZXMgPSBleHBvcnRzO1xucmV0dXJuIGV4cG9ydHM7XG5cbn0pO1xuXG5jbGFzcyBDYWxjdWxhdG9yIGV4dGVuZHMgQ29tcG9uZW50IHt9XG5Tb3kucmVnaXN0ZXIoQ2FsY3VsYXRvciwgdGVtcGxhdGVzKTtcbmV4cG9ydCB7IENhbGN1bGF0b3IsIHRlbXBsYXRlcyB9O1xuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVzO1xuLyoganNoaW50IGlnbm9yZTplbmQgKi9cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2FsY3VsYXRvci9DYWxjdWxhdG9yLnNveS5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBsYWJlbHMgPSBbXG5cdHt0ZXh0OiAnPCcsIGlzQ2xlYXJCdXR0b246IHRydWV9LFxuXHR7dGV4dDogJygnfSxcblx0e3RleHQ6ICcpJ30sXG5cdHt0ZXh0OiAnMSd9LFxuXHR7dGV4dDogJzInfSxcblx0e3RleHQ6ICczJ30sXG5cdHt0ZXh0OiAnNCd9LFxuXHR7dGV4dDogJzUnfSxcblx0e3RleHQ6ICc2J30sXG5cdHt0ZXh0OiAnNyd9LFxuXHR7dGV4dDogJzgnfSxcblx0e3RleHQ6ICc5J30sXG5cdHt0ZXh0OiAnMCcsIGJ1dHRvbkNsYXNzOiAnY2FsY3VsYXRvci1idXR0b24tLWRvdWJsZS1zaXplJ30sXG5cdHt0ZXh0OiAnLid9XG5dO1xuXG5leHBvcnQgY29uc3Qgb3BlcmF0b3JzID0gW1xuXHR7dGV4dDogJysnfSxcblx0e3RleHQ6ICctJ30sXG5cdHt0ZXh0OiAnKid9LFxuXHR7dGV4dDogJy8nfSxcblx0e3RleHQ6ICc9JywgaXNSZXN1bHRCdXR0b206IHRydWV9XG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9DYWxjdWxhdG9yL0NhbGN1bGF0b3JVdGlscy5qc1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHRlbXBsYXRlcyBmcm9tICcuL0NhbGN1bGF0b3JCdXR0b24uc295LmpzJztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnbWV0YWwtY29tcG9uZW50JztcbmltcG9ydCBTb3kgZnJvbSAnbWV0YWwtc295JztcblxuY2xhc3MgQ2FsY3VsYXRvckJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XG59XG5cblNveS5yZWdpc3RlcihDYWxjdWxhdG9yQnV0dG9uLCB0ZW1wbGF0ZXMpO1xuXG4vKipcbiAqIENhbGN1bGF0b3JCdXR0b24gU3RhdGUgRGVmaW5pdGlvblxuICovXG5DYWxjdWxhdG9yQnV0dG9uLlNUQVRFID0ge1xuXHQvKipcblx0ICogVGV4dCBwcmVzZW50IGluIGJ1dHRvblxuXHQgKi9cblx0dGV4dDoge1xuXHRcdHZhbHVlOiAnJ1xuXHR9LFxuXHQvKipcblx0ICogVGhlIGFjdGlvbiB0aGF0IHRoZSBidXR0b24gd2lsbCBkb1xuXHQgKi9cblx0Y2xpY2s6IHtcblx0XHR2YWx1ZTogZmFsc2Vcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FsY3VsYXRvckJ1dHRvbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvQ2FsY3VsYXRvckJ1dHRvbi9DYWxjdWxhdG9yQnV0dG9uLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICdtZXRhbC1jb21wb25lbnQnO1xuaW1wb3J0IFNveSBmcm9tICdtZXRhbC1zb3knO1xudmFyIHRlbXBsYXRlcztcbmdvb2cubG9hZE1vZHVsZShmdW5jdGlvbihleHBvcnRzKSB7XG5cbi8vIFRoaXMgZmlsZSB3YXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSBDYWxjdWxhdG9yQnV0dG9uLnNveS5cbi8vIFBsZWFzZSBkb24ndCBlZGl0IHRoaXMgZmlsZSBieSBoYW5kLlxuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgVGVtcGxhdGVzIGluIG5hbWVzcGFjZSBDYWxjdWxhdG9yQnV0dG9uLlxuICogQHB1YmxpY1xuICovXG5cbmdvb2cubW9kdWxlKCdDYWxjdWxhdG9yQnV0dG9uLmluY3JlbWVudGFsZG9tJyk7XG5cbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbnZhciBzb3kgPSBnb29nLnJlcXVpcmUoJ3NveScpO1xuLyoqIEBzdXBwcmVzcyB7ZXh0cmFSZXF1aXJlfSAqL1xudmFyIHNveWRhdGEgPSBnb29nLnJlcXVpcmUoJ3NveWRhdGEnKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbmdvb2cucmVxdWlyZSgnZ29vZy5pMThuLmJpZGknKTtcbi8qKiBAc3VwcHJlc3Mge2V4dHJhUmVxdWlyZX0gKi9cbmdvb2cucmVxdWlyZSgnZ29vZy5hc3NlcnRzJyk7XG52YXIgSW5jcmVtZW50YWxEb20gPSBnb29nLnJlcXVpcmUoJ2luY3JlbWVudGFsZG9tJyk7XG52YXIgaWVfb3BlbiA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuO1xudmFyIGllX2Nsb3NlID0gSW5jcmVtZW50YWxEb20uZWxlbWVudENsb3NlO1xudmFyIGllX3ZvaWQgPSBJbmNyZW1lbnRhbERvbS5lbGVtZW50Vm9pZDtcbnZhciBpZV9vcGVuX3N0YXJ0ID0gSW5jcmVtZW50YWxEb20uZWxlbWVudE9wZW5TdGFydDtcbnZhciBpZV9vcGVuX2VuZCA9IEluY3JlbWVudGFsRG9tLmVsZW1lbnRPcGVuRW5kO1xudmFyIGl0ZXh0ID0gSW5jcmVtZW50YWxEb20udGV4dDtcbnZhciBpYXR0ciA9IEluY3JlbWVudGFsRG9tLmF0dHI7XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2RhdGFcbiAqIEBwYXJhbSB7KG51bGx8dW5kZWZpbmVkKT19IG9wdF9pZ25vcmVkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsICo+PX0gb3B0X2lqRGF0YVxuICogQHJldHVybiB7dm9pZH1cbiAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAqL1xuZnVuY3Rpb24gJHJlbmRlcihvcHRfZGF0YSwgb3B0X2lnbm9yZWQsIG9wdF9pakRhdGEpIHtcbiAgaWVfb3BlbignYnV0dG9uJywgbnVsbCwgbnVsbCxcbiAgICAgICdkYXRhLXRleHQnLCBvcHRfZGF0YS50ZXh0LFxuICAgICAgJ2NsYXNzJywgJ1xcdCcgKyAob3B0X2RhdGEuYnV0dG9uQ2xhc3MgPyBvcHRfZGF0YS5idXR0b25DbGFzcyA6ICdjYWxjdWxhdG9yLWJ1dHRvbicpLFxuICAgICAgJ2RhdGEtb25DbGljaycsIG9wdF9kYXRhLmNsaWNrKTtcbiAgICBpdGV4dCgoZ29vZy5hc3NlcnRzLmFzc2VydCgob3B0X2RhdGEudGV4dCkgIT0gbnVsbCksIG9wdF9kYXRhLnRleHQpKTtcbiAgaWVfY2xvc2UoJ2J1dHRvbicpO1xufVxuZXhwb3J0cy5yZW5kZXIgPSAkcmVuZGVyO1xuaWYgKGdvb2cuREVCVUcpIHtcbiAgJHJlbmRlci5zb3lUZW1wbGF0ZU5hbWUgPSAnQ2FsY3VsYXRvckJ1dHRvbi5yZW5kZXInO1xufVxuXG5leHBvcnRzLnJlbmRlci5wYXJhbXMgPSBbXCJidXR0b25DbGFzc1wiLFwidGV4dFwiLFwiY2xpY2tcIl07XG5leHBvcnRzLnJlbmRlci50eXBlcyA9IHtcImJ1dHRvbkNsYXNzXCI6XCJhbnlcIixcInRleHRcIjpcImFueVwiLFwiY2xpY2tcIjpcImFueVwifTtcbnRlbXBsYXRlcyA9IGV4cG9ydHM7XG5yZXR1cm4gZXhwb3J0cztcblxufSk7XG5cbmNsYXNzIENhbGN1bGF0b3JCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge31cblNveS5yZWdpc3RlcihDYWxjdWxhdG9yQnV0dG9uLCB0ZW1wbGF0ZXMpO1xuZXhwb3J0IHsgQ2FsY3VsYXRvckJ1dHRvbiwgdGVtcGxhdGVzIH07XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZXM7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9DYWxjdWxhdG9yQnV0dG9uL0NhbGN1bGF0b3JCdXR0b24uc295LmpzXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==